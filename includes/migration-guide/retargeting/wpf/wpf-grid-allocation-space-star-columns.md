---
ms.openlocfilehash: 3709b9e694011666cebcb0ae09fbc838f65967af
ms.sourcegitcommit: e02d17b2cf9c1258dadda4810a5e6072a0089aee
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/01/2020
ms.locfileid: "85614395"
---
### <a name="wpf-grid-allocation-of-space-to-star-columns"></a><span data-ttu-id="b4e80-101">WPF 网格向 -列分配空间</span><span class="sxs-lookup"><span data-stu-id="b4e80-101">WPF Grid allocation of space to star-columns</span></span>

#### <a name="details"></a><span data-ttu-id="b4e80-102">详细信息</span><span class="sxs-lookup"><span data-stu-id="b4e80-102">Details</span></span>

<span data-ttu-id="b4e80-103">从 .NET Framework 4.7 开始，WPF 替换了 <xref:System.Windows.Controls.Grid> 用于向 \*-列分配空间的算法。</span><span class="sxs-lookup"><span data-stu-id="b4e80-103">Starting with the .NET Framework 4.7, WPF replaces the algorithm that <xref:System.Windows.Controls.Grid> uses to allocate space to \*-columns.</span></span> <span data-ttu-id="b4e80-104">这在以下许多情况下会更改分配给 \*-列的实际宽度：</span><span class="sxs-lookup"><span data-stu-id="b4e80-104">This will change the actual width assigned to \*-columns in a number of cases:</span></span>

- <span data-ttu-id="b4e80-105">当一个或多个 \*-列的最小或最大宽度替代相应列的按比例分配空间时。</span><span class="sxs-lookup"><span data-stu-id="b4e80-105">When one or more \*-columns also have a minimum or maximum width that overrides the proportional allocation for that colum.</span></span> <span data-ttu-id="b4e80-106">（最小宽度可以派生自显式声明 MinWidth，也可以派生自从列内容中获取的隐式最小值。</span><span class="sxs-lookup"><span data-stu-id="b4e80-106">(The minimum width can derive from an explicit MinWidth declaration, or from an implicit minimum obtained from the column's content.</span></span> <span data-ttu-id="b4e80-107">只能通过 MaxWidth 声明显式定义最大宽度。）</span><span class="sxs-lookup"><span data-stu-id="b4e80-107">The maximum width can only be defined explicitly, from a MaxWidth declaration.)</span></span>
- <span data-ttu-id="b4e80-108">当一个或多个 \*-列声明极大 \*-权重时（即大于 10^298）。</span><span class="sxs-lookup"><span data-stu-id="b4e80-108">When one or more \*-columns declare an extremely large \*-weight, greater than 10^298.</span></span>
- <span data-ttu-id="b4e80-109">当 \*-权重明显不同，遇到了浮点不稳定问题（溢出、下溢、精度损失）时。</span><span class="sxs-lookup"><span data-stu-id="b4e80-109">When the \*-weights are sufficiently different to encounter floating-point instability (overflow, underflow, loss of precision).</span></span>
- <span data-ttu-id="b4e80-110">当布局圆化处理已启用且有效显示 DPI 足够高时。</span><span class="sxs-lookup"><span data-stu-id="b4e80-110">When layout rounding is enabled, and the effective display DPI is sufficiently high.</span></span>
<span data-ttu-id="b4e80-111">在前两种情况下，新旧算法生成的宽度明显不同；在最后一种情况下，新旧算法生成的宽度最多相差一或两个像素。</span><span class="sxs-lookup"><span data-stu-id="b4e80-111">In the first two cases, the widths produced by the new algorithm can be significantly different from those produced by the old algorithm; in the last case, the difference will be at most one or two pixels.</span></span><p/><span data-ttu-id="b4e80-112">新算法修复了旧算法中的以下多处 bug：</span><span class="sxs-lookup"><span data-stu-id="b4e80-112">The new algorithm fixes several bugs present in the old algorithm:</span></span>

- <span data-ttu-id="b4e80-113">向列分配的总空间可能会超过网格宽度。</span><span class="sxs-lookup"><span data-stu-id="b4e80-113">Total allocation to columns can exceed the Grid's width.</span></span> <span data-ttu-id="b4e80-114">当向比例份额小于其大小下限的列分配空间时，可能会出现这种问题。</span><span class="sxs-lookup"><span data-stu-id="b4e80-114">This can occur when allocating space to a column whose proportional share is less than its minimum size.</span></span> <span data-ttu-id="b4e80-115">算法会分配大小下限对应的空间，这将减少其他列的可用空间。</span><span class="sxs-lookup"><span data-stu-id="b4e80-115">The algorithm allocates the minimum size, which decreases the space available to other columns.</span></span> <span data-ttu-id="b4e80-116">如果没有可分配空间的 \*-列剩余，分配的总空间可能会过大。</span><span class="sxs-lookup"><span data-stu-id="b4e80-116">If there are no \*-columns left to allocate, the total allocation will be too large.</span></span>
- <span data-ttu-id="b4e80-117">向列分配的总空间可能会占不满网格宽度。</span><span class="sxs-lookup"><span data-stu-id="b4e80-117">Total allocation can fall short of the Grid's width.</span></span> <span data-ttu-id="b4e80-118">这是第 1 个问题的对偶问题，当向比例份额大于其大小上限的列分配空间，没有剩余的 \*-列来收紧空间时，可能会出现这种问题。</span><span class="sxs-lookup"><span data-stu-id="b4e80-118">This is the dual problem to #1, arising when allocating to a column whose proportional share is greater than its maximum size, with no \*-columns left to take up the slack.</span></span>
- <span data-ttu-id="b4e80-119">可能会向两个 \*-列分配与其 \*-权重不成比例的空间。</span><span class="sxs-lookup"><span data-stu-id="b4e80-119">Two \*-columns can receive allocations not proportional to their \*-weights.</span></span> <span data-ttu-id="b4e80-120">这是第 1 个/第 2 个问题造成的较为温和的影响，当依序向 \*-列 A、B 和 C 分配空间，但 B 列的比例份额与约束下限（或上限）冲突时，可能会出现这种问题。</span><span class="sxs-lookup"><span data-stu-id="b4e80-120">This is a milder version of #1/#2, arising when allocating to \*-columns A, B, and C (in that order), where B's proportional share violates its min (or max) constraint.</span></span> <span data-ttu-id="b4e80-121">同样，这会更改 C 列的可用空间，它将比 A 列获得更少（或更多）的按比例分配空间。</span><span class="sxs-lookup"><span data-stu-id="b4e80-121">As above, this changes the space available to column C, who gets less (or more) proportional allocation than A did,</span></span>
- <span data-ttu-id="b4e80-122">权重极大 (&gt; 10^298) 的列全都被视为具有权重 10^298。</span><span class="sxs-lookup"><span data-stu-id="b4e80-122">Columns with extremely large weights (&gt; 10^298) are all treated as if they had weight 10^298.</span></span> <span data-ttu-id="b4e80-123">这些列（以及权重略小的列）之间的比例差异将不会生效。</span><span class="sxs-lookup"><span data-stu-id="b4e80-123">Proportional differences between them (and between columns with slightly smaller weights) are not honored.</span></span>
- <span data-ttu-id="b4e80-124">无法正确处理权重无穷大的列。</span><span class="sxs-lookup"><span data-stu-id="b4e80-124">Columns with inifinte weights are not handled correctly.</span></span> <span data-ttu-id="b4e80-125">[实际上，不能设置无穷大的权重，但这是一项人为限制。</span><span class="sxs-lookup"><span data-stu-id="b4e80-125">[Actually you can't set a weight to Infinity, but this is an artificial restriction.</span></span> <span data-ttu-id="b4e80-126">空间分配代码是在努力处理这样的列，但处理得并不好。]</span><span class="sxs-lookup"><span data-stu-id="b4e80-126">The allocation code was trying to handle it, but doing a bad job.]</span></span>
- <span data-ttu-id="b4e80-127">在避免溢出、下溢、精度损失和类似浮点问题时，存在一些小问题。</span><span class="sxs-lookup"><span data-stu-id="b4e80-127">Several minor problems while avoiding overflow, underflow, loss of precision and similar floating-point issues.</span></span>
- <span data-ttu-id="b4e80-128">在 DPI 足够高的情况下，无法正确调整布局的圆化处理。</span><span class="sxs-lookup"><span data-stu-id="b4e80-128">Adjustments for layout rounding are incorrect at sufficiently high DPI.</span></span>
<span data-ttu-id="b4e80-129">新算法生成符合以下条件的结果：</span><span class="sxs-lookup"><span data-stu-id="b4e80-129">The new algorithm produces results that meet the following criteria:</span></span><p/><span data-ttu-id="b4e80-130">答：</span><span class="sxs-lookup"><span data-stu-id="b4e80-130">A.</span></span> <span data-ttu-id="b4e80-131">分配给 \*-列的实际宽度永远不会小于其最小宽度，也不会大于其最大宽度。</span><span class="sxs-lookup"><span data-stu-id="b4e80-131">The actual width assigned to a \*-column is never less than its minimum width nor greater than its maximum width.</span></span><br/><span data-ttu-id="b4e80-132">B.</span><span class="sxs-lookup"><span data-stu-id="b4e80-132">B.</span></span> <span data-ttu-id="b4e80-133">对于没有分配最小或最大宽度的每个 <em>-列，向其分配与其 <em>-权重成比例的宽度。确切地讲，如果分别使用宽度 x</em> 和 y</em> 声明两个列，且没有向这两个列分配最小或最大宽度，那么将按同一比例向这两个列分配实际宽度 v 和 w：v / w == x / y。</span><span class="sxs-lookup"><span data-stu-id="b4e80-133">Each <em>-column that is not assigned its minimum or maximum width is assigned a width proportional to its <em>-weight. To be precise, if two columns are declared with width x</em> and y</em> respectively, and if neither column receives its minimum or maximum width, the actual widths v and w assigned to the columns are in the same proportion: v / w == x / y.</span></span><br/><span data-ttu-id="b4e80-134">C.</span><span class="sxs-lookup"><span data-stu-id="b4e80-134">C.</span></span> <span data-ttu-id="b4e80-135">分配给“成比例的”\*-列的总宽度等于分配给受约束列（分配有最小或最大宽度的固定、自动和 \*-列）后剩余的可用空间。</span><span class="sxs-lookup"><span data-stu-id="b4e80-135">The total width allocated to &quot;proportional&quot; \*-columns is equal to the space available after allocating to the constrained columns (fixed, auto, and \*-columns that are allocated their min or max width).</span></span> <span data-ttu-id="b4e80-136">此空间可能为零（例如，当最小宽度的总和超过了网格的可用宽度时）。</span><span class="sxs-lookup"><span data-stu-id="b4e80-136">This might be zero, for instance if the sum of the minimum widths exceeds the Grid's availbable width.</span></span><br/><span data-ttu-id="b4e80-137">D.</span><span class="sxs-lookup"><span data-stu-id="b4e80-137">D.</span></span> <span data-ttu-id="b4e80-138">所有这些语句都是针对“理想”布局进行解释的。</span><span class="sxs-lookup"><span data-stu-id="b4e80-138">All these statements are to be interpreted with respect to the &quot;ideal&quot; layout.</span></span> <span data-ttu-id="b4e80-139">当布局圆化处理有效时，实际宽度与理想宽度可能会相差一个像素。</span><span class="sxs-lookup"><span data-stu-id="b4e80-139">When layout rounding is in effect, the actual widths can differ from the ideal widths by as much as one pixel.</span></span><br/><span data-ttu-id="b4e80-140">旧算法只遵循了 (A)，并未遵循上面所述情况中的其他条件。</span><span class="sxs-lookup"><span data-stu-id="b4e80-140">The old algorithm honored (A) but failed to honor the other criteria in the cases outlined above.</span></span><p/><span data-ttu-id="b4e80-141">本文中有关列和宽度的所有说明同样也适用于行和高度。</span><span class="sxs-lookup"><span data-stu-id="b4e80-141">Everything said about columns and widths in this article applies as well to rows and heights.</span></span>

#### <a name="suggestion"></a><span data-ttu-id="b4e80-142">建议</span><span class="sxs-lookup"><span data-stu-id="b4e80-142">Suggestion</span></span>

<span data-ttu-id="b4e80-143">默认情况下，面向 .NET Framework 4.7 及更高 .NET Framework 版本的应用将显示新算法，而面向 .NET Framework 4.6.2 及更早版本的应用将显示旧算法。</span><span class="sxs-lookup"><span data-stu-id="b4e80-143">By default, apps that target versions of the .NET Framework starting with the .NET Framework 4.7 will see the new algorithm, while apps that target the .NET Framework 4.6.2 or earlier versions will see the old algorithm.</span></span><p/><span data-ttu-id="b4e80-144">若要替代默认设置，请使用以下配置设置：</span><span class="sxs-lookup"><span data-stu-id="b4e80-144">To override the default, use the following configuration setting:</span></span>

<pre><code class="lang-xml">&lt;runtime&gt;&#13;&#10;&lt;AppContextSwitchOverrides value=&quot;Switch.System.Windows.Controls.Grid.StarDefinitionsCanExceedAvailableSpace=true&quot; /&gt;&#13;&#10;&lt;/runtime&gt;&#13;&#10;</code></pre>

<span data-ttu-id="b4e80-145">值为 `true` 表示选择旧算法，值为 `false` 表示选择新算法。</span><span class="sxs-lookup"><span data-stu-id="b4e80-145">The value `true` selects the old algorithm, `false` selects the new algorithm.</span></span>

| <span data-ttu-id="b4e80-146">“属性”</span><span class="sxs-lookup"><span data-stu-id="b4e80-146">Name</span></span>    | <span data-ttu-id="b4e80-147">“值”</span><span class="sxs-lookup"><span data-stu-id="b4e80-147">Value</span></span>       |
|:--------|:------------|
| <span data-ttu-id="b4e80-148">范围</span><span class="sxs-lookup"><span data-stu-id="b4e80-148">Scope</span></span>   | <span data-ttu-id="b4e80-149">次要</span><span class="sxs-lookup"><span data-stu-id="b4e80-149">Minor</span></span>       |
| <span data-ttu-id="b4e80-150">Version</span><span class="sxs-lookup"><span data-stu-id="b4e80-150">Version</span></span> | <span data-ttu-id="b4e80-151">4.7</span><span class="sxs-lookup"><span data-stu-id="b4e80-151">4.7</span></span>         |
| <span data-ttu-id="b4e80-152">类型</span><span class="sxs-lookup"><span data-stu-id="b4e80-152">Type</span></span>    | <span data-ttu-id="b4e80-153">重定目标</span><span class="sxs-lookup"><span data-stu-id="b4e80-153">Retargeting</span></span> |
