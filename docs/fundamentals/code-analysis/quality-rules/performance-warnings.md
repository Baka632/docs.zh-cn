---
title: '性能规则 (代码分析) '
description: 了解代码分析性能规则。
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.performancerules
helpviewer_keywords:
- rules, performance
- performance rules
- performance, rules
- managed code analysis rules, performance rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 4409cc46eb73f13f8e59d7a51899da27035bb6af
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/25/2020
ms.locfileid: "96590170"
---
# <a name="performance-rules"></a><span data-ttu-id="f85d9-103">性能规则</span><span class="sxs-lookup"><span data-stu-id="f85d9-103">Performance rules</span></span>

<span data-ttu-id="f85d9-104">性能规则支持高性能库和应用程序。</span><span class="sxs-lookup"><span data-stu-id="f85d9-104">Performance rules support high-performance libraries and applications.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="f85d9-105">在本节中</span><span class="sxs-lookup"><span data-stu-id="f85d9-105">In this section</span></span>

| <span data-ttu-id="f85d9-106">规则</span><span class="sxs-lookup"><span data-stu-id="f85d9-106">Rule</span></span> | <span data-ttu-id="f85d9-107">描述</span><span class="sxs-lookup"><span data-stu-id="f85d9-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="f85d9-108">CA1802:在合适的位置使用文本</span><span class="sxs-lookup"><span data-stu-id="f85d9-108">CA1802: Use Literals Where Appropriate</span></span>](ca1802.md) | <span data-ttu-id="f85d9-109">字段在 Visual Basic) 中声明为静态和只读 (共享和只读，并使用编译时可的值进行初始化。</span><span class="sxs-lookup"><span data-stu-id="f85d9-109">A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized with a value that is computable at compile time.</span></span> <span data-ttu-id="f85d9-110">由于分配给目标字段的值是在编译时可的，因此请将该声明更改为 Visual Basic) "字段中的 const (Const，以便在编译时而不是在运行时计算该值。</span><span class="sxs-lookup"><span data-stu-id="f85d9-110">Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run time.</span></span> |
| [<span data-ttu-id="f85d9-111">CA1805：不必要地初始化</span><span class="sxs-lookup"><span data-stu-id="f85d9-111">CA1805: Do not initialize unnecessarily</span></span>](ca1805.md) | <span data-ttu-id="f85d9-112">在运行构造函数之前，.NET 运行时将引用类型的所有字段初始化为其默认值。</span><span class="sxs-lookup"><span data-stu-id="f85d9-112">The .NET runtime initializes all fields of reference types to their default values before running the constructor.</span></span> <span data-ttu-id="f85d9-113">在大多数情况下，显式将字段初始化为其默认值是冗余的，这会增加维护成本，并可能会降低性能 (例如，通过增加) 的程序集大小。</span><span class="sxs-lookup"><span data-stu-id="f85d9-113">In most cases, explicitly initializing a field to its default value is redundant, which adds to maintenance costs and may degrade performance (such as with increased assembly size).</span></span> |
| [<span data-ttu-id="f85d9-114">CA1806:不要忽略方法结果</span><span class="sxs-lookup"><span data-stu-id="f85d9-114">CA1806: Do not ignore method results</span></span>](ca1806.md) | <span data-ttu-id="f85d9-115">已创建新的对象，但从未使用过，或者创建并返回新字符串的方法未被使用，或者不使用新字符串，或者组件对象模型 (COM) 或 P/Invoke 方法返回从未使用过的 HRESULT 或错误代码。</span><span class="sxs-lookup"><span data-stu-id="f85d9-115">A new object is created but never used, or a method that creates and returns a new string is called and the new string is never used, or a Component Object Model (COM) or P/Invoke method returns an HRESULT or error code that is never used.</span></span> |
| [<span data-ttu-id="f85d9-116">CA1810:以内联方式初始化引用类型的静态字段</span><span class="sxs-lookup"><span data-stu-id="f85d9-116">CA1810: Initialize reference type static fields inline</span></span>](ca1810.md) | <span data-ttu-id="f85d9-117">当一个类型声明显式静态构造函数时，实时 (JIT) 编译器会向该类型的每个静态方法和实例构造函数中添加一项检查，以确保之前已调用该静态构造函数。</span><span class="sxs-lookup"><span data-stu-id="f85d9-117">When a type declares an explicit static constructor, the just-in-time (JIT) compiler adds a check to each static method and instance constructor of the type to make sure that the static constructor was previously called.</span></span> <span data-ttu-id="f85d9-118">静态构造函数检查会降低性能。</span><span class="sxs-lookup"><span data-stu-id="f85d9-118">Static constructor checks can decrease performance.</span></span> |
| [<span data-ttu-id="f85d9-119">CA1812:避免未实例化的内部类</span><span class="sxs-lookup"><span data-stu-id="f85d9-119">CA1812: Avoid uninstantiated internal classes</span></span>](ca1812.md) | <span data-ttu-id="f85d9-120">程序集级别类型的实例不是由程序集中的代码创建的。</span><span class="sxs-lookup"><span data-stu-id="f85d9-120">An instance of an assembly-level type is not created by code in the assembly.</span></span> |
| [<span data-ttu-id="f85d9-121">CA1813:避免使用非密封特性</span><span class="sxs-lookup"><span data-stu-id="f85d9-121">CA1813: Avoid unsealed attributes</span></span>](ca1813.md) | <span data-ttu-id="f85d9-122">.NET 提供了用于检索自定义特性的方法。</span><span class="sxs-lookup"><span data-stu-id="f85d9-122">.NET provides methods for retrieving custom attributes.</span></span> <span data-ttu-id="f85d9-123">默认情况下，这些方法搜索特性继承层次结构。</span><span class="sxs-lookup"><span data-stu-id="f85d9-123">By default, these methods search the attribute inheritance hierarchy.</span></span> <span data-ttu-id="f85d9-124">通过密封特性，将无需搜索继承层次结构，且能够提高性能。</span><span class="sxs-lookup"><span data-stu-id="f85d9-124">Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</span></span> |
| [<span data-ttu-id="f85d9-125">CA1814:与多维数组相比，首选使用交错数组</span><span class="sxs-lookup"><span data-stu-id="f85d9-125">CA1814: Prefer jagged arrays over multidimensional</span></span>](ca1814.md) | <span data-ttu-id="f85d9-126">交错数组是元素为数组的数组。</span><span class="sxs-lookup"><span data-stu-id="f85d9-126">A jagged array is an array whose elements are arrays.</span></span> <span data-ttu-id="f85d9-127">构成元素的数组可以是不同的大小，这可能会导致某些数据集的空间浪费更少。</span><span class="sxs-lookup"><span data-stu-id="f85d9-127">The arrays that make up the elements can be of different sizes, which can result in less wasted space for some sets of data.</span></span> |
| [<span data-ttu-id="f85d9-128">CA1815:重写值类型上的 Equals 和相等运算符</span><span class="sxs-lookup"><span data-stu-id="f85d9-128">CA1815: Override equals and operator equals on value types</span></span>](ca1815.md) | <span data-ttu-id="f85d9-129">对于值类型，Equals 的继承的实现使用反射库，并比较所有字段的内容。</span><span class="sxs-lookup"><span data-stu-id="f85d9-129">For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields.</span></span> <span data-ttu-id="f85d9-130">反射需要消耗大量计算资源，可能没有必要比较每一个字段是否相等。</span><span class="sxs-lookup"><span data-stu-id="f85d9-130">Reflection is computationally expensive, and comparing every field for equality might be unnecessary.</span></span> <span data-ttu-id="f85d9-131">如果希望用户对实例进行比较或排序，或者希望用户将实例用作哈希表键，则值类型应实现 Equals。</span><span class="sxs-lookup"><span data-stu-id="f85d9-131">If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</span></span> |
| [<span data-ttu-id="f85d9-132">CA1819:属性不应返回数组</span><span class="sxs-lookup"><span data-stu-id="f85d9-132">CA1819: Properties should not return arrays</span></span>](ca1819.md) | <span data-ttu-id="f85d9-133">即使属性是只读的，由属性返回的数组仍不受写保护。</span><span class="sxs-lookup"><span data-stu-id="f85d9-133">Arrays that are returned by properties are not write-protected, even if the property is read-only.</span></span> <span data-ttu-id="f85d9-134">若要使数组不会被更改，属性必须返回数组的副本。</span><span class="sxs-lookup"><span data-stu-id="f85d9-134">To keep the array tamper-proof, the property must return a copy of the array.</span></span> <span data-ttu-id="f85d9-135">通常，用户不能理解调用这种属性的负面性能影响。</span><span class="sxs-lookup"><span data-stu-id="f85d9-135">Typically, users will not understand the adverse performance implications of calling such a property.</span></span> |
| [<span data-ttu-id="f85d9-136">CA1820:使用字符串长度测试是否有空字符串</span><span class="sxs-lookup"><span data-stu-id="f85d9-136">CA1820: Test for empty strings using string length</span></span>](ca1820.md) | <span data-ttu-id="f85d9-137">使用 String.Length 属性或 String.IsNullOrEmpty 方法比较字符串要比使用 Equals 的速度快得多。</span><span class="sxs-lookup"><span data-stu-id="f85d9-137">Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</span></span> |
| [<span data-ttu-id="f85d9-138">CA1821:移除空终结器</span><span class="sxs-lookup"><span data-stu-id="f85d9-138">CA1821: Remove empty finalizers</span></span>](ca1821.md) | <span data-ttu-id="f85d9-139">应尽可能避免终结器，因为跟踪对象生存期会产生额外的性能系统开销。</span><span class="sxs-lookup"><span data-stu-id="f85d9-139">Whenever you can, avoid finalizers because of the additional performance overhead that is involved in tracking object lifetime.</span></span> <span data-ttu-id="f85d9-140">空的终结器会产生额外的开销，而不会带来任何好处。</span><span class="sxs-lookup"><span data-stu-id="f85d9-140">An empty finalizer incurs added overhead without any benefit.</span></span> |
| [<span data-ttu-id="f85d9-141">CA1822:将成员标记为 static</span><span class="sxs-lookup"><span data-stu-id="f85d9-141">CA1822: Mark members as static</span></span>](ca1822.md) | <span data-ttu-id="f85d9-142">不访问实例数据或调用实例方法的成员可以标记为静态 (在 Visual Basic) 中共享。</span><span class="sxs-lookup"><span data-stu-id="f85d9-142">Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic).</span></span> <span data-ttu-id="f85d9-143">在将这些方法标记为 static 之后，编译器将向这些成员发出非虚拟调用站点。</span><span class="sxs-lookup"><span data-stu-id="f85d9-143">After you mark the methods as static, the compiler will emit nonvirtual call sites to these members.</span></span> <span data-ttu-id="f85d9-144">这会使性能敏感的代码的性能得到显著提高。</span><span class="sxs-lookup"><span data-stu-id="f85d9-144">This can give you a measurable performance gain for performance-sensitive code.</span></span> |
| [<span data-ttu-id="f85d9-145">CA1823:避免未使用的私有字段</span><span class="sxs-lookup"><span data-stu-id="f85d9-145">CA1823: Avoid unused private fields</span></span>](ca1823.md) | <span data-ttu-id="f85d9-146">检测到程序集内有似乎未访问过的私有字段。</span><span class="sxs-lookup"><span data-stu-id="f85d9-146">Private fields were detected that do not appear to be accessed in the assembly.</span></span> |
| [<span data-ttu-id="f85d9-147">CA1824:用 NeutralResourcesLanguageAttribute 标记程序集</span><span class="sxs-lookup"><span data-stu-id="f85d9-147">CA1824: Mark assemblies with NeutralResourcesLanguageAttribute</span></span>](ca1824.md) | <span data-ttu-id="f85d9-148">NeutralResourcesLanguage 属性通知用于显示程序集的非特定区域性资源的语言资源管理器。</span><span class="sxs-lookup"><span data-stu-id="f85d9-148">The NeutralResourcesLanguage attribute informs the Resource Manager of the language that was used to display the resources of a neutral culture for an assembly.</span></span> <span data-ttu-id="f85d9-149">这将改进所加载的第一个资源的查找性能，并缩小工作集。</span><span class="sxs-lookup"><span data-stu-id="f85d9-149">This improves lookup performance for the first resource that you load and can reduce your working set.</span></span> |
| [<span data-ttu-id="f85d9-150">CA1825:避免数组分配长度为零</span><span class="sxs-lookup"><span data-stu-id="f85d9-150">CA1825: Avoid zero-length array allocations</span></span>](ca1825.md) | <span data-ttu-id="f85d9-151">初始化长度为零的数组将导致不必要的内存分配。</span><span class="sxs-lookup"><span data-stu-id="f85d9-151">Initializing a zero-length array leads to unnecessary memory allocation.</span></span> <span data-ttu-id="f85d9-152">相反，请通过调用来使用静态分配的空数组实例 <xref:System.Array.Empty%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="f85d9-152">Instead, use the statically allocated empty array instance by calling <xref:System.Array.Empty%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f85d9-153">内存分配在此方法的所有调用之间共享。</span><span class="sxs-lookup"><span data-stu-id="f85d9-153">The memory allocation is shared across all invocations of this method.</span></span> |
| [<span data-ttu-id="f85d9-154">CA1826:使用属性，而不是 Linq Enumerable 方法</span><span class="sxs-lookup"><span data-stu-id="f85d9-154">CA1826: Use property instead of Linq Enumerable method</span></span>](ca1826.md) | <span data-ttu-id="f85d9-155"><xref:System.Linq.Enumerable> LINQ 方法用于支持等效且更有效的属性的类型。</span><span class="sxs-lookup"><span data-stu-id="f85d9-155"><xref:System.Linq.Enumerable> LINQ method was used on a type that supports an equivalent, more efficient property.</span></span> |
| [<span data-ttu-id="f85d9-156">CA1827:如果可以使用 Any，请勿使用 Count/LongCount</span><span class="sxs-lookup"><span data-stu-id="f85d9-156">CA1827: Do not use Count/LongCount when Any can be used</span></span>](ca1827.md) | <span data-ttu-id="f85d9-157"><xref:System.Linq.Enumerable.Count%2A><xref:System.Linq.Enumerable.LongCount%2A>使用方法，其中 <xref:System.Linq.Enumerable.Any%2A> 方法会更有效。</span><span class="sxs-lookup"><span data-stu-id="f85d9-157"><xref:System.Linq.Enumerable.Count%2A> or <xref:System.Linq.Enumerable.LongCount%2A> method was used where <xref:System.Linq.Enumerable.Any%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="f85d9-158">CA1828:如果可以使用 AnyAsync，请勿使用 CountAsync/LongCountAsync</span><span class="sxs-lookup"><span data-stu-id="f85d9-158">CA1828: Do not use CountAsync/LongCountAsync when AnyAsync can be used</span></span>](ca1828.md) | <span data-ttu-id="f85d9-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A>使用方法，其中 <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> 方法会更有效。</span><span class="sxs-lookup"><span data-stu-id="f85d9-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> or <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> method was used where <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="f85d9-160">CA1829:使用 Length/Count 属性，而不是 Enumerable.Count 方法</span><span class="sxs-lookup"><span data-stu-id="f85d9-160">CA1829: Use Length/Count property instead of Enumerable.Count method</span></span>](ca1829.md) | <span data-ttu-id="f85d9-161"><xref:System.Linq.Enumerable.Count%2A> LINQ 方法用于支持等效的、更有效的或属性的类型 `Length` `Count` 。</span><span class="sxs-lookup"><span data-stu-id="f85d9-161"><xref:System.Linq.Enumerable.Count%2A> LINQ method was used on a type that supports an equivalent, more efficient `Length` or `Count` property.</span></span> |
| [<span data-ttu-id="f85d9-162">CA1830:在 StringBuilder 上优先使用强类型“追加和插入”方法重载</span><span class="sxs-lookup"><span data-stu-id="f85d9-162">CA1830: Prefer strongly-typed Append and Insert method overloads on StringBuilder</span></span>](ca1830.md) | <span data-ttu-id="f85d9-163"><xref:System.Text.StringBuilder.Append%2A> 和 <xref:System.Text.StringBuilder.Insert%2A> 为除 system.string 之外的多个类型提供重载。</span><span class="sxs-lookup"><span data-stu-id="f85d9-163"><xref:System.Text.StringBuilder.Append%2A> and <xref:System.Text.StringBuilder.Insert%2A> provide overloads for multiple types beyond System.String.</span></span>  <span data-ttu-id="f85d9-164">如果可能，更倾向于使用 ToString ( # A1 和基于字符串的重载中的强类型重载。</span><span class="sxs-lookup"><span data-stu-id="f85d9-164">When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload.</span></span> |
| [<span data-ttu-id="f85d9-165">CA1831:在合适的情况下，为字符串使用 AsSpan 而不是基于范围的索引器</span><span class="sxs-lookup"><span data-stu-id="f85d9-165">CA1831: Use AsSpan instead of Range-based indexers for string when appropriate</span></span>](ca1831.md) | <span data-ttu-id="f85d9-166">对字符串使用范围索引器并将值隐式赋值给 ReadOnlySpan &lt; char &gt; 类型时， <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> 将使用方法而不是 <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> ，这将生成请求的字符串部分的副本。</span><span class="sxs-lookup"><span data-stu-id="f85d9-166">When using a range-indexer on a string and implicitly assigning the value to a ReadOnlySpan&lt;char&gt; type, the method <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the string.</span></span> |
| [<span data-ttu-id="f85d9-167">CA1832:使用 AsSpan 或 AsMemory 而不是基于范围的索引器来获取数组的 ReadOnlySpan 或 ReadOnlyMemory 部分</span><span class="sxs-lookup"><span data-stu-id="f85d9-167">CA1832: Use AsSpan or AsMemory instead of Range-based indexers for getting ReadOnlySpan or ReadOnlyMemory portion of an array</span></span>](ca1832.md) | <span data-ttu-id="f85d9-168">在数组上使用范围索引器并将值隐式赋值给 <xref:System.ReadOnlySpan%601> 或类型时 <xref:System.ReadOnlyMemory%601> ， <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> 将使用方法而不是 <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> ，这将生成数组的请求部分的副本。</span><span class="sxs-lookup"><span data-stu-id="f85d9-168">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.ReadOnlySpan%601> or <xref:System.ReadOnlyMemory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="f85d9-169">CA1833:使用 AsSpan 或 AsMemory 而不是基于范围的索引器来获取数组的 Span 或 Memory 部分</span><span class="sxs-lookup"><span data-stu-id="f85d9-169">CA1833: Use AsSpan or AsMemory instead of Range-based indexers for getting Span or Memory portion of an array</span></span>](ca1833.md) | <span data-ttu-id="f85d9-170">在数组上使用范围索引器并将值隐式赋值给 <xref:System.Span%601> 或类型时 <xref:System.Memory%601> ， <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> 将使用方法而不是 <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> ，这将生成数组的请求部分的副本。</span><span class="sxs-lookup"><span data-stu-id="f85d9-170">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.Span%601> or <xref:System.Memory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="f85d9-171">CA1834:对单字符字符串使用 StringBuilder.Append(char)</span><span class="sxs-lookup"><span data-stu-id="f85d9-171">CA1834: Use StringBuilder.Append(char) for single character strings</span></span>](ca1834.md) | <span data-ttu-id="f85d9-172"><xref:System.Text.StringBuilder> 具有一个 `Append` 采用 `char` 作为参数的重载。</span><span class="sxs-lookup"><span data-stu-id="f85d9-172"><xref:System.Text.StringBuilder> has an `Append` overload that takes a `char` as its argument.</span></span> <span data-ttu-id="f85d9-173">更倾向 `char` 于调用重载以提高性能。</span><span class="sxs-lookup"><span data-stu-id="f85d9-173">Prefer calling the `char` overload to improve performance.</span></span> |
| [<span data-ttu-id="f85d9-174">CA1835：首选 "ReadAsync" 和 "WriteAsync" 的基于 Memory' 的重载</span><span class="sxs-lookup"><span data-stu-id="f85d9-174">CA1835: Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'</span></span>](ca1835.md) | <span data-ttu-id="f85d9-175">"Stream" 有一个 "ReadAsync" 重载，该重载采用 "Memory &lt; byte &gt; " 作为第一个参数，而 "WriteAsync" 重载采用 "ReadOnlyMemory &lt; Byte &gt; " 作为第一个参数。</span><span class="sxs-lookup"><span data-stu-id="f85d9-175">'Stream' has a 'ReadAsync' overload that takes a 'Memory&lt;Byte&gt;' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory&lt;Byte&gt;' as the first argument.</span></span> <span data-ttu-id="f85d9-176">更愿意调用基于内存的重载，这些重载更有效。</span><span class="sxs-lookup"><span data-stu-id="f85d9-176">Prefer calling the memory based overloads, which are more efficient.</span></span> |
| [<span data-ttu-id="f85d9-177">CA1836：优先 `IsEmpty` `Count` 使用（如果可用）</span><span class="sxs-lookup"><span data-stu-id="f85d9-177">CA1836: Prefer `IsEmpty` over `Count` when available</span></span>](ca1836.md) | <span data-ttu-id="f85d9-178">首选 `IsEmpty` 比、或更有效的属性， `Count` `Length` <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 以确定对象是否包含任何项。</span><span class="sxs-lookup"><span data-stu-id="f85d9-178">Prefer `IsEmpty` property that is more efficient than `Count`, `Length`, <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> or <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> to determine whether the object contains or not any items.</span></span> |
| [<span data-ttu-id="f85d9-179">CA1837：使用 `Environment.ProcessId` 而不是 `Process.GetCurrentProcess().Id`</span><span class="sxs-lookup"><span data-stu-id="f85d9-179">CA1837: Use `Environment.ProcessId` instead of `Process.GetCurrentProcess().Id`</span></span>](ca1837.md) | <span data-ttu-id="f85d9-180">`Environment.ProcessId` 比更简单、更快 `Process.GetCurrentProcess().Id` 。</span><span class="sxs-lookup"><span data-stu-id="f85d9-180">`Environment.ProcessId` is simpler and faster than `Process.GetCurrentProcess().Id`.</span></span> |
| [<span data-ttu-id="f85d9-181">CA1838：避免 `StringBuilder` P/invoke 参数</span><span class="sxs-lookup"><span data-stu-id="f85d9-181">CA1838: Avoid `StringBuilder` parameters for P/Invokes</span></span>](ca1838.md) | <span data-ttu-id="f85d9-182">的封送处理 `StringBuilder` 始终创建本机缓冲区副本，从而导致一个封送处理操作有多个分配。</span><span class="sxs-lookup"><span data-stu-id="f85d9-182">Marshaling of `StringBuilder` always creates a native buffer copy, resulting in multiple allocations for one marshaling operation.</span></span> |
