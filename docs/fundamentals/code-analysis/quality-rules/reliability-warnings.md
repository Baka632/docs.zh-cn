---
title: '可靠性规则 (代码分析) '
description: 了解代码分析可靠性规则。
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.reliabilityrules
helpviewer_keywords:
- rules, reliability
- reliability rules
- managed code analysis rules, reliability rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: a747dd4dcda351a1ddb0f3d069bb7bac895c32f8
ms.sourcegitcommit: 636af37170ae75a11c4f7d1ecd770820e7dfe7bd
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/07/2020
ms.locfileid: "96590536"
---
# <a name="reliability-rules"></a><span data-ttu-id="d5bed-103">可靠性规则</span><span class="sxs-lookup"><span data-stu-id="d5bed-103">Reliability rules</span></span>

<span data-ttu-id="d5bed-104">可靠性规则支持库和应用程序的可靠性，如正确的内存和线程使用。</span><span class="sxs-lookup"><span data-stu-id="d5bed-104">Reliability rules support library and application reliability, such as correct memory and thread usage.</span></span> <span data-ttu-id="d5bed-105">可靠性规则包括：</span><span class="sxs-lookup"><span data-stu-id="d5bed-105">The reliability rules include:</span></span>

|<span data-ttu-id="d5bed-106">规则</span><span class="sxs-lookup"><span data-stu-id="d5bed-106">Rule</span></span>|<span data-ttu-id="d5bed-107">描述</span><span class="sxs-lookup"><span data-stu-id="d5bed-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="d5bed-108">CA2000:丢失范围之前释放对象</span><span class="sxs-lookup"><span data-stu-id="d5bed-108">CA2000: Dispose objects before losing scope</span></span>](ca2000.md)|<span data-ttu-id="d5bed-109">由于可能发生异常事件，导致对象的终结器无法运行，因此，应显式释放对象，以避免对该对象的所有引用超出范围。</span><span class="sxs-lookup"><span data-stu-id="d5bed-109">Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed before all references to it are out of scope.</span></span>|
|[<span data-ttu-id="d5bed-110">CA2002:不要锁定具有弱标识的对象</span><span class="sxs-lookup"><span data-stu-id="d5bed-110">CA2002: Do not lock on objects with weak identity</span></span>](ca2002.md)|<span data-ttu-id="d5bed-111">当可以跨应用程序域边界直接进行访问对象时，则认为该对象具有弱标识。</span><span class="sxs-lookup"><span data-stu-id="d5bed-111">An object is said to have a weak identity when it can be directly accessed across application domain boundaries.</span></span> <span data-ttu-id="d5bed-112">对于尝试获取对具有弱标识的对象的锁的线程，该线程可能会被其他应用程序域中持有对同一对象的锁的另一线程所阻止。</span><span class="sxs-lookup"><span data-stu-id="d5bed-112">A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</span></span>|
|[<span data-ttu-id="d5bed-113">CA2007：不直接等待任务</span><span class="sxs-lookup"><span data-stu-id="d5bed-113">CA2007: Do not directly await a Task</span></span>](ca2007.md)|<span data-ttu-id="d5bed-114">异步方法会[awaits](../../../csharp/language-reference/operators/await.md)直接等待 <xref:System.Threading.Tasks.Task> 。</span><span class="sxs-lookup"><span data-stu-id="d5bed-114">An asynchronous method [awaits](../../../csharp/language-reference/operators/await.md) a <xref:System.Threading.Tasks.Task> directly.</span></span>|
|[<span data-ttu-id="d5bed-115">CA2008：不要在未传递 TaskScheduler 的情况下创建任务</span><span class="sxs-lookup"><span data-stu-id="d5bed-115">CA2008: Do not create tasks without passing a TaskScheduler</span></span>](ca2008.md)|<span data-ttu-id="d5bed-116">任务创建或继续操作使用未指定参数的方法重载 <xref:System.Threading.Tasks.TaskScheduler> 。</span><span class="sxs-lookup"><span data-stu-id="d5bed-116">A task creation or continuation operation uses a method overload that does not specify a <xref:System.Threading.Tasks.TaskScheduler> parameter.</span></span>|
|[<span data-ttu-id="d5bed-117">CA2009：请勿对 ImmutableCollection 值调用 ToImmutableCollection</span><span class="sxs-lookup"><span data-stu-id="d5bed-117">CA2009: Do not call ToImmutableCollection on an ImmutableCollection value</span></span>](ca2009.md)|<span data-ttu-id="d5bed-118">`ToImmutable` 不必要地对命名空间中的不可变集合调用方法 <xref:System.Collections.Immutable> 。</span><span class="sxs-lookup"><span data-stu-id="d5bed-118">`ToImmutable` method was unnecessarily called on an immutable collection from <xref:System.Collections.Immutable> namespace.</span></span>|
|[<span data-ttu-id="d5bed-119">CA2011:请勿在其资源库中分配属性</span><span class="sxs-lookup"><span data-stu-id="d5bed-119">CA2011: Do not assign property within its setter</span></span>](ca2011.md) | <span data-ttu-id="d5bed-120">属性在其自身的 [set 访问器](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor)中被意外赋值。</span><span class="sxs-lookup"><span data-stu-id="d5bed-120">A property was accidentally assigned a value within its own [set accessor](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor).</span></span> |
|[<span data-ttu-id="d5bed-121">CA2012:正确使用 ValueTask</span><span class="sxs-lookup"><span data-stu-id="d5bed-121">CA2012: Use ValueTasks correctly</span></span>](ca2012.md) | <span data-ttu-id="d5bed-122">从成员调用返回的 ValueTasks 将直接等待。</span><span class="sxs-lookup"><span data-stu-id="d5bed-122">ValueTasks returned from member invocations are intended to be directly awaited.</span></span>  <span data-ttu-id="d5bed-123">多次尝试使用 ValueTask 或在已知完成前直接访问一个结果可能会导致异常或损坏。</span><span class="sxs-lookup"><span data-stu-id="d5bed-123">Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.</span></span>  <span data-ttu-id="d5bed-124">忽略此类 ValueTask 可能表明出现功能 bug，并可能会降低性能。</span><span class="sxs-lookup"><span data-stu-id="d5bed-124">Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.</span></span> |
|[<span data-ttu-id="d5bed-125">CA2013:请勿将 ReferenceEquals 与值类型结合使用</span><span class="sxs-lookup"><span data-stu-id="d5bed-125">CA2013: Do not use ReferenceEquals with value types</span></span>](ca2013.md) | <span data-ttu-id="d5bed-126">使用比较值时 <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> ，如果 objA 和 objB 是值类型，则在将其传递给方法之前将它们装箱 <xref:System.Object.ReferenceEquals%2A> 。</span><span class="sxs-lookup"><span data-stu-id="d5bed-126">When comparing values using <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName>, if objA and objB are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="d5bed-127">这意味着，即使 objA 和 objB 都表示值类型的同一个实例，该方法也会 <xref:System.Object.ReferenceEquals%2A> 返回 false。</span><span class="sxs-lookup"><span data-stu-id="d5bed-127">This means that even if both objA and objB represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns false.</span></span> |
|[<span data-ttu-id="d5bed-128">CA2014：不要在循环中使用 stackalloc。</span><span class="sxs-lookup"><span data-stu-id="d5bed-128">CA2014: Do not use stackalloc in loops.</span></span>](ca2014.md) | <span data-ttu-id="d5bed-129">Stackalloc 分配的堆栈空间仅在当前方法的调用结束时释放。</span><span class="sxs-lookup"><span data-stu-id="d5bed-129">Stack space allocated by a stackalloc is only released at the end of the current method's invocation.</span></span>  <span data-ttu-id="d5bed-130">在循环中使用此方法可能会导致无限堆栈增长，并最终产生堆栈溢出情况。</span><span class="sxs-lookup"><span data-stu-id="d5bed-130">Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.</span></span> |
|[<span data-ttu-id="d5bed-131">CA2015：不要为派生自 MemoryManager T 的类型定义终结器 &lt;&gt;</span><span class="sxs-lookup"><span data-stu-id="d5bed-131">CA2015: Do not define finalizers for types derived from MemoryManager&lt;T&gt;</span></span>](ca2015.md) | <span data-ttu-id="d5bed-132">将终结器添加到从派生的类型 <xref:System.Buffers.MemoryManager%601> 时，可能会允许在仍在使用时释放内存 <xref:System.Span%601> 。</span><span class="sxs-lookup"><span data-stu-id="d5bed-132">Adding a finalizer to a type derived from <xref:System.Buffers.MemoryManager%601> may permit memory to be freed while it is still in use by a <xref:System.Span%601>.</span></span> |
|[<span data-ttu-id="d5bed-133">CA2016：将 CancellationToken 参数转发到采用一个该参数的方法</span><span class="sxs-lookup"><span data-stu-id="d5bed-133">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>](ca2016.md) | <span data-ttu-id="d5bed-134">将 `CancellationToken` 参数转发到方法，这些方法采用一个来确保正确传播操作取消通知，或显式传递 `CancellationToken.None` 以指示有意不传播标记。</span><span class="sxs-lookup"><span data-stu-id="d5bed-134">Forward the `CancellationToken` parameter to methods that take one to ensure the operation cancellation notifications gets properly propagated, or pass in `CancellationToken.None` explicitly to indicate intentionally not propagating the token.</span></span> |
