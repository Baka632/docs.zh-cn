---
title: 无服务器设计示例 - 无服务器应用
description: 了解无服务器体系结构支持的各种方案，从计划和基于事件的处理到文件触发器和流进程。
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: 3aa9b7951fd8f11a65a64c22443de7041aba7d94
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/24/2020
ms.locfileid: "91171749"
---
# <a name="serverless-design-examples"></a><span data-ttu-id="4b83d-103">无服务器设计示例</span><span class="sxs-lookup"><span data-stu-id="4b83d-103">Serverless design examples</span></span>

<span data-ttu-id="4b83d-104">存在许多无服务器的设计模式。</span><span class="sxs-lookup"><span data-stu-id="4b83d-104">There are many design patterns that exist for serverless.</span></span> <span data-ttu-id="4b83d-105">本部分捕获了一些使用无服务器的常见方案。</span><span class="sxs-lookup"><span data-stu-id="4b83d-105">This section captures some common scenarios that use serverless.</span></span> <span data-ttu-id="4b83d-106">所有这些示例的共同点是事件触发器和业务逻辑的基本组合。</span><span class="sxs-lookup"><span data-stu-id="4b83d-106">What all of the examples have in common is the fundamental combination of an event trigger and business logic.</span></span>

## <a name="scheduling"></a><span data-ttu-id="4b83d-107">计划</span><span class="sxs-lookup"><span data-stu-id="4b83d-107">Scheduling</span></span>

<span data-ttu-id="4b83d-108">计划任务是一种常见功能。</span><span class="sxs-lookup"><span data-stu-id="4b83d-108">Scheduling tasks is a common function.</span></span> <span data-ttu-id="4b83d-109">下图显示了不具有适当完整性检查的旧数据库。</span><span class="sxs-lookup"><span data-stu-id="4b83d-109">The following diagram shows a legacy database that doesn't have appropriate integrity checks.</span></span> <span data-ttu-id="4b83d-110">数据库必须定期进行清理。</span><span class="sxs-lookup"><span data-stu-id="4b83d-110">The database must be scrubbed periodically.</span></span> <span data-ttu-id="4b83d-111">无服务器函数查找无效数据并将其清除。</span><span class="sxs-lookup"><span data-stu-id="4b83d-111">The serverless function finds invalid data and cleans it.</span></span> <span data-ttu-id="4b83d-112">触发器是一种按计划运行代码的计时器。</span><span class="sxs-lookup"><span data-stu-id="4b83d-112">The trigger is a timer that runs the code on a schedule.</span></span>

![无服务器计划](./media/serverless-scheduling.png)

## <a name="command-and-query-responsibility-segregation-cqrs"></a><span data-ttu-id="4b83d-114">命令和查询责任分离 (CQRS)</span><span class="sxs-lookup"><span data-stu-id="4b83d-114">Command and Query Responsibility Segregation (CQRS)</span></span>

<span data-ttu-id="4b83d-115">命令和查询责任分离 (CQRS) 是一种为读取（或查询）数据和修改数据的操作提供不同接口的模式。</span><span class="sxs-lookup"><span data-stu-id="4b83d-115">Command and Query Responsibility Segregation (CQRS) is a pattern that provides different interfaces for reading (or querying) data and operations that modify data.</span></span> <span data-ttu-id="4b83d-116">它解决了几个常见问题。</span><span class="sxs-lookup"><span data-stu-id="4b83d-116">It addresses several common problems.</span></span> <span data-ttu-id="4b83d-117">在传统的基于创建读取更新删除 (CRUD) 的系统中，对同一数据存储的大量读写操作可能会产生冲突。</span><span class="sxs-lookup"><span data-stu-id="4b83d-117">In traditional Create Read Update Delete (CRUD) based systems, conflicts can arise from high volume of both reads and writes to the same data store.</span></span> <span data-ttu-id="4b83d-118">锁定可能频繁发生，并大大降低读取速度。</span><span class="sxs-lookup"><span data-stu-id="4b83d-118">Locking may frequently occur and dramatically slow down reads.</span></span> <span data-ttu-id="4b83d-119">通常，数据由多个域对象组合而成，且读取操作必须将来自不同实体的数据组合在一起。</span><span class="sxs-lookup"><span data-stu-id="4b83d-119">Often, data is presented as a composite of several domain objects and read operations must combine data from different entities.</span></span>

<span data-ttu-id="4b83d-120">使用 CQRS 时，读取可能涉及特殊的“平展”实体，该实体按使用方式对数据进行建模。</span><span class="sxs-lookup"><span data-stu-id="4b83d-120">Using CQRS, a read might involve a special "flattened" entity that models data the way it's consumed.</span></span> <span data-ttu-id="4b83d-121">读取的处理方式不同于其存储方式。</span><span class="sxs-lookup"><span data-stu-id="4b83d-121">The read is handled differently than how it's stored.</span></span> <span data-ttu-id="4b83d-122">例如，尽管数据库可以将联系人存储为带有子地址记录的标头记录，但读取可能涉及带有标头和地址属性的实体。</span><span class="sxs-lookup"><span data-stu-id="4b83d-122">For example, although the database may store a contact as a header record with a child address record, the read could involve an entity with both header and address properties.</span></span> <span data-ttu-id="4b83d-123">创建这种读取模型的方法有很多。</span><span class="sxs-lookup"><span data-stu-id="4b83d-123">There are myriad approaches to creating the read model.</span></span> <span data-ttu-id="4b83d-124">它可能是从视图中具体化来的。</span><span class="sxs-lookup"><span data-stu-id="4b83d-124">It might be materialized from views.</span></span> <span data-ttu-id="4b83d-125">更新操作可被封装为隔离的事件，然后触发对两个不同模型的更新。</span><span class="sxs-lookup"><span data-stu-id="4b83d-125">Update operations could be encapsulated as isolated events that then trigger updates to two different models.</span></span> <span data-ttu-id="4b83d-126">存在单独的模型用于读取和写入。</span><span class="sxs-lookup"><span data-stu-id="4b83d-126">Separate models exist for reading and writing.</span></span>

![CQRS 示例](./media/cqrs-example.png)

<span data-ttu-id="4b83d-128">无服务器可通过提供隔离的终结点来容纳 CQRS 模式。</span><span class="sxs-lookup"><span data-stu-id="4b83d-128">Serverless can accommodate the CQRS pattern by providing the segregated endpoints.</span></span> <span data-ttu-id="4b83d-129">一个无服务器函数容纳查询或读取，另一个无服务器函数或函数集处理更新操作。</span><span class="sxs-lookup"><span data-stu-id="4b83d-129">One serverless function accommodates queries or reads, and a different serverless function or set of functions handles update operations.</span></span> <span data-ttu-id="4b83d-130">无服务器函数还可以负责确保读取模型保持最新状态，并且可由数据库的[更改源](/azure/cosmos-db/change-feed)触发。</span><span class="sxs-lookup"><span data-stu-id="4b83d-130">A serverless function may also be responsible for keeping the read model up-to-date, and can be triggered by the database's [change feed](/azure/cosmos-db/change-feed).</span></span> <span data-ttu-id="4b83d-131">可简化前端开发以连接到所需的终结点。</span><span class="sxs-lookup"><span data-stu-id="4b83d-131">Front-end development is simplified to connecting to the necessary endpoints.</span></span> <span data-ttu-id="4b83d-132">事件处理在后端进行。</span><span class="sxs-lookup"><span data-stu-id="4b83d-132">Processing of events is handled on the back end.</span></span> <span data-ttu-id="4b83d-133">此模型还适用于大型项目，因为不同的团队可以处理不同的操作。</span><span class="sxs-lookup"><span data-stu-id="4b83d-133">This model also scales well for large projects because different teams may work on different operations.</span></span>

## <a name="event-based-processing"></a><span data-ttu-id="4b83d-134">基于事件的处理</span><span class="sxs-lookup"><span data-stu-id="4b83d-134">Event-based processing</span></span>

<span data-ttu-id="4b83d-135">在基于消息的系统中，通常会在队列或发布者/订阅者主题中收集事件以进行处理。</span><span class="sxs-lookup"><span data-stu-id="4b83d-135">In message-based systems, events are often collected in queues or publisher/subscriber topics to be acted upon.</span></span> <span data-ttu-id="4b83d-136">这些事件可触发无服务器函数来执行一种业务逻辑。</span><span class="sxs-lookup"><span data-stu-id="4b83d-136">These events can trigger serverless functions to execute a piece of business logic.</span></span> <span data-ttu-id="4b83d-137">事件来源的系统是基于事件的处理的一个示例。</span><span class="sxs-lookup"><span data-stu-id="4b83d-137">An example of event-based processing is event-sourced systems.</span></span> <span data-ttu-id="4b83d-138">引发“事件”以将任务标记为完成。</span><span class="sxs-lookup"><span data-stu-id="4b83d-138">An "event" is raised to mark a task as complete.</span></span> <span data-ttu-id="4b83d-139">事件触发的无服务器函数会更新相应的数据库文档。</span><span class="sxs-lookup"><span data-stu-id="4b83d-139">A serverless function triggered by the event updates the appropriate database document.</span></span> <span data-ttu-id="4b83d-140">第二个无服务器函数可能会使用事件来更新系统的读取模型。</span><span class="sxs-lookup"><span data-stu-id="4b83d-140">A second serverless function may use the event to update the read model for the system.</span></span> <span data-ttu-id="4b83d-141">[Azure 事件网格](/azure/event-grid/overview)提供了一种将事件与作为订阅者的函数集成的方法。</span><span class="sxs-lookup"><span data-stu-id="4b83d-141">[Azure Event Grid](/azure/event-grid/overview) provides a way to integrate events with functions as subscribers.</span></span>

> <span data-ttu-id="4b83d-142">事件是信息性消息。</span><span class="sxs-lookup"><span data-stu-id="4b83d-142">Events are informational messages.</span></span> <span data-ttu-id="4b83d-143">有关详细信息，请参阅[事件溯源模式](/azure/architecture/patterns/event-sourcing)。</span><span class="sxs-lookup"><span data-stu-id="4b83d-143">For more information, see [Event Sourcing pattern](/azure/architecture/patterns/event-sourcing).</span></span>

## <a name="file-triggers-and-transformations"></a><span data-ttu-id="4b83d-144">文件触发器和转换</span><span class="sxs-lookup"><span data-stu-id="4b83d-144">File triggers and transformations</span></span>

<span data-ttu-id="4b83d-145">提取、转换和加载 (ETL) 是一种常见的业务功能。</span><span class="sxs-lookup"><span data-stu-id="4b83d-145">Extract, Transform, and Load (ETL) is a common business function.</span></span> <span data-ttu-id="4b83d-146">无服务器是优秀的 ETL 解决方案，因为它允许将代码作为管道的一部分触发。</span><span class="sxs-lookup"><span data-stu-id="4b83d-146">Serverless is a great solution for ETL because it allows code to be triggered as part of a pipeline.</span></span> <span data-ttu-id="4b83d-147">单个代码组件可以解决各个方面的问题。</span><span class="sxs-lookup"><span data-stu-id="4b83d-147">Individual code components can address various aspects.</span></span> <span data-ttu-id="4b83d-148">一个无服务器函数可以下载该文件，另一个应用转换，再一个加载数据。</span><span class="sxs-lookup"><span data-stu-id="4b83d-148">One serverless function may download the file, another applies the transformation, and another loads the data.</span></span> <span data-ttu-id="4b83d-149">可以单独测试和部署代码，使其更易于按需维护和缩放。</span><span class="sxs-lookup"><span data-stu-id="4b83d-149">The code can be tested and deployed independently, making it easier to maintain and scale where needed.</span></span>

![无服务器文件触发器和转换](./media/serverless-file-triggers.png)

<span data-ttu-id="4b83d-151">在关系图中，“冷存储”提供在 [Azure 流分析](/azure/stream-analytics)中分析的数据。</span><span class="sxs-lookup"><span data-stu-id="4b83d-151">In the diagram, "cool storage" provides data that is parsed in [Azure Stream Analytics](/azure/stream-analytics).</span></span> <span data-ttu-id="4b83d-152">在数据流中遇到的任何问题都会触发 Azure 函数来解决异常。</span><span class="sxs-lookup"><span data-stu-id="4b83d-152">Any issues encountered in the data stream trigger an Azure Function to address the anomaly.</span></span>

## <a name="asynchronous-background-processing-and-messaging"></a><span data-ttu-id="4b83d-153">异步后台处理和消息传递</span><span class="sxs-lookup"><span data-stu-id="4b83d-153">Asynchronous background processing and messaging</span></span>

<span data-ttu-id="4b83d-154">有了异步消息传递和后台处理，应用程序无需等待即可启动进程。</span><span class="sxs-lookup"><span data-stu-id="4b83d-154">Asynchronous messaging and background processing allow applications to kick off processes without having to wait.</span></span> <span data-ttu-id="4b83d-155">OCR 应用是异步处理的一个示例。</span><span class="sxs-lookup"><span data-stu-id="4b83d-155">An example of asynchronous processing is an OCR app.</span></span> <span data-ttu-id="4b83d-156">提交图像，然后排队等候处理。</span><span class="sxs-lookup"><span data-stu-id="4b83d-156">An image is submitted and queued for processing.</span></span> <span data-ttu-id="4b83d-157">扫描图像以提取文本可能需要一些时间，完成后，将发送通知。</span><span class="sxs-lookup"><span data-stu-id="4b83d-157">Scanning the image to extract text may take time, and once it's finished a notification is sent.</span></span> <span data-ttu-id="4b83d-158">在此方案中，无服务器可以处理调用和结果。</span><span class="sxs-lookup"><span data-stu-id="4b83d-158">Serverless can handle both the invocation and the result in this scenario.</span></span>

## <a name="web-apps-and-apis"></a><span data-ttu-id="4b83d-159">Web 应用和 API</span><span class="sxs-lookup"><span data-stu-id="4b83d-159">Web apps and APIs</span></span>

<span data-ttu-id="4b83d-160">无服务器的常见方案是 N 层应用程序，在最常见方案中，UI 层为 Web 应用。</span><span class="sxs-lookup"><span data-stu-id="4b83d-160">A popular scenario for serverless is N-tier applications, most commonly ones where the UI layer is a web app.</span></span> <span data-ttu-id="4b83d-161">最热门的单页面应用程序 (SPA) 最近有激增的现象。</span><span class="sxs-lookup"><span data-stu-id="4b83d-161">The popularity of Single Page Applications (SPA) has surged recently.</span></span> <span data-ttu-id="4b83d-162">SPA 应用呈现单个页面，然后依赖 API 调用和返回的数据动态呈现新 UI，而无需重新加载整个页面。</span><span class="sxs-lookup"><span data-stu-id="4b83d-162">SPA apps render a single page, then rely on API calls and the returned data to dynamically render new UI without reloading a full page.</span></span> <span data-ttu-id="4b83d-163">客户端呈现为最终用户提供了一个速度更快、响应度更佳的应用程序。</span><span class="sxs-lookup"><span data-stu-id="4b83d-163">Client-side rendering provides a much faster, more responsive application to the end user.</span></span>

<span data-ttu-id="4b83d-164">HTTP 调用触发的无服务器终结点可用于处理 API 请求。</span><span class="sxs-lookup"><span data-stu-id="4b83d-164">Serverless endpoints triggered by HTTP calls can be used to handle the API requests.</span></span> <span data-ttu-id="4b83d-165">例如，广告服务公司可使用用户配置文件信息调用无服务器函数来请求自定义广告。</span><span class="sxs-lookup"><span data-stu-id="4b83d-165">For example, an ad services company may call a serverless function with user profile information to request custom advertising.</span></span> <span data-ttu-id="4b83d-166">无服务器函数返回自定义广告，并由网页呈现。</span><span class="sxs-lookup"><span data-stu-id="4b83d-166">The serverless function returns the custom ad and the web page renders it.</span></span>

![无服务器 Web API](./media/serverless-web-api.png)

## <a name="data-pipeline"></a><span data-ttu-id="4b83d-168">数据管道</span><span class="sxs-lookup"><span data-stu-id="4b83d-168">Data pipeline</span></span>

<span data-ttu-id="4b83d-169">无服务器函数可用于简化数据管道。</span><span class="sxs-lookup"><span data-stu-id="4b83d-169">Serverless functions can be used to facilitate a data pipeline.</span></span> <span data-ttu-id="4b83d-170">在此示例中，文件触发了一个函数，用于将 CSV 文件中的数据转换为表中的数据行。</span><span class="sxs-lookup"><span data-stu-id="4b83d-170">In this example, a file triggers a function to translate data in a CSV file to data rows in a table.</span></span> <span data-ttu-id="4b83d-171">组织表允许 Power BI 仪表板向最终用户呈现分析。</span><span class="sxs-lookup"><span data-stu-id="4b83d-171">The organized table allows a Power BI dashboard to present analytics to the end user.</span></span>

![无服务器数据管道](./media/serverless-data-pipeline.png)

## <a name="stream-processing"></a><span data-ttu-id="4b83d-173">流处理</span><span class="sxs-lookup"><span data-stu-id="4b83d-173">Stream processing</span></span>

<span data-ttu-id="4b83d-174">设备和传感器通常会生成必须实时处理的数据流。</span><span class="sxs-lookup"><span data-stu-id="4b83d-174">Devices and sensors often generate streams of data that must be processed in real time.</span></span> <span data-ttu-id="4b83d-175">有许多技术可以捕获从[事件中心](/azure/event-hubs/event-hubs-what-is-event-hubs)和 [IoT 中心](/azure/iot-hub)到[服务总线](/azure/service-bus)的消息和流。</span><span class="sxs-lookup"><span data-stu-id="4b83d-175">There are a number of technologies that can capture messages and streams from [Event Hubs](/azure/event-hubs/event-hubs-what-is-event-hubs) and [IoT Hub](/azure/iot-hub) to [Service Bus](/azure/service-bus).</span></span> <span data-ttu-id="4b83d-176">无论如何传输，无服务器都是一种处理传入消息和数据流的理想机制。</span><span class="sxs-lookup"><span data-stu-id="4b83d-176">Regardless of transport, serverless is an ideal mechanism for processing the messages and streams of data as they come in.</span></span> <span data-ttu-id="4b83d-177">无服务器可快速缩放，以满足大量数据的需求。</span><span class="sxs-lookup"><span data-stu-id="4b83d-177">Serverless can scale quickly to meet the demand of large volumes of data.</span></span> <span data-ttu-id="4b83d-178">无服务器代码可以应用业务逻辑来分析数据，并输出为机构化格式以执行操作和分析。</span><span class="sxs-lookup"><span data-stu-id="4b83d-178">The serverless code can apply business logic to parse the data and output in a structured format for action and analytics.</span></span>

![无服务器流处理](./media/serverless-stream-processing.png)

## <a name="api-gateway"></a><span data-ttu-id="4b83d-180">API 网关</span><span class="sxs-lookup"><span data-stu-id="4b83d-180">API gateway</span></span>

<span data-ttu-id="4b83d-181">API 网关为客户端提供单一入口点，然后将请求智能地路由到后端服务。</span><span class="sxs-lookup"><span data-stu-id="4b83d-181">An API gateway provides a single point of entry for clients and then intelligently routes requests to back-end services.</span></span> <span data-ttu-id="4b83d-182">管理大型服务集很有用。</span><span class="sxs-lookup"><span data-stu-id="4b83d-182">It's useful to manage large sets of services.</span></span> <span data-ttu-id="4b83d-183">它还可以通过轻松地将客户端连接到不同的环境来处理版本控制和简化开发。</span><span class="sxs-lookup"><span data-stu-id="4b83d-183">It can also handle versioning and simplify development by easily connecting clients to disparate environments.</span></span> <span data-ttu-id="4b83d-184">无服务器可处理单个微服务的后端缩放，同时通过 API 网关提供单个前端。</span><span class="sxs-lookup"><span data-stu-id="4b83d-184">Serverless can handle back-end scaling of individual microservices while presenting a single front end via an API gateway.</span></span>

![无服务器 API 网关](./media/serverless-api-gateway.png)

## <a name="recommended-resources"></a><span data-ttu-id="4b83d-186">推荐的资源</span><span class="sxs-lookup"><span data-stu-id="4b83d-186">Recommended resources</span></span>

- [<span data-ttu-id="4b83d-187">Azure 事件网格</span><span class="sxs-lookup"><span data-stu-id="4b83d-187">Azure Event Grid</span></span>](/azure/event-grid/overview)
- [<span data-ttu-id="4b83d-188">Azure IoT 中心</span><span class="sxs-lookup"><span data-stu-id="4b83d-188">Azure IoT Hub</span></span>](/azure/iot-hub)
- [<span data-ttu-id="4b83d-189">分布式数据管理挑战和解决方案</span><span class="sxs-lookup"><span data-stu-id="4b83d-189">Challenges and solutions for distributed data management</span></span>](../microservices/architect-microservice-container-applications/distributed-data-management.md)
- [<span data-ttu-id="4b83d-190">设计微服务：识别微服务边界</span><span class="sxs-lookup"><span data-stu-id="4b83d-190">Designing microservices: identifying microservice boundaries</span></span>](/azure/architecture/microservices/microservice-boundaries)
- [<span data-ttu-id="4b83d-191">事件中心</span><span class="sxs-lookup"><span data-stu-id="4b83d-191">Event Hubs</span></span>](/azure/event-hubs/event-hubs-what-is-event-hubs)
- [<span data-ttu-id="4b83d-192">事件溯源模式</span><span class="sxs-lookup"><span data-stu-id="4b83d-192">Event Sourcing pattern</span></span>](/azure/architecture/patterns/event-sourcing)
- [<span data-ttu-id="4b83d-193">实现断路器模式</span><span class="sxs-lookup"><span data-stu-id="4b83d-193">Implementing the Circuit Breaker pattern</span></span>](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md)
- [<span data-ttu-id="4b83d-194">IoT 中心</span><span class="sxs-lookup"><span data-stu-id="4b83d-194">IoT Hub</span></span>](/azure/iot-hub)
- [<span data-ttu-id="4b83d-195">服务总线</span><span class="sxs-lookup"><span data-stu-id="4b83d-195">Service Bus</span></span>](/azure/service-bus)
- [<span data-ttu-id="4b83d-196">使用 Azure Cosmos DB 中的更改源支持</span><span class="sxs-lookup"><span data-stu-id="4b83d-196">Working with the change feed support in Azure Cosmos DB</span></span>](/azure/cosmos-db/change-feed)

>[!div class="step-by-step"]
><span data-ttu-id="4b83d-197">[上一页](serverless-architecture-considerations.md)
>[下一页](azure-serverless-platform.md)</span><span class="sxs-lookup"><span data-stu-id="4b83d-197">[Previous](serverless-architecture-considerations.md)
[Next](azure-serverless-platform.md)</span></span>
