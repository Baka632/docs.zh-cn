---
title: 设计基础结构持久性层
description: 适用于容器化 .NET 应用程序的 .NET 微服务体系结构 | 在基础结构持久性层的设计中探索存储库模式。
ms.date: 10/08/2018
ms.openlocfilehash: 3c18582eb5db61a61b366c06f361d297e698b39a
ms.sourcegitcommit: 4ad2f8920251f3744240c3b42a443ffbe0a46577
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/08/2020
ms.locfileid: "86100842"
---
# <a name="design-the-infrastructure-persistence-layer"></a><span data-ttu-id="1a38d-103">设计基础结构持久性层</span><span class="sxs-lookup"><span data-stu-id="1a38d-103">Design the infrastructure persistence layer</span></span>

<span data-ttu-id="1a38d-104">数据持久性组件提供对微服务边界（即微服务的数据库）内托管的数据的访问。</span><span class="sxs-lookup"><span data-stu-id="1a38d-104">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice's database).</span></span> <span data-ttu-id="1a38d-105">它们包含组件（例如存储库和[工作单元](https://martinfowler.com/eaaCatalog/unitOfWork.html)类）的实际实现，例如自定义实体框架 (EF) <xref:Microsoft.EntityFrameworkCore.DbContext> 对象。</span><span class="sxs-lookup"><span data-stu-id="1a38d-105">They contain the actual implementation of components such as repositories and [Unit of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom Entity Framework (EF) <xref:Microsoft.EntityFrameworkCore.DbContext> objects.</span></span> <span data-ttu-id="1a38d-106">EF DbContext 实现两种模式：存储库模式和工作单元模式。</span><span class="sxs-lookup"><span data-stu-id="1a38d-106">EF DbContext implements both, the Repository and the Unit of Work patterns.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="1a38d-107">存储库模式</span><span class="sxs-lookup"><span data-stu-id="1a38d-107">The Repository pattern</span></span>

<span data-ttu-id="1a38d-108">存储库是封装访问数据源所需逻辑的类或组件。</span><span class="sxs-lookup"><span data-stu-id="1a38d-108">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="1a38d-109">它们集中提供常见的数据访问功能，从而提供更好的可维护性，并将用于访问数据库的基础结构或技术与域模型层分离。</span><span class="sxs-lookup"><span data-stu-id="1a38d-109">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="1a38d-110">如果使用像实体框架这样的对象关系映射 (ORM)，则可通过 LINQ 和强类型化来简化必须实现的代码。</span><span class="sxs-lookup"><span data-stu-id="1a38d-110">If you use an Object-Relational Mapper (ORM) like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="1a38d-111">这样你就可以专注于数据持久性逻辑而不是数据访问管道。</span><span class="sxs-lookup"><span data-stu-id="1a38d-111">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="1a38d-112">存储库模式是一种使用数据源的详细记录方式。</span><span class="sxs-lookup"><span data-stu-id="1a38d-112">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="1a38d-113">在 [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/)（企业应用程序体系结构模式）一书中，Martin Fowler 是这样描述存储库的：</span><span class="sxs-lookup"><span data-stu-id="1a38d-113">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

> <span data-ttu-id="1a38d-114">存储库执行域模型层与数据映射之间的中介者的任务，以类似于内存中一组域对象的方式工作。</span><span class="sxs-lookup"><span data-stu-id="1a38d-114">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="1a38d-115">客户端对象以声明方式生成查询，并将它们发送到存储库以获取答案。</span><span class="sxs-lookup"><span data-stu-id="1a38d-115">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="1a38d-116">从概念上讲，存储库封装了存储在数据库中的一组对象以及可对其执行的操作，从而提供一种更接近持久性层的方式。</span><span class="sxs-lookup"><span data-stu-id="1a38d-116">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="1a38d-117">存储库还明确支持在一个方向上分离工作域与数据分配或映射之间的依赖关系。</span><span class="sxs-lookup"><span data-stu-id="1a38d-117">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="1a38d-118">为每个聚合定义一个存储库</span><span class="sxs-lookup"><span data-stu-id="1a38d-118">Define one repository per aggregate</span></span>

<span data-ttu-id="1a38d-119">对于每个聚合或聚合根，应创建一个存储库类。</span><span class="sxs-lookup"><span data-stu-id="1a38d-119">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="1a38d-120">在基于域驱动设计 (DDD) 模式的微服务中，唯一应该用于更新数据库的渠道应是存储库。</span><span class="sxs-lookup"><span data-stu-id="1a38d-120">In a microservice based on Domain-Driven Design (DDD) patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="1a38d-121">这是因为它们与聚合根具有一对一的关系，聚合根控制着聚合的不变量和事务一致性。</span><span class="sxs-lookup"><span data-stu-id="1a38d-121">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate's invariants and transactional consistency.</span></span> <span data-ttu-id="1a38d-122">可以通过其他渠道查询数据库（就像使用 CQRS 方法时一样），因为查询不会更改数据库的状态。</span><span class="sxs-lookup"><span data-stu-id="1a38d-122">It's okay to query the database through other channels (as you can do following a CQRS approach), because queries don't change the state of the database.</span></span> <span data-ttu-id="1a38d-123">但是，事务区域（即更新）必须始终由存储库和聚合根控制。</span><span class="sxs-lookup"><span data-stu-id="1a38d-123">However, the transactional area (that is, the updates) must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="1a38d-124">从本质上讲，存储库允许以域实体的形式填充内存中来自数据库的数据。</span><span class="sxs-lookup"><span data-stu-id="1a38d-124">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="1a38d-125">一旦实体在内存中，就可以对它们进行更改，然后通过事务存回数据库中。</span><span class="sxs-lookup"><span data-stu-id="1a38d-125">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="1a38d-126">如前所述，如果使用 CQS/CQRS 体系结构模式，则由简单的 SQL 语句使用 Dapper 在域模型外并行执行初始查询。</span><span class="sxs-lookup"><span data-stu-id="1a38d-126">As noted earlier, if you're using the CQS/CQRS architectural pattern, the initial queries are performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="1a38d-127">这种方法比存储库更加灵活，因为可以查询和联接所需的任何表，并且这些查询不受聚合中的规则限制。</span><span class="sxs-lookup"><span data-stu-id="1a38d-127">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries aren't restricted by rules from the aggregates.</span></span> <span data-ttu-id="1a38d-128">该数据会发送到表示层或客户端应用。</span><span class="sxs-lookup"><span data-stu-id="1a38d-128">That data goes to the presentation layer or client app.</span></span>

<span data-ttu-id="1a38d-129">如果用户进行更改，要更新的数据会从客户端应用或表示层发送到应用层（例如 Web API 服务）。</span><span class="sxs-lookup"><span data-stu-id="1a38d-129">If the user makes changes, the data to be updated comes from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="1a38d-130">在命令处理程序中收到命令时，可以使用存储库获取要从数据库更新的数据。</span><span class="sxs-lookup"><span data-stu-id="1a38d-130">When you receive a command in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="1a38d-131">可使用通过命令传递的数据在内存中对其进行更新，然后通过事务在数据库中添加或更新数据（域实体）。</span><span class="sxs-lookup"><span data-stu-id="1a38d-131">You update it in memory with the data passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="1a38d-132">需要再次强调的是，应该仅为每个聚合根定义一个存储库，如图 7-17 所示。</span><span class="sxs-lookup"><span data-stu-id="1a38d-132">It's important to emphasize again that you should only define one repository for each aggregate root, as shown in Figure 7-17.</span></span> <span data-ttu-id="1a38d-133">若要实现聚合根的目标，即维持聚合中所有对象之间的事务一致性，就决不能为数据库中的每个表创建一个存储库。</span><span class="sxs-lookup"><span data-stu-id="1a38d-133">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![显示域和其他基础结构的关系的关系图。](./media/infrastructure-persistence-layer-design/repository-aggregate-database-table-relationships.png)

<span data-ttu-id="1a38d-135">**图 7-17**。</span><span class="sxs-lookup"><span data-stu-id="1a38d-135">**Figure 7-17**.</span></span> <span data-ttu-id="1a38d-136">存储库、聚合和数据库表之间的关系</span><span class="sxs-lookup"><span data-stu-id="1a38d-136">The relationship between repositories, aggregates, and database tables</span></span>

<span data-ttu-id="1a38d-137">上图显示了域层和基础结构层之间的关系：购买者聚合依赖于 IBuyerRepository 接口，而订单聚合依赖于 IOrderRepository 接口，这些接口由依赖于 UnitOfWork（可访问数据层中的表，也在此处实现）的对应存储库在基础结构层中实现。</span><span class="sxs-lookup"><span data-stu-id="1a38d-137">The above diagram shows the relationships between Domain and Infrastructure layers: Buyer Aggregate depends on the IBuyerRepository and Order Aggregate depends on the IOrderRepository interfaces, these interfaces are implemented in the Infrastructure layer by the corresponding repositories that depend on UnitOfWork, also implemented there, that accesses the tables in the Data tier.</span></span>

### <a name="enforce-one-aggregate-root-per-repository"></a><span data-ttu-id="1a38d-138">强制每个存储库使用一个聚合根</span><span class="sxs-lookup"><span data-stu-id="1a38d-138">Enforce one aggregate root per repository</span></span>

<span data-ttu-id="1a38d-139">以这样一种方式实现存储库设计可能很有价值，即实施仅聚合根具有存储库的规则。</span><span class="sxs-lookup"><span data-stu-id="1a38d-139">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="1a38d-140">可以创建一个泛型或基本存储库类型，以限制其使用的实体类型，确保这些实体具有 `IAggregateRoot` 标记接口。</span><span class="sxs-lookup"><span data-stu-id="1a38d-140">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the `IAggregateRoot` marker interface.</span></span>

<span data-ttu-id="1a38d-141">这样，在基础结构层实现的每个存储库类都会实现自己的协定或接口，如以下代码所示：</span><span class="sxs-lookup"><span data-stu-id="1a38d-141">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
      // ...
    }
}
```

<span data-ttu-id="1a38d-142">每个特定的存储库接口都实现 IRepository 泛型接口：</span><span class="sxs-lookup"><span data-stu-id="1a38d-142">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="1a38d-143">但是，若要让代码强制执行每个存储库都应与单个聚合关联的约定，一种更好的方式是实现泛型存储库类型。</span><span class="sxs-lookup"><span data-stu-id="1a38d-143">However, a better way to have the code enforce the convention that each repository is related to a single aggregate is to implement a generic repository type.</span></span> <span data-ttu-id="1a38d-144">这样便可以明确看出正在使用存储库定位特定聚合。</span><span class="sxs-lookup"><span data-stu-id="1a38d-144">That way, it's explicit that you're using a repository to target a specific aggregate.</span></span> <span data-ttu-id="1a38d-145">这可以通过实现泛型 `IRepository` 基接口轻松完成，如以下代码所示：</span><span class="sxs-lookup"><span data-stu-id="1a38d-145">That can be easily done by implementing a generic `IRepository` base interface, as in the following code:</span></span>

```csharp
public interface IRepository<T> where T : IAggregateRoot
{
    //....
}
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="1a38d-146">存储库模式使应用程序逻辑测试更轻松</span><span class="sxs-lookup"><span data-stu-id="1a38d-146">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="1a38d-147">存储库模式允许使用单元测试轻松测试应用程序。</span><span class="sxs-lookup"><span data-stu-id="1a38d-147">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="1a38d-148">请记住，单元测试只测试代码，不测试基础结构，所以存储库抽象使得它更容易实现这个目标。</span><span class="sxs-lookup"><span data-stu-id="1a38d-148">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="1a38d-149">如前面部分所述，建议在域模型层中定义并放置存储库接口，这样，应用层（例如，Web API 微服务）就不会直接依赖于已实现实际存储库类的基础结构层。</span><span class="sxs-lookup"><span data-stu-id="1a38d-149">As noted in an earlier section, it's recommended that you define and place the repository interfaces in the domain model layer so the application layer, such as your Web API microservice, doesn't depend directly on the infrastructure layer where you've implemented the actual repository classes.</span></span> <span data-ttu-id="1a38d-150">通过执行此操作并在 Web API 的控制器中使用依赖项注入，可以实现模拟存储库来返回假数据，而不是数据库中的数据。</span><span class="sxs-lookup"><span data-stu-id="1a38d-150">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="1a38d-151">这种分离方法可用于创建和运行单元测试，这些单元测试着重于测试应用程序的逻辑，而无需连接到数据库。</span><span class="sxs-lookup"><span data-stu-id="1a38d-151">This decoupled approach allows you to create and run unit tests that focus the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="1a38d-152">与数据库的连接可能会失败，更重要的是，针对数据库运行数百个测试的做法并不可取，原因有两个。</span><span class="sxs-lookup"><span data-stu-id="1a38d-152">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="1a38d-153">首先，由于存在大量测试，因此，运行起来可能很费时。</span><span class="sxs-lookup"><span data-stu-id="1a38d-153">First, it can take a long time because of the large number of tests.</span></span> <span data-ttu-id="1a38d-154">其次，数据库记录可能会更改并影响测试结果，因此它们可能不一致。</span><span class="sxs-lookup"><span data-stu-id="1a38d-154">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="1a38d-155">针对数据库进行的测试不是单元测试，而是集成测试。</span><span class="sxs-lookup"><span data-stu-id="1a38d-155">Testing against the database isn't a unit test but an integration test.</span></span> <span data-ttu-id="1a38d-156">你应该有许多快速运行的单元测试，较少针对数据库的集成测试。</span><span class="sxs-lookup"><span data-stu-id="1a38d-156">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="1a38d-157">根据单元测试的关注点分离原则，你的逻辑应作用于内存中的域实体。</span><span class="sxs-lookup"><span data-stu-id="1a38d-157">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="1a38d-158">它假定存储库类已经提供这些实体。</span><span class="sxs-lookup"><span data-stu-id="1a38d-158">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="1a38d-159">一旦你的逻辑修改了域实体，它就会假定存储库类将正确存储它们。</span><span class="sxs-lookup"><span data-stu-id="1a38d-159">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="1a38d-160">这里的重点在于针对域模型及其域逻辑创建单元测试。</span><span class="sxs-lookup"><span data-stu-id="1a38d-160">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="1a38d-161">聚合根是 DDD 中的主要一致性边界。</span><span class="sxs-lookup"><span data-stu-id="1a38d-161">Aggregate roots are the main consistency boundaries in DDD.</span></span>

<span data-ttu-id="1a38d-162">在 eShopOnContainers 中实现的存储库依赖于使用其更改跟踪器的存储库模式和工作单元模式的 EF Core DbContext 实现，因此，它们不会复制此功能。</span><span class="sxs-lookup"><span data-stu-id="1a38d-162">The repositories implemented in eShopOnContainers rely on EF Core's DbContext implementation of the Repository and Unit of Work patterns using its change tracker, so they don't duplicate this functionality.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="1a38d-163">存储库模式与传统数据访问类（DAL 类）模式之间的区别</span><span class="sxs-lookup"><span data-stu-id="1a38d-163">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="1a38d-164">数据访问对象直接对存储执行数据访问和持久性操作。</span><span class="sxs-lookup"><span data-stu-id="1a38d-164">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="1a38d-165">存储库使用要在工作单元对象的内存中执行的操作对数据进行标记（正如在 EF 中使用 <xref:Microsoft.EntityFrameworkCore.DbContext> 类时一样），但这些更新不会立即执行到数据库。</span><span class="sxs-lookup"><span data-stu-id="1a38d-165">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the <xref:Microsoft.EntityFrameworkCore.DbContext> class), but these updates aren't performed immediately to the database.</span></span>

<span data-ttu-id="1a38d-166">工作单元亦称单个事务，涉及多个插入、更新或删除操作。</span><span class="sxs-lookup"><span data-stu-id="1a38d-166">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="1a38d-167">简而言之，这意味着对于特定的用户操作（例如网站注册），所有插入、更新和删除操作都在单个事务中处理。</span><span class="sxs-lookup"><span data-stu-id="1a38d-167">In simple terms, it means that for a specific user action, such as a registration on a website, all the insert, update, and delete operations are handled in a single transaction.</span></span> <span data-ttu-id="1a38d-168">这比以更繁琐的方式处理多个数据库事务更有效。</span><span class="sxs-lookup"><span data-stu-id="1a38d-168">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="1a38d-169">这几个持久性操作稍后会在应用层中的代码发出命令时，在单个操作中执行。</span><span class="sxs-lookup"><span data-stu-id="1a38d-169">These multiple persistence operations are performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="1a38d-170">关于将内存中更改应用于实际数据库存储的决策通常基于[工作单元模式](https://martinfowler.com/eaaCatalog/unitOfWork.html)。</span><span class="sxs-lookup"><span data-stu-id="1a38d-170">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="1a38d-171">在 EF 中，工作单元模式作为 <xref:Microsoft.EntityFrameworkCore.DbContext> 实现。</span><span class="sxs-lookup"><span data-stu-id="1a38d-171">In EF, the Unit of Work pattern is implemented as the <xref:Microsoft.EntityFrameworkCore.DbContext>.</span></span>

<span data-ttu-id="1a38d-172">在许多情况下，这种对存储应用操作的模式或方式可以提高应用程序性能并减少出现不一致的可能性。</span><span class="sxs-lookup"><span data-stu-id="1a38d-172">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="1a38d-173">此外，它还能减少数据库表中的事务阻塞，因为所有预期操作都作为一个事务的一部分进行提交。</span><span class="sxs-lookup"><span data-stu-id="1a38d-173">It also reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="1a38d-174">与对数据库执行许多独立操作相比，这样做效率更高。</span><span class="sxs-lookup"><span data-stu-id="1a38d-174">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="1a38d-175">因此，选定的 ORM 能够通过在同一个事务中对几个更新操作进行分组来优化对数据库的执行，而不是使用许多单独的小型事务执行。</span><span class="sxs-lookup"><span data-stu-id="1a38d-175">Therefore, the selected ORM can optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-shouldnt-be-mandatory"></a><span data-ttu-id="1a38d-176">存储库不应该是强制性的</span><span class="sxs-lookup"><span data-stu-id="1a38d-176">Repositories shouldn't be mandatory</span></span>

<span data-ttu-id="1a38d-177">自定义存储库适用于前面提到的原因，这也是 eShopOnContainers 中的订购微服务所采用的方法。</span><span class="sxs-lookup"><span data-stu-id="1a38d-177">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="1a38d-178">但是，它不是一种必须在 DDD 设计中甚至在一般的 .NET 开发中实现的模式。</span><span class="sxs-lookup"><span data-stu-id="1a38d-178">However, it isn't an essential pattern to implement in a DDD design or even in general .NET development.</span></span>

<span data-ttu-id="1a38d-179">例如，Jimmy Bogard 在为本指南提供直接反馈时表示：</span><span class="sxs-lookup"><span data-stu-id="1a38d-179">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

> <span data-ttu-id="1a38d-180">这可能是我最重要的一次反馈。</span><span class="sxs-lookup"><span data-stu-id="1a38d-180">This'll probably be my biggest feedback.</span></span> <span data-ttu-id="1a38d-181">我真的不喜欢存储库，主要是因为它们隐藏了底层持久性机制的重要细节。</span><span class="sxs-lookup"><span data-stu-id="1a38d-181">I'm really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="1a38d-182">这也是我选择 MediatR 命令的原因。</span><span class="sxs-lookup"><span data-stu-id="1a38d-182">It's why I go for MediatR for commands, too.</span></span> <span data-ttu-id="1a38d-183">我可以利用持久性层的完整功能，将所有域行为推送到我的聚合根中。</span><span class="sxs-lookup"><span data-stu-id="1a38d-183">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="1a38d-184">我通常不想模拟存储库 — 我仍然需要对真实存在的东西执行集成测试。</span><span class="sxs-lookup"><span data-stu-id="1a38d-184">I don't usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="1a38d-185">使用 CQRS 意味着我们不再需要存储库。</span><span class="sxs-lookup"><span data-stu-id="1a38d-185">Going CQRS meant that we didn't really have a need for repositories any more.</span></span>

<span data-ttu-id="1a38d-186">虽然存储库可能会很有用，但就设计聚合模式和丰富域模型而言，它们对 DDD 设计并不重要。</span><span class="sxs-lookup"><span data-stu-id="1a38d-186">Repositories might be useful, but they are not critical for your DDD design, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="1a38d-187">因此，你可以根据需要使用或不使用存储库模式。</span><span class="sxs-lookup"><span data-stu-id="1a38d-187">Therefore, use the Repository pattern or not, as you see fit.</span></span> <span data-ttu-id="1a38d-188">不管怎样，你将在使用 EF Core 时使用存储库模式，在这种情况下，存储库涵盖整个微服务或界定上下文。</span><span class="sxs-lookup"><span data-stu-id="1a38d-188">Anyway, you'll be using the repository pattern whenever you use EF Core although, in this case, the repository covers the whole microservice or bounded context.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="1a38d-189">其他资源</span><span class="sxs-lookup"><span data-stu-id="1a38d-189">Additional resources</span></span>

### <a name="repository-pattern"></a><span data-ttu-id="1a38d-190">存储库模式</span><span class="sxs-lookup"><span data-stu-id="1a38d-190">Repository pattern</span></span>

- <span data-ttu-id="1a38d-191">**Edward Hieatt 和 Rob Mee.Repository pattern**（存储库模式）。</span><span class="sxs-lookup"><span data-stu-id="1a38d-191">**Edward Hieatt and Rob Mee. Repository pattern.**</span></span> \
  <https://martinfowler.com/eaaCatalog/repository.html>

- <span data-ttu-id="1a38d-192">**The Repository pattern** \（存储库模式）</span><span class="sxs-lookup"><span data-stu-id="1a38d-192">**The Repository pattern** </span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10)>

- <span data-ttu-id="1a38d-193">**Eric Evans。域驱动设计：Tackling Complexity in the Heart of Software.** （域驱动设计：软件核心复杂性应对之道）\</span><span class="sxs-lookup"><span data-stu-id="1a38d-193">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="1a38d-194">（书；包含对存储库模式的讨论）</span><span class="sxs-lookup"><span data-stu-id="1a38d-194">(Book; includes a discussion of the Repository pattern) </span></span>\
  <https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/>

### <a name="unit-of-work-pattern"></a><span data-ttu-id="1a38d-195">工作单元模式</span><span class="sxs-lookup"><span data-stu-id="1a38d-195">Unit of Work pattern</span></span>

- <span data-ttu-id="1a38d-196">**Martin Fowler。Unit of Work pattern**（工作单元模式）。\</span><span class="sxs-lookup"><span data-stu-id="1a38d-196">**Martin Fowler. Unit of Work pattern.**</span></span> \
  <https://martinfowler.com/eaaCatalog/unitOfWork.html>

- <span data-ttu-id="1a38d-197">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application** \（在 ASP.NET MVC 应用程序中实现存储库模式和工作单元模式）</span><span class="sxs-lookup"><span data-stu-id="1a38d-197">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application** </span></span>\
  <https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application>

>[!div class="step-by-step"]
><span data-ttu-id="1a38d-198">[上一页](domain-events-design-implementation.md)
>[下一页](infrastructure-persistence-layer-implementation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="1a38d-198">[Previous](domain-events-design-implementation.md)
[Next](infrastructure-persistence-layer-implementation-entity-framework-core.md)</span></span>
