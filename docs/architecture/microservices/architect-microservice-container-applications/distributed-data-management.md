---
title: 分布式数据管理的挑战和解决方案
description: 了解微服务体系中的分布式数据管理面临的挑战和相应解决方案。
ms.date: 09/20/2018
ms.openlocfilehash: 1439dd5a04c3991a2b3b2ef12763843f9f339a29
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/24/2020
ms.locfileid: "91152646"
---
# <a name="challenges-and-solutions-for-distributed-data-management"></a><span data-ttu-id="a5de3-103">分布式数据管理的挑战和解决方案</span><span class="sxs-lookup"><span data-stu-id="a5de3-103">Challenges and solutions for distributed data management</span></span>

## <a name="challenge-1-how-to-define-the-boundaries-of-each-microservice"></a><span data-ttu-id="a5de3-104">挑战 \#1：如何定义每个微服务的边界</span><span class="sxs-lookup"><span data-stu-id="a5de3-104">Challenge \#1: How to define the boundaries of each microservice</span></span>

<span data-ttu-id="a5de3-105">定义微服务边界可能是每位用户遇到的第一项挑战。</span><span class="sxs-lookup"><span data-stu-id="a5de3-105">Defining microservice boundaries is probably the first challenge anyone encounters.</span></span> <span data-ttu-id="a5de3-106">每个微服务必须是应用程序的一部分，并且每个微服务应对其带来的优势和挑战具有自治性。</span><span class="sxs-lookup"><span data-stu-id="a5de3-106">Each microservice has to be a piece of your application and each microservice should be autonomous with all the benefits and challenges that it conveys.</span></span> <span data-ttu-id="a5de3-107">但是，如何识别这些边界？</span><span class="sxs-lookup"><span data-stu-id="a5de3-107">But how do you identify those boundaries?</span></span>

<span data-ttu-id="a5de3-108">首先，需要着重关注应用程序的逻辑域模型和相关数据。</span><span class="sxs-lookup"><span data-stu-id="a5de3-108">First, you need to focus on the application's logical domain models and related data.</span></span> <span data-ttu-id="a5de3-109">尝试识别同一应用程序中数据和不同上下文的分离岛。</span><span class="sxs-lookup"><span data-stu-id="a5de3-109">Try to identify decoupled islands of data and different contexts within the same application.</span></span> <span data-ttu-id="a5de3-110">每个上下文可能具有不同的业务语言（不同的业务术语）。</span><span class="sxs-lookup"><span data-stu-id="a5de3-110">Each context could have a different business language (different business terms).</span></span> <span data-ttu-id="a5de3-111">应独立定义和管理上下文。</span><span class="sxs-lookup"><span data-stu-id="a5de3-111">The contexts should be defined and managed independently.</span></span> <span data-ttu-id="a5de3-112">不同上下文中所用的术语和实体可能听起来很相似，但你可能会发现在特定上下文中，用于一个目的的某个业务概念可在另一上下文中用于不同目的，甚至名称也可能会不同。</span><span class="sxs-lookup"><span data-stu-id="a5de3-112">The terms and entities that are used in those different contexts might sound similar, but you might discover that in a particular context, a business concept with one is used for a different purpose in another context, and might even have a different name.</span></span> <span data-ttu-id="a5de3-113">例如，用户在身份或成员身份上下文中称为用户，在 CRM 上下文中称为客户，在订购上下文中称为购买者等等。</span><span class="sxs-lookup"><span data-stu-id="a5de3-113">For instance, a user can be referred as a user in the identity or membership context, as a customer in a CRM context, as a buyer in an ordering context, and so forth.</span></span>

<span data-ttu-id="a5de3-114">多个应用程序上下文（各上下文具有不同域）之间的边界识别方法，也可用于识别各业务微服务及其相关域模型和数据的边界。</span><span class="sxs-lookup"><span data-stu-id="a5de3-114">The way you identify boundaries between multiple application contexts with a different domain for each context is exactly how you can identify the boundaries for each business microservice and its related domain model and data.</span></span> <span data-ttu-id="a5de3-115">始终尝试最大程度减少这些微服务之间的耦合度。</span><span class="sxs-lookup"><span data-stu-id="a5de3-115">You always attempt to minimize the coupling between those microservices.</span></span> <span data-ttu-id="a5de3-116">本指南稍后将在[识别每个微服务的域模型边界](identify-microservice-domain-model-boundaries.md)部分详细介绍此识别方法和域模型设计。</span><span class="sxs-lookup"><span data-stu-id="a5de3-116">This guide goes into more detail about this identification and domain model design in the section [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md) later.</span></span>

## <a name="challenge-2-how-to-create-queries-that-retrieve-data-from-several-microservices"></a><span data-ttu-id="a5de3-117">挑战 \#2：如何创建从多个微服务中检索数据的查询</span><span class="sxs-lookup"><span data-stu-id="a5de3-117">Challenge \#2: How to create queries that retrieve data from several microservices</span></span>

<span data-ttu-id="a5de3-118">第二个挑战是如何实现从多个微服务中检索数据的查询，同时避免从远程客户端应用到微服务的闲聊通信。</span><span class="sxs-lookup"><span data-stu-id="a5de3-118">A second challenge is how to implement queries that retrieve data from several microservices, while avoiding chatty communication to the microservices from remote client apps.</span></span> <span data-ttu-id="a5de3-119">例如，某个移动应用中需要显示属于购物篮、目录和用户标识微服务的用户信息的单个屏幕。</span><span class="sxs-lookup"><span data-stu-id="a5de3-119">An example could be a single screen from a mobile app that needs to show user information that's owned by the basket, catalog, and user identity microservices.</span></span> <span data-ttu-id="a5de3-120">还例如，某个复杂报告涉及位于多个微服务中的表。</span><span class="sxs-lookup"><span data-stu-id="a5de3-120">Another example would be a complex report involving many tables located in multiple microservices.</span></span> <span data-ttu-id="a5de3-121">正确的解决方案取决于查询的复杂程度。</span><span class="sxs-lookup"><span data-stu-id="a5de3-121">The right solution depends on the complexity of the queries.</span></span> <span data-ttu-id="a5de3-122">但在任何情况下，如果想要提高系统通信的效率，都需要通过某种方法来聚合信息。</span><span class="sxs-lookup"><span data-stu-id="a5de3-122">But in any case, you'll need a way to aggregate information if you want to improve the efficiency in the communications of your system.</span></span> <span data-ttu-id="a5de3-123">最常用的解决方案如下。</span><span class="sxs-lookup"><span data-stu-id="a5de3-123">The most popular solutions are the following.</span></span>

<span data-ttu-id="a5de3-124">**API 网关。**</span><span class="sxs-lookup"><span data-stu-id="a5de3-124">**API Gateway.**</span></span> <span data-ttu-id="a5de3-125">对于来自多个微服务（拥有不同数据库）的简单数据聚合，推荐方法是称为 API 网关的聚合微服务。</span><span class="sxs-lookup"><span data-stu-id="a5de3-125">For simple data aggregation from multiple microservices that own different databases, the recommended approach is an aggregation microservice referred to as an API Gateway.</span></span> <span data-ttu-id="a5de3-126">但是，实现这种模式需谨慎，因为它可能成为系统中的瓶颈点，并可能违反微服务自治原则。</span><span class="sxs-lookup"><span data-stu-id="a5de3-126">However, you need to be careful about implementing this pattern, because it can be a choke point in your system, and it can violate the principle of microservice autonomy.</span></span> <span data-ttu-id="a5de3-127">若要降低这种可能性，可以采用多个细粒度 API 网关，每个网关都着重于系统的垂直“切片”或业务区域。</span><span class="sxs-lookup"><span data-stu-id="a5de3-127">To mitigate this possibility, you can have multiple fined-grained API Gateways each one focusing on a vertical "slice" or business area of the system.</span></span> <span data-ttu-id="a5de3-128">API 网关模式稍后将在[“API 网关”部分](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md#why-consider-api-gateways-instead-of-direct-client-to-microservice-communication)中详细介绍。</span><span class="sxs-lookup"><span data-stu-id="a5de3-128">The API Gateway pattern is explained in more detail in the [API Gateway section](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md#why-consider-api-gateways-instead-of-direct-client-to-microservice-communication) later.</span></span>

<span data-ttu-id="a5de3-129">**具有查询/读取表的 CQRS。**</span><span class="sxs-lookup"><span data-stu-id="a5de3-129">**CQRS with query/reads tables.**</span></span> <span data-ttu-id="a5de3-130">用于聚合来自多个微服务的数据的另一个解决方案是[具体化视图模式](/azure/architecture/patterns/materialized-view)。</span><span class="sxs-lookup"><span data-stu-id="a5de3-130">Another solution for aggregating data from multiple microservices is the [Materialized View pattern](/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="a5de3-131">此方法将事先（在发生实际查询之前准备非规范化数据）生成一个包含属于多个微服务的数据的只读表。</span><span class="sxs-lookup"><span data-stu-id="a5de3-131">In this approach, you generate, in advance (prepare denormalized data before the actual queries happen), a read-only table with the data that's owned by multiple microservices.</span></span> <span data-ttu-id="a5de3-132">该表采用满足客户端应用要求的格式。</span><span class="sxs-lookup"><span data-stu-id="a5de3-132">The table has a format suited to the client app's needs.</span></span>

<span data-ttu-id="a5de3-133">考虑到移动应用屏幕等。</span><span class="sxs-lookup"><span data-stu-id="a5de3-133">Consider something like the screen for a mobile app.</span></span> <span data-ttu-id="a5de3-134">如果有单个数据库，则可以使用 SQL 查询（用于执行涉及多个表的复杂联接）将该屏幕的数据拉取在一起。</span><span class="sxs-lookup"><span data-stu-id="a5de3-134">If you have a single database, you might pull together the data for that screen using a SQL query that performs a complex join involving multiple tables.</span></span> <span data-ttu-id="a5de3-135">但是，如果有多个数据库，并且每个数据库都都属于不同微服务，则无法查询这些数据库和创建 SQL 联接。</span><span class="sxs-lookup"><span data-stu-id="a5de3-135">However, when you have multiple databases, and each database is owned by a different microservice, you cannot query those databases and create a SQL join.</span></span> <span data-ttu-id="a5de3-136">此时，复杂查询则变成了一种挑战。</span><span class="sxs-lookup"><span data-stu-id="a5de3-136">Your complex query becomes a challenge.</span></span> <span data-ttu-id="a5de3-137">可以使用 CQRS 方法来满足需求，即在仅用于查询的不同数据库中创建非规范化表。</span><span class="sxs-lookup"><span data-stu-id="a5de3-137">You can address the requirement using a CQRS approach—you create a denormalized table in a different database that's used just for queries.</span></span> <span data-ttu-id="a5de3-138">该表可专门针对复杂查询所需的数据进行设计，应用程序屏幕所需的字段和查询表中的列之间具有一对一关系。</span><span class="sxs-lookup"><span data-stu-id="a5de3-138">The table can be designed specifically for the data you need for the complex query, with a one-to-one relationship between fields needed by your application's screen and the columns in the query table.</span></span> <span data-ttu-id="a5de3-139">该表还可用于报告。</span><span class="sxs-lookup"><span data-stu-id="a5de3-139">It could also serve for reporting purposes.</span></span>

<span data-ttu-id="a5de3-140">这种方法不仅解决了原本的问题（如何跨微服务查询和联接），而且相比于复杂联接，它还显著提高了性能，因为你的查询表中已具有应用程序所需的数据。</span><span class="sxs-lookup"><span data-stu-id="a5de3-140">This approach not only solves the original problem (how to query and join across microservices), but it also improves performance considerably when compared with a complex join, because you already have the data that the application needs in the query table.</span></span> <span data-ttu-id="a5de3-141">当然，使用具有查询/读取表的命令和查询责任分离 (CQRS) 意味着需要完成额外的开发工作，并且需要达成最终一致性。</span><span class="sxs-lookup"><span data-stu-id="a5de3-141">Of course, using Command and Query Responsibility Segregation (CQRS) with query/reads tables means additional development work, and you'll need to embrace eventual consistency.</span></span> <span data-ttu-id="a5de3-142">尽管如此，针对[协作方案](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/)（或竞争方案，这取决于考虑角度）中性能和高可伸缩性的要求，应采用具有多个数据库的 CQRS。</span><span class="sxs-lookup"><span data-stu-id="a5de3-142">Nonetheless, requirements on performance and high scalability in [collaborative scenarios](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (or competitive scenarios, depending on the point of view) are where you should apply CQRS with multiple databases.</span></span>

<span data-ttu-id="a5de3-143">**中央数据库的“冷数据”。**</span><span class="sxs-lookup"><span data-stu-id="a5de3-143">**"Cold data" in central databases.**</span></span> <span data-ttu-id="a5de3-144">对于可能不需要实时数据的复杂报告和查询，常用方法是将“热数据”（来自微服务的事务数据）作为“冷数据”导出到仅用于报告的大型数据库中。</span><span class="sxs-lookup"><span data-stu-id="a5de3-144">For complex reports and queries that might not require real-time data, a common approach is to export your "hot data" (transactional data from the microservices) as "cold data" into large databases that are used only for reporting.</span></span> <span data-ttu-id="a5de3-145">该中央数据库系统可以是基于大数据的系统（如 Hadoop）、基于 Azure SQL 数据仓库的数据仓库，甚至是仅用于报告的单个 SQL 数据库（如果无大小方面的考量）。</span><span class="sxs-lookup"><span data-stu-id="a5de3-145">That central database system can be a Big Data-based system, like Hadoop, a data warehouse like one based on Azure SQL Data Warehouse, or even a single SQL database that's used just for reports (if size won't be an issue).</span></span>

<span data-ttu-id="a5de3-146">请注意，此集中式数据库仅用于不需要实时数据的查询和报告。</span><span class="sxs-lookup"><span data-stu-id="a5de3-146">Keep in mind that this centralized database would be used only for queries and reports that do not need real-time data.</span></span> <span data-ttu-id="a5de3-147">作为事实来源的原始更新和事务必须位于微服务数据中。</span><span class="sxs-lookup"><span data-stu-id="a5de3-147">The original updates and transactions, as your source of truth, have to be in your microservices data.</span></span> <span data-ttu-id="a5de3-148">用于同步数据的方法有两种：使用事件驱动的通信（将在后面部分介绍），或使用其他数据库基础结构导入/导出工具。</span><span class="sxs-lookup"><span data-stu-id="a5de3-148">The way you would synchronize data would be either by using event-driven communication (covered in the next sections) or by using other database infrastructure import/export tools.</span></span> <span data-ttu-id="a5de3-149">如果使用事件驱动通信，该集成进程与之前介绍的针对 CQRS 查询表传播数据的方法类似。</span><span class="sxs-lookup"><span data-stu-id="a5de3-149">If you use event-driven communication, that integration process would be similar to the way you propagate data as described earlier for CQRS query tables.</span></span>

<span data-ttu-id="a5de3-150">但是，如果应用程序设计需要不断聚合来自多个微服务的信息以进行复杂查询，那么这可能不是个好的设计：一个微服务应尽可能地与其他微服务分离。</span><span class="sxs-lookup"><span data-stu-id="a5de3-150">However, if your application design involves constantly aggregating information from multiple microservices for complex queries, it might be a symptom of a bad design -a microservice should be as isolated as possible from other microservices.</span></span> <span data-ttu-id="a5de3-151">（这不包括始终应使用冷数据中央数据库的报告/分析。）通常情况下，合并微服务可能会导致此问题。</span><span class="sxs-lookup"><span data-stu-id="a5de3-151">(This excludes reports/analytics that always should use cold-data central databases.) Having this problem often might be a reason to merge microservices.</span></span> <span data-ttu-id="a5de3-152">需要通过强大的依赖项、内聚和数据聚合在各微服务的发展自治和部署之间取得平衡。</span><span class="sxs-lookup"><span data-stu-id="a5de3-152">You need to balance the autonomy of evolution and deployment of each microservice with strong dependencies, cohesion, and data aggregation.</span></span>

## <a name="challenge-3-how-to-achieve-consistency-across-multiple-microservices"></a><span data-ttu-id="a5de3-153">挑战 \#3：如何实现微服务之间的一致性</span><span class="sxs-lookup"><span data-stu-id="a5de3-153">Challenge \#3: How to achieve consistency across multiple microservices</span></span>

<span data-ttu-id="a5de3-154">如前所述，每个微服务拥有的数据是该微服务专有的，并且只能通过其本身的微服务 API 访问。</span><span class="sxs-lookup"><span data-stu-id="a5de3-154">As stated previously, the data owned by each microservice is private to that microservice and can only be accessed using its microservice API.</span></span> <span data-ttu-id="a5de3-155">因此，面临的挑战是如何在保持多个微服务的一致性的同时实现端到端的业务进程。</span><span class="sxs-lookup"><span data-stu-id="a5de3-155">Therefore, a challenge presented is how to implement end-to-end business processes while keeping consistency across multiple microservices.</span></span>

<span data-ttu-id="a5de3-156">若要分析此问题，请先查看来自 [eShopOnContainers 引用应用程序](https://aka.ms/eshoponcontainers)的示例。</span><span class="sxs-lookup"><span data-stu-id="a5de3-156">To analyze this problem, let's look at an example from the [eShopOnContainers reference application](https://aka.ms/eshoponcontainers).</span></span> <span data-ttu-id="a5de3-157">目录微服务保存关于所有产品的信息，包括产品价格。</span><span class="sxs-lookup"><span data-stu-id="a5de3-157">The Catalog microservice maintains information about all the products, including the product price.</span></span> <span data-ttu-id="a5de3-158">购物篮微服务管理有关用户添加到购物篮中的产品项的时态数据，其中包括产品项在添加到购物篮时的价格。</span><span class="sxs-lookup"><span data-stu-id="a5de3-158">The Basket microservice manages temporal data about product items that users are adding to their shopping baskets, which includes the price of the items at the time they were added to the basket.</span></span> <span data-ttu-id="a5de3-159">在目录中更新产品的价格后，还应在保存该相同产品的活动购物篮中更新该价格，且系统可能应当提醒用户，自他们将该特定产品项添加到购物篮以来，其价格已发生变化。</span><span class="sxs-lookup"><span data-stu-id="a5de3-159">When a product's price is updated in the catalog, that price should also be updated in the active baskets that hold that same product, plus the system should probably warn the user saying that a particular item's price has changed since they added it to their basket.</span></span>

<span data-ttu-id="a5de3-160">在此应用程序的假设单片版本中，当产品表中的价格发生变化时，目录子系统只需使用 ACID 事务即可更新购物篮表中的当前价格。</span><span class="sxs-lookup"><span data-stu-id="a5de3-160">In a hypothetical monolithic version of this application, when the price changes in the products table, the catalog subsystem could simply use an ACID transaction to update the current price in the Basket table.</span></span>

<span data-ttu-id="a5de3-161">但是，在基于微服务的应用程序中，产品表和购物篮表属于其各自的微服务。</span><span class="sxs-lookup"><span data-stu-id="a5de3-161">However, in a microservices-based application, the Product and Basket tables are owned by their respective microservices.</span></span> <span data-ttu-id="a5de3-162">如图 4-9 所示，微服务不应在其自己的事务中包含属于另一微服务的表/存储，甚至在直接查询中也不能包含。</span><span class="sxs-lookup"><span data-stu-id="a5de3-162">No microservice should ever include tables/storage owned by another microservice in its own transactions, not even in direct queries, as shown in Figure 4-9.</span></span>

![显示微服务数据库数据无法共享的示意图。](./media/distributed-data-management/indepentent-microservice-databases.png)

<span data-ttu-id="a5de3-164">**图 4-9**.</span><span class="sxs-lookup"><span data-stu-id="a5de3-164">**Figure 4-9**.</span></span> <span data-ttu-id="a5de3-165">微服务不能直接访问另一微服务中的表</span><span class="sxs-lookup"><span data-stu-id="a5de3-165">A microservice can't directly access a table in another microservice</span></span>

<span data-ttu-id="a5de3-166">目录微服务不应直接更新购物篮表，因为购物篮表属于购物篮微服务。</span><span class="sxs-lookup"><span data-stu-id="a5de3-166">The Catalog microservice shouldn't update the Basket table directly, because the Basket table is owned by the Basket microservice.</span></span> <span data-ttu-id="a5de3-167">若要更新购物篮微服务，目录微服务可能应当基于异步通信（例如集成事件，即消息和基于事件的通信）使用最终一致性。</span><span class="sxs-lookup"><span data-stu-id="a5de3-167">To make an update to the Basket microservice, the Catalog microservice should use eventual consistency probably based on asynchronous communication such as integration events (message and event-based communication).</span></span> <span data-ttu-id="a5de3-168">这是 [eShopOnContainers](https://aka.ms/eshoponcontainers) 引用应用程序跨微服务执行此类一致性的方式。</span><span class="sxs-lookup"><span data-stu-id="a5de3-168">This is how the [eShopOnContainers](https://aka.ms/eshoponcontainers) reference application performs this type of consistency across microservices.</span></span>

<span data-ttu-id="a5de3-169">如 [CAP 定理](https://en.wikipedia.org/wiki/CAP_theorem)所阐述的，需要选择可用性或 ACID 非常一致性。</span><span class="sxs-lookup"><span data-stu-id="a5de3-169">As stated by the [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem), you need to choose between availability and ACID strong consistency.</span></span> <span data-ttu-id="a5de3-170">大多数基于微服务的方案都需要可用性和高可伸缩性，而不是非常一致性。</span><span class="sxs-lookup"><span data-stu-id="a5de3-170">Most microservice-based scenarios demand availability and high scalability as opposed to strong consistency.</span></span> <span data-ttu-id="a5de3-171">任务关键应用程序必须保持最新并且处于运行状态，开发人员可通过用于处理弱或最终一致性的技术来实现非常一致性。</span><span class="sxs-lookup"><span data-stu-id="a5de3-171">Mission-critical applications must remain up and running, and developers can work around strong consistency by using techniques for working with weak or eventual consistency.</span></span> <span data-ttu-id="a5de3-172">这是大多数基于微服务的体系结构采用的方法。</span><span class="sxs-lookup"><span data-stu-id="a5de3-172">This is the approach taken by most microservice-based architectures.</span></span>

<span data-ttu-id="a5de3-173">此外，ACID 式或两阶段提交事务不仅针对微服务原则；大多数 NoSQL 数据库（如 Azure Cosmos DB、MongoDB 等）不支持两阶段提交事务（在分布式数据库方案中十分常见）。</span><span class="sxs-lookup"><span data-stu-id="a5de3-173">Moreover, ACID-style or two-phase commit transactions are not just against microservices principles; most NoSQL databases (like Azure Cosmos DB, MongoDB, etc.) do not support two-phase commit transactions, typical in distributed databases scenarios.</span></span> <span data-ttu-id="a5de3-174">但是，维护服务和数据库的数据一致性至关重要。</span><span class="sxs-lookup"><span data-stu-id="a5de3-174">However, maintaining data consistency across services and databases is essential.</span></span> <span data-ttu-id="a5de3-175">此挑战还涉及，当某些数据需要冗余时（例如，需要在目录微服务和购物篮微服务中使用产品名称或说明时），如何在多个微服务之间传播更改。</span><span class="sxs-lookup"><span data-stu-id="a5de3-175">This challenge is also related to the question of how to propagate changes across multiple microservices when certain data needs to be redundant—for example, when you need to have the product's name or description in the Catalog microservice and the Basket microservice.</span></span>

<span data-ttu-id="a5de3-176">针对此问题的一个良好解决方案是，在通过事件驱动通信和发布订阅系统形成的微服务之间使用最终一致性。</span><span class="sxs-lookup"><span data-stu-id="a5de3-176">A good solution for this problem is to use eventual consistency between microservices articulated through event-driven communication and a publish-and-subscribe system.</span></span> <span data-ttu-id="a5de3-177">本指南后面的[异步事件驱动通信](asynchronous-message-based-communication.md#asynchronous-event-driven-communication)部分将介绍这些主题。</span><span class="sxs-lookup"><span data-stu-id="a5de3-177">These topics are covered in the section [Asynchronous event-driven communication](asynchronous-message-based-communication.md#asynchronous-event-driven-communication) later in this guide.</span></span>

## <a name="challenge-4-how-to-design-communication-across-microservice-boundaries"></a><span data-ttu-id="a5de3-178">挑战 \#4：如何设计跨微服务边界的通信</span><span class="sxs-lookup"><span data-stu-id="a5de3-178">Challenge \#4: How to design communication across microservice boundaries</span></span>

<span data-ttu-id="a5de3-179">跨微服务边界的通信是真正的挑战。</span><span class="sxs-lookup"><span data-stu-id="a5de3-179">Communicating across microservice boundaries is a real challenge.</span></span> <span data-ttu-id="a5de3-180">在此上下文中，通信不是指应使用何种协议（HTTP 和 REST、AMQP、消息等）。</span><span class="sxs-lookup"><span data-stu-id="a5de3-180">In this context, communication doesn't refer to what protocol you should use (HTTP and REST, AMQP, messaging, and so on).</span></span> <span data-ttu-id="a5de3-181">相反，它解决了应使用何种通信方式的问题，尤其是应如何耦合微服务。</span><span class="sxs-lookup"><span data-stu-id="a5de3-181">Instead, it addresses what communication style you should use, and especially how coupled your microservices should be.</span></span> <span data-ttu-id="a5de3-182">根据耦合的程度，在故障发生时，该故障对系统的影响将会有很大差异。</span><span class="sxs-lookup"><span data-stu-id="a5de3-182">Depending on the level of coupling, when failure occurs, the impact of that failure on your system will vary significantly.</span></span>

<span data-ttu-id="a5de3-183">在分布式系统（如基于微服务的应用程序）中，由于许多项目不断移动并且许多服务器或主机之间存在分布式服务，因此组件最终将失败。</span><span class="sxs-lookup"><span data-stu-id="a5de3-183">In a distributed system like a microservices-based application, with so many artifacts moving around and with distributed services across many servers or hosts, components will eventually fail.</span></span> <span data-ttu-id="a5de3-184">这可能导致部分故障甚至更大规模的中断，因此需要在设计微服务和跨微服务的通信时，考虑此类分布式系统中的常见风险。</span><span class="sxs-lookup"><span data-stu-id="a5de3-184">Partial failure and even larger outages will occur, so you need to design your microservices and the communication across them considering the common risks in this type of distributed system.</span></span>

<span data-ttu-id="a5de3-185">常用方法是实现基于 HTTP (REST) 的微服务，因为该服务具有简便性。</span><span class="sxs-lookup"><span data-stu-id="a5de3-185">A popular approach is to implement HTTP (REST)-based microservices, due to their simplicity.</span></span> <span data-ttu-id="a5de3-186">基于 HTTP 的方法是完全可以接受的；这里存在的问题与其使用方法有关。</span><span class="sxs-lookup"><span data-stu-id="a5de3-186">An HTTP-based approach is perfectly acceptable; the issue here is related to how you use it.</span></span> <span data-ttu-id="a5de3-187">如果使用 HTTP 请求和响应只是为了与来自客户端应用程序或 API 网关的微服务进行交互，这是可行的。</span><span class="sxs-lookup"><span data-stu-id="a5de3-187">If you use HTTP requests and responses just to interact with your microservices from client applications or from API Gateways, that's fine.</span></span> <span data-ttu-id="a5de3-188">但如果创建跨微服务的长链同步 HTTP 调用，就好像微服务是单片应用程序中的对象一样进行跨边界通信，则应用程序最终会遇到问题。</span><span class="sxs-lookup"><span data-stu-id="a5de3-188">But if you create long chains of synchronous HTTP calls across microservices, communicating across their boundaries as if the microservices were objects in a monolithic application, your application will eventually run into problems.</span></span>

<span data-ttu-id="a5de3-189">例如，假设客户端应用程序对单个微服务（如订购微服务）进行 HTTP API 调用。</span><span class="sxs-lookup"><span data-stu-id="a5de3-189">For instance, imagine that your client application makes an HTTP API call to an individual microservice like the Ordering microservice.</span></span> <span data-ttu-id="a5de3-190">如果订购微服务在相同的请求/响应周期内转而使用 HTTP 调用其他微服务，则表示正在创建 HTTP 调用链。</span><span class="sxs-lookup"><span data-stu-id="a5de3-190">If the Ordering microservice in turn calls additional microservices using HTTP within the same request/response cycle, you're creating a chain of HTTP calls.</span></span> <span data-ttu-id="a5de3-191">刚开始时，这可能听起来很合理。</span><span class="sxs-lookup"><span data-stu-id="a5de3-191">It might sound reasonable initially.</span></span> <span data-ttu-id="a5de3-192">但是，如果继续进行，则需要考虑一些重要问题：</span><span class="sxs-lookup"><span data-stu-id="a5de3-192">However, there are important points to consider when going down this path:</span></span>

- <span data-ttu-id="a5de3-193">阻止和低降低。</span><span class="sxs-lookup"><span data-stu-id="a5de3-193">Blocking and low performance.</span></span> <span data-ttu-id="a5de3-194">由于 HTTP 的同步性质，直到所有内部 HTTP 调用完成后，原始请求才会收到响应。</span><span class="sxs-lookup"><span data-stu-id="a5de3-194">Due to the synchronous nature of HTTP, the original request doesn't get a response until all the internal HTTP calls are finished.</span></span> <span data-ttu-id="a5de3-195">假设这些调用的数量显著增加，同时某个对微服务的中间 HTTP 调用受到阻止。</span><span class="sxs-lookup"><span data-stu-id="a5de3-195">Imagine if the number of these calls increases significantly and at the same time one of the intermediate HTTP calls to a microservice is blocked.</span></span> <span data-ttu-id="a5de3-196">这会对性能造成影响，并且随着其他 HTTP 请求的增加，整体可伸缩性将受到的影响将成倍增长。</span><span class="sxs-lookup"><span data-stu-id="a5de3-196">The result is that performance is impacted, and the overall scalability will be exponentially affected as additional HTTP requests increase.</span></span>

- <span data-ttu-id="a5de3-197">将微服务与 HTTP 耦合。</span><span class="sxs-lookup"><span data-stu-id="a5de3-197">Coupling microservices with HTTP.</span></span> <span data-ttu-id="a5de3-198">业务微服务不应与其他业务微服务耦合。</span><span class="sxs-lookup"><span data-stu-id="a5de3-198">Business microservices shouldn't be coupled with other business microservices.</span></span> <span data-ttu-id="a5de3-199">理想情况下，它们不应“知道”其他微服务的存在。</span><span class="sxs-lookup"><span data-stu-id="a5de3-199">Ideally, they shouldn't "know" about the existence of other microservices.</span></span> <span data-ttu-id="a5de3-200">如果应用程序依赖于如例所示的耦合微服务，那么几乎不可能实现每个微服务的自治。</span><span class="sxs-lookup"><span data-stu-id="a5de3-200">If your application relies on coupling microservices as in the example, achieving autonomy per microservice will be almost impossible.</span></span>

- <span data-ttu-id="a5de3-201">任一微服务中的失败。</span><span class="sxs-lookup"><span data-stu-id="a5de3-201">Failure in any one microservice.</span></span> <span data-ttu-id="a5de3-202">如果实现由 HTTP 调用链接的微服务链，那么任一微服务失败（最终所有微服务都将失败）都将导致整个微服务链的失败。</span><span class="sxs-lookup"><span data-stu-id="a5de3-202">If you implemented a chain of microservices linked by HTTP calls, when any of the microservices fails (and eventually they will fail) the whole chain of microservices will fail.</span></span> <span data-ttu-id="a5de3-203">基于微服务的系统应设计为在部分故障期间也尽可能地继续工作。</span><span class="sxs-lookup"><span data-stu-id="a5de3-203">A microservice-based system should be designed to continue to work as well as possible during partial failures.</span></span> <span data-ttu-id="a5de3-204">即使通过指数退避或断路器机制实现使用重试的客户端逻辑，HTTP 调用链越复杂，实现基于 HTTP 的故障策略也会越复杂。</span><span class="sxs-lookup"><span data-stu-id="a5de3-204">Even if you implement client logic that uses retries with exponential backoff or circuit breaker mechanisms, the more complex the HTTP call chains are, the more complex it is to implement a failure strategy based on HTTP.</span></span>

<span data-ttu-id="a5de3-205">事实上，如果内部微服务如前文所述通过创建 HTTP 请求链进行通信，那么可能会认为你拥有一个单片应用程序，但是它基于进程之间的 HTTP，而不是进程间的通信机制。</span><span class="sxs-lookup"><span data-stu-id="a5de3-205">In fact, if your internal microservices are communicating by creating chains of HTTP requests as described, it could be argued that you have a monolithic application, but one based on HTTP between processes instead of intra-process communication mechanisms.</span></span>

<span data-ttu-id="a5de3-206">因此，为强化微服务自治并且提升复原能力，应尽可能少地使用跨微服务的请求/响应通信链。</span><span class="sxs-lookup"><span data-stu-id="a5de3-206">Therefore, in order to enforce microservice autonomy and have better resiliency, you should minimize the use of chains of request/response communication across microservices.</span></span> <span data-ttu-id="a5de3-207">建议只使用异步交互进行微服务之间的通信，方法是使用基于消息和基于事件的异步通信，或（异步）使用独立于原始 HTTP 请求/响应周期的 HTTP 轮询。</span><span class="sxs-lookup"><span data-stu-id="a5de3-207">It's recommended that you use only asynchronous interaction for inter-microservice communication, either by using asynchronous message- and event-based communication, or by using (asynchronous) HTTP polling independently of the original HTTP request/response cycle.</span></span>

<span data-ttu-id="a5de3-208">异步通信的使用稍后将在本指南的[异步微服务集成强化微服务的自治性](communication-in-microservice-architecture.md#asynchronous-microservice-integration-enforces-microservices-autonomy)和[基于消息的异步通信](asynchronous-message-based-communication.md)部分详细介绍。</span><span class="sxs-lookup"><span data-stu-id="a5de3-208">The use of asynchronous communication is explained with additional details later in this guide in the sections [Asynchronous microservice integration enforces microservice's autonomy](communication-in-microservice-architecture.md#asynchronous-microservice-integration-enforces-microservices-autonomy) and [Asynchronous message-based communication](asynchronous-message-based-communication.md).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="a5de3-209">其他资源</span><span class="sxs-lookup"><span data-stu-id="a5de3-209">Additional resources</span></span>

- <span data-ttu-id="a5de3-210">**The CAP Theorem**（CAP 定理） </span><span class="sxs-lookup"><span data-stu-id="a5de3-210">**CAP theorem** </span></span>\
  <https://en.wikipedia.org/wiki/CAP_theorem>

- <span data-ttu-id="a5de3-211">**Eventual Consistency**（最终一致性） </span><span class="sxs-lookup"><span data-stu-id="a5de3-211">**Eventual consistency** </span></span>\
  <https://en.wikipedia.org/wiki/Eventual_consistency>

- <span data-ttu-id="a5de3-212">**Data Consistency Primer**（数据一致性入门指南） </span><span class="sxs-lookup"><span data-stu-id="a5de3-212">**Data Consistency Primer** </span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/dn589800(v=pandp.10)>

- <span data-ttu-id="a5de3-213">**Martin Fowler。CQRS (Command and Query Responsibility Segregation)** （CQRS [命令和查询责任分离]） </span><span class="sxs-lookup"><span data-stu-id="a5de3-213">**Martin Fowler. CQRS (Command and Query Responsibility Segregation)** </span></span>\
  <https://martinfowler.com/bliki/CQRS.html>

- <span data-ttu-id="a5de3-214">**Materialized View**（具体化视图） </span><span class="sxs-lookup"><span data-stu-id="a5de3-214">**Materialized View** </span></span>\
  <https://docs.microsoft.com/azure/architecture/patterns/materialized-view>

- <span data-ttu-id="a5de3-215">**Charles Row.ACID vs.BASE：数据库事务处理不断变化的 pH** </span><span class="sxs-lookup"><span data-stu-id="a5de3-215">**Charles Row. ACID vs. BASE: The Shifting pH of Database Transaction Processing** </span></span>\
  <https://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/>

- <span data-ttu-id="a5de3-216">**Compensating Transaction**（补偿事务） </span><span class="sxs-lookup"><span data-stu-id="a5de3-216">**Compensating Transaction** </span></span>\
  <https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction>

- <span data-ttu-id="a5de3-217">**Udi Dahan.面向服务的组合** </span><span class="sxs-lookup"><span data-stu-id="a5de3-217">**Udi Dahan. Service Oriented Composition** </span></span>\
  <https://udidahan.com/2014/07/30/service-oriented-composition-with-video/>

>[!div class="step-by-step"]
><span data-ttu-id="a5de3-218">[上一页](logical-versus-physical-architecture.md)
>[下一页](identify-microservice-domain-model-boundaries.md)</span><span class="sxs-lookup"><span data-stu-id="a5de3-218">[Previous](logical-versus-physical-architecture.md)
[Next](identify-microservice-domain-model-boundaries.md)</span></span>
