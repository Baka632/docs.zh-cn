---
title: Docker 应用程序中的状态和数据
description: Docker 应用程序中的状态和数据管理。 微服务实例是可消耗的，但数据不是，本文介绍如何使用微服务处理这一问题。
ms.date: 09/20/2018
ms.openlocfilehash: 10271d41dcd0574cd212663c2ee22ae06c2c1269
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/24/2020
ms.locfileid: "91152619"
---
# <a name="state-and-data-in-docker-applications"></a><span data-ttu-id="ddee3-104">Docker 应用程序中的状态和数据</span><span class="sxs-lookup"><span data-stu-id="ddee3-104">State and data in Docker applications</span></span>

<span data-ttu-id="ddee3-105">在大多数情况下，可以将容器视为进程的实例。</span><span class="sxs-lookup"><span data-stu-id="ddee3-105">In most cases, you can think of a container as an instance of a process.</span></span> <span data-ttu-id="ddee3-106">进程不维护持久状态。</span><span class="sxs-lookup"><span data-stu-id="ddee3-106">A process doesn't maintain persistent state.</span></span> <span data-ttu-id="ddee3-107">虽然容器可以写入其本地存储，但假设一个实例将无限期地存在，就像假设内存中的单个位置将是持久的一样。</span><span class="sxs-lookup"><span data-stu-id="ddee3-107">While a container can write to its local storage, assuming that an instance will be around indefinitely would be like assuming that a single location in memory will be durable.</span></span> <span data-ttu-id="ddee3-108">应假定容器映像（如进程）拥有多个实例或最终会被终止。</span><span class="sxs-lookup"><span data-stu-id="ddee3-108">You should assume that container images, like processes, have multiple instances or will eventually be killed.</span></span> <span data-ttu-id="ddee3-109">如果使用容器业务流程协调程序对其进行管理，则应假定它们可能会从一个节点或 VM 移动到另一个节点或 VM。</span><span class="sxs-lookup"><span data-stu-id="ddee3-109">If they're managed with a container orchestrator, you should assume that they might get moved from one node or VM to another.</span></span>

<span data-ttu-id="ddee3-110">以下解决方案用于管理 Docker 应用程序中的数据：</span><span class="sxs-lookup"><span data-stu-id="ddee3-110">The following solutions are used to manage data in Docker applications:</span></span>

<span data-ttu-id="ddee3-111">从 Docker 主机，作为 [Docker 卷](https://docs.docker.com/engine/admin/volumes/)：</span><span class="sxs-lookup"><span data-stu-id="ddee3-111">From the Docker host, as [Docker Volumes](https://docs.docker.com/engine/admin/volumes/):</span></span>

- <span data-ttu-id="ddee3-112">**卷**存储在由 Docker 管理的主机文件系统区域中。</span><span class="sxs-lookup"><span data-stu-id="ddee3-112">**Volumes** are stored in an area of the host filesystem that's managed by Docker.</span></span>

- <span data-ttu-id="ddee3-113">**绑定装载**可映射到主机文件系统中的任何文件夹，因此不能通过 Docker 进程控制访问，且访问可带来安全风险，原因在于容器可访问敏感的 OS 文件夹。</span><span class="sxs-lookup"><span data-stu-id="ddee3-113">**Bind mounts** can map to any folder in the host filesystem, so access can't be controlled from Docker process and can pose a security risk as a container could access sensitive OS folders.</span></span>

- <span data-ttu-id="ddee3-114">**tmpfs 装载**类似仅存在于主机内存中的虚拟文件夹，并且绝不会写入文件系统。</span><span class="sxs-lookup"><span data-stu-id="ddee3-114">**tmpfs mounts** are like virtual folders that only exist in the host's memory and are never written to the filesystem.</span></span>

<span data-ttu-id="ddee3-115">从远程存储：</span><span class="sxs-lookup"><span data-stu-id="ddee3-115">From remote storage:</span></span>

- <span data-ttu-id="ddee3-116">[Azure 存储](https://azure.microsoft.com/documentation/services/storage/)，提供可异地分发存储，为容器提供良好的持久性解决方案。</span><span class="sxs-lookup"><span data-stu-id="ddee3-116">[Azure Storage](https://azure.microsoft.com/documentation/services/storage/), which provides geo-distributable storage, providing a good long-term persistence solution for containers.</span></span>

- <span data-ttu-id="ddee3-117">远程关系数据库（如 [Azure SQL 数据库](https://azure.microsoft.com/services/sql-database/)）或 NoSQL 数据库（如 [Azure Cosmos DB](/azure/cosmos-db/introduction)）或缓存服务（如 [Redis](https://redis.io/)）。</span><span class="sxs-lookup"><span data-stu-id="ddee3-117">Remote relational databases like [Azure SQL Database](https://azure.microsoft.com/services/sql-database/) or NoSQL databases like [Azure Cosmos DB](/azure/cosmos-db/introduction), or cache services like [Redis](https://redis.io/).</span></span>

<span data-ttu-id="ddee3-118">从 Docker 容器：</span><span class="sxs-lookup"><span data-stu-id="ddee3-118">From the Docker container:</span></span>

- <span data-ttu-id="ddee3-119">**覆盖文件系统**。</span><span class="sxs-lookup"><span data-stu-id="ddee3-119">**Overlay File System**.</span></span> <span data-ttu-id="ddee3-120">此 Docker 功能实现了写入时复制任务，该任务将更新后的信息存储到容器的根文件系统中。</span><span class="sxs-lookup"><span data-stu-id="ddee3-120">This Docker feature implements a copy-on-write task that stores updated information to the root file system of the container.</span></span> <span data-ttu-id="ddee3-121">该信息“基于”容器所基于的原始映像。</span><span class="sxs-lookup"><span data-stu-id="ddee3-121">That information is "on top" of the original image on which the container is based.</span></span> <span data-ttu-id="ddee3-122">如果从系统中删除容器，则这些更改将丢失。</span><span class="sxs-lookup"><span data-stu-id="ddee3-122">If the container is deleted from the system, those changes are lost.</span></span> <span data-ttu-id="ddee3-123">因此，虽然可以在其本地存储中保存容器的状态，但围绕这一点设计系统将与容器设计的前提相冲突，而容器设计在默认情况下为无状态。</span><span class="sxs-lookup"><span data-stu-id="ddee3-123">Therefore, while it's possible to save the state of a container within its local storage, designing a system around this would conflict with the premise of container design, which by default is stateless.</span></span>

<span data-ttu-id="ddee3-124">但是，现在使用 Docker 卷是处理 Docker 中的本地数据的首选方式。</span><span class="sxs-lookup"><span data-stu-id="ddee3-124">However, using Docker Volumes is now the preferred way to handle local data in Docker.</span></span> <span data-ttu-id="ddee3-125">如需了解有关容器中的存储的详细信息，请查看 [Docker 存储驱动程序](https://docs.docker.com/storage/storagedriver/select-storage-driver/)和[关于存储驱动程序](https://docs.docker.com/storage/storagedriver/)。</span><span class="sxs-lookup"><span data-stu-id="ddee3-125">If you need more information about storage in containers check on [Docker storage drivers](https://docs.docker.com/storage/storagedriver/select-storage-driver/) and [About storage drivers](https://docs.docker.com/storage/storagedriver/).</span></span>

<span data-ttu-id="ddee3-126">下面提供了有关这些选项的更多详细信息：</span><span class="sxs-lookup"><span data-stu-id="ddee3-126">The following provides more detail about these options:</span></span>

<span data-ttu-id="ddee3-127">**卷**是从主机 OS 映射到容器目录的目录。</span><span class="sxs-lookup"><span data-stu-id="ddee3-127">**Volumes** are directories mapped from the host OS to directories in containers.</span></span> <span data-ttu-id="ddee3-128">当容器中的代码访问该目录时，该访问实际上是对主机操作系统上的一个目录的访问。</span><span class="sxs-lookup"><span data-stu-id="ddee3-128">When code in the container has access to the directory, that access is actually to a directory on the host OS.</span></span> <span data-ttu-id="ddee3-129">此目录不与容器自身的生存期绑定，且该目录由 Docker 管理并独立于主机计算机的核心功能。</span><span class="sxs-lookup"><span data-stu-id="ddee3-129">This directory is not tied to the lifetime of the container itself, and the directory is managed by Docker and isolated from the core functionality of the host machine.</span></span> <span data-ttu-id="ddee3-130">因此，数据卷用于将独立于容器的生命周期的数据持久保存。</span><span class="sxs-lookup"><span data-stu-id="ddee3-130">Thus, data volumes are designed to persist data independently of the life of the container.</span></span> <span data-ttu-id="ddee3-131">如果从 Docker 主机中删除容器或图像，不会删除数据卷中保留的数据。</span><span class="sxs-lookup"><span data-stu-id="ddee3-131">If you delete a container or an image from the Docker host, the data persisted in the data volume isn't deleted.</span></span>

<span data-ttu-id="ddee3-132">可以命名卷，也可以让卷保持匿名（默认设置）。</span><span class="sxs-lookup"><span data-stu-id="ddee3-132">Volumes can be named or anonymous (the default).</span></span> <span data-ttu-id="ddee3-133">命名卷是**数据卷容器**的演变，它使得在不同容器之间共享数据变得容易。</span><span class="sxs-lookup"><span data-stu-id="ddee3-133">Named volumes are the evolution of **Data Volume Containers** and make it easy to share data between containers.</span></span> <span data-ttu-id="ddee3-134">卷还支持卷驱动程序，使你可将数据存储在远程主机上等。</span><span class="sxs-lookup"><span data-stu-id="ddee3-134">Volumes also support volume drivers that allow you to store data on remote hosts, among other options.</span></span>

<span data-ttu-id="ddee3-135">**绑定装载**很久以前就已经可用，并允许将任何文件夹映射到容器中的装入点。</span><span class="sxs-lookup"><span data-stu-id="ddee3-135">**Bind mounts** are available since a long time ago and allow the mapping of any folder to a mount point in a container.</span></span> <span data-ttu-id="ddee3-136">绑定挂载的限制比卷的限制多，并存在一些重要安全问题，因此，卷是建议选项。</span><span class="sxs-lookup"><span data-stu-id="ddee3-136">Bind mounts have more limitations than volumes and some important security issues, so volumes are the recommended option.</span></span>

<span data-ttu-id="ddee3-137">**tmpfs 装载**相当于仅存在于主机内存中的虚拟文件夹，并且绝不会写入文件系统。</span><span class="sxs-lookup"><span data-stu-id="ddee3-137">**tmpfs mounts** are basically virtual folders that live only in the host's memory and are never written to the filesystem.</span></span> <span data-ttu-id="ddee3-138">它们快速且安全，但使用内存，且仅适用于临时的非持久性数据。</span><span class="sxs-lookup"><span data-stu-id="ddee3-138">They are fast and secure but use memory and are only meant for temporary, non-persistent data.</span></span>

<span data-ttu-id="ddee3-139">如图 4-5 所示，常规 Docker 卷可以存储在容器本身之外，但是在主机服务器或 VM 的物理边界内。</span><span class="sxs-lookup"><span data-stu-id="ddee3-139">As shown in Figure 4-5, regular Docker volumes can be stored outside of the containers themselves but within the physical boundaries of the host server or VM.</span></span> <span data-ttu-id="ddee3-140">但是，Docker 容器无法从一个主机服务器或 VM 访问另一个主机服务器或 VM 的卷。</span><span class="sxs-lookup"><span data-stu-id="ddee3-140">However, Docker containers can't access a volume from one host server or VM to another.</span></span> <span data-ttu-id="ddee3-141">换而言之，如果使用这些卷，那么不能管理在不同 Docker 主机上运行的容器之间共享的数据，尽管可通过支持远程主机的卷驱动程序来实现这一功能。</span><span class="sxs-lookup"><span data-stu-id="ddee3-141">In other words, with these volumes, it isn't possible to manage data shared between containers that run on different Docker hosts, although it could be achieved with a volume driver that supports remote hosts.</span></span>

![显示基于容器的应用程序的数据卷和外部数据源的示意图。](./media/docker-application-state-data/volumes-external-data-sources.png)

<span data-ttu-id="ddee3-143">**图 4-5**。</span><span class="sxs-lookup"><span data-stu-id="ddee3-143">**Figure 4-5**.</span></span> <span data-ttu-id="ddee3-144">基于容器的应用程序的卷和外部数据源</span><span class="sxs-lookup"><span data-stu-id="ddee3-144">Volumes and external data sources for container-based applications</span></span>

<span data-ttu-id="ddee3-145">卷可在容器之间共享，但仅限于同一台主机，除非使用支持远程主机的远程驱动程序。</span><span class="sxs-lookup"><span data-stu-id="ddee3-145">Volumes can be shared between containers, but only in the same host, unless you use a remote driver that supports remote hosts.</span></span> <span data-ttu-id="ddee3-146">此外，当 Docker 容器由业务流程协调程序管理时，容器可能会在主机之间“移动”，这取决于群集所执行的优化。</span><span class="sxs-lookup"><span data-stu-id="ddee3-146">In addition, when Docker containers are managed by an orchestrator, containers might "move" between hosts, depending on the optimizations performed by the cluster.</span></span> <span data-ttu-id="ddee3-147">因此，不建议将数据卷用于业务数据。</span><span class="sxs-lookup"><span data-stu-id="ddee3-147">Therefore, it isn't recommended that you use data volumes for business data.</span></span> <span data-ttu-id="ddee3-148">但它们是一种良好的机制，可以处理跟踪文件、时态文件或类似的不会影响业务数据一致性的文件。</span><span class="sxs-lookup"><span data-stu-id="ddee3-148">But they're a good mechanism to work with trace files, temporal files, or similar that will not impact business data consistency.</span></span>

<span data-ttu-id="ddee3-149">远程数据源和缓存工具（如 Azure SQL 数据库、Azure Cosmos DB）或远程缓存（如 Redis）可以在容器化应用程序中使用，与开发时没有容器的使用方式相同  。</span><span class="sxs-lookup"><span data-stu-id="ddee3-149">**Remote data sources and cache** tools like Azure SQL Database, Azure Cosmos DB, or a remote cache like Redis can be used in containerized applications the same way they are used when developing without containers.</span></span> <span data-ttu-id="ddee3-150">这是存储业务应用程序数据的一种行之有效的方法。</span><span class="sxs-lookup"><span data-stu-id="ddee3-150">This is a proven way to store business application data.</span></span>

<span data-ttu-id="ddee3-151">Azure 存储。 </span><span class="sxs-lookup"><span data-stu-id="ddee3-151">**Azure Storage.**</span></span> <span data-ttu-id="ddee3-152">业务数据通常需要放在外部资源或数据库中，如 Azure 存储。</span><span class="sxs-lookup"><span data-stu-id="ddee3-152">Business data usually will need to be placed in external resources or databases, like Azure Storage.</span></span> <span data-ttu-id="ddee3-153">Azure 存储在云中具体提供以下服务：</span><span class="sxs-lookup"><span data-stu-id="ddee3-153">Azure Storage, in concrete, provides the following services in the cloud:</span></span>

- <span data-ttu-id="ddee3-154">Blob 存储存储非结构化的对象数据。</span><span class="sxs-lookup"><span data-stu-id="ddee3-154">Blob storage stores unstructured object data.</span></span> <span data-ttu-id="ddee3-155">Blob 可以是任何类型的文本或二进制数据，如文档或媒体文件（图像、音频和视频文件）。</span><span class="sxs-lookup"><span data-stu-id="ddee3-155">A blob can be any type of text or binary data, such as document or media files (images, audio, and video files).</span></span> <span data-ttu-id="ddee3-156">Blob 存储也称为对象存储。</span><span class="sxs-lookup"><span data-stu-id="ddee3-156">Blob storage is also referred to as Object storage.</span></span>

- <span data-ttu-id="ddee3-157">文件存储为使用标准 SMB 协议的旧版应用程序提供共享存储。</span><span class="sxs-lookup"><span data-stu-id="ddee3-157">File storage offers shared storage for legacy applications using standard SMB protocol.</span></span> <span data-ttu-id="ddee3-158">Azure 虚拟机和云服务可以通过装载的共享在应用程序组件之间共享文件数据。</span><span class="sxs-lookup"><span data-stu-id="ddee3-158">Azure virtual machines and cloud services can share file data across application components via mounted shares.</span></span> <span data-ttu-id="ddee3-159">本地应用程序可以通过文件服务 REST API 访问共享中的文件数据。</span><span class="sxs-lookup"><span data-stu-id="ddee3-159">On-premises applications can access file data in a share via the File service REST API.</span></span>

- <span data-ttu-id="ddee3-160">表存储存储结构化数据集。</span><span class="sxs-lookup"><span data-stu-id="ddee3-160">Table storage stores structured datasets.</span></span> <span data-ttu-id="ddee3-161">表存储是 NoSQL 键属性数据存储，它允许快速开发和快速访问大量数据。</span><span class="sxs-lookup"><span data-stu-id="ddee3-161">Table storage is a NoSQL key-attribute data store, which allows rapid development and fast access to large quantities of data.</span></span>

<span data-ttu-id="ddee3-162">关系数据库和 NoSQL 数据库。 </span><span class="sxs-lookup"><span data-stu-id="ddee3-162">**Relational databases and NoSQL databases.**</span></span> <span data-ttu-id="ddee3-163">外部数据库有很多选择，包括关系数据库（如 SQL Server、PostgreSQL、Oracle）或 NoSQL 数据库（如 Azure Cosmos DB、MongoDB）等。这些数据库将不会作为本指南的一部分加以解释，因为它们在一个完全不同的主题中。</span><span class="sxs-lookup"><span data-stu-id="ddee3-163">There are many choices for external databases, from relational databases like SQL Server, PostgreSQL, Oracle, or NoSQL databases like Azure Cosmos DB, MongoDB, etc. These databases are not going to be explained as part of this guide since they are in a completely different subject.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="ddee3-164">[上一页](containerize-monolithic-applications.md)
>[下一页](service-oriented-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="ddee3-164">[Previous](containerize-monolithic-applications.md)
[Next](service-oriented-architecture.md)</span></span>
