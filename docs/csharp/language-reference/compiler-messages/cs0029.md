---
description: 编译器错误 CS0029
title: 编译器错误 CS0029
ms.date: 07/20/2015
f1_keywords:
- CS0029
helpviewer_keywords:
- CS0029
ms.assetid: 63c3e574-1868-4a9e-923e-dcd9f38bce88
ms.openlocfilehash: 4f6a1f9bfc16ebaaecf38645de377b9b29bbbf8e
ms.sourcegitcommit: e7acba36517134238065e4d50bb4a1cfe47ebd06
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/04/2020
ms.locfileid: "89465021"
---
# <a name="compiler-error-cs0029"></a><span data-ttu-id="9471e-103">编译器错误 CS0029</span><span class="sxs-lookup"><span data-stu-id="9471e-103">Compiler Error CS0029</span></span>

<span data-ttu-id="9471e-104">无法将类型“type”隐式转换为“type”</span><span class="sxs-lookup"><span data-stu-id="9471e-104">Cannot implicitly convert type 'type' to 'type'</span></span>

 <span data-ttu-id="9471e-105">编译器要求显式转换。</span><span class="sxs-lookup"><span data-stu-id="9471e-105">The compiler requires an explicit conversion.</span></span> <span data-ttu-id="9471e-106">例如，可能需要将右值转换成与左值相同的类型。</span><span class="sxs-lookup"><span data-stu-id="9471e-106">For example, you may need to cast an r-value to be the same type as an l-value.</span></span> <span data-ttu-id="9471e-107">或者必须提供转换例程以支持某些运算符重载。</span><span class="sxs-lookup"><span data-stu-id="9471e-107">Or, you must provide conversion routines to support certain operator overloads.</span></span>

 <span data-ttu-id="9471e-108">在将某个类型的变量赋给其他类型的变量时必须进行转换。</span><span class="sxs-lookup"><span data-stu-id="9471e-108">Conversions must occur when assigning a variable of one type to a variable of a different type.</span></span> <span data-ttu-id="9471e-109">在不同类型的变量之间进行赋值时，编译器必须将赋值运算符右边的类型转换为赋值运算符左边的类型。</span><span class="sxs-lookup"><span data-stu-id="9471e-109">When making an assignment between variables of different types, the compiler must convert the type on the right-hand side of the assignment operator to the type on the left-hand side of the assignment operator.</span></span> <span data-ttu-id="9471e-110">以下面的代码为例：</span><span class="sxs-lookup"><span data-stu-id="9471e-110">Take the following the code:</span></span>

```csharp
int i = 50;
long lng = 100;
i = lng;
```

 <span data-ttu-id="9471e-111">`i = lng;` 进行赋值运算，但赋值运算符左右两边变量的数据类型不匹配。</span><span class="sxs-lookup"><span data-stu-id="9471e-111">`i = lng;` makes an assignment, but the data types of the variables on the left and right-hand side of the assignment operator don't match.</span></span> <span data-ttu-id="9471e-112">进行赋值前，编译器将变量 `lng`（类型为 long）隐式转换为 int。此为隐式转换，因为没有代码显式指示编译器执行此转换。</span><span class="sxs-lookup"><span data-stu-id="9471e-112">Before making the assignment the compiler is implicitly converting the variable `lng`, which is of type long, to an int. This is implicit because no code explicitly instructed the compiler to perform this conversion.</span></span> <span data-ttu-id="9471e-113">此代码的问题在于上述转换被视为收缩转换，但由于可能会丢失数据，所以编译器不允许进行隐式收缩转换。</span><span class="sxs-lookup"><span data-stu-id="9471e-113">The problem with this code is that this is considered a narrowing conversion, and the compiler does not allow implicit narrowing conversions because there could be a potential loss of data.</span></span>

 <span data-ttu-id="9471e-114">如果转换后的数据类型所占用的内存存储空间比转换前的数据类型所占用的少，则存在收缩转换。</span><span class="sxs-lookup"><span data-stu-id="9471e-114">A narrowing conversion exists when converting to a data type that occupies less storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="9471e-115">例如，将 long 类型转换为 int 类型可视为收缩转换。</span><span class="sxs-lookup"><span data-stu-id="9471e-115">For example, converting a long to an int would be considered a narrowing conversion.</span></span> <span data-ttu-id="9471e-116">long 类型占用 8 个字节的内存，而 int 类型只占用 4 个字节。</span><span class="sxs-lookup"><span data-stu-id="9471e-116">A long occupies 8 bytes of memory while an int occupies 4 bytes.</span></span> <span data-ttu-id="9471e-117">若要查看数据丢失如何发生，请考虑以下示例：</span><span class="sxs-lookup"><span data-stu-id="9471e-117">To see how data loss can occur, consider the following sample:</span></span>

```csharp
int i = 50;
long lng = 3147483647;
i = lng;
```

 <span data-ttu-id="9471e-118">变量 `lng` 现在包含的值因过大而无法存储在变量 `i` 中。</span><span class="sxs-lookup"><span data-stu-id="9471e-118">The variable `lng` now contains a value that cannot be stored in the variable `i` because it is too large.</span></span> <span data-ttu-id="9471e-119">如果要将该值转换为 int 类型，就会丢失一些数据，并且转换后的值不同于转换前的值。</span><span class="sxs-lookup"><span data-stu-id="9471e-119">If we were to convert this value to an int type we would be losing some of our data and the converted value would not be the same as the value before the conversion.</span></span>

 <span data-ttu-id="9471e-120">扩大转换与收缩转换相反。</span><span class="sxs-lookup"><span data-stu-id="9471e-120">A widening conversion would be the opposite of a narrowing conversion.</span></span> <span data-ttu-id="9471e-121">对于扩大转换，转换后的数据类型占用的内存存储空间比转换前的数据类型占用的多。</span><span class="sxs-lookup"><span data-stu-id="9471e-121">With widening conversions, we are converting to a data type that occupies more storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="9471e-122">下面是一个扩大转换示例：</span><span class="sxs-lookup"><span data-stu-id="9471e-122">Here is an example of a widening conversion:</span></span>

```csharp
int i = 50;
long lng = 100;
lng = i;
```

 <span data-ttu-id="9471e-123">请注意此代码示例和第一个示例之间的区别。</span><span class="sxs-lookup"><span data-stu-id="9471e-123">Notice the difference between this code sample and the first.</span></span> <span data-ttu-id="9471e-124">此示例中，变量 `lng` 位于赋值运算符的左边，所以它是赋值目标。</span><span class="sxs-lookup"><span data-stu-id="9471e-124">This time the variable `lng` is on the left-hand side of the assignment operator, so it is the target of our assignment.</span></span> <span data-ttu-id="9471e-125">在可以进行赋值前，编译器必须将变量 `i`（类型为 int）隐式转换为 long 类型。</span><span class="sxs-lookup"><span data-stu-id="9471e-125">Before the assignment can be made, the compiler must implicitly convert the variable `i`, which is of type int, to type long.</span></span> <span data-ttu-id="9471e-126">这是一个扩大转换，因为是从占用 4 个字节内存的类型 (int) 转换为占用 8 个字节内存的类型 (long)。</span><span class="sxs-lookup"><span data-stu-id="9471e-126">This is a widening conversion since we are converting from a type that occupies 4 bytes of memory (an int) to a type that occupies 8 bytes of memory (a long).</span></span> <span data-ttu-id="9471e-127">由于不会发生数据丢失，所以允许进行隐式扩大转换。</span><span class="sxs-lookup"><span data-stu-id="9471e-127">Implicit widening conversions are allowed because there is no potential loss of data.</span></span> <span data-ttu-id="9471e-128">任何可存储于 int 类型的值也可存储于 long 类型。</span><span class="sxs-lookup"><span data-stu-id="9471e-128">Any value that can be stored in an int can also be stored in a long.</span></span>

 <span data-ttu-id="9471e-129">由于不允许进行隐式收缩转换，因此为了能够编译此代码，需要显式转换数据类型。</span><span class="sxs-lookup"><span data-stu-id="9471e-129">We know that implicit narrowing conversions are not allowed, so to be able to compile this code we need to explicitly convert the data type.</span></span> <span data-ttu-id="9471e-130">使用强制转换完成显式转换。</span><span class="sxs-lookup"><span data-stu-id="9471e-130">Explicit conversions are done using casting.</span></span> <span data-ttu-id="9471e-131">强制转换是 C# 中用来描述将一种数据类型转换为另一种数据类型的术语。</span><span class="sxs-lookup"><span data-stu-id="9471e-131">Casting is the term used in C# to describe converting one data type to another.</span></span> <span data-ttu-id="9471e-132">若要编译代码，需使用以下语法：</span><span class="sxs-lookup"><span data-stu-id="9471e-132">To get the code to compile we would need to use the following syntax:</span></span>

```csharp
int i = 50;
long lng = 100;
i = (int) lng;   // Cast to int.
```

 <span data-ttu-id="9471e-133">第三行代码告知编译器在进行赋值前，将变量 `lng`（类型为 long）显式转换为 int 类型。</span><span class="sxs-lookup"><span data-stu-id="9471e-133">The third line of code tells the compiler to explicitly convert the variable `lng`, which is of type long, to an int before making the assignment.</span></span> <span data-ttu-id="9471e-134">切记，使用收缩转换可能会丢失数据。</span><span class="sxs-lookup"><span data-stu-id="9471e-134">Remember that with a narrowing conversion, there is a potential loss of data.</span></span> <span data-ttu-id="9471e-135">应小心使用收缩转换，即使可以编译代码，也可能会在运行时获得意外结果。</span><span class="sxs-lookup"><span data-stu-id="9471e-135">Narrowing conversions should be used with caution and even though the code will compile you may get unexpected results at run-time.</span></span>

 <span data-ttu-id="9471e-136">此讨论只针对值类型。</span><span class="sxs-lookup"><span data-stu-id="9471e-136">This discussion has only been for value types.</span></span> <span data-ttu-id="9471e-137">使用值类型就是直接使用存储在变量中的数据。</span><span class="sxs-lookup"><span data-stu-id="9471e-137">When working with value types you work directly with the data stored in the variable.</span></span> <span data-ttu-id="9471e-138">但是，.NET 也具有引用类型。</span><span class="sxs-lookup"><span data-stu-id="9471e-138">However, .NET also has reference types.</span></span> <span data-ttu-id="9471e-139">使用引用类型就是使用对变量的引用，而不是使用实际数据。</span><span class="sxs-lookup"><span data-stu-id="9471e-139">When working with reference types you are working with a reference to a variable, not the actual data.</span></span> <span data-ttu-id="9471e-140">引用类型的示例包括类、接口和数组。</span><span class="sxs-lookup"><span data-stu-id="9471e-140">Examples of reference types would be classes, interfaces and arrays.</span></span> <span data-ttu-id="9471e-141">不能隐式或显式地将一个引用类型转换为其他引用类型，除非编译器允许特定的转换或可以实现相应的转换运算符。</span><span class="sxs-lookup"><span data-stu-id="9471e-141">You cannot implicitly or explicitly convert one reference type to another unless the compiler allows the specific conversion or the appropriate conversion operators are implemented.</span></span>

 <span data-ttu-id="9471e-142">以下示例生成 CS0029：</span><span class="sxs-lookup"><span data-stu-id="9471e-142">The following sample generates CS0029:</span></span>

```csharp
// CS0029.cs
public class MyInt
{
    private int x = 0;

    // Uncomment this conversion routine to resolve CS0029.
    /*
    public static implicit operator int(MyInt i)
    {
        return i.x;
    }
    */

    public static void Main()
    {
        var myInt = new MyInt();
        int i = myInt; // CS0029
    }
}
```

## <a name="see-also"></a><span data-ttu-id="9471e-143">另请参阅</span><span class="sxs-lookup"><span data-stu-id="9471e-143">See also</span></span>

- [<span data-ttu-id="9471e-144">用户定义转换运算符</span><span class="sxs-lookup"><span data-stu-id="9471e-144">User-defined conversion operators</span></span>](../operators/user-defined-conversion-operators.md)
