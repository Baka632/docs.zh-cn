---
description: 编译器错误 CS1612
title: 编译器错误 CS1612
ms.date: 07/20/2015
f1_keywords:
- CS1612
helpviewer_keywords:
- CS1612
ms.assetid: ef5db985-030a-4f15-b53f-e92c9297c6a3
ms.openlocfilehash: 2e23ebacc472da318c85ac0ab2a7b02d96435afe
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/24/2020
ms.locfileid: "91171528"
---
# <a name="compiler-error-cs1612"></a><span data-ttu-id="a026d-103">编译器错误 CS1612</span><span class="sxs-lookup"><span data-stu-id="a026d-103">Compiler Error CS1612</span></span>

<span data-ttu-id="a026d-104">无法修改“expression”的返回值，因为它不是变量</span><span class="sxs-lookup"><span data-stu-id="a026d-104">Cannot modify the return value of 'expression' because it is not a variable</span></span>  
  
 <span data-ttu-id="a026d-105">尝试修改某一值类型，该值类型作为中间表达式的结果生成但不存储于变量中。</span><span class="sxs-lookup"><span data-stu-id="a026d-105">An attempt was made to modify a value type that is produced as the result of an intermediate expression but is not stored in a variable.</span></span> <span data-ttu-id="a026d-106">如果尝试直接修改泛型集合中的结构，则会发生此错误，如下例所示：</span><span class="sxs-lookup"><span data-stu-id="a026d-106">This error can occur when you attempt to directly modify a struct in a generic collection, as shown in the following example:</span></span>  
  
```csharp  
List<myStruct> list = {…};  
list[0].Name = "MyStruct42"; //CS1612  
```  
  
 <span data-ttu-id="a026d-107">若要修改结构，请首先将其赋给局部变量，修改该变量，然后将变量赋回集合中的项。</span><span class="sxs-lookup"><span data-stu-id="a026d-107">To modify the struct, first assign it to a local variable, modify the variable, then assign the variable back to the item in the collection.</span></span>  
  
```csharp  
List<myStruct> list = {…};  
MyStruct ms = list[0];  
ms.Name = "MyStruct42";  
list[0] = ms;  
```  
  
 <span data-ttu-id="a026d-108">之所以会发生此错误，原因是在赋值时复制了值类型。</span><span class="sxs-lookup"><span data-stu-id="a026d-108">This error occurs because value types are copied on assignment.</span></span> <span data-ttu-id="a026d-109">在从属性或索引器中检索值类型时，所获取的是对象的副本，而不是对于对象本身的引用。</span><span class="sxs-lookup"><span data-stu-id="a026d-109">When you retrieve a value type from a property or indexer, you are getting a copy of the object, not a reference to the object itself.</span></span> <span data-ttu-id="a026d-110">返回的副本不由属性或索引器存储，因为它们实际上是方法，而不是存储位置（变量）。</span><span class="sxs-lookup"><span data-stu-id="a026d-110">The copy that is returned is not stored by the property or indexer because they are actually methods, not storage locations (variables).</span></span> <span data-ttu-id="a026d-111">必须将副本存储在声明的变量中，然后才能对其进行修改。</span><span class="sxs-lookup"><span data-stu-id="a026d-111">You must store the copy into a variable that you declare before you can modify it.</span></span>  
  
 <span data-ttu-id="a026d-112">引用类型不会发生此错误，因为在这种情况下，属性或索引器将返回对现有对象的引用，该对象是存储位置。</span><span class="sxs-lookup"><span data-stu-id="a026d-112">The error does not occur with reference types because a property or indexer in that case returns a reference to an existing object, which is a storage location.</span></span>  
  
 <span data-ttu-id="a026d-113">如果是在定义类或结构，则修改属性声明，提供对结构成员的访问，即可解决此错误。</span><span class="sxs-lookup"><span data-stu-id="a026d-113">If you are defining the class or struct, you can resolve this error by modifying your property declaration to provide access to the members of a struct.</span></span> <span data-ttu-id="a026d-114">如果是在编写客户端代码，则创建你自己的结构实例，修改其字段，然后将整个结构赋回给该属性，即可解决此错误。</span><span class="sxs-lookup"><span data-stu-id="a026d-114">If you are writing client code, you can resolve the error by creating your own instance of the struct, modifying its fields, and then assigning the entire struct back to the property.</span></span> <span data-ttu-id="a026d-115">第三种替代方式是，可以将结构更改为类。</span><span class="sxs-lookup"><span data-stu-id="a026d-115">As a third alternative, you can change your struct to a class.</span></span>  
  
## <a name="example"></a><span data-ttu-id="a026d-116">示例</span><span class="sxs-lookup"><span data-stu-id="a026d-116">Example</span></span>  

 <span data-ttu-id="a026d-117">尝试通过将返回整个结构的封闭类中的属性访问结构成员时，也会出现 CS1612，如下面的示例中所示：</span><span class="sxs-lookup"><span data-stu-id="a026d-117">CS1612 also occurs when you attempt to access the member of a struct through a property on an enclosing class that is returning the entire struct, as shown in the following example:</span></span>  
  
```csharp  
// CS1612.cs  
using System;  
  
public struct MyStruct  
{  
    public int Width;  
}  
  
public class ListView  
{  
    MyStruct ms;  
    public MyStruct Size  
    {  
        get { return ms; }  
        set { ms = value; }  
    }  
}  
  
public class MyClass  
{  
    public MyClass()  
    {  
        ListView lvi;  
        lvi = new ListView();  
        lvi.Size.Width = 5; // CS1612  
  
        // You can use the following lines instead.  
        // MyStruct ms;  
        // ms.Width = 5;  
        // lvi.Size = ms;
    }  
  
    public static void Main()
    {  
        MyClass mc = new MyClass();  
        // Keep the console open in debug mode.  
        Console.WriteLine("Press any key to exit.");  
        Console.ReadKey();
    }  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="a026d-118">请参阅</span><span class="sxs-lookup"><span data-stu-id="a026d-118">See also</span></span>

- [<span data-ttu-id="a026d-119">结构类型</span><span class="sxs-lookup"><span data-stu-id="a026d-119">Structure types</span></span>](../builtin-types/struct.md)
- [<span data-ttu-id="a026d-120">值类型</span><span class="sxs-lookup"><span data-stu-id="a026d-120">Value types</span></span>](../builtin-types/value-types.md)
- [<span data-ttu-id="a026d-121">引用类型</span><span class="sxs-lookup"><span data-stu-id="a026d-121">Reference types</span></span>](../keywords/reference-types.md)
