---
title: 可为 null 的引用类型 - C# 引用
description: 了解 C# 中可为 null 的引用类型及其使用方法
ms.date: 04/06/2020
ms.openlocfilehash: d961af9ba3b4776e6b4ec3eeea5392fb0d0394ce
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/18/2020
ms.locfileid: "94822420"
---
# <a name="nullable-reference-types-c-reference"></a><span data-ttu-id="13aa0-103">可为 null 的引用类型（C# 引用）</span><span class="sxs-lookup"><span data-stu-id="13aa0-103">Nullable reference types (C# reference)</span></span>

> [!NOTE]
> <span data-ttu-id="13aa0-104">本文介绍可为 null 的引用类型。</span><span class="sxs-lookup"><span data-stu-id="13aa0-104">This article covers nullable reference types.</span></span> <span data-ttu-id="13aa0-105">还可以声明[可为 null 的值类型](nullable-value-types.md)。</span><span class="sxs-lookup"><span data-stu-id="13aa0-105">You can also declare [nullable value types](nullable-value-types.md).</span></span>

<span data-ttu-id="13aa0-106">由于在可为 null 的感知上下文选择加入了代码，从 C#8.0 开始，可以使用可为 null 的引用类型  。</span><span class="sxs-lookup"><span data-stu-id="13aa0-106">Nullable reference types are available beginning with C# 8.0, in code that has opted in to a *nullable aware context*.</span></span> <span data-ttu-id="13aa0-107">可为 null 的引用类型、null 静态分析警告和 [null 包容运算符](../operators/null-forgiving.md)是可选的语言功能。</span><span class="sxs-lookup"><span data-stu-id="13aa0-107">Nullable reference types, the null static analysis warnings, and the [null-forgiving operator](../operators/null-forgiving.md) are optional language features.</span></span> <span data-ttu-id="13aa0-108">默认情况下，所有功能都将关闭。</span><span class="sxs-lookup"><span data-stu-id="13aa0-108">All are turned off by default.</span></span> <span data-ttu-id="13aa0-109">可为 null 的上下文在项目级使用生成设置进行控制，或在代码中使用 pragmas 进行控制  。</span><span class="sxs-lookup"><span data-stu-id="13aa0-109">A *nullable context* is controlled at the project level using build settings, or in code using pragmas.</span></span>

 <span data-ttu-id="13aa0-110">在可为 null 的感知上下文中：</span><span class="sxs-lookup"><span data-stu-id="13aa0-110">In a nullable aware context:</span></span>

- <span data-ttu-id="13aa0-111">引用类型 `T` 的变量必须用非 null 值进行初始化，并且不能为其分配可能为 `null` 的值。</span><span class="sxs-lookup"><span data-stu-id="13aa0-111">A variable of a reference type `T` must be initialized with non-null, and may never be assigned a value that may be `null`.</span></span>
- <span data-ttu-id="13aa0-112">引用类型 `T?` 的变量可以用 `null` 进行初始化，也可以分配 `null`，但在取消引用之前必须对照 `null` 进行检查。</span><span class="sxs-lookup"><span data-stu-id="13aa0-112">A variable of a reference type `T?` may be initialized with `null` or assigned `null`, but is required to be checked against `null` before de-referencing.</span></span>
- <span data-ttu-id="13aa0-113">类型为 `T?` 的变量 `m` 在应用 null 包容运算符时被认为是非空的，如 `m!` 中所示。</span><span class="sxs-lookup"><span data-stu-id="13aa0-113">A variable `m` of type `T?` is considered to be non-null when you apply the null-forgiving operator, as in `m!`.</span></span>

<span data-ttu-id="13aa0-114">不可为 null 的引用类型 `T` 和可为 null 的引用类型 `T?` 之间的区别按照编译器对上述规则的解释强制执行的。</span><span class="sxs-lookup"><span data-stu-id="13aa0-114">The distinctions between a non-nullable reference type `T` and a nullable reference type `T?` are enforced by the compiler's interpretation of the preceding rules.</span></span> <span data-ttu-id="13aa0-115">类型为 `T` 的变量和类型为 `T?` 的变量由相同的 .NET 类型表示。</span><span class="sxs-lookup"><span data-stu-id="13aa0-115">A variable of type `T` and a variable of type `T?` are represented by the same .NET type.</span></span> <span data-ttu-id="13aa0-116">下面的示例声明了一个不可为 null 的字符串和一个可为 null 的字符串，然后使用 null 包容运算符将一个值分配给不可为 null 的字符串：</span><span class="sxs-lookup"><span data-stu-id="13aa0-116">The following example declares a non-nullable string and a nullable string, and then uses the null-forgiving operator to assign a value to a non-nullable string:</span></span>

:::code language="csharp" source="snippets/shared/NullableReferenceTypes.cs" id="SnippetCoreSyntax":::

<span data-ttu-id="13aa0-117">变量 `notNull` 和 `nullable` 都由 <xref:System.String> 类型表示。</span><span class="sxs-lookup"><span data-stu-id="13aa0-117">The variables `notNull` and `nullable` are both represented by the <xref:System.String> type.</span></span> <span data-ttu-id="13aa0-118">因为不可为 null 的类型和可为 null 的类型都存储为相同的类型，所以有几个位置不允许使用可为 null 的引用类型。</span><span class="sxs-lookup"><span data-stu-id="13aa0-118">Because the non-nullable and nullable types are both stored as the same type, there are several locations where using a nullable reference type isn't allowed.</span></span> <span data-ttu-id="13aa0-119">通常，可为 null 的引用类型不能用作基类或实现的接口。</span><span class="sxs-lookup"><span data-stu-id="13aa0-119">In general, a nullable reference type can't be used as a base class or implemented interface.</span></span> <span data-ttu-id="13aa0-120">可为 null 的引用类型不能用于任何对象创建或类型测试表达式。</span><span class="sxs-lookup"><span data-stu-id="13aa0-120">A nullable reference type can't be used in any object creation or type testing expression.</span></span> <span data-ttu-id="13aa0-121">可为 null 的引用类型不能是成员访问表达式的类型。</span><span class="sxs-lookup"><span data-stu-id="13aa0-121">A nullable reference type can't be the type of a member access expression.</span></span> <span data-ttu-id="13aa0-122">下面的示例说明了这些构造：</span><span class="sxs-lookup"><span data-stu-id="13aa0-122">The following examples show these constructs:</span></span>

```csharp
public MyClass : System.Object? // not allowed
{
}

var nullEmpty = System.String?.Empty; // Not allowed
var maybeObject = new object?(); // Not allowed
try
{
    if (thing is string? nullableString) // not allowed
        Console.WriteLine(nullableString);
} catch (Exception? e) // Not Allowed
{
    Console.WriteLine("error");
}
```

## <a name="nullable-references-and-static-analysis"></a><span data-ttu-id="13aa0-123">可为 null 的引用和静态分析</span><span class="sxs-lookup"><span data-stu-id="13aa0-123">Nullable references and static analysis</span></span>

<span data-ttu-id="13aa0-124">上一部分中的示例说明了可为 null 的引用类型的性质。</span><span class="sxs-lookup"><span data-stu-id="13aa0-124">The examples in the previous section illustrate the nature of nullable reference types.</span></span> <span data-ttu-id="13aa0-125">可为 null 的引用类型不是新的类类型，而是对现有引用类型的注释。</span><span class="sxs-lookup"><span data-stu-id="13aa0-125">Nullable reference types aren't new class types, but rather annotations on existing reference types.</span></span> <span data-ttu-id="13aa0-126">编译器使用这些注释来帮助你查找代码中潜在的 null 引用错误。</span><span class="sxs-lookup"><span data-stu-id="13aa0-126">The compiler uses those annotations to help you find potential null reference errors in your code.</span></span> <span data-ttu-id="13aa0-127">不可为 null 的引用类型和可为 null 的引用类型在运行时没有区别。</span><span class="sxs-lookup"><span data-stu-id="13aa0-127">There's no runtime difference between a non-nullable reference type and a nullable reference type.</span></span> <span data-ttu-id="13aa0-128">编译器不会为不可为 null 的引用类型添加任何运行时检查。</span><span class="sxs-lookup"><span data-stu-id="13aa0-128">The compiler doesn't add any runtime checking for non-nullable reference types.</span></span> <span data-ttu-id="13aa0-129">这有利于编译时分析。</span><span class="sxs-lookup"><span data-stu-id="13aa0-129">The benefits are in the compile-time analysis.</span></span> <span data-ttu-id="13aa0-130">编译器将生成警告，帮助你查找和修复代码中潜在的 null 错误。</span><span class="sxs-lookup"><span data-stu-id="13aa0-130">The compiler generates warnings that help you find and fix potential null errors in your code.</span></span> <span data-ttu-id="13aa0-131">你需声明意向，如果代码违反该意向，编译器会发出警告。</span><span class="sxs-lookup"><span data-stu-id="13aa0-131">You declare your intent, and the compiler warns you when your code violates that intent.</span></span>

<span data-ttu-id="13aa0-132">在可为 null 的上下文中，编译器对任何引用类型的变量（可为 null 的和不可为 null 的）执行静态分析。</span><span class="sxs-lookup"><span data-stu-id="13aa0-132">In a nullable enabled context, the compiler performs static analysis on variables of any reference type, both nullable and non-nullable.</span></span> <span data-ttu-id="13aa0-133">编译器跟踪每个引用变量的 null 状态，如“非 null”和“可能为 null”   。</span><span class="sxs-lookup"><span data-stu-id="13aa0-133">The compiler tracks the null state of each reference variable as either *not null* or *maybe null*.</span></span> <span data-ttu-id="13aa0-134">不可为 null 的引用的默认状态为“非 null”  。</span><span class="sxs-lookup"><span data-stu-id="13aa0-134">The default state of a non-nullable reference is *not null*.</span></span> <span data-ttu-id="13aa0-135">可为 null 的引用的默认状态为“可能为 null”  。</span><span class="sxs-lookup"><span data-stu-id="13aa0-135">The default state of a nullable reference is *maybe null*.</span></span>

<span data-ttu-id="13aa0-136">不可为 null 的引用类型在取消引用时应该始终是安全的，因为它们的 null 状态是“非 null”  。</span><span class="sxs-lookup"><span data-stu-id="13aa0-136">Non-nullable reference types should always be safe to dereference because their null state is *not null*.</span></span> <span data-ttu-id="13aa0-137">若强制执行该规则，如果不可为 null 的引用类型没有初始化为非 null 值，编译器将发出警告。</span><span class="sxs-lookup"><span data-stu-id="13aa0-137">To enforce that rule, the compiler issues warnings if a non-nullable reference type isn't initialized to a non-null value.</span></span> <span data-ttu-id="13aa0-138">必须在声明的位置分配局部变量。</span><span class="sxs-lookup"><span data-stu-id="13aa0-138">Local variables must be assigned where they're declared.</span></span> <span data-ttu-id="13aa0-139">每个构造函数都必须分配每个字段，无论是在其主体、被调用的构造函数还是使用字段初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="13aa0-139">Every constructor must assign every field, either in its body, a called constructor, or using a field initializer.</span></span> <span data-ttu-id="13aa0-140">如果将不可为 null 的引用分配给状态为“可能为 null”的引用，编译器将发出警告  。</span><span class="sxs-lookup"><span data-stu-id="13aa0-140">The compiler issues warnings if a non-nullable reference is assigned to a reference whose state is *maybe null*.</span></span> <span data-ttu-id="13aa0-141">但是，由于不可为 null 的引用是“非 null”，因此在取消引用这些变量时不会发出警告  。</span><span class="sxs-lookup"><span data-stu-id="13aa0-141">However, because a non-nullable reference is *not null*, no warnings are issued when those variables are de-referenced.</span></span>

<span data-ttu-id="13aa0-142">可为 null 的引用类型可以进行初始化或分配给 `null`。</span><span class="sxs-lookup"><span data-stu-id="13aa0-142">Nullable reference types may be initialized or assigned to `null`.</span></span> <span data-ttu-id="13aa0-143">因此，静态分析必须在取消对变量的引用之前确定该变量为“非 null”  。</span><span class="sxs-lookup"><span data-stu-id="13aa0-143">Therefore, static analysis must determine that a variable is *not null* before it's dereferenced.</span></span> <span data-ttu-id="13aa0-144">如果可为 null 的引用被确定为“可能为 null”，则不能将其分配给不可为 null 的引用变量  。</span><span class="sxs-lookup"><span data-stu-id="13aa0-144">If a nullable reference is determined to be *maybe null*, it can't be assigned to a non-nullable reference variable.</span></span> <span data-ttu-id="13aa0-145">以下类显示了这些警告的示例：</span><span class="sxs-lookup"><span data-stu-id="13aa0-145">The following class shows examples of these warnings:</span></span>

:::code language="csharp" source="snippets/shared/NullableReferenceTypes.cs" id="SnippetClassWithNullable":::

<span data-ttu-id="13aa0-146">以下代码段显示了编译器在使用此类时发出警告的位置：</span><span class="sxs-lookup"><span data-stu-id="13aa0-146">The following snippet shows where the compiler emits warnings when using this class:</span></span>

:::code language="csharp" source="snippets/shared/NullableReferenceTypes.cs" id="SnippetLocalWarnings":::

<span data-ttu-id="13aa0-147">前面的示例演示编译器的静态分析，以确定引用变量的 null 状态。</span><span class="sxs-lookup"><span data-stu-id="13aa0-147">The preceding examples demonstrate the compiler's static analysis to determine the null state of reference variables.</span></span> <span data-ttu-id="13aa0-148">编译器对 null 检查和分配应用语言规则以通知其分析。</span><span class="sxs-lookup"><span data-stu-id="13aa0-148">The compiler applies language rules for null checks and assignments to inform its analysis.</span></span>  <span data-ttu-id="13aa0-149">编译器无法对方法或属性的语义进行假设。</span><span class="sxs-lookup"><span data-stu-id="13aa0-149">The compiler can't make assumptions about the semantics of methods or properties.</span></span> <span data-ttu-id="13aa0-150">如果调用执行 null 检查的方法，则编译器无法得知这些方法会影响变量的 null 状态。</span><span class="sxs-lookup"><span data-stu-id="13aa0-150">If you call methods that perform null checks, the compiler can't know those methods affect a variable's null state.</span></span> <span data-ttu-id="13aa0-151">可以将许多属性添加到 API，以通知编译器有关参数和返回值的语义。</span><span class="sxs-lookup"><span data-stu-id="13aa0-151">There are a number of attributes you can add to your APIs to inform the compiler about the semantics of arguments and return values.</span></span> <span data-ttu-id="13aa0-152">这些属性已应用于 .NET Core 库中的许多常见 API。</span><span class="sxs-lookup"><span data-stu-id="13aa0-152">These attributes have been applied to many common APIs in the .NET Core libraries.</span></span> <span data-ttu-id="13aa0-153">例如，<xref:System.String.IsNullOrEmpty%2A> 已经更新，编译器正确地将该方法解释为 null 检查。</span><span class="sxs-lookup"><span data-stu-id="13aa0-153">For example, <xref:System.String.IsNullOrEmpty%2A> has been updated, and the compiler correctly interprets that method as a null check.</span></span> <span data-ttu-id="13aa0-154">有关应用于 null 状态静态分析的属性的更多信息，请参阅[可为 null 属性](../attributes/nullable-analysis.md)的文章。</span><span class="sxs-lookup"><span data-stu-id="13aa0-154">For more information about the attributes that apply to null state static analysis, see the article on [Nullable attributes](../attributes/nullable-analysis.md).</span></span>

## <a name="setting-the-nullable-context"></a><span data-ttu-id="13aa0-155">设置可为 null 的上下文</span><span class="sxs-lookup"><span data-stu-id="13aa0-155">Setting the nullable context</span></span>

<span data-ttu-id="13aa0-156">可以通过两种方式控制可为 null 的上下文。</span><span class="sxs-lookup"><span data-stu-id="13aa0-156">There are two ways to control the nullable context.</span></span> <span data-ttu-id="13aa0-157">在项目级别，可以添加 `<Nullable>enable</Nullable>` 项目设置。</span><span class="sxs-lookup"><span data-stu-id="13aa0-157">At the project level, you can add the `<Nullable>enable</Nullable>` project setting.</span></span> <span data-ttu-id="13aa0-158">在单个 C# 源文件中，可以添加 `#nullable enable` 来启用可为 null 的上下文。</span><span class="sxs-lookup"><span data-stu-id="13aa0-158">In a single C# source file, you can add the `#nullable enable` pragma to enable the nullable context.</span></span> <span data-ttu-id="13aa0-159">请参阅关于[设置可为 null 策略](../../nullable-migration-strategies.md)的文章。</span><span class="sxs-lookup"><span data-stu-id="13aa0-159">See the article on [setting a nullable strategy](../../nullable-migration-strategies.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="13aa0-160">C# 语言规范</span><span class="sxs-lookup"><span data-stu-id="13aa0-160">C# language specification</span></span>

<span data-ttu-id="13aa0-161">有关详细信息，请参阅 [C# 语言规范](~/_csharplang/spec/introduction.md)的以下建议：</span><span class="sxs-lookup"><span data-stu-id="13aa0-161">For more information, see the following proposals for the [C# language specification](~/_csharplang/spec/introduction.md):</span></span>

- [<span data-ttu-id="13aa0-162">可为空引用类型</span><span class="sxs-lookup"><span data-stu-id="13aa0-162">Nullable reference types</span></span>](~/_csharplang/proposals/csharp-8.0/nullable-reference-types.md)
- [<span data-ttu-id="13aa0-163">可为空引用类型规范草案</span><span class="sxs-lookup"><span data-stu-id="13aa0-163">Draft nullable reference types specification</span></span>](~/_csharplang/proposals/csharp-9.0/nullable-reference-types-specification.md)

## <a name="see-also"></a><span data-ttu-id="13aa0-164">请参阅</span><span class="sxs-lookup"><span data-stu-id="13aa0-164">See also</span></span>

- [<span data-ttu-id="13aa0-165">C# 参考</span><span class="sxs-lookup"><span data-stu-id="13aa0-165">C# reference</span></span>](../index.md)
- [<span data-ttu-id="13aa0-166">可以为 null 的值类型</span><span class="sxs-lookup"><span data-stu-id="13aa0-166">Nullable value types</span></span>](nullable-value-types.md)
