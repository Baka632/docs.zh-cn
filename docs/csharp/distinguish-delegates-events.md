---
title: 委托和事件
description: 了解委托和事件的区别，以及何时使用 .NET Core 的这两种功能。
ms.date: 06/20/2016
ms.technology: csharp-fundamentals
ms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911
ms.openlocfilehash: 193a9b0fe0e0c36deb6552449c92135057412225
ms.sourcegitcommit: b1f4756120deaecb8b554477bb040620f69a4209
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/03/2020
ms.locfileid: "89414664"
---
# <a name="distinguishing-delegates-and-events"></a><span data-ttu-id="93ef5-103">区别委托和事件</span><span class="sxs-lookup"><span data-stu-id="93ef5-103">Distinguishing Delegates and Events</span></span>

[<span data-ttu-id="93ef5-104">上一篇</span><span class="sxs-lookup"><span data-stu-id="93ef5-104">Previous</span></span>](modern-events.md)

<span data-ttu-id="93ef5-105">对不熟悉 .NET Core 平台的开发人员而言，在基于 `delegates` 的设计和基于 `events` 的设计之间做出选择是困难的。</span><span class="sxs-lookup"><span data-stu-id="93ef5-105">Developers that are new to the .NET Core platform often struggle when deciding between a design based on `delegates` and a design based on `events`.</span></span> <span data-ttu-id="93ef5-106">委托或事件的选择通常比较难，因为这两种语言功能很相似。</span><span class="sxs-lookup"><span data-stu-id="93ef5-106">The choice of delegates or events is often difficult, because the two language features are similar.</span></span> <span data-ttu-id="93ef5-107">事件甚至是使用委托的语言支持构建的。</span><span class="sxs-lookup"><span data-stu-id="93ef5-107">Events are even built using the language support for delegates.</span></span>

<span data-ttu-id="93ef5-108">它们都提供了一个后期绑定方案：在该方案中，组件通过调用仅在运行时识别的方法进行通信。</span><span class="sxs-lookup"><span data-stu-id="93ef5-108">They both offer a late binding scenario: they enable scenarios where a component communicates by calling a method that is only known at runtime.</span></span> <span data-ttu-id="93ef5-109">它们都支持单个和多个订阅服务器方法。</span><span class="sxs-lookup"><span data-stu-id="93ef5-109">They both support single and multiple subscriber methods.</span></span> <span data-ttu-id="93ef5-110">这称为单播和多播支持。</span><span class="sxs-lookup"><span data-stu-id="93ef5-110">You may find this referred to as singlecast and multicast support.</span></span> <span data-ttu-id="93ef5-111">二者均支持用于添加和删除处理程序的类似语法。</span><span class="sxs-lookup"><span data-stu-id="93ef5-111">They both support similar syntax for adding and removing handlers.</span></span> <span data-ttu-id="93ef5-112">最后，引发事件和调用委托使用完全相同的方法调用语法。</span><span class="sxs-lookup"><span data-stu-id="93ef5-112">Finally, raising an event and calling a delegate use exactly the same method call syntax.</span></span> <span data-ttu-id="93ef5-113">它们甚至都支持与 `?.` 运算符一起使用的相同的 `Invoke()` 方法语法。</span><span class="sxs-lookup"><span data-stu-id="93ef5-113">They even both support the same `Invoke()` method syntax for use with the `?.` operator.</span></span>

<span data-ttu-id="93ef5-114">鉴于所有这些相似之处，很难确定何时使用何种语法。</span><span class="sxs-lookup"><span data-stu-id="93ef5-114">With all those similarities, it is easy to have trouble determining when to use which.</span></span>

## <a name="listening-to-events-is-optional"></a><span data-ttu-id="93ef5-115">侦听事件是可选的</span><span class="sxs-lookup"><span data-stu-id="93ef5-115">Listening to Events is Optional</span></span>

<span data-ttu-id="93ef5-116">在确定要使用的语言功能时，最重要的考虑因素为是否必须具有附加的订阅服务器。</span><span class="sxs-lookup"><span data-stu-id="93ef5-116">The most important consideration in determining which language feature to use is whether or not there must be an attached subscriber.</span></span> <span data-ttu-id="93ef5-117">如果代码必须调用订阅服务器提供的代码，则在需要实现回调时，应使用基于委托的设计。</span><span class="sxs-lookup"><span data-stu-id="93ef5-117">If your code must call the code supplied by the subscriber, you should use a design based on delegates when you need to implement callback.</span></span> <span data-ttu-id="93ef5-118">如果你的代码在不调用任何订阅服务器的情况下可完成其所有工作，则应使用基于事件的设计。</span><span class="sxs-lookup"><span data-stu-id="93ef5-118">If your code can complete all its work without calling any subscribers, you should use a design based on events.</span></span>

<span data-ttu-id="93ef5-119">请考虑本部分中生成的示例。</span><span class="sxs-lookup"><span data-stu-id="93ef5-119">Consider the examples built during this section.</span></span> <span data-ttu-id="93ef5-120">必须为使用 `List.Sort()` 生成的代码提供 comparer 函数，以便对元素进行正确排序。</span><span class="sxs-lookup"><span data-stu-id="93ef5-120">The code you built using `List.Sort()` must be given a comparer function in order to properly sort the elements.</span></span> <span data-ttu-id="93ef5-121">必须与委托一起提供 LINQ 查询，以便确定要返回的元素。</span><span class="sxs-lookup"><span data-stu-id="93ef5-121">LINQ queries must be supplied with delegates in order to determine what elements to return.</span></span> <span data-ttu-id="93ef5-122">二者均使用与委托一起生成的设计。</span><span class="sxs-lookup"><span data-stu-id="93ef5-122">Both used a design built with delegates.</span></span>

<span data-ttu-id="93ef5-123">请考虑 `Progress` 事件。</span><span class="sxs-lookup"><span data-stu-id="93ef5-123">Consider the `Progress` event.</span></span> <span data-ttu-id="93ef5-124">它会报告任务进度。</span><span class="sxs-lookup"><span data-stu-id="93ef5-124">It reports progress on a task.</span></span>
<span data-ttu-id="93ef5-125">无论是否具有侦听器，该任务将继续进行。</span><span class="sxs-lookup"><span data-stu-id="93ef5-125">The task continues to proceed whether or not there are any listeners.</span></span>
<span data-ttu-id="93ef5-126">`FileSearcher` 是另一个示例。</span><span class="sxs-lookup"><span data-stu-id="93ef5-126">The `FileSearcher` is another example.</span></span> <span data-ttu-id="93ef5-127">即使没有附加事件订阅服务器，它仍将搜索和查找已找到的所有文件。</span><span class="sxs-lookup"><span data-stu-id="93ef5-127">It would still search and find all the files that were sought, even with no event subscribers attached.</span></span>
<span data-ttu-id="93ef5-128">即使没有任何订阅服务器侦听事件，UX 控件仍正常工作。</span><span class="sxs-lookup"><span data-stu-id="93ef5-128">UX controls still work correctly, even when there are no subscribers listening to the events.</span></span> <span data-ttu-id="93ef5-129">它们都使用基于事件的设计。</span><span class="sxs-lookup"><span data-stu-id="93ef5-129">They both use designs based on events.</span></span>

## <a name="return-values-require-delegates"></a><span data-ttu-id="93ef5-130">返回值需要委托</span><span class="sxs-lookup"><span data-stu-id="93ef5-130">Return Values Require Delegates</span></span>

<span data-ttu-id="93ef5-131">另一个注意事项是委托方法所需的方法原型。</span><span class="sxs-lookup"><span data-stu-id="93ef5-131">Another consideration is the method prototype you would want for your delegate method.</span></span> <span data-ttu-id="93ef5-132">如你所见，用于事件的委托均具有无效的返回类型。</span><span class="sxs-lookup"><span data-stu-id="93ef5-132">As you've seen, the delegates used for events all have a void return type.</span></span> <span data-ttu-id="93ef5-133">你还看到，存在创建事件处理程序的惯用语，该事件处理程序通过修改事件参数对象的属性将信息传回到事件源。</span><span class="sxs-lookup"><span data-stu-id="93ef5-133">You've also seen that there are idioms to create event handlers that do pass information back to event sources through modifying properties of the event argument object.</span></span> <span data-ttu-id="93ef5-134">虽然这些惯用语可发挥作用，但它们不像从方法返回值那样自然。</span><span class="sxs-lookup"><span data-stu-id="93ef5-134">While these idioms do work, they are not as natural as returning a value from a method.</span></span>

<span data-ttu-id="93ef5-135">请注意，这两种试探法可能经常同时存在：如果委托方法返回值，则可能会以某种方式影响算法。</span><span class="sxs-lookup"><span data-stu-id="93ef5-135">Notice that these two heuristics may often both be present: If your delegate method returns a value, it will likely impact the algorithm in some way.</span></span>

## <a name="events-have-private-invocation"></a><span data-ttu-id="93ef5-136">事件具有专用调用</span><span class="sxs-lookup"><span data-stu-id="93ef5-136">Events Have Private Invocation</span></span>

<span data-ttu-id="93ef5-137">包含事件的类以外的类只能添加和删除事件侦听器；只有包含事件的类才能调用事件。</span><span class="sxs-lookup"><span data-stu-id="93ef5-137">Classes other than the one in which an event is contained can only add and remove event listeners; only the class containing the event can invoke the event.</span></span> <span data-ttu-id="93ef5-138">事件通常是公共类成员。</span><span class="sxs-lookup"><span data-stu-id="93ef5-138">Events are typically public class members.</span></span>
<span data-ttu-id="93ef5-139">相比之下，委托通常作为参数传递，并存储为私有类成员（如果它们全部存储）。</span><span class="sxs-lookup"><span data-stu-id="93ef5-139">By comparison, delegates are often passed as parameters and stored as private class members, if they are stored at all.</span></span>

## <a name="event-listeners-often-have-longer-lifetimes"></a><span data-ttu-id="93ef5-140">事件侦听器通常具有较长的生存期</span><span class="sxs-lookup"><span data-stu-id="93ef5-140">Event Listeners Often Have Longer Lifetimes</span></span>

<span data-ttu-id="93ef5-141">事件侦听器通常具有较长的生存期的这一理由不太充分。</span><span class="sxs-lookup"><span data-stu-id="93ef5-141">That event listeners have longer lifetimes is a slightly weaker justification.</span></span> <span data-ttu-id="93ef5-142">但是，你可能会发现，当事件源将在很长一段时间内引发事件时，基于事件的设计会更加自然。</span><span class="sxs-lookup"><span data-stu-id="93ef5-142">However, you may find that event-based designs are more natural when the event source will be raising events over a long period of time.</span></span> <span data-ttu-id="93ef5-143">可以在许多系统上看到基于事件的 UX 控件设计示例。</span><span class="sxs-lookup"><span data-stu-id="93ef5-143">You can see examples of event-based design for UX controls on many systems.</span></span> <span data-ttu-id="93ef5-144">订阅事件后，事件源可能会在程序的整个生存期内引发事件。</span><span class="sxs-lookup"><span data-stu-id="93ef5-144">Once you subscribe to an event, the event source may raise events throughout the lifetime of the program.</span></span>
<span data-ttu-id="93ef5-145">（当不再需要事件时，可以取消订阅事件。）</span><span class="sxs-lookup"><span data-stu-id="93ef5-145">(You can unsubscribe from events when you no longer need them.)</span></span>

<span data-ttu-id="93ef5-146">将其与许多基于委托的设计（其中委托用作方法的参数，且在返回该方法后不再使用此委托）进行比较。</span><span class="sxs-lookup"><span data-stu-id="93ef5-146">Contrast that with many delegate-based designs, where a delegate is used as an argument to a method, and the delegate is not used after that method returns.</span></span>

## <a name="evaluate-carefully"></a><span data-ttu-id="93ef5-147">仔细评估</span><span class="sxs-lookup"><span data-stu-id="93ef5-147">Evaluate Carefully</span></span>

<span data-ttu-id="93ef5-148">以上考虑因素并非固定不变的规则。</span><span class="sxs-lookup"><span data-stu-id="93ef5-148">The above considerations are not hard and fast rules.</span></span> <span data-ttu-id="93ef5-149">相反，它们代表可帮助决定针对特定使用情况的最佳选择的指南。</span><span class="sxs-lookup"><span data-stu-id="93ef5-149">Instead, they represent guidance that can help you decide which choice is best for your particular usage.</span></span> <span data-ttu-id="93ef5-150">因为两者类似，所以甚至可以将两者作为原型，并考虑使用更加自然的一种。</span><span class="sxs-lookup"><span data-stu-id="93ef5-150">Because they are similar, you can even prototype both, and consider which would be more natural to work with.</span></span> <span data-ttu-id="93ef5-151">两者均能很好地处理后期绑定方案。</span><span class="sxs-lookup"><span data-stu-id="93ef5-151">They both handle late binding scenarios well.</span></span> <span data-ttu-id="93ef5-152">使用能与设计进行最佳通讯的一种。</span><span class="sxs-lookup"><span data-stu-id="93ef5-152">Use the one that communicates your design the best.</span></span>
