---
title: 匿名类型 - C# 编程指南
description: C# 中的匿名类型将一组只读属性封装到一个对象中，而无需显式定义一个类型。 编译器会生成名称。
ms.date: 07/20/2015
helpviewer_keywords:
- anonymous types [C#]
- C# Language, anonymous types
ms.assetid: 59c9d7a4-3b0e-475e-b620-0ab86c088e9b
ms.openlocfilehash: f60c1ea4f3f029ec3b81a4197a711523ec372df9
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/24/2020
ms.locfileid: "91186154"
---
# <a name="anonymous-types-c-programming-guide"></a><span data-ttu-id="ed1d2-104">匿名类型（C# 编程指南）</span><span class="sxs-lookup"><span data-stu-id="ed1d2-104">Anonymous Types (C# Programming Guide)</span></span>

<span data-ttu-id="ed1d2-105">匿名类型提供了一种方便的方法，可用来将一组只读属性封装到单个对象中，而无需首先显式定义一个类型。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-105">Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first.</span></span> <span data-ttu-id="ed1d2-106">类型名由编译器生成，并且不能在源代码级使用。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-106">The type name is generated by the compiler and is not available at the source code level.</span></span> <span data-ttu-id="ed1d2-107">每个属性的类型由编译器推断。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-107">The type of each property is inferred by the compiler.</span></span>  
  
 <span data-ttu-id="ed1d2-108">可通过使用 [new](../../language-reference/operators/new-operator.md) 运算符和对象初始值创建匿名类型。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-108">You create anonymous types by using the [new](../../language-reference/operators/new-operator.md) operator together with an object initializer.</span></span> <span data-ttu-id="ed1d2-109">有关对象初始值设定项的详细信息，请参阅[对象和集合初始值设定项](./object-and-collection-initializers.md)。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-109">For more information about object initializers, see [Object and Collection Initializers](./object-and-collection-initializers.md).</span></span>  
  
 <span data-ttu-id="ed1d2-110">以下示例显示了用两个名为 `Amount` 和 `Message` 的属性进行初始化的匿名类型。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-110">The following example shows an anonymous type that is initialized with two properties named `Amount` and `Message`.</span></span>  
  
```csharp  
var v = new { Amount = 108, Message = "Hello" };  
  
// Rest the mouse pointer over v.Amount and v.Message in the following  
// statement to verify that their inferred types are int and string.  
Console.WriteLine(v.Amount + v.Message);  
```  
  
 <span data-ttu-id="ed1d2-111">匿名类型通常用在查询表达式的 [select](../../language-reference/keywords/select-clause.md) 子句中，以便返回源序列中每个对象的属性子集。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-111">Anonymous types typically are used in the [select](../../language-reference/keywords/select-clause.md) clause of a query expression to return a subset of the properties from each object in the source sequence.</span></span> <span data-ttu-id="ed1d2-112">有关查询的详细信息，请参阅[C# 中的 LINQ](../../linq/index.md)。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-112">For more information about queries, see [LINQ in C#](../../linq/index.md).</span></span>  
  
 <span data-ttu-id="ed1d2-113">匿名类型包含一个或多个公共只读属性。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-113">Anonymous types contain one or more public read-only properties.</span></span> <span data-ttu-id="ed1d2-114">包含其他种类的类成员（如方法或事件）为无效。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-114">No other kinds of class members, such as methods or events, are valid.</span></span> <span data-ttu-id="ed1d2-115">用来初始化属性的表达式不能为 `null`、匿名函数或指针类型。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-115">The expression that is used to initialize a property cannot be `null`, an anonymous function, or a pointer type.</span></span>  
  
 <span data-ttu-id="ed1d2-116">最常见的方案是用其他类型的属性初始化匿名类型。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-116">The most common scenario is to initialize an anonymous type with properties from another type.</span></span> <span data-ttu-id="ed1d2-117">在下面的示例中，假定名为 `Product` 的类存在。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-117">In the following example, assume that a class exists that is named `Product`.</span></span> <span data-ttu-id="ed1d2-118">类 `Product` 包括 `Color` 和 `Price` 属性，以及你不感兴趣的其他属性。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-118">Class `Product` includes `Color` and `Price` properties, together with other properties that you are not interested in.</span></span> <span data-ttu-id="ed1d2-119">变量 `Product``products` 是  对象的集合。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-119">Variable `products` is a collection of `Product` objects.</span></span> <span data-ttu-id="ed1d2-120">匿名类型声明以 `new` 关键字开始。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-120">The anonymous type declaration starts with the `new` keyword.</span></span> <span data-ttu-id="ed1d2-121">声明初始化了一个只使用 `Product` 的两个属性的新类型。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-121">The declaration initializes a new type that uses only two properties from `Product`.</span></span> <span data-ttu-id="ed1d2-122">这将导致在查询中返回较少数量的数据。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-122">This causes a smaller amount of data to be returned in the query.</span></span>  
  
 <span data-ttu-id="ed1d2-123">如果你没有在匿名类型中指定成员名称，编译器会为匿名类型成员指定与用于初始化这些成员的属性相同的名称。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-123">If you do not specify member names in the anonymous type, the compiler gives the anonymous type members the same name as the property being used to initialize them.</span></span> <span data-ttu-id="ed1d2-124">必须为使用表达式初始化的属性提供名称，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-124">You must provide a name for a property that is being initialized with an expression, as shown in the previous example.</span></span> <span data-ttu-id="ed1d2-125">在下面示例中，匿名类型的属性名称都为 `Price``Color` 和 。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-125">In the following example, the names of the properties of the anonymous type are `Color` and `Price`.</span></span>  
  
 [!code-csharp[csRef30Features#81](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csRef30Features/CS/csref30.cs#81)]  
  
 <span data-ttu-id="ed1d2-126">通常，当使用匿名类型来初始化变量时，可以通过使用 [var](../../language-reference/keywords/var.md) 将变量作为隐式键入的本地变量来进行声明。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-126">Typically, when you use an anonymous type to initialize a variable, you declare the variable as an implicitly typed local variable by using [var](../../language-reference/keywords/var.md).</span></span> <span data-ttu-id="ed1d2-127">类型名称无法在变量声明中给出，因为只有编译器能访问匿名类型的基础名称。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-127">The type name cannot be specified in the variable declaration because only the compiler has access to the underlying name of the anonymous type.</span></span> <span data-ttu-id="ed1d2-128">有关 `var` 的详细信息，请参阅[隐式类型本地变量](./implicitly-typed-local-variables.md)。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-128">For more information about `var`, see [Implicitly Typed Local Variables](./implicitly-typed-local-variables.md).</span></span>  
  
 <span data-ttu-id="ed1d2-129">可通过将隐式键入的本地变量与隐式键入的数组相结合创建匿名键入的元素的数组，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-129">You can create an array of anonymously typed elements by combining an implicitly typed local variable and an implicitly typed array, as shown in the following example.</span></span>  
  
```csharp  
var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};  
```  
  
## <a name="remarks"></a><span data-ttu-id="ed1d2-130">备注</span><span class="sxs-lookup"><span data-stu-id="ed1d2-130">Remarks</span></span>  

 <span data-ttu-id="ed1d2-131">匿名类型是直接从[对象](../../language-reference/builtin-types/reference-types.md)派生的[类](../../language-reference/keywords/class.md)类型，并且其无法强制转换为除[对象](../../language-reference/builtin-types/reference-types.md)外的任意类型。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-131">Anonymous types are [class](../../language-reference/keywords/class.md) types that derive directly from [object](../../language-reference/builtin-types/reference-types.md), and that cannot be cast to any type except [object](../../language-reference/builtin-types/reference-types.md).</span></span> <span data-ttu-id="ed1d2-132">虽然你的应用程序不能访问它，编译器还是提供了每一个匿名类型的名称。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-132">The compiler provides a name for each anonymous type, although your application cannot access it.</span></span> <span data-ttu-id="ed1d2-133">从公共语言运行时的角度来看，匿名类型与任何其他引用类型没有什么不同。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-133">From the perspective of the common language runtime, an anonymous type is no different from any other reference type.</span></span>  
  
 <span data-ttu-id="ed1d2-134">如果程序集中的两个或多个匿名对象初始值指定了属性序列，这些属性采用相同顺序且具有相同的名称和类型，则编译器将对象视为相同类型的实例。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-134">If two or more anonymous object initializers in an assembly specify a sequence of properties that are in the same order and that have the same names and types, the compiler treats the objects as instances of the same type.</span></span> <span data-ttu-id="ed1d2-135">它们共享同一编译器生成的类型信息。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-135">They share the same compiler-generated type information.</span></span>  
  
 <span data-ttu-id="ed1d2-136">无法将字段、属性、时间或方法的返回类型声明为具有匿名类型。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-136">You cannot declare a field, a property, an event, or the return type of a method as having an anonymous type.</span></span> <span data-ttu-id="ed1d2-137">同样，你不能将方法、属性、构造函数或索引器的形参声明为具有匿名类型。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-137">Similarly, you cannot declare a formal parameter of a method, property, constructor, or indexer as having an anonymous type.</span></span> <span data-ttu-id="ed1d2-138">要将匿名类型或包含匿名类型的集合作为参数传递给某一方法，可将参数作为类型对象进行声明。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-138">To pass an anonymous type, or a collection that contains anonymous types, as an argument to a method, you can declare the parameter as type object.</span></span> <span data-ttu-id="ed1d2-139">但是，这样做会使强类型化作用无效。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-139">However, doing this defeats the purpose of strong typing.</span></span> <span data-ttu-id="ed1d2-140">如果必须存储查询结果或者必须将查询结果传递到方法边界外部，请考虑使用普通的命名结构或类而不是匿名类型。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-140">If you must store query results or pass them outside the method boundary, consider using an ordinary named struct or class instead of an anonymous type.</span></span>  
  
 <span data-ttu-id="ed1d2-141">由于匿名类型上的 <xref:System.Object.Equals%2A> 和 <xref:System.Object.GetHashCode%2A> 方法是根据方法属性的 `Equals` 和 `GetHashCode` 定义的，因此仅当同一匿名类型的两个实例的所有属性都相等时，这两个实例才相等。</span><span class="sxs-lookup"><span data-stu-id="ed1d2-141">Because the <xref:System.Object.Equals%2A> and <xref:System.Object.GetHashCode%2A> methods on anonymous types are defined in terms of the `Equals` and `GetHashCode` methods of the properties, two instances of the same anonymous type are equal only if all their properties are equal.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ed1d2-142">请参阅</span><span class="sxs-lookup"><span data-stu-id="ed1d2-142">See also</span></span>

- [<span data-ttu-id="ed1d2-143">C# 编程指南</span><span class="sxs-lookup"><span data-stu-id="ed1d2-143">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="ed1d2-144">对象和集合初始值设定项</span><span class="sxs-lookup"><span data-stu-id="ed1d2-144">Object and Collection Initializers</span></span>](./object-and-collection-initializers.md)
- [<span data-ttu-id="ed1d2-145">C# 中的 LINQ 入门</span><span class="sxs-lookup"><span data-stu-id="ed1d2-145">Getting Started with LINQ in C#</span></span>](../concepts/linq/index.md)
- [<span data-ttu-id="ed1d2-146">C# 中的 LINQ</span><span class="sxs-lookup"><span data-stu-id="ed1d2-146">LINQ in C#</span></span>](../../linq/index.md)
