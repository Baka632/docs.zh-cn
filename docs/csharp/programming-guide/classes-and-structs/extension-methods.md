---
title: 扩展方法 - C# 编程指南
description: C# 中的扩展方法使你能够向现有类型添加方法，而无需创建新的派生类型，重新编译或以其他方式修改原始类型。
ms.date: 03/19/2020
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: 116087ac1aab57f2869b05f436801c7861c56eca
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/11/2020
ms.locfileid: "88063700"
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="a909d-103">扩展方法（C# 编程指南）</span><span class="sxs-lookup"><span data-stu-id="a909d-103">Extension Methods (C# Programming Guide)</span></span>

<span data-ttu-id="a909d-104">扩展方法使你能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。</span><span class="sxs-lookup"><span data-stu-id="a909d-104">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="a909d-105">扩展方法是一种静态方法，但可以像扩展类型上的实例方法一样进行调用。</span><span class="sxs-lookup"><span data-stu-id="a909d-105">Extension methods are static methods, but they're called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="a909d-106">对于用 C#、F# 和 Visual Basic 编写的客户端代码，调用扩展方法与调用在类型中定义的方法没有明显区别。</span><span class="sxs-lookup"><span data-stu-id="a909d-106">For client code written in C#, F# and Visual Basic, there's no apparent difference between calling an extension method and the methods defined in a type.</span></span>

<span data-ttu-id="a909d-107">最常见的扩展方法是 LINQ 标准查询运算符，它将查询功能添加到现有的 <xref:System.Collections.IEnumerable?displayProperty=nameWithType> 和 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 类型。</span><span class="sxs-lookup"><span data-stu-id="a909d-107">The most common extension methods are the LINQ standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="a909d-108">若要使用标准查询运算符，请先使用 `using System.Linq` 指令将它们置于范围中。</span><span class="sxs-lookup"><span data-stu-id="a909d-108">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="a909d-109">然后，任何实现了 <xref:System.Collections.Generic.IEnumerable%601> 的类型看起来都具有 <xref:System.Linq.Enumerable.GroupBy%2A>、<xref:System.Linq.Enumerable.OrderBy%2A>、<xref:System.Linq.Enumerable.Average%2A> 等实例方法。</span><span class="sxs-lookup"><span data-stu-id="a909d-109">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="a909d-110">在 <xref:System.Collections.Generic.IEnumerable%601> 类型的实例（如 <xref:System.Collections.Generic.List%601> 或 <xref:System.Array>）后键入“dot”时，可以在 IntelliSense 语句完成中看到这些附加方法。</span><span class="sxs-lookup"><span data-stu-id="a909d-110">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>

### <a name="orderby-example"></a><span data-ttu-id="a909d-111">OrderBy 示例</span><span class="sxs-lookup"><span data-stu-id="a909d-111">OrderBy Example</span></span>

<span data-ttu-id="a909d-112">下面的示例演示如何对一个整数数组调用标准查询运算符 `OrderBy` 方法。</span><span class="sxs-lookup"><span data-stu-id="a909d-112">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="a909d-113">括号里面的表达式是一个 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="a909d-113">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="a909d-114">很多标准查询运算符采用 Lambda 表达式作为参数，但这不是扩展方法的必要条件。</span><span class="sxs-lookup"><span data-stu-id="a909d-114">Many standard query operators take lambda expressions as parameters, but this isn't a requirement for extension methods.</span></span> <span data-ttu-id="a909d-115">有关详细信息，请参阅 [Lambda 表达式](../../language-reference/operators/lambda-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="a909d-115">For more information, see [Lambda Expressions](../../language-reference/operators/lambda-expressions.md).</span></span>

[!code-csharp[csProgGuideExtensionMethods#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#3)]

<span data-ttu-id="a909d-116">扩展方法被定义为静态方法，但它们是通过实例方法语法进行调用的。</span><span class="sxs-lookup"><span data-stu-id="a909d-116">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="a909d-117">它们的第一个参数指定方法操作的类型。</span><span class="sxs-lookup"><span data-stu-id="a909d-117">Their first parameter specifies which type the method operates on.</span></span> <span data-ttu-id="a909d-118">参数前面是[此](../../language-reference/keywords/this.md)修饰符。</span><span class="sxs-lookup"><span data-stu-id="a909d-118">The parameter is preceded by the [this](../../language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="a909d-119">仅当你使用 `using` 指令将命名空间显式导入到源代码中之后，扩展方法才位于范围中。</span><span class="sxs-lookup"><span data-stu-id="a909d-119">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>

<span data-ttu-id="a909d-120">下面的示例演示为 <xref:System.String?displayProperty=nameWithType> 类定义的一个扩展方法。</span><span class="sxs-lookup"><span data-stu-id="a909d-120">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="a909d-121">它是在非嵌套的、非泛型静态类内部定义的：</span><span class="sxs-lookup"><span data-stu-id="a909d-121">It's defined inside a non-nested, non-generic static class:</span></span>

[!code-csharp[csProgGuideExtensionMethods#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#4)]

<span data-ttu-id="a909d-122">可使用此 `WordCount` 指令将 `using` 扩展方法置于范围中：</span><span class="sxs-lookup"><span data-stu-id="a909d-122">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>

```csharp
using ExtensionMethods;
```

<span data-ttu-id="a909d-123">而且，可以使用以下语法从应用程序中调用该扩展方法：</span><span class="sxs-lookup"><span data-stu-id="a909d-123">And it can be called from an application by using this syntax:</span></span>

```csharp
string s = "Hello Extension Methods";
int i = s.WordCount();
```

<span data-ttu-id="a909d-124">在代码中，可以使用实例方法语法调用该扩展方法。</span><span class="sxs-lookup"><span data-stu-id="a909d-124">You invoke the extension method in your code with instance method syntax.</span></span> <span data-ttu-id="a909d-125">编译器生成的中间语言 (IL) 会将代码转换为对静态方法的调用。</span><span class="sxs-lookup"><span data-stu-id="a909d-125">The intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="a909d-126">并未真正违反封装原则。</span><span class="sxs-lookup"><span data-stu-id="a909d-126">The principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="a909d-127">扩展方法无法访问它们所扩展的类型中的专用变量。</span><span class="sxs-lookup"><span data-stu-id="a909d-127">Extension methods cannot access private variables in the type they are extending.</span></span>

<span data-ttu-id="a909d-128">有关详细信息，请参阅[如何实现和调用自定义扩展方法](./how-to-implement-and-call-a-custom-extension-method.md)。</span><span class="sxs-lookup"><span data-stu-id="a909d-128">For more information, see [How to implement and call a custom  extension method](./how-to-implement-and-call-a-custom-extension-method.md).</span></span>

<span data-ttu-id="a909d-129">通常，你更多时候是调用扩展方法而不是实现你自己的扩展方法。</span><span class="sxs-lookup"><span data-stu-id="a909d-129">In general, you'll probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="a909d-130">由于扩展方法是使用实例方法语法调用的，因此不需要任何特殊知识即可从客户端代码中使用它们。</span><span class="sxs-lookup"><span data-stu-id="a909d-130">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="a909d-131">若要为特定类型启用扩展方法，只需为在其中定义这些方法的命名空间添加 `using` 指令。</span><span class="sxs-lookup"><span data-stu-id="a909d-131">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="a909d-132">例如，若要使用标准查询运算符，请将此 `using` 指令添加到代码中：</span><span class="sxs-lookup"><span data-stu-id="a909d-132">For example, to use the standard query operators, add this `using` directive to your code:</span></span>

```csharp
using System.Linq;
```

<span data-ttu-id="a909d-133">（你可能还必须添加对 System.Core.dll 的引用。）你将注意到，标准查询运算符现在作为可供大多数 <xref:System.Collections.Generic.IEnumerable%601> 类型使用的附加方法显示在 IntelliSense 中。</span><span class="sxs-lookup"><span data-stu-id="a909d-133">(You may also have to add a reference to System.Core.dll.) You'll notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>

## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="a909d-134">在编译时绑定扩展方法</span><span class="sxs-lookup"><span data-stu-id="a909d-134">Binding Extension Methods at Compile Time</span></span>

<span data-ttu-id="a909d-135">可以使用扩展方法来扩展类或接口，但不能重写扩展方法。</span><span class="sxs-lookup"><span data-stu-id="a909d-135">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="a909d-136">与接口或类方法具有相同名称和签名的扩展方法永远不会被调用。</span><span class="sxs-lookup"><span data-stu-id="a909d-136">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="a909d-137">编译时，扩展方法的优先级总是比类型本身中定义的实例方法低。</span><span class="sxs-lookup"><span data-stu-id="a909d-137">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="a909d-138">换句话说，如果某个类型具有一个名为 `Process(int i)` 的方法，而你有一个具有相同签名的扩展方法，则编译器总是绑定到该实例方法。</span><span class="sxs-lookup"><span data-stu-id="a909d-138">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="a909d-139">当编译器遇到方法调用时，它首先在该类型的实例方法中寻找匹配的方法。</span><span class="sxs-lookup"><span data-stu-id="a909d-139">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="a909d-140">如果未找到任何匹配方法，编译器将搜索为该类型定义的任何扩展方法，并且绑定到它找到的第一个扩展方法。</span><span class="sxs-lookup"><span data-stu-id="a909d-140">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="a909d-141">下面的示例演示编译器如何确定要绑定到哪个扩展方法或实例方法。</span><span class="sxs-lookup"><span data-stu-id="a909d-141">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>

## <a name="example"></a><span data-ttu-id="a909d-142">示例</span><span class="sxs-lookup"><span data-stu-id="a909d-142">Example</span></span>

<span data-ttu-id="a909d-143">下面的示例演示 C# 编译器在确定是将方法调用绑定到类型上的实例方法还是绑定到扩展方法时所遵循的规则。</span><span class="sxs-lookup"><span data-stu-id="a909d-143">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="a909d-144">静态类 `Extensions` 包含为任何实现了 `IMyInterface` 的类型定义的扩展方法。</span><span class="sxs-lookup"><span data-stu-id="a909d-144">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="a909d-145">类 `A`、`B` 和 `C` 都实现了该接口。</span><span class="sxs-lookup"><span data-stu-id="a909d-145">Classes `A`, `B`, and `C` all implement the interface.</span></span>

<span data-ttu-id="a909d-146">`MethodB` 扩展方法永远不会被调用，因为它的名称和签名与这些类已经实现的方法完全匹配。</span><span class="sxs-lookup"><span data-stu-id="a909d-146">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>

<span data-ttu-id="a909d-147">如果编译器找不到具有匹配签名的实例方法，它会绑定到匹配的扩展方法（如果存在这样的方法）。</span><span class="sxs-lookup"><span data-stu-id="a909d-147">When the compiler can't find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>

[!code-csharp[csProgGuideExtensionMethods#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#5)]

## <a name="common-usage-patterns"></a><span data-ttu-id="a909d-148">常见使用模式</span><span class="sxs-lookup"><span data-stu-id="a909d-148">Common Usage Patterns</span></span>

### <a name="collection-functionality"></a><span data-ttu-id="a909d-149">集合功能</span><span class="sxs-lookup"><span data-stu-id="a909d-149">Collection Functionality</span></span>

<span data-ttu-id="a909d-150">过去，创建”集合类”通常是为了使给定类型实现 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 接口，并实现对该类型集合的功能。</span><span class="sxs-lookup"><span data-stu-id="a909d-150">In the past, it was common to create "Collection Classes" that implemented the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface for a given type and contained functionality that acted on collections of that type.</span></span> <span data-ttu-id="a909d-151">创建这种类型的集合对象没有任何问题，但也可以通过对 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 使用扩展来实现相同的功能。</span><span class="sxs-lookup"><span data-stu-id="a909d-151">While there's nothing wrong with creating this type of collection object, the same functionality can be achieved by using an extension on the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a909d-152">扩展的优势是允许从任何集合（如 <xref:System.Array?displayProperty=nameWithType> 或实现该类型 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 的 <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>）调用功能。</span><span class="sxs-lookup"><span data-stu-id="a909d-152">Extensions have the advantage of allowing the functionality to be called from any collection such as an <xref:System.Array?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> that implements <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> on that type.</span></span> <span data-ttu-id="a909d-153">可以在[本文前面的内容](#orderby-example)中找到使用 Int32 的数组的示例。</span><span class="sxs-lookup"><span data-stu-id="a909d-153">An example of this using an Array of Int32 can be found [earlier in this article](#orderby-example).</span></span>

### <a name="layer-specific-functionality"></a><span data-ttu-id="a909d-154">特定于层的功能</span><span class="sxs-lookup"><span data-stu-id="a909d-154">Layer-Specific Functionality</span></span>

<span data-ttu-id="a909d-155">使用洋葱架构或其他分层应用程序设计时，通常具有一组域实体或数据传输对象，可用于跨应用程序边界进行通信。</span><span class="sxs-lookup"><span data-stu-id="a909d-155">When using an Onion Architecture or other layered application design, it's common to have a set of Domain Entities or Data Transfer Objects that can be used to communicate across application boundaries.</span></span> <span data-ttu-id="a909d-156">这些对象通常不包含任何功能，或者只包含适用于应用程序的所有层的最少功能。</span><span class="sxs-lookup"><span data-stu-id="a909d-156">These objects generally contain no functionality, or only minimal functionality that applies to all layers of the application.</span></span> <span data-ttu-id="a909d-157">使用扩展方法可以添加特定于每个应用程序层的功能，而无需使用其他层中不需要的方法来向下加载对象。</span><span class="sxs-lookup"><span data-stu-id="a909d-157">Extension methods can be used to add functionality that is specific to each application layer without loading the object down with methods not needed or wanted in other layers.</span></span>

```csharp
public class DomainEntity
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

static class DomainEntityExtensions
{
    static string FullName(this DomainEntity value)
        => $"{value.FirstName} {value.LastName}";
}
```

### <a name="extending-predefined-types"></a><span data-ttu-id="a909d-158">扩展预定义类型</span><span class="sxs-lookup"><span data-stu-id="a909d-158">Extending Predefined Types</span></span>

<span data-ttu-id="a909d-159">当需要创建可重用功能时，我们无需创建新对象，而是可以扩展现有类型，例如 .NET 或 CLR 类型。</span><span class="sxs-lookup"><span data-stu-id="a909d-159">Rather than creating new objects when reusable functionality needs to be created, we can often extend an existing type, such as a .NET or CLR type.</span></span> <span data-ttu-id="a909d-160">例如，如果不使用扩展方法，我们可能会创建 `Engine` 或 `Query` 类，对可从代码中的多个位置调用的 SQL Server 执行查询。</span><span class="sxs-lookup"><span data-stu-id="a909d-160">As an example, if we don't use extension methods, we might create an `Engine` or `Query` class to do the work of executing a query on a SQL Server that may be called from multiple places in our code.</span></span> <span data-ttu-id="a909d-161">但是，如果换做使用扩展方法扩展 <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> 类，就可以从与 SQL Server 连接的任何位置执行该查询。</span><span class="sxs-lookup"><span data-stu-id="a909d-161">However we can instead extend the <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> class using extension methods to perform that query from anywhere we have a connection to a SQL Server.</span></span> <span data-ttu-id="a909d-162">一些其他示例可能是向 <xref:System.String?displayProperty=nameWithType> 类添加常见功能、扩展 <xref:System.IO.File?displayProperty=nameWithType>、<xref:System.IO.Stream?displayProperty=nameWithType> 以及 <xref:System.Exception?displayProperty=nameWithType> 对象的数据处理功能以实现特定的错误处理功能。</span><span class="sxs-lookup"><span data-stu-id="a909d-162">Other examples might be to add common functionality to the <xref:System.String?displayProperty=nameWithType> class, extend the data processing capabilities of the <xref:System.IO.File?displayProperty=nameWithType> and <xref:System.IO.Stream?displayProperty=nameWithType> objects, and <xref:System.Exception?displayProperty=nameWithType> objects for specific error handling functionality.</span></span> <span data-ttu-id="a909d-163">这些用例的类型仅受想象力和判断力的限制。</span><span class="sxs-lookup"><span data-stu-id="a909d-163">These types of use-cases are limited only by your imagination and good sense.</span></span>

<span data-ttu-id="a909d-164">使用 `struct` 类型扩展预定义类型可能很困难，因为它们已通过值传递给方法。</span><span class="sxs-lookup"><span data-stu-id="a909d-164">Extending predefined types can be difficult with `struct` types because they're passed by value to methods.</span></span> <span data-ttu-id="a909d-165">这意味着将对结构的副本进行任何结构更改。</span><span class="sxs-lookup"><span data-stu-id="a909d-165">That means any changes to the struct are made to a copy of the struct.</span></span> <span data-ttu-id="a909d-166">扩展方法退出后，将不显示这些更改。</span><span class="sxs-lookup"><span data-stu-id="a909d-166">Those changes aren't visible once the extension method exits.</span></span> <span data-ttu-id="a909d-167">从 C# 7.2 开始，可以将 `ref` 修饰符添加到扩展方法的第一个参数。</span><span class="sxs-lookup"><span data-stu-id="a909d-167">Beginning with C# 7.2, you can add the `ref` modifier to the first argument of an extension method.</span></span> <span data-ttu-id="a909d-168">添加 `ref` 修饰符意味着第一个参数是通过引用传递的。</span><span class="sxs-lookup"><span data-stu-id="a909d-168">Adding the `ref` modifier means the first argument is passed by reference.</span></span> <span data-ttu-id="a909d-169">在这种情况下，可以编写扩展方法来更改要扩展的结构的状态。</span><span class="sxs-lookup"><span data-stu-id="a909d-169">This enables you to write extension methods that change the state of the struct being extended.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="a909d-170">通用准则</span><span class="sxs-lookup"><span data-stu-id="a909d-170">General Guidelines</span></span>

<span data-ttu-id="a909d-171">尽管通过修改对象的代码来添加功能，或者在合理和可行的情况下派生新类型等方式仍是可取的，但扩展方法已成为在整个 .NET 生态系统中创建可重用功能的关键选项。</span><span class="sxs-lookup"><span data-stu-id="a909d-171">While it's still considered preferable to add functionality by modifying an object's code or deriving a new type whenever it's reasonable and possible to do so, extension methods have become a crucial option for creating reusable functionality throughout the .NET ecosystem.</span></span> <span data-ttu-id="a909d-172">对于原始源不受控制、派生对象不合适或不可用，或者不应在功能适用范围之外公开功能的情况，扩展方法是一个不错的选择。</span><span class="sxs-lookup"><span data-stu-id="a909d-172">For those occasions when the original source isn't under your control, when a derived object is inappropriate or impossible, or when the functionality shouldn't be exposed beyond its applicable scope, Extension methods are an excellent choice.</span></span>

<span data-ttu-id="a909d-173">有关派生类型的详细信息，请参阅[继承](./inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="a909d-173">For more information on derived types, see [Inheritance](./inheritance.md).</span></span>

<span data-ttu-id="a909d-174">在使用扩展方法来扩展你无法控制其源代码的类型时，你需要承受该类型实现中的更改会导致扩展方法失效的风险。</span><span class="sxs-lookup"><span data-stu-id="a909d-174">When using an extension method to extend a type whose source code you aren't in control of, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>

<span data-ttu-id="a909d-175">如果确实为给定类型实现了扩展方法，请记住以下几点：</span><span class="sxs-lookup"><span data-stu-id="a909d-175">If you do implement extension methods for a given type, remember the following points:</span></span>

- <span data-ttu-id="a909d-176">如果扩展方法与该类型中定义的方法具有相同的签名，则扩展方法永远不会被调用。</span><span class="sxs-lookup"><span data-stu-id="a909d-176">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>
- <span data-ttu-id="a909d-177">在命名空间级别将扩展方法置于范围中。</span><span class="sxs-lookup"><span data-stu-id="a909d-177">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="a909d-178">例如，如果你在一个名为 `Extensions` 的命名空间中具有多个包含扩展方法的静态类，则这些扩展方法将全部由 `using Extensions;` 指令置于范围中。</span><span class="sxs-lookup"><span data-stu-id="a909d-178">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they'll all be brought into scope by the `using Extensions;` directive.</span></span>

<span data-ttu-id="a909d-179">针对已实现的类库，不应为了避免程序集的版本号递增而使用扩展方法。</span><span class="sxs-lookup"><span data-stu-id="a909d-179">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="a909d-180">如果要向你拥有源代码的库中添加重要功能，请遵循适用于程序集版本控制的 .NET 准则。</span><span class="sxs-lookup"><span data-stu-id="a909d-180">If you want to add significant functionality to a library for which you own the source code, follow the .NET guidelines for assembly versioning.</span></span> <span data-ttu-id="a909d-181">有关详细信息，请参阅[程序集版本控制](../../../standard/assembly/versioning.md)。</span><span class="sxs-lookup"><span data-stu-id="a909d-181">For more information, see [Assembly Versioning](../../../standard/assembly/versioning.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="a909d-182">请参阅</span><span class="sxs-lookup"><span data-stu-id="a909d-182">See also</span></span>

- [<span data-ttu-id="a909d-183">C# 编程指南</span><span class="sxs-lookup"><span data-stu-id="a909d-183">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="a909d-184">并行编程示例（这些示例包括许多示例扩展方法）</span><span class="sxs-lookup"><span data-stu-id="a909d-184">Parallel Programming Samples (these include many example extension methods)</span></span>](/samples/browse/?products=dotnet-core%2Cdotnet-standard&term=parallel)
- [<span data-ttu-id="a909d-185">Lambda 表达式</span><span class="sxs-lookup"><span data-stu-id="a909d-185">Lambda Expressions</span></span>](../../language-reference/operators/lambda-expressions.md)
- [<span data-ttu-id="a909d-186">标准查询运算符概述</span><span class="sxs-lookup"><span data-stu-id="a909d-186">Standard Query Operators Overview</span></span>](../concepts/linq/standard-query-operators-overview.md)
- <span data-ttu-id="a909d-187">[Conversion rules for Instance parameters and their impact](https://docs.microsoft.com/archive/blogs/sreekarc/conversion-rules-for-instance-parameters-and-their-impact)（实例参数及其影响的转换规则）</span><span class="sxs-lookup"><span data-stu-id="a909d-187">[Conversion rules for Instance parameters and their impact](https://docs.microsoft.com/archive/blogs/sreekarc/conversion-rules-for-instance-parameters-and-their-impact)</span></span>
- <span data-ttu-id="a909d-188">[Extension methods Interoperability between languages](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-interoperability-between-languages)（语言间扩展方法的互操作性）</span><span class="sxs-lookup"><span data-stu-id="a909d-188">[Extension methods Interoperability between languages](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-interoperability-between-languages)</span></span>
- <span data-ttu-id="a909d-189">[Extension methods and Curried Delegates](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-and-curried-delegates)（扩展方法和扩充委托）</span><span class="sxs-lookup"><span data-stu-id="a909d-189">[Extension methods and Curried Delegates](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-and-curried-delegates)</span></span>
- <span data-ttu-id="a909d-190">[Extension method Binding and Error reporting](https://docs.microsoft.com/archive/blogs/sreekarc/extension-method-binding-and-error-reporting)（扩展方法绑定和错误报告）</span><span class="sxs-lookup"><span data-stu-id="a909d-190">[Extension method Binding and Error reporting](https://docs.microsoft.com/archive/blogs/sreekarc/extension-method-binding-and-error-reporting)</span></span>
