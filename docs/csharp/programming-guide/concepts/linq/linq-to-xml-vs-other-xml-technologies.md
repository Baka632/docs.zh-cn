---
title: LINQ to XML 与其他 XML 技术 3
description: 本文将 LINQ to XML 与多种 XML 技术（包括 XmlReader、XSLT、MSXML 和 XmlLite）进行比较，帮助你确定要使用的技术。
ms.date: 07/20/2015
ms.assetid: 01b8e746-12d3-471d-b811-7539e4547784
ms.openlocfilehash: 0abe6021dae83df0db0d4116eb3c2919d024a62d
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/24/2020
ms.locfileid: "87165325"
---
# <a name="linq-to-xml-vs-other-xml-technologies"></a><span data-ttu-id="e30a2-103">LINQ to XML 与其他 XML 技术</span><span class="sxs-lookup"><span data-stu-id="e30a2-103">LINQ to XML vs. Other XML Technologies</span></span>
<span data-ttu-id="e30a2-104">本主题将 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 与下面的 XML 技术进行比较：<xref:System.Xml.XmlReader>、XSLT、MSXML 和 XmlLite。</span><span class="sxs-lookup"><span data-stu-id="e30a2-104">This topic compares [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] to the following XML technologies: <xref:System.Xml.XmlReader>, XSLT, MSXML, and XmlLite.</span></span> <span data-ttu-id="e30a2-105">了解这些信息，有助于确定要使用哪种技术。</span><span class="sxs-lookup"><span data-stu-id="e30a2-105">This information can help you decide which technology to use.</span></span>  
  
 <span data-ttu-id="e30a2-106">有关比较 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 与文档对象模型 (DOM) 的信息，请参阅 [LINQ to XML 与DOM (C#)](./linq-to-xml-vs-dom.md)。</span><span class="sxs-lookup"><span data-stu-id="e30a2-106">For a comparison of [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] to the Document Object Model (DOM), see [LINQ to XML vs. DOM (C#)](./linq-to-xml-vs-dom.md).</span></span>  
  
## <a name="linq-to-xml-vs-xmlreader"></a><span data-ttu-id="e30a2-107">LINQ to XML 与XmlReader</span><span class="sxs-lookup"><span data-stu-id="e30a2-107">LINQ to XML vs. XmlReader</span></span>  
 <span data-ttu-id="e30a2-108"><xref:System.Xml.XmlReader> 是一种快速的只进非缓存分析器。</span><span class="sxs-lookup"><span data-stu-id="e30a2-108"><xref:System.Xml.XmlReader> is a fast, forward-only, non-caching parser.</span></span>  
  
 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] <span data-ttu-id="e30a2-109">在 <xref:System.Xml.XmlReader> 基础之上实现，它们紧密集成在一起。</span><span class="sxs-lookup"><span data-stu-id="e30a2-109">is implemented on top of <xref:System.Xml.XmlReader>, and they are tightly integrated.</span></span> <span data-ttu-id="e30a2-110">但是，您也可以单独使用 <xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="e30a2-110">However, you can also use <xref:System.Xml.XmlReader> by itself.</span></span>  
  
 <span data-ttu-id="e30a2-111">例如，假设要生成一项 Web 服务，该服务每秒将分析几百个 XML 文档，而这些文档具有相同的结构，因此，只需编写一种代码实现即可对 XML 进行分析。</span><span class="sxs-lookup"><span data-stu-id="e30a2-111">For example, suppose you are building a Web service that will parse hundreds of XML documents per second, and the documents have the same structure, meaning that you only have to write one implementation of the code to parse the XML.</span></span> <span data-ttu-id="e30a2-112">在这种情况下，您可能希望单独使用 <xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="e30a2-112">In this case, you would probably want to use <xref:System.Xml.XmlReader> by itself.</span></span>  
  
 <span data-ttu-id="e30a2-113">相反，如果要生成一个系统，用以分析多种小型 XML 文档，而这些文档各不相同，则可能希望利用 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 提高工作效率。</span><span class="sxs-lookup"><span data-stu-id="e30a2-113">In contrast, if you are building a system that parses many smaller XML documents, and each one is different, you would want to take advantage of the productivity improvements that [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] provides.</span></span>  
  
## <a name="linq-to-xml-vs-xslt"></a><span data-ttu-id="e30a2-114">LINQ to XML 与XSLT</span><span class="sxs-lookup"><span data-stu-id="e30a2-114">LINQ to XML vs. XSLT</span></span>  
 <span data-ttu-id="e30a2-115">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 和 XSLT 都提供丰富的 XML 文档转换功能。</span><span class="sxs-lookup"><span data-stu-id="e30a2-115">Both [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] and XSLT provide extensive XML document transformation capabilities.</span></span> <span data-ttu-id="e30a2-116">XSLT 是基于规则的声明性方法。</span><span class="sxs-lookup"><span data-stu-id="e30a2-116">XSLT is a rule-based, declarative approach.</span></span> <span data-ttu-id="e30a2-117">XSLT 高级程序员以函数编程方式编写 XSLT，这种方式强调无状态方法。</span><span class="sxs-lookup"><span data-stu-id="e30a2-117">Advanced XSLT programmers write XSLT in a functional programming style that emphasizes a stateless approach.</span></span> <span data-ttu-id="e30a2-118">可以使用实现后无副作用的纯函数编写转换。</span><span class="sxs-lookup"><span data-stu-id="e30a2-118">Transformations can be written using pure functions that are implemented without side effects.</span></span> <span data-ttu-id="e30a2-119">许多开发人员还不熟悉这种基于规则的方法（即函数方法），需要付出努力和花费大量时间来学习这项技术。</span><span class="sxs-lookup"><span data-stu-id="e30a2-119">This rule-based or functional approach is unfamiliar to many developers, and can be difficult and time-consuming to learn.</span></span>  
  
 <span data-ttu-id="e30a2-120">XSLT 是非常高效的系统，可以生成高性能的应用程序。</span><span class="sxs-lookup"><span data-stu-id="e30a2-120">XSLT can be a very productive system that yields high-performance applications.</span></span> <span data-ttu-id="e30a2-121">例如，一些大型 Web 公司使用 XSLT 从 XML（提取自很多数据存储区）生成 HTML。</span><span class="sxs-lookup"><span data-stu-id="e30a2-121">For example, some big Web companies use XSLT as a way to generate HTML from XML that has been pulled from a variety of data stores.</span></span> <span data-ttu-id="e30a2-122">托管 XSLT 引擎将 XSLT 编译为 CLR 代码，在某些情况下，其性能甚至比本机 XSLT 引擎还要好。</span><span class="sxs-lookup"><span data-stu-id="e30a2-122">The managed XSLT engine compiles XSLT to CLR code, and performs even better in some scenarios than the native XSLT engine.</span></span>  
  
 <span data-ttu-id="e30a2-123">但是，XSLT 没有利用许多开发人员都具备的 C# 和 Visual Basic 知识。</span><span class="sxs-lookup"><span data-stu-id="e30a2-123">However, XSLT does not take advantage of the C# and Visual Basic knowledge that many developers have.</span></span> <span data-ttu-id="e30a2-124">它要求开发人员用一种不同的复杂编程语言来编写代码。</span><span class="sxs-lookup"><span data-stu-id="e30a2-124">It requires developers to write code in a different and complex programming language.</span></span> <span data-ttu-id="e30a2-125">如果使用两种非集成开发系统，例如 C#（或 Visual Basic）和 XSLT，软件系统的开发和维护会更加困难。</span><span class="sxs-lookup"><span data-stu-id="e30a2-125">Using two non-integrated development systems such as C# (or Visual Basic) and XSLT results in software systems that are more difficult to develop and maintain.</span></span>  
  
 <span data-ttu-id="e30a2-126">掌握 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 查询表达式之后，[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]转换就是一项功能强大、易于使用的技术。</span><span class="sxs-lookup"><span data-stu-id="e30a2-126">After you have mastered [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] query expressions, [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] transformations are a powerful technology that is easy to use.</span></span> <span data-ttu-id="e30a2-127">本质上，XML 文档是这样形成的：使用函数构造，从各种源提取数据，动态构造 <xref:System.Xml.Linq.XElement> 对象，再将全部内容组合到一个新 XML 树中。</span><span class="sxs-lookup"><span data-stu-id="e30a2-127">Basically, you form your XML document by using functional construction, pulling in data from various sources, constructing <xref:System.Xml.Linq.XElement> objects dynamically, and assembling the whole into a new XML tree.</span></span> <span data-ttu-id="e30a2-128">经过这种转换，可以生成一个全新的文档。</span><span class="sxs-lookup"><span data-stu-id="e30a2-128">The transformation can generate a completely new document.</span></span> <span data-ttu-id="e30a2-129">相对来说，在 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 中构造转换比较容易、直观，编写出的代码可读性也较强。</span><span class="sxs-lookup"><span data-stu-id="e30a2-129">Constructing transformations in [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] is relatively easy and intuitive, and the resulting code is readable.</span></span> <span data-ttu-id="e30a2-130">这样可以减少开发和维护成本。</span><span class="sxs-lookup"><span data-stu-id="e30a2-130">This reduces development and maintenance costs.</span></span>  
  
 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] <span data-ttu-id="e30a2-131">不是用来替代 XSLT 的。</span><span class="sxs-lookup"><span data-stu-id="e30a2-131">is not intended to replace XSLT.</span></span> <span data-ttu-id="e30a2-132">对于复杂的以文档为中心的 XML 转换，XSLT 仍是很好的工具，如果文档结构的定义不完备，更是如此。</span><span class="sxs-lookup"><span data-stu-id="e30a2-132">XSLT is still the tool of choice for complicated and document-centric XML transformations, especially if the structure of the document is not well defined.</span></span>  
  
 <span data-ttu-id="e30a2-133">XSLT 的优势在于符合万维网联合会 (W3C) 标准。</span><span class="sxs-lookup"><span data-stu-id="e30a2-133">XSLT has the advantage of being a World Wide Web Consortium (W3C) standard.</span></span> <span data-ttu-id="e30a2-134">如果要求只使用符合标准的技术，XSLT 可能更为合适。</span><span class="sxs-lookup"><span data-stu-id="e30a2-134">If you have a requirement that you use only technologies that are standards, XSLT might be more appropriate.</span></span>  
  
 <span data-ttu-id="e30a2-135">XSLT 是 XML，因此可以以编程方式进行操作。</span><span class="sxs-lookup"><span data-stu-id="e30a2-135">XSLT is XML, and therefore can be programmatically manipulated.</span></span>  
  
## <a name="linq-to-xml-vs-msxml"></a><span data-ttu-id="e30a2-136">LINQ to XML 与MSXML</span><span class="sxs-lookup"><span data-stu-id="e30a2-136">LINQ to XML vs. MSXML</span></span>  
 <span data-ttu-id="e30a2-137">MSXML 是基于 COM 的技术，用于处理 Microsoft Windows 提供的 XML。</span><span class="sxs-lookup"><span data-stu-id="e30a2-137">MSXML is the COM-based technology for processing XML that is included with Microsoft Windows.</span></span> <span data-ttu-id="e30a2-138">MSXML 提供 DOM 的本机实现，并且支持 XPath 和 XSLT。</span><span class="sxs-lookup"><span data-stu-id="e30a2-138">MSXML provides a native implementation of the DOM with support for XPath and XSLT.</span></span> <span data-ttu-id="e30a2-139">它还包含基于事件的 SAX2 非缓存分析器。</span><span class="sxs-lookup"><span data-stu-id="e30a2-139">It also contains the SAX2 non-caching, event-based parser.</span></span>  
  
 <span data-ttu-id="e30a2-140">MSXML 性能良好，默认情况下，在大多数情况中都是安全的，在 Internet Explorer 中可以利用此功能来执行 AJAX 式应用程序中的客户端 XML 处理。</span><span class="sxs-lookup"><span data-stu-id="e30a2-140">MSXML performs well, is secure by default in most scenarios, and can be accessed in Internet Explorer for performing client-side XML processing in AJAX-style applications.</span></span> <span data-ttu-id="e30a2-141">在任何支持 COM 的编程语言（包括 C++、JavaScript 和 Visual Basic 6.0）中，都可以使用 MSXML。</span><span class="sxs-lookup"><span data-stu-id="e30a2-141">MSXML can be used from any programming language that supports COM, including C++, JavaScript, and Visual Basic 6.0.</span></span>  
  
 <span data-ttu-id="e30a2-142">建议不要在基于公共语言运行库 (CLR) 的托管代码中使用 MSXML。</span><span class="sxs-lookup"><span data-stu-id="e30a2-142">MSXML is not recommended for use in managed code based on the common language runtime (CLR).</span></span>  
  
## <a name="linq-to-xml-vs-xmllite"></a><span data-ttu-id="e30a2-143">LINQ to XML 与XmlLite</span><span class="sxs-lookup"><span data-stu-id="e30a2-143">LINQ to XML vs. XmlLite</span></span>  
 <span data-ttu-id="e30a2-144">XmlLite 是一种只进非缓存提取型分析器。</span><span class="sxs-lookup"><span data-stu-id="e30a2-144">XmlLite is a non-caching, forward only, pull parser.</span></span> <span data-ttu-id="e30a2-145">开发人员主要将 XmlLite 用于 C++。</span><span class="sxs-lookup"><span data-stu-id="e30a2-145">Developers primarily use XmlLite with C++.</span></span> <span data-ttu-id="e30a2-146">建议开发人员不要将 XmlLite 用于托管代码。</span><span class="sxs-lookup"><span data-stu-id="e30a2-146">It is not recommended for developers to use XmlLite with managed code.</span></span>  
  
 <span data-ttu-id="e30a2-147">XmlLite 的主要优势在于它是快速的轻量 XML 分析器，在大多数方案中都是安全的。</span><span class="sxs-lookup"><span data-stu-id="e30a2-147">The main advantage of XmlLite is that it is a lightweight, fast XML parser that is secure in most scenarios.</span></span> <span data-ttu-id="e30a2-148">它可能受到的威胁很少。</span><span class="sxs-lookup"><span data-stu-id="e30a2-148">Its threat surface area is very small.</span></span> <span data-ttu-id="e30a2-149">如果必须分析不受信任的文档，并且要预防受到拒绝服务或数据暴露等攻击，则 XmlLite 可能是很好的选择。</span><span class="sxs-lookup"><span data-stu-id="e30a2-149">If you have to parse untrusted documents and you want to protect against attacks such as denial of service or exposure of data, XmlLite might be a good option.</span></span>  
  
 <span data-ttu-id="e30a2-150">XmlLite 未与语言集成查询 (LINQ) 集成。</span><span class="sxs-lookup"><span data-stu-id="e30a2-150">XmlLite is not integrated with Language-Integrated Query (LINQ).</span></span> <span data-ttu-id="e30a2-151">它不会使程序员的工作效率得到提高，而工作效率提高正是 LINQ 背后的推动力量。</span><span class="sxs-lookup"><span data-stu-id="e30a2-151">It does not yield the programmer productivity improvements that are the motivating force behind LINQ.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e30a2-152">请参阅</span><span class="sxs-lookup"><span data-stu-id="e30a2-152">See also</span></span>

- [<span data-ttu-id="e30a2-153">入门 (LINQ to XML)</span><span class="sxs-lookup"><span data-stu-id="e30a2-153">Getting Started (LINQ to XML)</span></span>](./linq-to-xml-overview.md)
