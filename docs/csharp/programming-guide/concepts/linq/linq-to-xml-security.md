---
title: LINQ to XML 安全性 (C#)
description: 了解与 LINQ to XML 相关的安全问题，包括一些减轻安全隐患的指导。
ms.date: 07/20/2015
ms.assetid: ef2c0dc9-ecf9-4c17-b24e-144184ab725f
ms.openlocfilehash: dc9fd13f19dcf6d9cbbb2b0b7608009cc4da1108
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/24/2020
ms.locfileid: "87165309"
---
# <a name="linq-to-xml-security-c"></a><span data-ttu-id="bd0bc-103">LINQ to XML 安全性 (C#)</span><span class="sxs-lookup"><span data-stu-id="bd0bc-103">LINQ to XML Security (C#)</span></span>
<span data-ttu-id="bd0bc-104">本主题说明与 LINQ to XML 相关的安全问题。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-104">This topic describes security issues associated with LINQ to XML.</span></span> <span data-ttu-id="bd0bc-105">此外，它还提供减轻安全隐患的一些指导。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-105">In addition, it provides some guidance for mitigating security exposure.</span></span>  
  
## <a name="linq-to-xml-security-overview"></a><span data-ttu-id="bd0bc-106">LINQ to XML 安全性概述</span><span class="sxs-lookup"><span data-stu-id="bd0bc-106">LINQ to XML Security Overview</span></span>  
 <span data-ttu-id="bd0bc-107">在旨在提高编程方便性和使服务器端应用程序具有严格安全要求两者之间，LINQ to XML 更倾向于前者。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-107">LINQ to XML is designed more for programming convenience than for server-side applications with stringent security requirements.</span></span> <span data-ttu-id="bd0bc-108">多数 XML 方案均涉及处理受信任的 XML 文档，而不涉及处理上载到服务器的不受信任的 XML 文档。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-108">Most XML scenarios consist of processing trusted XML documents, rather than processing untrusted XML documents that are uploaded to a server.</span></span> <span data-ttu-id="bd0bc-109">LINQ to XML 针对这些方案进行了优化。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-109">LINQ to XML is optimized for these scenarios.</span></span>  
  
 <span data-ttu-id="bd0bc-110">如果您必须处理来自未知源的不受信任的数据，Microsoft 建议您使用 <xref:System.Xml.XmlReader> 类的一个实例，并将该实例配置为筛除已知 XML 拒绝服务 (DoS) 攻击。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-110">If you must process untrusted data from unknown sources, Microsoft recommends that you use an instance of the <xref:System.Xml.XmlReader> class that has been configured to filter out known XML denial of service (DoS) attacks.</span></span>  
  
 <span data-ttu-id="bd0bc-111">如果您已配置 <xref:System.Xml.XmlReader> 以缓解拒绝服务攻击，则可以使用该读取器填充 LINQ to XML 树，同时仍可受益于 LINQ to XML 所提供的高编程效率。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-111">If you have configured an <xref:System.Xml.XmlReader> to mitigate denial of service attacks, you can use that reader to populate a LINQ to XML tree and still benefit from the programmer productivity enhancements of LINQ to XML.</span></span> <span data-ttu-id="bd0bc-112">许多缓解技术均涉及创建配置为可缓解安全问题的读取器，然后通过配置的读取器实例化 XML 树。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-112">Many mitigation techniques involve creating readers that are configured to mitigate the security issue, and then instantiating an XML tree through the configured reader.</span></span>  
  
 <span data-ttu-id="bd0bc-113">由于文档不受大小、深度、元素名称大小等的限制，因此 XML 从本质上就容易受到拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-113">XML is intrinsically vulnerable to denial of service attacks because documents are unbounded in size, depth, element name size, and more.</span></span> <span data-ttu-id="bd0bc-114">不管使用哪个组件处理 XML，都应该始终准备好在应用程序域使用过多资源的情况下回收应用程序域。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-114">Regardless of the component that you use to process XML, you should always be prepared to recycle the application domain if it uses excessive resources.</span></span>  
  
## <a name="mitigation-of-xml-xsd-xpath-and-xslt-attacks"></a><span data-ttu-id="bd0bc-115">缓解 XML、XSD、XPath 和 XSLT 攻击</span><span class="sxs-lookup"><span data-stu-id="bd0bc-115">Mitigation of XML, XSD, XPath, and XSLT Attacks</span></span>  
 <span data-ttu-id="bd0bc-116">LINQ to XML 是基于 <xref:System.Xml.XmlReader> 和 <xref:System.Xml.XmlWriter> 生成的。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-116">LINQ to XML is built upon <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter>.</span></span> <span data-ttu-id="bd0bc-117">LINQ to XML 通过 <xref:System.Xml.Schema?displayProperty=nameWithType> 和 <xref:System.Xml.XPath?displayProperty=nameWithType> 命名空间中的扩展方法支持 XSD 和 XPath。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-117">LINQ to XML supports XSD and XPath through extension methods in the <xref:System.Xml.Schema?displayProperty=nameWithType> and <xref:System.Xml.XPath?displayProperty=nameWithType> namespaces.</span></span> <span data-ttu-id="bd0bc-118">在结合 LINQ to XML 使用 <xref:System.Xml.XmlReader>、<xref:System.Xml.XPath.XPathNavigator> 和 <xref:System.Xml.XmlWriter> 类时，可以调用 XSLT 来转换 XML 树。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-118">Using the <xref:System.Xml.XmlReader>, <xref:System.Xml.XPath.XPathNavigator>, and <xref:System.Xml.XmlWriter> classes in conjunction with LINQ to XML, you can invoke XSLT to transform XML trees.</span></span>  
  
 <span data-ttu-id="bd0bc-119">如果在不足够安全的环境中操作，则可能会遇到许多与 XML 及 <xref:System.Xml?displayProperty=nameWithType>、<xref:System.Xml.Schema?displayProperty=nameWithType>、<xref:System.Xml.XPath?displayProperty=nameWithType> 和 <xref:System.Xml.Xsl?displayProperty=nameWithType> 中的类的使用相关的安全问题。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-119">If you are operating in a less secure environment, there are a number of security issues that are associated with XML and the use of the classes in <xref:System.Xml?displayProperty=nameWithType>, <xref:System.Xml.Schema?displayProperty=nameWithType>, <xref:System.Xml.XPath?displayProperty=nameWithType>, and <xref:System.Xml.Xsl?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bd0bc-120">这些问题包括但不限于以下问题：</span><span class="sxs-lookup"><span data-stu-id="bd0bc-120">These issues include, but are not limited to, the following:</span></span>  
  
- <span data-ttu-id="bd0bc-121">XSD、XPath 和 XSLT 是基于字符串的语言，您可以使用此语言指定消耗很多时间和内存的操作。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-121">XSD, XPath, and XSLT are string-based languages in which you can specify operations that consume a lot of time or memory.</span></span> <span data-ttu-id="bd0bc-122">从不受信任的源获取 XSD、XPath 或 XSLT 字符串的应用程序程序员应当负责验证这些字符串以确保其中不包含恶意内容，或监视这些字符串并尽量避免计算这些字符串时消耗过多的系统资源。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-122">It is the responsibility of application programmers who take XSD, XPath, or XSLT strings from untrusted sources to validate that the strings are not malicious, or to monitor and mitigate the possibility that evaluating these strings will lead to excessive system resource consumption.</span></span>  
  
- <span data-ttu-id="bd0bc-123">XSD 架构（包括内联架构）从本质上就容易受到拒绝服务攻击，因此不应接受来自不受信任的源的架构。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-123">XSD schemas (including inline schemas) are inherently vulnerable to denial of service attacks; you should not accept schemas from untrusted sources.</span></span>  
  
- <span data-ttu-id="bd0bc-124">XSD 和 XSLT 可能包括对其他文件的引用，这种引用可能导致跨区和跨域攻击。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-124">XSD and XSLT can include references to other files, and such references can result in cross-zone and cross-domain attacks.</span></span>  
  
- <span data-ttu-id="bd0bc-125">DTD 中的外部实体可能会导致跨区和跨域攻击。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-125">External entities in DTDs can result in cross-zone and cross-domain attacks.</span></span>  
  
- <span data-ttu-id="bd0bc-126">DTD 容易受到拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-126">DTDs are vulnerable to denial of service attacks.</span></span>  
  
- <span data-ttu-id="bd0bc-127">异常深的 XML 文档可能引起拒绝服务问题；您可能需要限制 XML 文档的深度。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-127">Exceptionally deep XML documents can pose denial of service issues; you might want to limit the depth of XML documents.</span></span>  
  
- <span data-ttu-id="bd0bc-128">不接受不受信任的程序集中的支持组件，如 <xref:System.Xml.NameTable>、<xref:System.Xml.XmlNamespaceManager> 和 <xref:System.Xml.XmlResolver> 对象。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-128">Do not accept supporting components, such as <xref:System.Xml.NameTable>, <xref:System.Xml.XmlNamespaceManager>, and <xref:System.Xml.XmlResolver> objects, from untrusted assemblies.</span></span>  
  
- <span data-ttu-id="bd0bc-129">分块区读取数据以缓解大文档攻击。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-129">Read data in chunks to mitigate large document attacks.</span></span>  
  
- <span data-ttu-id="bd0bc-130">XSLT 样式表中的脚本块易于受到多种攻击。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-130">Script blocks in XSLT style sheets can expose a number of attacks.</span></span>  
  
- <span data-ttu-id="bd0bc-131">构造动态 XPath 表达式之前需仔细验证这些表达式。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-131">Validate carefully before constructing dynamic XPath expressions.</span></span>  
  
## <a name="linq-to-xml-security-issues"></a><span data-ttu-id="bd0bc-132">LINQ to XML 安全问题</span><span class="sxs-lookup"><span data-stu-id="bd0bc-132">LINQ to XML Security Issues</span></span>  
 <span data-ttu-id="bd0bc-133">本主题中介绍的安全问题不区分顺序。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-133">The security issues in this topic are not presented in any particular order.</span></span> <span data-ttu-id="bd0bc-134">所有问题都很重要，都应得到相应解决。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-134">All issues are important and should be addressed as appropriate.</span></span>  
  
 <span data-ttu-id="bd0bc-135">成功的特权提升攻击可使恶意程序集能够更好地控制其环境。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-135">A successful elevation of privilege attack gives a malicious assembly more control over its environment.</span></span> <span data-ttu-id="bd0bc-136">成功的特权提升攻击可能导致数据泄露、拒绝服务等。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-136">A successful elevation of privilege attack can result in disclosure of data, denial of service, and more.</span></span>  
  
 <span data-ttu-id="bd0bc-137">应用程序不应该向未经授权查看数据的用户泄露数据。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-137">Applications should not disclose data to users who are not authorized to see that data.</span></span>  
  
 <span data-ttu-id="bd0bc-138">拒绝服务攻击会导致 XML 分析器或 LINQ to XML 消耗过多的内存或 CPU 时间。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-138">Denial of service attacks cause the XML parser or LINQ to XML to consume excessive amounts of memory or CPU time.</span></span> <span data-ttu-id="bd0bc-139">拒绝服务攻击的严重性可视为比特权提升攻击或数据泄露攻击的严重性低。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-139">Denial of service attacks are considered to be less severe than elevation of privilege attacks or disclosure of data attacks.</span></span> <span data-ttu-id="bd0bc-140">但在服务器需要处理来自不受信任的源的 XML 文档的方案中，拒绝服务攻击很重要。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-140">However, they are important in a scenario where a server needs to process XML documents from untrusted sources.</span></span>  
  
### <a name="exceptions-and-error-messages-might-reveal-data"></a><span data-ttu-id="bd0bc-141">异常和错误消息可能会泄露数据</span><span class="sxs-lookup"><span data-stu-id="bd0bc-141">Exceptions and Error Messages Might Reveal Data</span></span>  
 <span data-ttu-id="bd0bc-142">错误说明中可能会显示数据，如正在转换的数据、文件名或实现详细信息。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-142">The description of an error might reveal data, such as the data being transformed, file names, or implementation details.</span></span> <span data-ttu-id="bd0bc-143">不应向不受信任的调用方公开错误消息。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-143">Error messages should not be exposed to callers that are not trusted.</span></span> <span data-ttu-id="bd0bc-144">您应该捕捉所有错误并用自己的自定义错误消息报告错误。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-144">You should catch all errors and report errors with your own custom error messages.</span></span>  
  
### <a name="do-not-call-codeaccesspermissionsassert-in-an-event-handler"></a><span data-ttu-id="bd0bc-145">不要在事件处理程序中调用 CodeAccessPermissions.Assert</span><span class="sxs-lookup"><span data-stu-id="bd0bc-145">Do Not Call CodeAccessPermissions.Assert in an Event Handler</span></span>  
 <span data-ttu-id="bd0bc-146">程序集可具有较低或较高的权限。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-146">An assembly can have lesser or greater permissions.</span></span> <span data-ttu-id="bd0bc-147">程序集的权限越高，其对计算机及其环境的控制程度也就越高。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-147">An assembly that has greater permissions has greater control over the computer and its environments.</span></span>  
  
 <span data-ttu-id="bd0bc-148">如果具有较高权限的程序集中的代码在事件处理程序中调用 <xref:System.Security.CodeAccessPermission.Assert%2A?displayProperty=nameWithType>，然后将 XML 树传递给具有受限制权限的恶意程序集，则恶意程序集可能引发事件。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-148">If code in an assembly with greater permissions calls <xref:System.Security.CodeAccessPermission.Assert%2A?displayProperty=nameWithType> in an event handler, and then the XML tree is passed to a malicious assembly that has restricted permissions, the malicious assembly can cause an event to be raised.</span></span> <span data-ttu-id="bd0bc-149">由于该事件运行具有较高权限的程序集中的代码，因此恶意程序集将使用提升的特权运行。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-149">Because the event runs code that is in the assembly with greater permissions, the malicious assembly would then be operating with elevated privileges.</span></span>  
  
 <span data-ttu-id="bd0bc-150">Microsoft 建议您永远不要在事件处理程序中调用 <xref:System.Security.CodeAccessPermission.Assert%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-150">Microsoft recommends that you never call <xref:System.Security.CodeAccessPermission.Assert%2A?displayProperty=nameWithType> in an event handler.</span></span>  
  
### <a name="dtds-are-not-secure"></a><span data-ttu-id="bd0bc-151">DTD 不安全</span><span class="sxs-lookup"><span data-stu-id="bd0bc-151">DTDs are Not Secure</span></span>  
 <span data-ttu-id="bd0bc-152">DTD 中的实体在本质上就不安全。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-152">Entities in DTDs are inherently not secure.</span></span> <span data-ttu-id="bd0bc-153">包含 DTD 的恶意 XML 文档可使分析器使用全部内存和 CPU 时间，从而导致拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-153">It is possible for a malicious XML document that contains a DTD to cause the parser to use all memory and CPU time, causing a denial of service attack.</span></span> <span data-ttu-id="bd0bc-154">因此，在 LINQ to XML 中，默认情况下关闭 DTD 处理。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-154">Therefore, in LINQ to XML, DTD processing is turned off by default.</span></span> <span data-ttu-id="bd0bc-155">您不应接受来自不受信任源的 DTD。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-155">You should not accept DTDs from untrusted sources.</span></span>  
  
 <span data-ttu-id="bd0bc-156">接受来自不受信任源的 DTD 的一个示例是：允许 Web 用户上载引用 DTD 和 DTD 文件的 XML 文件的 Web 应用程序。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-156">One example of accepting DTDs from untrusted sources is a Web application that allows Web users to upload an XML file that references a DTD and a DTD file.</span></span> <span data-ttu-id="bd0bc-157">在验证该文件时，恶意 DTD 会在您的服务器上执行拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-157">Upon validation of the file, a malicious DTD could execute a denial of service attack on your server.</span></span> <span data-ttu-id="bd0bc-158">接受来自不受信任源的 DTD 的另一个示例是：引用网络共享上也允许匿名 FTP 访问的 DTD。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-158">Another example of accepting DTDs from untrusted sources is to reference a DTD on a network share that also allows anonymous FTP access.</span></span>  
  
### <a name="avoid-excessive-buffer-allocation"></a><span data-ttu-id="bd0bc-159">避免分配过多的缓冲区</span><span class="sxs-lookup"><span data-stu-id="bd0bc-159">Avoid Excessive Buffer Allocation</span></span>  
 <span data-ttu-id="bd0bc-160">应用程序开发人员应该知道，过大的数据源可能导致资源耗尽和拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-160">Application developers should be aware that extremely large data sources can lead to resource exhaustion and denial of service attacks.</span></span>  
  
 <span data-ttu-id="bd0bc-161">如果恶意用户提交或上载非常大的 XML 文档，则可能导致 LINQ to XML 使用过多的系统资源。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-161">If a malicious user submits or uploads a very large XML document, it could cause LINQ to XML to consume excessive system resources.</span></span> <span data-ttu-id="bd0bc-162">这可能构成拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-162">This can constitute a denial of service attack.</span></span> <span data-ttu-id="bd0bc-163">为防止这种情况的发生，可以设置 <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A?displayProperty=nameWithType> 属性并创建一个读取器，然后限制读取器可以加载的文档大小。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-163">To prevent this, you can set the <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A?displayProperty=nameWithType> property, and create a reader that is then limited in the size of document that it can load.</span></span> <span data-ttu-id="bd0bc-164">然后使用该读取器创建 XML 树。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-164">You then use the reader to create the XML tree.</span></span>  
  
 <span data-ttu-id="bd0bc-165">例如，如果您知道来自不受信任源的 XML 文档的预计最大大小不会超过 50K 字节，则将 <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A?displayProperty=nameWithType> 设置为 100,000。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-165">For example, if you know that the maximum expected size of your XML documents coming from an untrusted source will be less than 50K bytes, set <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A?displayProperty=nameWithType> to 100,000.</span></span> <span data-ttu-id="bd0bc-166">这不会妨碍您处理 XML 文档，同时还可在要上载的文档会使用大量内存的情况下缓解拒绝服务威胁。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-166">This will not encumber your processing of XML documents, and at the same time it will mitigate denial of service threats where documents might be uploaded that would consume large amounts of memory.</span></span>  
  
### <a name="avoid-excess-entity-expansion"></a><span data-ttu-id="bd0bc-167">避免过度扩展实体</span><span class="sxs-lookup"><span data-stu-id="bd0bc-167">Avoid Excess Entity Expansion</span></span>  
 <span data-ttu-id="bd0bc-168">使用 DTD 时的一种已知拒绝服务攻击是导致过度扩展实体的文档造成的。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-168">One of the known denial of service attacks when using a DTD is a document that causes excessive entity expansion.</span></span> <span data-ttu-id="bd0bc-169">为防止这种情况的发生，可以设置 <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A?displayProperty=nameWithType> 属性并创建一个读取器，然后限制从实体扩展中生成的字符数。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-169">To prevent this, you can set the <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A?displayProperty=nameWithType> property, and create a reader that is then limited in the number of characters that result from entity expansion.</span></span> <span data-ttu-id="bd0bc-170">然后使用该读取器创建 XML 树。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-170">You then use the reader to create the XML tree.</span></span>  
  
### <a name="limit-the-depth-of-the-xml-hierarchy"></a><span data-ttu-id="bd0bc-171">限制 XML 层次结构的深度</span><span class="sxs-lookup"><span data-stu-id="bd0bc-171">Limit the Depth of the XML Hierarchy</span></span>  
 <span data-ttu-id="bd0bc-172">在提交具有过深层次结构的文档时，会发生一种可能的拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-172">One possible denial of service attack is when a document is submitted that has excessive depth of hierarchy.</span></span> <span data-ttu-id="bd0bc-173">为了防止这种情况的发生，可以将 <xref:System.Xml.XmlReader> 包装在您自己的可计算元素深度的类中。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-173">To prevent this, you can wrap a <xref:System.Xml.XmlReader> in your own class that counts the depth of elements.</span></span> <span data-ttu-id="bd0bc-174">如果深度超过预设的合理等级，您可以终止处理恶意文档。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-174">If the depth exceeds a predetermined reasonable level, you can terminate the processing of the malicious document.</span></span>  
  
### <a name="protect-against-untrusted-xmlreader-or-xmlwriter-implementations"></a><span data-ttu-id="bd0bc-175">防止不受信任的 XmlReader 或 XmlWriter 实现</span><span class="sxs-lookup"><span data-stu-id="bd0bc-175">Protect Against Untrusted XmlReader or XmlWriter Implementations</span></span>  
 <span data-ttu-id="bd0bc-176">管理员应验证任何外部提供的 <xref:System.Xml.XmlReader> 或 <xref:System.Xml.XmlWriter> 实现都要具有强名称且已经在计算机配置中注册。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-176">Administrators should verify that any externally supplied <xref:System.Xml.XmlReader> or <xref:System.Xml.XmlWriter> implementations have strong names and have been registered in the machine configuration.</span></span> <span data-ttu-id="bd0bc-177">这可防止加载伪装成读取器或编写器的恶意代码。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-177">This prevents malicious code masquerading as a reader or writer from being loaded.</span></span>  
  
### <a name="periodically-free-objects-that-reference-xname"></a><span data-ttu-id="bd0bc-178">定期释放引用 XName 的对象</span><span class="sxs-lookup"><span data-stu-id="bd0bc-178">Periodically Free Objects that Reference XName</span></span>  
 <span data-ttu-id="bd0bc-179">为防止某些类型的攻击，应用程序程序员应该定期释放引用应用程序域中的 <xref:System.Xml.Linq.XName> 对象的所有对象。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-179">To protect against certain kinds of attacks, application programmers should free all objects that reference an <xref:System.Xml.Linq.XName> object in the application domain on a regular basis.</span></span>  
  
### <a name="protect-against-random-xml-names"></a><span data-ttu-id="bd0bc-180">防止随机 XML 名称</span><span class="sxs-lookup"><span data-stu-id="bd0bc-180">Protect Against Random XML Names</span></span>  
 <span data-ttu-id="bd0bc-181">从不受信任的源中获取数据的应用程序应该考虑使用包装在自定义代码中的 <xref:System.Xml.XmlReader> 来检查是否可能会出现随机 XML 名称和命名空间。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-181">Applications that take data from untrusted sources should consider using an <xref:System.Xml.XmlReader> that is wrapped in custom code to inspect for the possibility of random XML names and namespaces.</span></span> <span data-ttu-id="bd0bc-182">如果检测到这样的随机 XML 名称和命名空间，则应用程序可以终止处理恶意文档。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-182">If such random XML names and namespaces are detected, the application can then terminate the processing of the malicious document.</span></span>  
  
 <span data-ttu-id="bd0bc-183">您可能需要将任何给定命名空间中的名称数目（包括不在命名空间中的名称）限制为合理的极限。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-183">You might want to limit the number of names in any given namespace (including names in no namespace) to a reasonable limit.</span></span>  
  
### <a name="annotations-are-accessible-by-software-components-that-share-a-linq-to-xml-tree"></a><span data-ttu-id="bd0bc-184">通过共享 LINQ to XML 树的软件组件可以访问批注</span><span class="sxs-lookup"><span data-stu-id="bd0bc-184">Annotations Are Accessible by Software Components that Share a LINQ to XML Tree</span></span>  
 <span data-ttu-id="bd0bc-185">LINQ to XML 可用于生成处理管道，其中的不同应用程序组件可分别加载、验证、查询、转换、更新和保存在组件之间作为 XML 树传递的 XML 数据。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-185">LINQ to XML could be used to build processing pipelines in which different application components load, validate, query, transform, update, and save XML data that is passed between components as XML trees.</span></span> <span data-ttu-id="bd0bc-186">这有助于优化性能，因为仅在管道末端消耗加载对象并将对象序列化为 XML 文本的系统资源。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-186">This can help optimize performance, because the overhead of loading and serializing objects to XML text is done only at the ends of the pipeline.</span></span> <span data-ttu-id="bd0bc-187">但开发人员必须知道，由一个组件创建的所有批注和事件处理程序都可以由其他组件访问。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-187">Developers must be aware, however, that all annotations and event handlers created by one component are accessible to other components.</span></span> <span data-ttu-id="bd0bc-188">如果组件的信任级别不同，这可能会造成很多安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-188">This can create a number of vulnerabilities if the components have different levels of trust.</span></span> <span data-ttu-id="bd0bc-189">若要在低信任级别的组件之间生成安全管道，在将数据传递给不受信任的组件之前，您必须将 LINQ to XML 对象序列化为 XML 文本。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-189">To build secure pipelines across less trusted components, you must serialize LINQ to XML objects to XML text before passing the data to an untrusted component.</span></span>  
  
 <span data-ttu-id="bd0bc-190">某些安全功能是由公共语言运行库 (CLR) 提供的。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-190">Some security is provided by the common language runtime (CLR).</span></span> <span data-ttu-id="bd0bc-191">例如，不包括私有类的组件无法访问由该类键控的批注。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-191">For example, a component that does not include a private class cannot access annotations keyed by that class.</span></span> <span data-ttu-id="bd0bc-192">但是，不能读取批注的组件却可以删除该批注。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-192">However, annotations can be deleted by components that cannot read them.</span></span> <span data-ttu-id="bd0bc-193">这可能用作篡改攻击。</span><span class="sxs-lookup"><span data-stu-id="bd0bc-193">This could be used as a tampering attack.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="bd0bc-194">请参阅</span><span class="sxs-lookup"><span data-stu-id="bd0bc-194">See also</span></span>

- [<span data-ttu-id="bd0bc-195">编程指南 (LINQ to XML) (C#)</span><span class="sxs-lookup"><span data-stu-id="bd0bc-195">Programming Guide (LINQ to XML) (C#)</span></span>](linq-to-xml-overview.md)
