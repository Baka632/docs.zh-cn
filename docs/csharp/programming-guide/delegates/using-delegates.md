---
title: 使用委托 - C# 编程指南
description: 了解如何使用委托。 委托是一种面向对象的类型安全的安全类型，可安全地封装方法。
ms.date: 07/20/2015
helpviewer_keywords:
- delegates [C#], how to use
ms.assetid: 99a2fc27-a32e-4a34-921c-e65497520eec
ms.openlocfilehash: a9b625b8c0785ed2f446be27c11dc76108bc4bce
ms.sourcegitcommit: 6f58a5f75ceeb936f8ee5b786e9adb81a9a3bee9
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/28/2020
ms.locfileid: "87302147"
---
# <a name="using-delegates-c-programming-guide"></a><span data-ttu-id="96f04-104">使用委托（C# 编程指南）</span><span class="sxs-lookup"><span data-stu-id="96f04-104">Using Delegates (C# Programming Guide)</span></span>

<span data-ttu-id="96f04-105">[委托](../../language-reference/builtin-types/reference-types.md)是安全封装方法的类型，类似于 C 和 C++ 中的函数指针。</span><span class="sxs-lookup"><span data-stu-id="96f04-105">A [delegate](../../language-reference/builtin-types/reference-types.md) is a type that safely encapsulates a method, similar to a function pointer in C and C++.</span></span> <span data-ttu-id="96f04-106">与 C 函数指针不同的是，委托是面向对象的、类型安全的和可靠的。</span><span class="sxs-lookup"><span data-stu-id="96f04-106">Unlike C function pointers, delegates are object-oriented, type safe, and secure.</span></span> <span data-ttu-id="96f04-107">委托的类型由委托的名称确定。</span><span class="sxs-lookup"><span data-stu-id="96f04-107">The type of a delegate is defined by the name of the delegate.</span></span> <span data-ttu-id="96f04-108">以下示例声明名为 `Del` 的委托，该委托可以封装采用[字符串](../../language-reference/builtin-types/reference-types.md)作为参数并返回 [void](../../language-reference/builtin-types/void.md) 的方法：</span><span class="sxs-lookup"><span data-stu-id="96f04-108">The following example declares a delegate named `Del` that can encapsulate a method that takes a [string](../../language-reference/builtin-types/reference-types.md) as an argument and returns [void](../../language-reference/builtin-types/void.md):</span></span>

[!code-csharp[csProgGuideDelegates#21](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#21)]

<span data-ttu-id="96f04-109">委托对象通常通过提供委托将封装的方法的名称或使用[匿名函数](../statements-expressions-operators/anonymous-functions.md)构造。</span><span class="sxs-lookup"><span data-stu-id="96f04-109">A delegate object is normally constructed by providing the name of the method the delegate will wrap, or with an [anonymous function](../statements-expressions-operators/anonymous-functions.md).</span></span> <span data-ttu-id="96f04-110">对委托进行实例化后，委托会将对其进行的方法调用传递到该方法。</span><span class="sxs-lookup"><span data-stu-id="96f04-110">Once a delegate is instantiated, a method call made to the delegate will be passed by the delegate to that method.</span></span> <span data-ttu-id="96f04-111">调用方传递到委托的参数将传递到该方法，并且委托会将方法的返回值（如果有）返回到调用方。</span><span class="sxs-lookup"><span data-stu-id="96f04-111">The parameters passed to the delegate by the caller are passed to the method, and the return value, if any, from the method is returned to the caller by the delegate.</span></span> <span data-ttu-id="96f04-112">这被称为调用委托。</span><span class="sxs-lookup"><span data-stu-id="96f04-112">This is known as invoking the delegate.</span></span> <span data-ttu-id="96f04-113">实例化的委托可以按封装的方法本身进行调用。</span><span class="sxs-lookup"><span data-stu-id="96f04-113">An instantiated delegate can be invoked as if it were the wrapped method itself.</span></span> <span data-ttu-id="96f04-114">例如：</span><span class="sxs-lookup"><span data-stu-id="96f04-114">For example:</span></span>

[!code-csharp[csProgGuideDelegates#22](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#22)]  

[!code-csharp[csProgGuideDelegates#23](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#23)]

<span data-ttu-id="96f04-115">委托类型派生自 .NET 中的 <xref:System.Delegate> 类。</span><span class="sxs-lookup"><span data-stu-id="96f04-115">Delegate types are derived from the <xref:System.Delegate> class in .NET.</span></span> <span data-ttu-id="96f04-116">委托类型是[密封的](../../language-reference/keywords/sealed.md)，它们不能派生自 <xref:System.Delegate>，也不能从其派生出自定义类。</span><span class="sxs-lookup"><span data-stu-id="96f04-116">Delegate types are [sealed](../../language-reference/keywords/sealed.md)—they cannot be derived from— and it is not possible to derive custom classes from <xref:System.Delegate>.</span></span> <span data-ttu-id="96f04-117">由于实例化的委托是一个对象，因此可以作为参数传递或分配给一个属性。</span><span class="sxs-lookup"><span data-stu-id="96f04-117">Because the instantiated delegate is an object, it can be passed as a parameter, or assigned to a property.</span></span> <span data-ttu-id="96f04-118">这允许方法接受委托作为参数并在稍后调用委托。</span><span class="sxs-lookup"><span data-stu-id="96f04-118">This allows a method to accept a delegate as a parameter, and call the delegate at some later time.</span></span> <span data-ttu-id="96f04-119">这被称为异步回调，是在长进程完成时通知调用方的常用方法。</span><span class="sxs-lookup"><span data-stu-id="96f04-119">This is known as an asynchronous callback, and is a common method of notifying a caller when a long process has completed.</span></span> <span data-ttu-id="96f04-120">当以这种方式使用委托时，使用委托的代码不需要知道要使用的实现方法。</span><span class="sxs-lookup"><span data-stu-id="96f04-120">When a delegate is used in this fashion, the code using the delegate does not need any knowledge of the implementation of the method being used.</span></span> <span data-ttu-id="96f04-121">功能类似于封装接口提供的功能。</span><span class="sxs-lookup"><span data-stu-id="96f04-121">The functionality is similar to the encapsulation interfaces provide.</span></span>

<span data-ttu-id="96f04-122">回调的另一个常见用途是定义自定义比较方法并将该委托传递到短方法。</span><span class="sxs-lookup"><span data-stu-id="96f04-122">Another common use of callbacks is defining a custom comparison method and passing that delegate to a sort method.</span></span> <span data-ttu-id="96f04-123">它允许调用方的代码成为排序算法的一部分。</span><span class="sxs-lookup"><span data-stu-id="96f04-123">It allows the caller's code to become part of the sort algorithm.</span></span> <span data-ttu-id="96f04-124">以下示例方法使用 `Del` 类型作为参数：</span><span class="sxs-lookup"><span data-stu-id="96f04-124">The following example method uses the `Del` type as a parameter:</span></span>

[!code-csharp[csProgGuideDelegates#24](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#24)]

<span data-ttu-id="96f04-125">然后，你可以将上面创建的委托传递到该方法：</span><span class="sxs-lookup"><span data-stu-id="96f04-125">You can then pass the delegate created above to that method:</span></span>

[!code-csharp[csProgGuideDelegates#25](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#25)]

<span data-ttu-id="96f04-126">并将以下输出接收到控制台：</span><span class="sxs-lookup"><span data-stu-id="96f04-126">and receive the following output to the console:</span></span>

```console
The number is: 3
```

<span data-ttu-id="96f04-127">以抽象方式使用委托时，`MethodWithCallback` 不需要直接调用控制台，记住，其不必设计为具有控制台。</span><span class="sxs-lookup"><span data-stu-id="96f04-127">Using the delegate as an abstraction, `MethodWithCallback` does not need to call the console directly—it does not have to be designed with a console in mind.</span></span> <span data-ttu-id="96f04-128">`MethodWithCallback` 的作用是简单准备字符串并将字符串传递到其他方法。</span><span class="sxs-lookup"><span data-stu-id="96f04-128">What `MethodWithCallback` does is simply prepare a string and pass the string to another method.</span></span> <span data-ttu-id="96f04-129">由于委托的方法可以使用任意数量的参数，此功能特别强大。</span><span class="sxs-lookup"><span data-stu-id="96f04-129">This is especially powerful since a delegated method can use any number of parameters.</span></span>

<span data-ttu-id="96f04-130">当委托构造为封装实例方法时，委托将同时引用实例和方法。</span><span class="sxs-lookup"><span data-stu-id="96f04-130">When a delegate is constructed to wrap an instance method, the delegate references both the instance and the method.</span></span> <span data-ttu-id="96f04-131">委托不知道除其所封装方法以外的实例类型，因此委托可以引用任何类型的对象，只要该对象上有与委托签名匹配的方法。</span><span class="sxs-lookup"><span data-stu-id="96f04-131">A delegate has no knowledge of the instance type aside from the method it wraps, so a delegate can refer to any type of object as long as there is a method on that object that matches the delegate signature.</span></span> <span data-ttu-id="96f04-132">当委托构造为封装静态方法时，委托仅引用方法。</span><span class="sxs-lookup"><span data-stu-id="96f04-132">When a delegate is constructed to wrap a static method, it only references the method.</span></span> <span data-ttu-id="96f04-133">请考虑以下声明：</span><span class="sxs-lookup"><span data-stu-id="96f04-133">Consider the following declarations:</span></span>

[!code-csharp[csProgGuideDelegates#26](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#26)]

<span data-ttu-id="96f04-134">加上之前显示的静态 `DelegateMethod`，我们现在已有三个 `Del` 实例可以封装的方法。</span><span class="sxs-lookup"><span data-stu-id="96f04-134">Along with the static `DelegateMethod` shown previously, we now have three methods that can be wrapped by a `Del` instance.</span></span>

<span data-ttu-id="96f04-135">调用时，委托可以调用多个方法。</span><span class="sxs-lookup"><span data-stu-id="96f04-135">A delegate can call more than one method when invoked.</span></span> <span data-ttu-id="96f04-136">这被称为多播。</span><span class="sxs-lookup"><span data-stu-id="96f04-136">This is referred to as multicasting.</span></span> <span data-ttu-id="96f04-137">若要向委托的方法列表（调用列表）添加其他方法，只需使用加法运算符或加法赋值运算符（“+”或“+=”）添加两个委托。</span><span class="sxs-lookup"><span data-stu-id="96f04-137">To add an extra method to the delegate's list of methods—the invocation list—simply requires adding two delegates using the addition or addition assignment operators ('+' or '+=').</span></span> <span data-ttu-id="96f04-138">例如：</span><span class="sxs-lookup"><span data-stu-id="96f04-138">For example:</span></span>

[!code-csharp[csProgGuideDelegates#27](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#27)]

<span data-ttu-id="96f04-139">此时，`allMethodsDelegate` 的调用列表中包含三个方法，分别为 `Method1`、`Method2` 和 `DelegateMethod`。</span><span class="sxs-lookup"><span data-stu-id="96f04-139">At this point `allMethodsDelegate` contains three methods in its invocation list—`Method1`, `Method2`, and `DelegateMethod`.</span></span> <span data-ttu-id="96f04-140">原有的三个委托（`d1`、`d2` 和 `d3`）保持不变。</span><span class="sxs-lookup"><span data-stu-id="96f04-140">The original three delegates, `d1`, `d2`, and `d3`, remain unchanged.</span></span> <span data-ttu-id="96f04-141">调用 `allMethodsDelegate` 时，将按顺序调用所有三个方法。</span><span class="sxs-lookup"><span data-stu-id="96f04-141">When `allMethodsDelegate` is invoked, all three methods are called in order.</span></span> <span data-ttu-id="96f04-142">如果委托使用引用参数，引用将按相反的顺序传递到所有这三个方法，并且一种方法进行的任何更改都将在另一种方法上见到。</span><span class="sxs-lookup"><span data-stu-id="96f04-142">If the delegate uses reference parameters, the reference is passed sequentially to each of the three methods in turn, and any changes by one method are visible to the next method.</span></span> <span data-ttu-id="96f04-143">当方法引发未在方法内捕获到的异常时，该异常将传递到委托的调用方，并且不会调用调用列表中的后续方法。</span><span class="sxs-lookup"><span data-stu-id="96f04-143">When any of the methods throws an exception that is not caught within the method, that exception is passed to the caller of the delegate and no subsequent methods in the invocation list are called.</span></span> <span data-ttu-id="96f04-144">如果委托具有返回值和/或输出参数，它将返回上次调用方法的返回值和参数。</span><span class="sxs-lookup"><span data-stu-id="96f04-144">If the delegate has a return value and/or out parameters, it returns the return value and parameters of the last method invoked.</span></span> <span data-ttu-id="96f04-145">若要删除调用列表中的方法，请使用[减法运算符或减法赋值运算符](../../language-reference/operators/subtraction-operator.md)（`-` 或 `-=`）。</span><span class="sxs-lookup"><span data-stu-id="96f04-145">To remove a method from the invocation list, use the [subtraction or subtraction assignment operators](../../language-reference/operators/subtraction-operator.md) (`-` or `-=`).</span></span> <span data-ttu-id="96f04-146">例如：</span><span class="sxs-lookup"><span data-stu-id="96f04-146">For example:</span></span>

[!code-csharp[csProgGuideDelegates#28](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#28)]

<span data-ttu-id="96f04-147">由于委托类型派生自 `System.Delegate`，因此可以在委托上调用该类定义的方法和属性。</span><span class="sxs-lookup"><span data-stu-id="96f04-147">Because delegate types are derived from `System.Delegate`, the methods and properties defined by that class can be called on the delegate.</span></span> <span data-ttu-id="96f04-148">例如，若要查询委托调用列表中方法的数量，你可以编写：</span><span class="sxs-lookup"><span data-stu-id="96f04-148">For example, to find the number of methods in a delegate's invocation list, you may write:</span></span>

[!code-csharp[csProgGuideDelegates#29](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#29)]

<span data-ttu-id="96f04-149">调用列表中具有多个方法的委托派生自 <xref:System.MulticastDelegate>，该类属于 `System.Delegate` 的子类。</span><span class="sxs-lookup"><span data-stu-id="96f04-149">Delegates with more than one method in their invocation list derive from <xref:System.MulticastDelegate>, which is a subclass of `System.Delegate`.</span></span> <span data-ttu-id="96f04-150">由于这两个类都支持 `GetInvocationList`，因此在其他情况下，上述代码也将产生作用。</span><span class="sxs-lookup"><span data-stu-id="96f04-150">The above code works in either case because both classes support `GetInvocationList`.</span></span>

<span data-ttu-id="96f04-151">多播委托广泛用于事件处理中。</span><span class="sxs-lookup"><span data-stu-id="96f04-151">Multicast delegates are used extensively in event handling.</span></span> <span data-ttu-id="96f04-152">事件源对象将事件通知发送到已注册接收该事件的接收方对象。</span><span class="sxs-lookup"><span data-stu-id="96f04-152">Event source objects send event notifications to recipient objects that have registered to receive that event.</span></span> <span data-ttu-id="96f04-153">若要注册一个事件，接收方需要创建用于处理该事件的方法，然后为该方法创建委托并将委托传递到事件源。</span><span class="sxs-lookup"><span data-stu-id="96f04-153">To register for an event, the recipient creates a method designed to handle the event, then creates a delegate for that method and passes the delegate to the event source.</span></span> <span data-ttu-id="96f04-154">事件发生时，源调用委托。</span><span class="sxs-lookup"><span data-stu-id="96f04-154">The source calls the delegate when the event occurs.</span></span> <span data-ttu-id="96f04-155">然后，委托将对接收方调用事件处理方法，从而提供事件数据。</span><span class="sxs-lookup"><span data-stu-id="96f04-155">The delegate then calls the event handling method on the recipient, delivering the event data.</span></span> <span data-ttu-id="96f04-156">给定事件的委托类型由事件源确定。</span><span class="sxs-lookup"><span data-stu-id="96f04-156">The delegate type for a given event is defined by the event source.</span></span> <span data-ttu-id="96f04-157">有关详细信息，请参阅[事件](../events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="96f04-157">For more, see [Events](../events/index.md).</span></span>

<span data-ttu-id="96f04-158">在编译时比较分配的两个不同类型的委托将导致编译错误。</span><span class="sxs-lookup"><span data-stu-id="96f04-158">Comparing delegates of two different types assigned at compile-time will result in a compilation error.</span></span> <span data-ttu-id="96f04-159">如果委托实例是静态的 `System.Delegate` 类型，则允许比较，但在运行时将返回 false。</span><span class="sxs-lookup"><span data-stu-id="96f04-159">If the delegate instances are statically of the type `System.Delegate`, then the comparison is allowed, but will return false at run time.</span></span> <span data-ttu-id="96f04-160">例如：</span><span class="sxs-lookup"><span data-stu-id="96f04-160">For example:</span></span>

[!code-csharp[csProgGuideDelegates#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#30)]

## <a name="see-also"></a><span data-ttu-id="96f04-161">另请参阅</span><span class="sxs-lookup"><span data-stu-id="96f04-161">See also</span></span>

- [<span data-ttu-id="96f04-162">C# 编程指南</span><span class="sxs-lookup"><span data-stu-id="96f04-162">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="96f04-163">委托</span><span class="sxs-lookup"><span data-stu-id="96f04-163">Delegates</span></span>](./index.md)
- [<span data-ttu-id="96f04-164">使用委托中的变体</span><span class="sxs-lookup"><span data-stu-id="96f04-164">Using Variance in Delegates</span></span>](../concepts/covariance-contravariance/using-variance-in-delegates.md)
- [<span data-ttu-id="96f04-165">委托中的变体</span><span class="sxs-lookup"><span data-stu-id="96f04-165">Variance in Delegates</span></span>](../concepts/covariance-contravariance/variance-in-delegates.md)
- [<span data-ttu-id="96f04-166">对 Func 和 Action 泛型委托使用变体</span><span class="sxs-lookup"><span data-stu-id="96f04-166">Using Variance for Func and Action Generic Delegates</span></span>](../concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)
- [<span data-ttu-id="96f04-167">事件</span><span class="sxs-lookup"><span data-stu-id="96f04-167">Events</span></span>](../events/index.md)
