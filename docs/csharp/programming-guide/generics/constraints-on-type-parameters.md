---
title: 类型参数约束 - C# 编程指南
description: 了解类型参数约束。 约束告知编译器类型参数必须具备的功能。
ms.date: 04/12/2018
helpviewer_keywords:
- generics [C#], type constraints
- type constraints [C#]
- type parameters [C#], constraints
- unbound type parameter [C#]
ms.openlocfilehash: 8230dfed11bb4ba21e922827cc1a525ce45ba3e5
ms.sourcegitcommit: 9d525bb8109216ca1dc9e39c149d4902f4b43da5
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/04/2020
ms.locfileid: "96599110"
---
# <a name="constraints-on-type-parameters-c-programming-guide"></a><span data-ttu-id="706ac-104">类型参数的约束（C# 编程指南）</span><span class="sxs-lookup"><span data-stu-id="706ac-104">Constraints on type parameters (C# Programming Guide)</span></span>

<span data-ttu-id="706ac-105">约束告知编译器类型参数必须具备的功能。</span><span class="sxs-lookup"><span data-stu-id="706ac-105">Constraints inform the compiler about the capabilities a type argument must have.</span></span> <span data-ttu-id="706ac-106">在没有任何约束的情况下，类型参数可以是任何类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-106">Without any constraints, the type argument could be any type.</span></span> <span data-ttu-id="706ac-107">编译器只能假定 <xref:System.Object?displayProperty=nameWithType> 的成员，它是任何 .NET 类型的最终基类。</span><span class="sxs-lookup"><span data-stu-id="706ac-107">The compiler can only assume the members of <xref:System.Object?displayProperty=nameWithType>, which is the ultimate base class for any .NET type.</span></span> <span data-ttu-id="706ac-108">有关详细信息，请参阅[使用约束的原因](#why-use-constraints)。</span><span class="sxs-lookup"><span data-stu-id="706ac-108">For more information, see [Why use constraints](#why-use-constraints).</span></span> <span data-ttu-id="706ac-109">如果客户端代码使用不满足约束的类型，编译器将发出错误。</span><span class="sxs-lookup"><span data-stu-id="706ac-109">If client code uses a type that doesn't satisfy a constraint, the compiler issues an error.</span></span> <span data-ttu-id="706ac-110">通过使用 `where` 上下文关键字指定约束。</span><span class="sxs-lookup"><span data-stu-id="706ac-110">Constraints are specified by using the `where` contextual keyword.</span></span> <span data-ttu-id="706ac-111">下表列出了各种类型的约束：</span><span class="sxs-lookup"><span data-stu-id="706ac-111">The following table lists the various types of constraints:</span></span>

|<span data-ttu-id="706ac-112">约束</span><span class="sxs-lookup"><span data-stu-id="706ac-112">Constraint</span></span>|<span data-ttu-id="706ac-113">描述</span><span class="sxs-lookup"><span data-stu-id="706ac-113">Description</span></span>|
|----------------|-----------------|
|`where T : struct`|<span data-ttu-id="706ac-114">类型参数必须是不可为 null 的[值类型](../../language-reference/builtin-types/value-types.md)。</span><span class="sxs-lookup"><span data-stu-id="706ac-114">The type argument must be a non-nullable [value type](../../language-reference/builtin-types/value-types.md).</span></span> <span data-ttu-id="706ac-115">有关可为 null 的值类型的信息，请参阅[可为 null 的值类型](../../language-reference/builtin-types/nullable-value-types.md)。</span><span class="sxs-lookup"><span data-stu-id="706ac-115">For information about nullable value types, see [Nullable value types](../../language-reference/builtin-types/nullable-value-types.md).</span></span> <span data-ttu-id="706ac-116">由于所有值类型都具有可访问的无参数构造函数，因此 `struct` 约束表示 `new()` 约束，并且不能与 `new()` 约束结合使用。</span><span class="sxs-lookup"><span data-stu-id="706ac-116">Because all value types have an accessible parameterless constructor, the `struct` constraint implies the `new()` constraint and can't be combined with the `new()` constraint.</span></span> <span data-ttu-id="706ac-117">`struct` 约束也不能与 `unmanaged` 约束结合使用。</span><span class="sxs-lookup"><span data-stu-id="706ac-117">You can't combine the `struct` constraint with the `unmanaged` constraint.</span></span>|
|`where T : class`|<span data-ttu-id="706ac-118">类型参数必须是引用类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-118">The type argument must be a reference type.</span></span> <span data-ttu-id="706ac-119">此约束还应用于任何类、接口、委托或数组类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-119">This constraint applies also to any class, interface, delegate, or array type.</span></span> <span data-ttu-id="706ac-120">在 C#8.0 或更高版本中的可为 null 上下文中，`T` 必须是不可为 null 的引用类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-120">In a nullable context in C# 8.0 or later, `T` must be a non-nullable reference type.</span></span> |
|`where T : class?`|<span data-ttu-id="706ac-121">类型参数必须是可为 null 或不可为 null 的引用类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-121">The type argument must be a reference type, either nullable or non-nullable.</span></span> <span data-ttu-id="706ac-122">此约束还应用于任何类、接口、委托或数组类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-122">This constraint applies also to any class, interface, delegate, or array type.</span></span>|
|`where T : notnull`|<span data-ttu-id="706ac-123">类型参数必须是不可为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-123">The type argument must be a non-nullable type.</span></span> <span data-ttu-id="706ac-124">参数可以是 C# 8.0 或更高版本中的不可为 null 的引用类型，也可以是不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-124">The argument can be a non-nullable reference type in C# 8.0 or later, or a non-nullable value type.</span></span> |
|`where T : unmanaged`|<span data-ttu-id="706ac-125">类型参数必须是不可为 null 的[非托管类型](../../language-reference/builtin-types/unmanaged-types.md)。</span><span class="sxs-lookup"><span data-stu-id="706ac-125">The type argument must be a non-nullable [unmanaged type](../../language-reference/builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="706ac-126">`unmanaged` 约束表示 `struct` 约束，且不能与 `struct` 约束或 `new()` 约束结合使用。</span><span class="sxs-lookup"><span data-stu-id="706ac-126">The `unmanaged` constraint implies the `struct` constraint and can't be combined with either the `struct` or `new()` constraints.</span></span>|
|`where T : new()`|<span data-ttu-id="706ac-127">类型参数必须具有公共无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="706ac-127">The type argument must have a public parameterless constructor.</span></span> <span data-ttu-id="706ac-128">与其他约束一起使用时，`new()` 约束必须最后指定。</span><span class="sxs-lookup"><span data-stu-id="706ac-128">When used together with other constraints, the `new()` constraint must be specified last.</span></span> <span data-ttu-id="706ac-129">`new()` 约束不能与 `struct` 和 `unmanaged` 约束结合使用。</span><span class="sxs-lookup"><span data-stu-id="706ac-129">The `new()` constraint can't be combined with the `struct` and `unmanaged` constraints.</span></span>|
|<span data-ttu-id="706ac-130">`where T :` *\<base class name>*</span><span class="sxs-lookup"><span data-stu-id="706ac-130">`where T :` *\<base class name>*</span></span>|<span data-ttu-id="706ac-131">类型参数必须是指定的基类或派生自指定的基类。</span><span class="sxs-lookup"><span data-stu-id="706ac-131">The type argument must be or derive from the specified base class.</span></span> <span data-ttu-id="706ac-132">在 C# 8.0 及更高版本中的可为 null 上下文中，`T` 必须是从指定基类派生的不可为 null 的引用类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-132">In a nullable context in C# 8.0 and later, `T` must be a non-nullable reference type derived from the specified base class.</span></span> |
|<span data-ttu-id="706ac-133">`where T :` *\<base class name>?*</span><span class="sxs-lookup"><span data-stu-id="706ac-133">`where T :` *\<base class name>?*</span></span>|<span data-ttu-id="706ac-134">类型参数必须是指定的基类或派生自指定的基类。</span><span class="sxs-lookup"><span data-stu-id="706ac-134">The type argument must be or derive from the specified base class.</span></span> <span data-ttu-id="706ac-135">在 C# 8.0 及更高版本中的可为 null 上下文中，`T` 可以是从指定基类派生的可为 null 或不可为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-135">In a nullable context in C# 8.0 and later, `T` may be either a nullable or non-nullable type derived from the specified base class.</span></span> |
|<span data-ttu-id="706ac-136">`where T :` *\<interface name>*</span><span class="sxs-lookup"><span data-stu-id="706ac-136">`where T :` *\<interface name>*</span></span>|<span data-ttu-id="706ac-137">类型参数必须是指定的接口或实现指定的接口。</span><span class="sxs-lookup"><span data-stu-id="706ac-137">The type argument must be or implement the specified interface.</span></span> <span data-ttu-id="706ac-138">可指定多个接口约束。</span><span class="sxs-lookup"><span data-stu-id="706ac-138">Multiple interface constraints can be specified.</span></span> <span data-ttu-id="706ac-139">约束接口也可以是泛型。</span><span class="sxs-lookup"><span data-stu-id="706ac-139">The constraining interface can also be generic.</span></span> <span data-ttu-id="706ac-140">在 C# 8.0 及更高版本中的可为 null 上下文中，`T` 必须是实现指定接口的不可为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-140">In a nullable context in C# 8.0 and later, `T` must be a non-nullable type that implements the specified interface.</span></span>|
|<span data-ttu-id="706ac-141">`where T :` *\<interface name>?*</span><span class="sxs-lookup"><span data-stu-id="706ac-141">`where T :` *\<interface name>?*</span></span>|<span data-ttu-id="706ac-142">类型参数必须是指定的接口或实现指定的接口。</span><span class="sxs-lookup"><span data-stu-id="706ac-142">The type argument must be or implement the specified interface.</span></span> <span data-ttu-id="706ac-143">可指定多个接口约束。</span><span class="sxs-lookup"><span data-stu-id="706ac-143">Multiple interface constraints can be specified.</span></span> <span data-ttu-id="706ac-144">约束接口也可以是泛型。</span><span class="sxs-lookup"><span data-stu-id="706ac-144">The constraining interface can also be generic.</span></span> <span data-ttu-id="706ac-145">在 C# 8.0 中的可为 null 上下文中，`T` 可以是可为 null 的引用类型、不可为 null 的引用类型或值类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-145">In a nullable context in C# 8.0, `T` may be a nullable reference type, a non-nullable reference type, or a value type.</span></span> <span data-ttu-id="706ac-146">`T` 不能是可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-146">`T` may not be a nullable value type.</span></span>|
|`where T : U`|<span data-ttu-id="706ac-147">为 `T` 提供的类型参数必须是为 `U` 提供的参数或派生自为 `U` 提供的参数。</span><span class="sxs-lookup"><span data-stu-id="706ac-147">The type argument supplied for `T` must be or derive from the argument supplied for `U`.</span></span> <span data-ttu-id="706ac-148">在可为 null 的上下文中，如果 `U` 是不可为 null 的引用类型，`T` 必须是不可为 null 的引用类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-148">In a nullable context, if `U` is a non-nullable reference type, `T` must be non-nullable reference type.</span></span> <span data-ttu-id="706ac-149">如果 `U` 是可为 null 的引用类型，则 `T` 可以是可为 null 的引用类型，也可以是不可为 null 的引用类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-149">If `U` is a nullable reference type, `T` may be either nullable or non-nullable.</span></span> |

## <a name="why-use-constraints"></a><span data-ttu-id="706ac-150">使用约束的原因</span><span class="sxs-lookup"><span data-stu-id="706ac-150">Why use constraints</span></span>

<span data-ttu-id="706ac-151">约束指定类型参数的功能和预期。</span><span class="sxs-lookup"><span data-stu-id="706ac-151">Constraints specify the capabilities and expectations of a type parameter.</span></span> <span data-ttu-id="706ac-152">声明这些约束意味着你可以使用约束类型的操作和方法调用。</span><span class="sxs-lookup"><span data-stu-id="706ac-152">Declaring those constraints means you can use the operations and method calls of the constraining type.</span></span> <span data-ttu-id="706ac-153">如果泛型类或方法对泛型成员使用除简单赋值之外的任何操作或调用 <xref:System.Object?displayProperty=nameWithType> 不支持的任何方法，则必须对类型参数应用约束。</span><span class="sxs-lookup"><span data-stu-id="706ac-153">If your generic class or method uses any operation on the generic members beyond simple assignment or calling any methods not supported by <xref:System.Object?displayProperty=nameWithType>, you'll have to apply constraints to the type parameter.</span></span> <span data-ttu-id="706ac-154">例如，基类约束告诉编译器，仅此类型的对象或派生自此类型的对象可用作类型参数。</span><span class="sxs-lookup"><span data-stu-id="706ac-154">For example, the base class constraint tells the compiler that only objects of this type or derived from this type will be used as type arguments.</span></span> <span data-ttu-id="706ac-155">编译器有了此保证后，就能够允许在泛型类中调用该类型的方法。</span><span class="sxs-lookup"><span data-stu-id="706ac-155">Once the compiler has this guarantee, it can allow methods of that type to be called in the generic class.</span></span> <span data-ttu-id="706ac-156">以下代码示例演示可通过应用基类约束添加到（[泛型介绍](../../../standard/generics/index.md)中的）`GenericList<T>` 类的功能。</span><span class="sxs-lookup"><span data-stu-id="706ac-156">The following code example demonstrates the functionality you can add to the `GenericList<T>` class (in [Introduction to Generics](../../../standard/generics/index.md)) by applying a base class constraint.</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#9)]

<span data-ttu-id="706ac-157">约束使泛型类能够使用 `Employee.Name` 属性。</span><span class="sxs-lookup"><span data-stu-id="706ac-157">The constraint enables the generic class to use the `Employee.Name` property.</span></span> <span data-ttu-id="706ac-158">约束指定类型 `T` 的所有项都保证是 `Employee` 对象或从 `Employee` 继承的对象。</span><span class="sxs-lookup"><span data-stu-id="706ac-158">The constraint specifies that all items of type `T` are guaranteed to be either an `Employee` object or an object that inherits from `Employee`.</span></span>

<span data-ttu-id="706ac-159">可以对同一类型参数应用多个约束，并且约束自身可以是泛型类型，如下所示：</span><span class="sxs-lookup"><span data-stu-id="706ac-159">Multiple constraints can be applied to the same type parameter, and the constraints themselves can be generic types, as follows:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#10)]

<span data-ttu-id="706ac-160">在应用 `where T : class` 约束时，请避免对类型参数使用 `==` 和 `!=` 运算符，因为这些运算符仅测试引用标识而不测试值相等性。</span><span class="sxs-lookup"><span data-stu-id="706ac-160">When applying the `where T : class` constraint, avoid the `==` and `!=` operators on the type parameter because these operators will test for reference identity only, not for value equality.</span></span> <span data-ttu-id="706ac-161">即使在用作参数的类型中重载这些运算符也会发生此行为。</span><span class="sxs-lookup"><span data-stu-id="706ac-161">This behavior occurs even if these operators are overloaded in a type that is used as an argument.</span></span> <span data-ttu-id="706ac-162">下面的代码说明了这一点；即使 <xref:System.String> 类重载 `==` 运算符，输出也为 false。</span><span class="sxs-lookup"><span data-stu-id="706ac-162">The following code illustrates this point; the output is false even though the <xref:System.String> class overloads the `==` operator.</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#11)]

<span data-ttu-id="706ac-163">编译器只知道 `T` 在编译时是引用类型，并且必须使用对所有引用类型都有效的默认运算符。</span><span class="sxs-lookup"><span data-stu-id="706ac-163">The compiler only knows that `T` is a reference type at compile time and must use the default operators that are valid for all reference types.</span></span> <span data-ttu-id="706ac-164">如果必须测试值相等性，建议同时应用 `where T : IEquatable<T>` 或 `where T : IComparable<T>` 约束，并在用于构造泛型类的任何类中实现该接口。</span><span class="sxs-lookup"><span data-stu-id="706ac-164">If you must test for value equality, the recommended way is to also apply the `where T : IEquatable<T>` or `where T : IComparable<T>` constraint and implement the interface in any class that will be used to construct the generic class.</span></span>

## <a name="constraining-multiple-parameters"></a><span data-ttu-id="706ac-165">约束多个参数</span><span class="sxs-lookup"><span data-stu-id="706ac-165">Constraining multiple parameters</span></span>

<span data-ttu-id="706ac-166">可以对多个参数应用多个约束，对一个参数应用多个约束，如下例所示：</span><span class="sxs-lookup"><span data-stu-id="706ac-166">You can apply constraints to multiple parameters, and multiple constraints to a single parameter, as shown in the following example:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#12)]

## <a name="unbounded-type-parameters"></a><span data-ttu-id="706ac-167">未绑定的类型参数</span><span class="sxs-lookup"><span data-stu-id="706ac-167">Unbounded type parameters</span></span>

 <span data-ttu-id="706ac-168">没有约束的类型参数（如公共类 `SampleClass<T>{}` 中的 T）称为未绑定的类型参数。</span><span class="sxs-lookup"><span data-stu-id="706ac-168">Type parameters that have no constraints, such as T in public class `SampleClass<T>{}`, are called unbounded type parameters.</span></span> <span data-ttu-id="706ac-169">未绑定的类型参数具有以下规则：</span><span class="sxs-lookup"><span data-stu-id="706ac-169">Unbounded type parameters have the following rules:</span></span>

- <span data-ttu-id="706ac-170">不能使用 `!=` 和 `==` 运算符，因为无法保证具体的类型参数能支持这些运算符。</span><span class="sxs-lookup"><span data-stu-id="706ac-170">The `!=` and `==` operators can't be used because there's no guarantee that the concrete type argument will support these operators.</span></span>
- <span data-ttu-id="706ac-171">可以在它们与 `System.Object` 之间来回转换，或将它们显式转换为任何接口类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-171">They can be converted to and from `System.Object` or explicitly converted to any interface type.</span></span>
- <span data-ttu-id="706ac-172">可以将它们与 [null](../../language-reference/keywords/null.md) 进行比较。</span><span class="sxs-lookup"><span data-stu-id="706ac-172">You can compare them to [null](../../language-reference/keywords/null.md).</span></span> <span data-ttu-id="706ac-173">将未绑定的参数与 `null` 进行比较时，如果类型参数为值类型，则该比较将始终返回 false。</span><span class="sxs-lookup"><span data-stu-id="706ac-173">If an unbounded parameter is compared to `null`, the comparison will always return false if the type argument is a value type.</span></span>

## <a name="type-parameters-as-constraints"></a><span data-ttu-id="706ac-174">类型参数作为约束</span><span class="sxs-lookup"><span data-stu-id="706ac-174">Type parameters as constraints</span></span>

<span data-ttu-id="706ac-175">在具有自己类型参数的成员函数必须将该参数约束为包含类型的类型参数时，将泛型类型参数用作约束非常有用，如下例所示：</span><span class="sxs-lookup"><span data-stu-id="706ac-175">The use of a generic type parameter as a constraint is useful when a member function with its own type parameter has to constrain that parameter to the type parameter of the containing type, as shown in the following example:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#13)]

<span data-ttu-id="706ac-176">在上述示例中，`T` 在 `Add` 方法的上下文中是一个类型约束，而在 `List` 类的上下文中是一个未绑定的类型参数。</span><span class="sxs-lookup"><span data-stu-id="706ac-176">In the previous example, `T` is a type constraint in the context of the `Add` method, and an unbounded type parameter in the context of the `List` class.</span></span>

<span data-ttu-id="706ac-177">类型参数还可在泛型类定义中用作约束。</span><span class="sxs-lookup"><span data-stu-id="706ac-177">Type parameters can also be used as constraints in generic class definitions.</span></span> <span data-ttu-id="706ac-178">必须在尖括号中声明该类型参数以及任何其他类型参数：</span><span class="sxs-lookup"><span data-stu-id="706ac-178">The type parameter must be declared within the angle brackets together with any other type parameters:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#14)]

<span data-ttu-id="706ac-179">类型参数作为泛型类的约束的作用非常有限，因为编译器除了假设类型参数派生自 `System.Object` 以外，不会做其他任何假设。</span><span class="sxs-lookup"><span data-stu-id="706ac-179">The usefulness of type parameters as constraints with generic classes is limited because the compiler can assume nothing about the type parameter except that it derives from `System.Object`.</span></span> <span data-ttu-id="706ac-180">如果要在两个类型参数之间强制继承关系，可以将类型参数用作泛型类的约束。</span><span class="sxs-lookup"><span data-stu-id="706ac-180">Use type parameters as constraints on generic classes in scenarios in which you want to enforce an inheritance relationship between two type parameters.</span></span>

## <a name="notnull-constraint"></a><span data-ttu-id="706ac-181">NotNull 约束</span><span class="sxs-lookup"><span data-stu-id="706ac-181">NotNull constraint</span></span>

<span data-ttu-id="706ac-182">从 C# 8.0 开始，在可为 null 上下文中，可以使用 `notnull` 约束指定类型参数必须是不可为 null 的值类型或不可为 null 的引用类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-182">Beginning with C# 8.0 in a nullable context, you can use the `notnull` constraint to specify that the type argument must be a non-nullable value type or non-nullable reference type.</span></span> <span data-ttu-id="706ac-183">`notnull` 约束只能在 `nullable enable` 上下文中使用。</span><span class="sxs-lookup"><span data-stu-id="706ac-183">The `notnull` constraint can only be used in a `nullable enable` context.</span></span> <span data-ttu-id="706ac-184">如果在可以为 null 的不明显上下文中添加 `notnull` 约束，则编译器将生成警告。</span><span class="sxs-lookup"><span data-stu-id="706ac-184">The compiler generates a warning if you add the `notnull` constraint in a nullable oblivious context.</span></span>

<span data-ttu-id="706ac-185">与其他约束不同，如果类型参数违反 `notnull` 约束，那么在 `nullable enable` 上下文中编译该代码时，编译器会生成警告。</span><span class="sxs-lookup"><span data-stu-id="706ac-185">Unlike other constraints, when a type argument violates the `notnull` constraint, the compiler generates a warning when that code is compiled in a `nullable enable` context.</span></span> <span data-ttu-id="706ac-186">如果在可以为 null 的不明显上下文中编译代码，则编译器不会生成任何警告或错误。</span><span class="sxs-lookup"><span data-stu-id="706ac-186">If the code is compiled in a nullable oblivious context, the compiler doesn't generate any warnings or errors.</span></span>

<span data-ttu-id="706ac-187">从 C# 8.0 开始，在可为 null 上下文中，`class` 约束指定类型参数必须是不可为 null 的引用类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-187">Beginning with C# 8.0 in a nullable context, the `class` constraint specifies that the type argument must be a non-nullable reference type.</span></span> <span data-ttu-id="706ac-188">在可为 null 上下文中，当类型参数是可为 null 的引用类型时，编译器会生成警告。</span><span class="sxs-lookup"><span data-stu-id="706ac-188">In a nullable context, when a type parameter is a nullable reference type, the compiler generates a warning.</span></span>

## <a name="unmanaged-constraint"></a><span data-ttu-id="706ac-189">非托管约束</span><span class="sxs-lookup"><span data-stu-id="706ac-189">Unmanaged constraint</span></span>

<span data-ttu-id="706ac-190">从 C# 7.3 开始，可使用 `unmanaged` 约束来指定类型参数必须是不可为 null 的[非托管类型](../../language-reference/builtin-types/unmanaged-types.md)。</span><span class="sxs-lookup"><span data-stu-id="706ac-190">Beginning with C# 7.3, you can use the `unmanaged` constraint to specify that the type parameter must be a non-nullable [unmanaged type](../../language-reference/builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="706ac-191">通过 `unmanaged` 约束，用户能编写可重用例程，从而使用可作为内存块操作的类型，如以下示例所示：</span><span class="sxs-lookup"><span data-stu-id="706ac-191">The `unmanaged` constraint enables you to write reusable routines to work with types that can be manipulated as blocks of memory, as shown in the following example:</span></span>

[!code-csharp[using the unmanaged constraint](snippets/GenericWhereConstraints.cs#15)]

<span data-ttu-id="706ac-192">以上方法必须在 `unsafe` 上下文中编译，因为它并不是在已知的内置类型上使用 `sizeof` 运算符。</span><span class="sxs-lookup"><span data-stu-id="706ac-192">The preceding method must be compiled in an `unsafe` context because it uses the `sizeof` operator on a type not known to be a built-in type.</span></span> <span data-ttu-id="706ac-193">如果没有 `unmanaged` 约束，则 `sizeof` 运算符不可用。</span><span class="sxs-lookup"><span data-stu-id="706ac-193">Without the `unmanaged` constraint, the `sizeof` operator is unavailable.</span></span>

<span data-ttu-id="706ac-194">`unmanaged` 约束表示 `struct` 约束，且不能与其结合使用。</span><span class="sxs-lookup"><span data-stu-id="706ac-194">The `unmanaged` constraint implies the `struct` constraint and can't be combined with it.</span></span> <span data-ttu-id="706ac-195">因为 `struct` 约束表示 `new()` 约束，且 `unmanaged` 约束也不能与 `new()` 约束结合使用。</span><span class="sxs-lookup"><span data-stu-id="706ac-195">Because the `struct` constraint implies the `new()` constraint, the `unmanaged` constraint can't be combined with the `new()` constraint as well.</span></span>

## <a name="delegate-constraints"></a><span data-ttu-id="706ac-196">委托约束</span><span class="sxs-lookup"><span data-stu-id="706ac-196">Delegate constraints</span></span>

<span data-ttu-id="706ac-197">同样从 C# 7.3 开始，可将 <xref:System.Delegate?displayProperty=nameWithType> 或 <xref:System.MulticastDelegate?displayProperty=nameWithType> 用作基类约束。</span><span class="sxs-lookup"><span data-stu-id="706ac-197">Also beginning with C# 7.3, you can use <xref:System.Delegate?displayProperty=nameWithType> or <xref:System.MulticastDelegate?displayProperty=nameWithType> as a base class constraint.</span></span> <span data-ttu-id="706ac-198">CLR 始终允许此约束，但 C# 语言不允许。</span><span class="sxs-lookup"><span data-stu-id="706ac-198">The CLR always allowed this constraint, but the C# language disallowed it.</span></span> <span data-ttu-id="706ac-199">使用 `System.Delegate` 约束，用户能够以类型安全的方式编写使用委托的代码。</span><span class="sxs-lookup"><span data-stu-id="706ac-199">The `System.Delegate` constraint enables you to write code that works with delegates in a type-safe manner.</span></span> <span data-ttu-id="706ac-200">以下代码定义了合并两个同类型委托的扩展方法：</span><span class="sxs-lookup"><span data-stu-id="706ac-200">The following code defines an extension method that combines two delegates provided they're the same type:</span></span>

[!code-csharp[using the delegate constraint](snippets/GenericWhereConstraints.cs#16)]

<span data-ttu-id="706ac-201">可使用上述方法来合并相同类型的委托：</span><span class="sxs-lookup"><span data-stu-id="706ac-201">You can use the above method to combine delegates that are the same type:</span></span>

[!code-csharp[using the unmanaged constraint](snippets/GenericWhereConstraints.cs#17)]

<span data-ttu-id="706ac-202">如果取消评论最后一行，它将不会编译。</span><span class="sxs-lookup"><span data-stu-id="706ac-202">If you uncomment the last line, it won't compile.</span></span> <span data-ttu-id="706ac-203">`first` 和 `test` 均为委托类型，但它们是不同的委托类型。</span><span class="sxs-lookup"><span data-stu-id="706ac-203">Both `first` and `test` are delegate types, but they're different delegate types.</span></span>

## <a name="enum-constraints"></a><span data-ttu-id="706ac-204">枚举约束</span><span class="sxs-lookup"><span data-stu-id="706ac-204">Enum constraints</span></span>

<span data-ttu-id="706ac-205">从 C# 7.3 开始，还可指定 <xref:System.Enum?displayProperty=nameWithType> 类型作为基类约束。</span><span class="sxs-lookup"><span data-stu-id="706ac-205">Beginning in C# 7.3, you can also specify the <xref:System.Enum?displayProperty=nameWithType> type as a base class constraint.</span></span> <span data-ttu-id="706ac-206">CLR 始终允许此约束，但 C# 语言不允许。</span><span class="sxs-lookup"><span data-stu-id="706ac-206">The CLR always allowed this constraint, but the C# language disallowed it.</span></span> <span data-ttu-id="706ac-207">使用 `System.Enum` 的泛型提供类型安全的编程，缓存使用 `System.Enum` 中静态方法的结果。</span><span class="sxs-lookup"><span data-stu-id="706ac-207">Generics using `System.Enum` provide type-safe programming to cache results from using the static methods in `System.Enum`.</span></span> <span data-ttu-id="706ac-208">以下示例查找枚举类型的所有有效的值，然后生成将这些值映射到其字符串表示形式的字典。</span><span class="sxs-lookup"><span data-stu-id="706ac-208">The following sample finds all the valid values for an enum type, and then builds a dictionary that maps those values to its string representation.</span></span>

[!code-csharp[using the enum constraint](snippets/GenericWhereConstraints.cs#18)]

<span data-ttu-id="706ac-209">`Enum.GetValues` 和 `Enum.GetName` 使用反射，这会对性能产生影响。</span><span class="sxs-lookup"><span data-stu-id="706ac-209">`Enum.GetValues` and `Enum.GetName` use reflection, which has performance implications.</span></span> <span data-ttu-id="706ac-210">可调用 `EnumNamedValues` 来生成可缓存和重用的集合，而不是重复执行需要反射才能实施的调用。</span><span class="sxs-lookup"><span data-stu-id="706ac-210">You can call `EnumNamedValues` to build a collection that is cached and reused rather than repeating the calls that require reflection.</span></span>

<span data-ttu-id="706ac-211">如以下示例所示，可使用它来创建枚举并生成其值和名称的字典：</span><span class="sxs-lookup"><span data-stu-id="706ac-211">You could use it as shown in the following sample to create an enum and build a dictionary of its values and names:</span></span>

[!code-csharp[enum definition](snippets/GenericWhereConstraints.cs#19)]

[!code-csharp[using the enum constrained method](snippets/GenericWhereConstraints.cs#20)]

## <a name="see-also"></a><span data-ttu-id="706ac-212">请参阅</span><span class="sxs-lookup"><span data-stu-id="706ac-212">See also</span></span>

- <xref:System.Collections.Generic>
- [<span data-ttu-id="706ac-213">C# 编程指南</span><span class="sxs-lookup"><span data-stu-id="706ac-213">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="706ac-214">泛型介绍</span><span class="sxs-lookup"><span data-stu-id="706ac-214">Introduction to Generics</span></span>](./index.md)
- [<span data-ttu-id="706ac-215">泛型类</span><span class="sxs-lookup"><span data-stu-id="706ac-215">Generic Classes</span></span>](./generic-classes.md)
- [<span data-ttu-id="706ac-216">new 约束</span><span class="sxs-lookup"><span data-stu-id="706ac-216">new Constraint</span></span>](../../language-reference/keywords/new-constraint.md)
