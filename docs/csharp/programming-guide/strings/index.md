---
title: 字符串 - C# 编程指南
description: 了解 C# 编程中的字符串。 请参阅有关声明和初始化字符串、字符串对象不可变性和字符串转义序列的信息。
ms.date: 06/27/2019
helpviewer_keywords:
- C# language, strings
- strings [C#]
ms.assetid: 21580405-cb25-4541-89d5-037846a38b07
ms.openlocfilehash: ba2bd6c90fa28624d52e7ef2e341b43da7ea19a2
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/24/2020
ms.locfileid: "91176209"
---
# <a name="strings-c-programming-guide"></a><span data-ttu-id="9009c-104">字符串（C# 编程指南）</span><span class="sxs-lookup"><span data-stu-id="9009c-104">Strings (C# Programming Guide)</span></span>

<span data-ttu-id="9009c-105">字符串是值为文本的 <xref:System.String> 类型对象。</span><span class="sxs-lookup"><span data-stu-id="9009c-105">A string is an object of type <xref:System.String> whose value is text.</span></span> <span data-ttu-id="9009c-106">文本在内部存储为 <xref:System.Char> 对象的依序只读集合。</span><span class="sxs-lookup"><span data-stu-id="9009c-106">Internally, the text is stored as a sequential read-only collection of <xref:System.Char> objects.</span></span> <span data-ttu-id="9009c-107">在 C# 字符串末尾没有 null 终止字符；因此，一个 C# 字符串可以包含任何数量的嵌入的 null 字符 ('\0')。</span><span class="sxs-lookup"><span data-stu-id="9009c-107">There is no null-terminating character at the end of a C# string; therefore a C# string can contain any number of embedded null characters ('\0').</span></span> <span data-ttu-id="9009c-108">字符串的 <xref:System.String.Length%2A> 属性表示其包含的 `Char` 对象数量，而非 Unicode 字符数。</span><span class="sxs-lookup"><span data-stu-id="9009c-108">The <xref:System.String.Length%2A> property of a string represents the number of `Char` objects it contains, not the number of Unicode characters.</span></span> <span data-ttu-id="9009c-109">若要访问字符串中的各个 Unicode 码位，请使用 <xref:System.Globalization.StringInfo> 对象。</span><span class="sxs-lookup"><span data-stu-id="9009c-109">To access the individual Unicode code points in a string, use the <xref:System.Globalization.StringInfo> object.</span></span>  
  
## <a name="string-vs-systemstring"></a><span data-ttu-id="9009c-110">string 与System.String</span><span class="sxs-lookup"><span data-stu-id="9009c-110">string vs. System.String</span></span>  

 <span data-ttu-id="9009c-111">在 C# 中，`string` 关键字是 <xref:System.String> 的别名。</span><span class="sxs-lookup"><span data-stu-id="9009c-111">In C#, the `string` keyword is an alias for <xref:System.String>.</span></span> <span data-ttu-id="9009c-112">因此，`String` 和 `string` 是等效的，你可以使用你所喜欢的任何一种命名约定。</span><span class="sxs-lookup"><span data-stu-id="9009c-112">Therefore, `String` and `string` are equivalent, and you can use whichever naming convention you prefer.</span></span> <span data-ttu-id="9009c-113">`String` 类提供了安全创建、操作和比较字符串的多种方法。</span><span class="sxs-lookup"><span data-stu-id="9009c-113">The `String` class provides many methods for safely creating, manipulating, and comparing strings.</span></span> <span data-ttu-id="9009c-114">此外，C# 语言重载了部分运算符，以简化常见字符串操作。</span><span class="sxs-lookup"><span data-stu-id="9009c-114">In addition, the C# language overloads some operators to simplify common string operations.</span></span> <span data-ttu-id="9009c-115">有关关键字的详细信息，请参阅 [string](../../language-reference/builtin-types/reference-types.md)。</span><span class="sxs-lookup"><span data-stu-id="9009c-115">For more information about the keyword, see [string](../../language-reference/builtin-types/reference-types.md).</span></span> <span data-ttu-id="9009c-116">有关类型及其方法的详细信息，请参阅 <xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="9009c-116">For more information about the type and its methods, see <xref:System.String>.</span></span>  
  
## <a name="declaring-and-initializing-strings"></a><span data-ttu-id="9009c-117">声明和初始化字符串</span><span class="sxs-lookup"><span data-stu-id="9009c-117">Declaring and Initializing Strings</span></span>  

 <span data-ttu-id="9009c-118">可以使用各种方法声明和初始化字符串，如以下示例中所示：</span><span class="sxs-lookup"><span data-stu-id="9009c-118">You can declare and initialize strings in various ways, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStrings#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#1)]  
  
 <span data-ttu-id="9009c-119">请注意，不要使用 [new](../../language-reference/operators/new-operator.md) 运算符创建字符串对象，除非使用字符数组初始化字符串。</span><span class="sxs-lookup"><span data-stu-id="9009c-119">Note that you do not use the [new](../../language-reference/operators/new-operator.md) operator to create a string object except when initializing the string with an array of chars.</span></span>  
  
 <span data-ttu-id="9009c-120">使用 <xref:System.String.Empty> 常量值初始化字符串，以新建字符串长度为零的 <xref:System.String> 对象。</span><span class="sxs-lookup"><span data-stu-id="9009c-120">Initialize a string with the <xref:System.String.Empty> constant value to create a new <xref:System.String> object whose string is of zero length.</span></span> <span data-ttu-id="9009c-121">长度为零的字符串文本表示法是“”。</span><span class="sxs-lookup"><span data-stu-id="9009c-121">The string literal representation of a zero-length string is "".</span></span> <span data-ttu-id="9009c-122">通过使用 <xref:System.String.Empty> 值（而不是 [null](../../language-reference/keywords/null.md)）初始化字符串，可以减少 <xref:System.NullReferenceException> 发生的可能性。</span><span class="sxs-lookup"><span data-stu-id="9009c-122">By initializing strings with the <xref:System.String.Empty> value instead of [null](../../language-reference/keywords/null.md), you can reduce the chances of a <xref:System.NullReferenceException> occurring.</span></span> <span data-ttu-id="9009c-123">尝试访问字符串前，先使用静态 <xref:System.String.IsNullOrEmpty%28System.String%29> 方法验证字符串的值。</span><span class="sxs-lookup"><span data-stu-id="9009c-123">Use the static <xref:System.String.IsNullOrEmpty%28System.String%29> method to verify the value of a string before you try to access it.</span></span>  
  
## <a name="immutability-of-string-objects"></a><span data-ttu-id="9009c-124">字符串对象的不可变性</span><span class="sxs-lookup"><span data-stu-id="9009c-124">Immutability of String Objects</span></span>  

 <span data-ttu-id="9009c-125">字符串对象是“不可变的”：它们在创建后无法更改。</span><span class="sxs-lookup"><span data-stu-id="9009c-125">String objects are *immutable*: they cannot be changed after they have been created.</span></span> <span data-ttu-id="9009c-126">看起来是在修改字符串的所有 <xref:System.String> 方法和 C# 运算符实际上都是在新的字符串对象中返回结果。</span><span class="sxs-lookup"><span data-stu-id="9009c-126">All of the <xref:System.String> methods and C# operators that appear to modify a string actually return the results in a new string object.</span></span> <span data-ttu-id="9009c-127">在下面的示例中，当 `s1` 和 `s2` 的内容被串联在一起以形成单个字符串时，两个原始字符串没有被修改。</span><span class="sxs-lookup"><span data-stu-id="9009c-127">In the following example, when the contents of `s1` and `s2` are concatenated to form a single string, the two original strings are unmodified.</span></span> <span data-ttu-id="9009c-128">`+=` 运算符创建一个新的字符串，其中包含组合的内容。</span><span class="sxs-lookup"><span data-stu-id="9009c-128">The `+=` operator creates a new string that contains the combined contents.</span></span> <span data-ttu-id="9009c-129">这个新对象被分配给变量 `s1`，而分配给 `s1` 的原始对象被释放，以供垃圾回收，因为没有任何其他变量包含对它的引用。</span><span class="sxs-lookup"><span data-stu-id="9009c-129">That new object is assigned to the variable `s1`, and the original object that was assigned to `s1` is released for garbage collection because no other variable holds a reference to it.</span></span>  
  
 [!code-csharp[csProgGuideStrings#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#2)]  
  
 <span data-ttu-id="9009c-130">由于字符串“modification”实际上是一个新创建的字符串，因此，必须在创建对字符串的引用时使用警告。</span><span class="sxs-lookup"><span data-stu-id="9009c-130">Because a string "modification" is actually a new string creation, you must use caution when you create references to strings.</span></span> <span data-ttu-id="9009c-131">如果创建了字符串的引用，然后“修改”了原始字符串，则该引用将继续指向原始对象，而非指向修改字符串时所创建的新对象。</span><span class="sxs-lookup"><span data-stu-id="9009c-131">If you create a reference to a string, and then "modify" the original string, the reference will continue to point to the original object instead of the new object that was created when the string was modified.</span></span> <span data-ttu-id="9009c-132">以下代码阐释了此行为：</span><span class="sxs-lookup"><span data-stu-id="9009c-132">The following code illustrates this behavior:</span></span>  
  
 [!code-csharp[csProgGuideStrings#25](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#25)]  
  
 <span data-ttu-id="9009c-133">有关如何创建基于修改的新字符串的详细信息，例如原始字符串上的搜索和替换操作，请参阅[如何修改字符串内容](../../how-to/modify-string-contents.md)。</span><span class="sxs-lookup"><span data-stu-id="9009c-133">For more information about how to create new strings that are based on modifications such as search and replace operations on the original string, see [How to modify string contents](../../how-to/modify-string-contents.md).</span></span>  
  
## <a name="regular-and-verbatim-string-literals"></a><span data-ttu-id="9009c-134">常规和逐字字符串文本</span><span class="sxs-lookup"><span data-stu-id="9009c-134">Regular and Verbatim String Literals</span></span>  

 <span data-ttu-id="9009c-135">在必须嵌入 C# 提供的转义字符时，使用常规字符串文本，如以下示例所示：</span><span class="sxs-lookup"><span data-stu-id="9009c-135">Use regular string literals when you must embed escape characters provided by C#, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStrings#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#3)]  
  
 <span data-ttu-id="9009c-136">当字符串文本包含反斜杠字符（例如在文件路径中）时，出于便捷性和更强的可读性的考虑，使用逐字字符串。</span><span class="sxs-lookup"><span data-stu-id="9009c-136">Use verbatim strings for convenience and better readability when the string text contains backslash characters, for example in file paths.</span></span> <span data-ttu-id="9009c-137">由于逐字字符串将新的行字符作为字符串文本的一部分保留，因此可将其用于初始化多行字符串。</span><span class="sxs-lookup"><span data-stu-id="9009c-137">Because verbatim strings preserve new line characters as part of the string text, they can be used to initialize multiline strings.</span></span> <span data-ttu-id="9009c-138">使用双引号在逐字字符串内部嵌入引号。</span><span class="sxs-lookup"><span data-stu-id="9009c-138">Use double quotation marks to embed a quotation mark inside a verbatim string.</span></span> <span data-ttu-id="9009c-139">下面的示例演示逐字字符串的一些常见用法：</span><span class="sxs-lookup"><span data-stu-id="9009c-139">The following example shows some common uses for verbatim strings:</span></span>  
  
 [!code-csharp[csProgGuideStrings#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#4)]  
  
## <a name="string-escape-sequences"></a><span data-ttu-id="9009c-140">字符串转义序列</span><span class="sxs-lookup"><span data-stu-id="9009c-140">String Escape Sequences</span></span>  
  
|<span data-ttu-id="9009c-141">转义序列</span><span class="sxs-lookup"><span data-stu-id="9009c-141">Escape sequence</span></span>|<span data-ttu-id="9009c-142">字符名称</span><span class="sxs-lookup"><span data-stu-id="9009c-142">Character name</span></span>|<span data-ttu-id="9009c-143">Unicode 编码</span><span class="sxs-lookup"><span data-stu-id="9009c-143">Unicode encoding</span></span>|  
|---------------------|--------------------|----------------------|  
|<span data-ttu-id="9009c-144">\\'</span><span class="sxs-lookup"><span data-stu-id="9009c-144">\\'</span></span>|<span data-ttu-id="9009c-145">单引号</span><span class="sxs-lookup"><span data-stu-id="9009c-145">Single quote</span></span>|<span data-ttu-id="9009c-146">0x0027</span><span class="sxs-lookup"><span data-stu-id="9009c-146">0x0027</span></span>|  
|<span data-ttu-id="9009c-147">\\"</span><span class="sxs-lookup"><span data-stu-id="9009c-147">\\"</span></span>|<span data-ttu-id="9009c-148">双引号</span><span class="sxs-lookup"><span data-stu-id="9009c-148">Double quote</span></span>|<span data-ttu-id="9009c-149">0x0022</span><span class="sxs-lookup"><span data-stu-id="9009c-149">0x0022</span></span>|  
|\\\\ |<span data-ttu-id="9009c-150">反斜杠</span><span class="sxs-lookup"><span data-stu-id="9009c-150">Backslash</span></span>|<span data-ttu-id="9009c-151">0x005C</span><span class="sxs-lookup"><span data-stu-id="9009c-151">0x005C</span></span>|  
|<span data-ttu-id="9009c-152">\0</span><span class="sxs-lookup"><span data-stu-id="9009c-152">\0</span></span>|<span data-ttu-id="9009c-153">null</span><span class="sxs-lookup"><span data-stu-id="9009c-153">Null</span></span>|<span data-ttu-id="9009c-154">0x0000</span><span class="sxs-lookup"><span data-stu-id="9009c-154">0x0000</span></span>|  
|<span data-ttu-id="9009c-155">\a</span><span class="sxs-lookup"><span data-stu-id="9009c-155">\a</span></span>|<span data-ttu-id="9009c-156">警报</span><span class="sxs-lookup"><span data-stu-id="9009c-156">Alert</span></span>|<span data-ttu-id="9009c-157">0x0007</span><span class="sxs-lookup"><span data-stu-id="9009c-157">0x0007</span></span>|  
|<span data-ttu-id="9009c-158">\b</span><span class="sxs-lookup"><span data-stu-id="9009c-158">\b</span></span>|<span data-ttu-id="9009c-159">Backspace</span><span class="sxs-lookup"><span data-stu-id="9009c-159">Backspace</span></span>|<span data-ttu-id="9009c-160">0x0008</span><span class="sxs-lookup"><span data-stu-id="9009c-160">0x0008</span></span>|  
|<span data-ttu-id="9009c-161">\f</span><span class="sxs-lookup"><span data-stu-id="9009c-161">\f</span></span>|<span data-ttu-id="9009c-162">换页</span><span class="sxs-lookup"><span data-stu-id="9009c-162">Form feed</span></span>|<span data-ttu-id="9009c-163">0x000C</span><span class="sxs-lookup"><span data-stu-id="9009c-163">0x000C</span></span>|  
|<span data-ttu-id="9009c-164">\n</span><span class="sxs-lookup"><span data-stu-id="9009c-164">\n</span></span>|<span data-ttu-id="9009c-165">换行</span><span class="sxs-lookup"><span data-stu-id="9009c-165">New line</span></span>|<span data-ttu-id="9009c-166">0x000A</span><span class="sxs-lookup"><span data-stu-id="9009c-166">0x000A</span></span>|  
|<span data-ttu-id="9009c-167">\r</span><span class="sxs-lookup"><span data-stu-id="9009c-167">\r</span></span>|<span data-ttu-id="9009c-168">回车</span><span class="sxs-lookup"><span data-stu-id="9009c-168">Carriage return</span></span>|<span data-ttu-id="9009c-169">0x000D</span><span class="sxs-lookup"><span data-stu-id="9009c-169">0x000D</span></span>|  
|<span data-ttu-id="9009c-170">\t</span><span class="sxs-lookup"><span data-stu-id="9009c-170">\t</span></span>|<span data-ttu-id="9009c-171">水平制表符</span><span class="sxs-lookup"><span data-stu-id="9009c-171">Horizontal tab</span></span>|<span data-ttu-id="9009c-172">0x0009</span><span class="sxs-lookup"><span data-stu-id="9009c-172">0x0009</span></span>|  
|<span data-ttu-id="9009c-173">\v</span><span class="sxs-lookup"><span data-stu-id="9009c-173">\v</span></span>|<span data-ttu-id="9009c-174">垂直制表符</span><span class="sxs-lookup"><span data-stu-id="9009c-174">Vertical tab</span></span>|<span data-ttu-id="9009c-175">0x000B</span><span class="sxs-lookup"><span data-stu-id="9009c-175">0x000B</span></span>|  
|<span data-ttu-id="9009c-176">\u</span><span class="sxs-lookup"><span data-stu-id="9009c-176">\u</span></span>|<span data-ttu-id="9009c-177">Unicode 转义序列 (UTF-16)</span><span class="sxs-lookup"><span data-stu-id="9009c-177">Unicode escape sequence (UTF-16)</span></span>|<span data-ttu-id="9009c-178">`\uHHHH`（范围：0000 - FFFF；示例：`\u00E7` =“ç”）</span><span class="sxs-lookup"><span data-stu-id="9009c-178">`\uHHHH` (range: 0000 - FFFF; example: `\u00E7` = "ç")</span></span>|  
|<span data-ttu-id="9009c-179">\U</span><span class="sxs-lookup"><span data-stu-id="9009c-179">\U</span></span>|<span data-ttu-id="9009c-180">Unicode 转义序列 (UTF-32)</span><span class="sxs-lookup"><span data-stu-id="9009c-180">Unicode escape sequence (UTF-32)</span></span>|<span data-ttu-id="9009c-181">`\U00HHHHHH`（范围：000000 - 10FFFF；示例：`\U0001F47D` =“&#x1F47D;”)</span><span class="sxs-lookup"><span data-stu-id="9009c-181">`\U00HHHHHH` (range: 000000 - 10FFFF; example: `\U0001F47D` = "&#x1F47D;")</span></span>|  
|<span data-ttu-id="9009c-182">\x</span><span class="sxs-lookup"><span data-stu-id="9009c-182">\x</span></span>|<span data-ttu-id="9009c-183">除长度可变外，Unicode 转义序列与“\u”类似</span><span class="sxs-lookup"><span data-stu-id="9009c-183">Unicode escape sequence similar to "\u" except with variable length</span></span>|<span data-ttu-id="9009c-184">`\xH[H][H][H]`（范围：0 - FFFF；示例：`\x00E7`、`\x0E7` 或 `\xE7` =“ç”）</span><span class="sxs-lookup"><span data-stu-id="9009c-184">`\xH[H][H][H]` (range: 0 - FFFF; example: `\x00E7` or `\x0E7` or `\xE7` = "ç")</span></span>|  
  
> [!WARNING]
> <span data-ttu-id="9009c-185">使用 `\x` 转义序列且指定的位数小于 4 个十六进制数字时，如果紧跟在转义序列后面的字符是有效的十六进制数字（即 0-9、A-F 和 a-f），则这些字符将被解释为转义序列的一部分。</span><span class="sxs-lookup"><span data-stu-id="9009c-185">When using the `\x` escape sequence and specifying less than 4 hex digits, if the characters that immediately follow the escape sequence are valid hex digits (i.e. 0-9, A-F, and a-f), they will be interpreted as being part of the escape sequence.</span></span> <span data-ttu-id="9009c-186">例如，`\xA1` 会生成“&#161;”，即码位 U+00A1。</span><span class="sxs-lookup"><span data-stu-id="9009c-186">For example, `\xA1` produces "&#161;", which is code point U+00A1.</span></span> <span data-ttu-id="9009c-187">但是，如果下一个字符是“A”或“a”，则转义序列将转而被解释为 `\xA1A` 并生成“&#x0A1A;”（即码位 U+0A1A）。</span><span class="sxs-lookup"><span data-stu-id="9009c-187">However, if the next character is "A" or "a", then the escape sequence will instead be interpreted as being `\xA1A` and produce "&#x0A1A;", which is code point U+0A1A.</span></span> <span data-ttu-id="9009c-188">在此类情况下，如果指定全部 4 个十六进制数字（例如 `\x00A1`），则可能导致解释出错。</span><span class="sxs-lookup"><span data-stu-id="9009c-188">In such cases, specifying all 4 hex digits (e.g. `\x00A1` ) will prevent any possible misinterpretation.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9009c-189">在编译时，逐字字符串被转换为普通字符串，并具有所有相同的转义序列。</span><span class="sxs-lookup"><span data-stu-id="9009c-189">At compile time, verbatim strings are converted to ordinary strings with all the same escape sequences.</span></span> <span data-ttu-id="9009c-190">因此，如果在调试器监视窗口中查看逐字字符串，将看到由编译器添加的转义字符，而不是来自你的源代码的逐字字符串版本。</span><span class="sxs-lookup"><span data-stu-id="9009c-190">Therefore, if you view a verbatim string in the debugger watch window, you will see the escape characters that were added by the compiler, not the verbatim version from your source code.</span></span> <span data-ttu-id="9009c-191">例如，原义字符串 `@"C:\files.txt"` 在监视窗口中显示为“C:\\\files.txt”。</span><span class="sxs-lookup"><span data-stu-id="9009c-191">For example, the verbatim string `@"C:\files.txt"` will appear in the watch window as "C:\\\files.txt".</span></span>  
  
## <a name="format-strings"></a><span data-ttu-id="9009c-192">格式字符串</span><span class="sxs-lookup"><span data-stu-id="9009c-192">Format Strings</span></span>  

 <span data-ttu-id="9009c-193">格式字符串是在运行时以动态方式确定其内容的字符串。</span><span class="sxs-lookup"><span data-stu-id="9009c-193">A format string is a string whose contents are determined dynamically at runtime.</span></span> <span data-ttu-id="9009c-194">格式字符串是通过将内插表达式或占位符嵌入字符串大括号内创建的。</span><span class="sxs-lookup"><span data-stu-id="9009c-194">Format strings are created by embedding *interpolated expressions* or placeholders inside of braces within a string.</span></span> <span data-ttu-id="9009c-195">大括号 (`{...}`) 中的所有内容都将解析为一个值，并在运行时以格式化字符串的形式输出。</span><span class="sxs-lookup"><span data-stu-id="9009c-195">Everything inside the braces (`{...}`) will be resolved to a value and output as a formatted string at runtime.</span></span> <span data-ttu-id="9009c-196">有两种方法创建格式字符串：字符串内插和复合格式。</span><span class="sxs-lookup"><span data-stu-id="9009c-196">There are two methods to create format strings: string interpolation and composite formatting.</span></span>

### <a name="string-interpolation"></a><span data-ttu-id="9009c-197">字符串内插</span><span class="sxs-lookup"><span data-stu-id="9009c-197">String Interpolation</span></span>

<span data-ttu-id="9009c-198">在 C# 6.0 及更高版本中提供，[内插字符串](../../language-reference/tokens/interpolated.md)由 `$` 特殊字符标识，并在大括号中包含内插表达式。</span><span class="sxs-lookup"><span data-stu-id="9009c-198">Available in C# 6.0 and later, [*interpolated strings*](../../language-reference/tokens/interpolated.md) are identified by the `$` special character and include interpolated expressions in braces.</span></span> <span data-ttu-id="9009c-199">如果不熟悉字符串内插，请参阅[字符串内插 - C# 交互式教程](../../tutorials/exploration/interpolated-strings.yml)快速概览。</span><span class="sxs-lookup"><span data-stu-id="9009c-199">If you are new to string interpolation, see the [String interpolation - C# interactive tutorial](../../tutorials/exploration/interpolated-strings.yml) for a quick overview.</span></span>

<span data-ttu-id="9009c-200">使用字符串内插来改善代码的可读性和可维护性。</span><span class="sxs-lookup"><span data-stu-id="9009c-200">Use string interpolation to improve the readability and maintainability of your code.</span></span> <span data-ttu-id="9009c-201">字符串内插可实现与 `String.Format` 方法相同的结果，但提高了易用性和内联清晰度。</span><span class="sxs-lookup"><span data-stu-id="9009c-201">String interpolation achieves the same results as the `String.Format` method, but improves ease of use and inline clarity.</span></span>

[!code-csharp[csProgGuideFormatStrings](~/samples/snippets/csharp/programming-guide/strings/Strings_1.cs#StringInterpolation)]

### <a name="composite-formatting"></a><span data-ttu-id="9009c-202">复合格式设置</span><span class="sxs-lookup"><span data-stu-id="9009c-202">Composite Formatting</span></span>

<span data-ttu-id="9009c-203"><xref:System.String.Format%2A?displayProperty=nameWithType> 利用大括号中的占位符创建格式字符串。</span><span class="sxs-lookup"><span data-stu-id="9009c-203">The <xref:System.String.Format%2A?displayProperty=nameWithType> utilizes placeholders in braces to create a format string.</span></span> <span data-ttu-id="9009c-204">此示例生成与上面使用的字符串内插方法类似的输出。</span><span class="sxs-lookup"><span data-stu-id="9009c-204">This example results in similar output to the string interpolation method used above.</span></span>
  
[!code-csharp[csProgGuideFormatStrings](~/samples/snippets/csharp/programming-guide/strings/Strings_1.cs#StringFormat)]

<span data-ttu-id="9009c-205">有关设置 .NET 类型格式的详细信息，请参阅 [.NET 中的格式设置类型](../../../standard/base-types/formatting-types.md)。</span><span class="sxs-lookup"><span data-stu-id="9009c-205">For more information on formatting .NET types see [Formatting Types in .NET](../../../standard/base-types/formatting-types.md).</span></span>
  
## <a name="substrings"></a><span data-ttu-id="9009c-206">子字符串</span><span class="sxs-lookup"><span data-stu-id="9009c-206">Substrings</span></span>  

 <span data-ttu-id="9009c-207">子字符串是包含在字符串中的任何字符序列。</span><span class="sxs-lookup"><span data-stu-id="9009c-207">A substring is any sequence of characters that is contained in a string.</span></span> <span data-ttu-id="9009c-208">使用 <xref:System.String.Substring%2A> 方法可以通过原始字符串的一部分新建字符串。</span><span class="sxs-lookup"><span data-stu-id="9009c-208">Use the <xref:System.String.Substring%2A> method to create a new string from a part of the original string.</span></span> <span data-ttu-id="9009c-209">可以使用 <xref:System.String.IndexOf%2A> 方法搜索一次或多次出现的子字符串。</span><span class="sxs-lookup"><span data-stu-id="9009c-209">You can search for one or more occurrences of a substring by using the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="9009c-210">使用 <xref:System.String.Replace%2A> 方法可以将出现的所有指定子字符串替换为新字符串。</span><span class="sxs-lookup"><span data-stu-id="9009c-210">Use the <xref:System.String.Replace%2A> method to replace all occurrences of a specified substring with a new string.</span></span> <span data-ttu-id="9009c-211">与 <xref:System.String.Substring%2A> 方法一样，<xref:System.String.Replace%2A> 实际返回的是新字符串，且不修改原始字符串。</span><span class="sxs-lookup"><span data-stu-id="9009c-211">Like the <xref:System.String.Substring%2A> method, <xref:System.String.Replace%2A> actually returns a new string and does not modify the original string.</span></span> <span data-ttu-id="9009c-212">有关详细信息，请参阅[如何搜索字符串](../../how-to/search-strings.md)和[如何修改字符串内容](../../how-to/modify-string-contents.md)。</span><span class="sxs-lookup"><span data-stu-id="9009c-212">For more information, see [How to search strings](../../how-to/search-strings.md) and [How to modify string contents](../../how-to/modify-string-contents.md).</span></span>
  
 [!code-csharp[csProgGuideStrings#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#7)]  
  
## <a name="accessing-individual-characters"></a><span data-ttu-id="9009c-213">访问单个字符</span><span class="sxs-lookup"><span data-stu-id="9009c-213">Accessing Individual Characters</span></span>  

 <span data-ttu-id="9009c-214">可以使用包含索引值的数组表示法来获取对单个字符的只读访问权限，如下面的示例中所示：</span><span class="sxs-lookup"><span data-stu-id="9009c-214">You can use array notation with an index value to acquire read-only access to individual characters, as in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStrings#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#8)]  
  
 <span data-ttu-id="9009c-215">如果 <xref:System.String> 方法不提供修改字符串中的各个字符所需的功能，可以使用 <xref:System.Text.StringBuilder> 对象“就地”修改各个字符，再新建字符串来使用 <xref:System.Text.StringBuilder> 方法存储结果。</span><span class="sxs-lookup"><span data-stu-id="9009c-215">If the <xref:System.String> methods do not provide the functionality that you must have to modify individual characters in a string, you can use a <xref:System.Text.StringBuilder> object to modify the individual chars "in-place", and then create a new string to store the results by using the <xref:System.Text.StringBuilder> methods.</span></span> <span data-ttu-id="9009c-216">在下面的示例中，假定必须以特定方式修改原始字符串，然后存储结果以供未来使用：</span><span class="sxs-lookup"><span data-stu-id="9009c-216">In the following example, assume that you must modify the original string in a particular way and then store the results for future use:</span></span>  
  
 [!code-csharp[csProgGuideStrings#27](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#27)]  
  
## <a name="null-strings-and-empty-strings"></a><span data-ttu-id="9009c-217">Null 字符串和空字符串</span><span class="sxs-lookup"><span data-stu-id="9009c-217">Null Strings and Empty Strings</span></span>  

 <span data-ttu-id="9009c-218">空字符串是包含零个字符的 <xref:System.String?displayProperty=nameWithType> 对象实例。</span><span class="sxs-lookup"><span data-stu-id="9009c-218">An empty string is an instance of a <xref:System.String?displayProperty=nameWithType> object that contains zero characters.</span></span> <span data-ttu-id="9009c-219">空字符串常用在各种编程方案中，表示空文本字段。</span><span class="sxs-lookup"><span data-stu-id="9009c-219">Empty strings are used often in various programming scenarios to represent a blank text field.</span></span> <span data-ttu-id="9009c-220">可以对空字符串调用方法，因为它们是有效的 <xref:System.String?displayProperty=nameWithType> 对象。</span><span class="sxs-lookup"><span data-stu-id="9009c-220">You can call methods on empty strings because they are valid <xref:System.String?displayProperty=nameWithType> objects.</span></span> <span data-ttu-id="9009c-221">对空字符串进行了初始化，如下所示：</span><span class="sxs-lookup"><span data-stu-id="9009c-221">Empty strings are initialized as follows:</span></span>  
  
```csharp  
string s = String.Empty;  
```  
  
 <span data-ttu-id="9009c-222">相比较而言，null 字符串并不指 <xref:System.String?displayProperty=nameWithType> 对象实例，只要尝试对 null 字符串调用方法，都会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="9009c-222">By contrast, a null string does not refer to an instance of a <xref:System.String?displayProperty=nameWithType> object and any attempt to call a method on a null string causes a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="9009c-223">但是，可以在串联和与其他字符串的比较操作中使用 null 字符串。</span><span class="sxs-lookup"><span data-stu-id="9009c-223">However, you can use null strings in concatenation and comparison operations with other strings.</span></span> <span data-ttu-id="9009c-224">以下示例说明了对 null 字符串的引用会引发和不会引发意外的某些情况：</span><span class="sxs-lookup"><span data-stu-id="9009c-224">The following examples illustrate some cases in which a reference to a null string does and does not cause an exception to be thrown:</span></span>  
  
 [!code-csharp[csProgGuideStrings#20](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#20)]  
  
## <a name="using-stringbuilder-for-fast-string-creation"></a><span data-ttu-id="9009c-225">使用 StringBuilder 快速创建字符串</span><span class="sxs-lookup"><span data-stu-id="9009c-225">Using StringBuilder for Fast String Creation</span></span>  

 <span data-ttu-id="9009c-226">.NET 中的字符串操作进行了高度的优化，在大多数情况下不会显著影响性能。</span><span class="sxs-lookup"><span data-stu-id="9009c-226">String operations in .NET are highly optimized and in most cases do not significantly impact performance.</span></span> <span data-ttu-id="9009c-227">但是，在某些情况下（例如，执行数百次或数千次的紧密循环），字符串操作可能影响性能。</span><span class="sxs-lookup"><span data-stu-id="9009c-227">However, in some scenarios such as tight loops that are executing many hundreds or thousands of times, string operations can affect performance.</span></span> <span data-ttu-id="9009c-228"><xref:System.Text.StringBuilder> 类创建字符串缓冲区，用于在程序执行多个字符串操控时提升性能。</span><span class="sxs-lookup"><span data-stu-id="9009c-228">The <xref:System.Text.StringBuilder> class creates a string buffer that offers better performance if your program performs many string manipulations.</span></span> <span data-ttu-id="9009c-229">使用 <xref:System.Text.StringBuilder> 字符串，还可以重新分配各个字符，而内置字符串数据类型则不支持这样做。</span><span class="sxs-lookup"><span data-stu-id="9009c-229">The <xref:System.Text.StringBuilder> string also enables you to reassign individual characters, something the built-in string data type does not support.</span></span> <span data-ttu-id="9009c-230">例如，此代码更改字符串的内容，而无需创建新的字符串：</span><span class="sxs-lookup"><span data-stu-id="9009c-230">This code, for example, changes the content of a string without creating a new string:</span></span>  
  
 [!code-csharp[csProgGuideStrings#15](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#15)]  
  
 <span data-ttu-id="9009c-231">在以下示例中，<xref:System.Text.StringBuilder> 对象用于通过一组数字类型创建字符串：</span><span class="sxs-lookup"><span data-stu-id="9009c-231">In this example, a <xref:System.Text.StringBuilder> object is used to create a string from a set of numeric types:</span></span>  
  
 [!code-csharp[TestStringBuilder#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/TestStringBuilder.cs)]
  
## <a name="strings-extension-methods-and-linq"></a><span data-ttu-id="9009c-232">字符串、扩展方法和 LINQ</span><span class="sxs-lookup"><span data-stu-id="9009c-232">Strings, Extension Methods and LINQ</span></span>  

 <span data-ttu-id="9009c-233">由于 <xref:System.String> 类型实现 <xref:System.Collections.Generic.IEnumerable%601>，因此可以对字符串使用 <xref:System.Linq.Enumerable> 类中定义的扩展方法。</span><span class="sxs-lookup"><span data-stu-id="9009c-233">Because the <xref:System.String> type implements <xref:System.Collections.Generic.IEnumerable%601>, you can use the extension methods defined in the <xref:System.Linq.Enumerable> class on strings.</span></span> <span data-ttu-id="9009c-234">为了避免视觉干扰，这些方法已从 <xref:System.String> 类型的 IntelliSense 中排除，但它们仍然可用。</span><span class="sxs-lookup"><span data-stu-id="9009c-234">To avoid visual clutter, these methods are excluded from IntelliSense for the <xref:System.String> type, but they are available nevertheless.</span></span> <span data-ttu-id="9009c-235">还可以使用字符串上的 LINQ 查询表达式。</span><span class="sxs-lookup"><span data-stu-id="9009c-235">You can also use LINQ query expressions on strings.</span></span> <span data-ttu-id="9009c-236">有关详细信息，请参阅 [LINQ 和字符串](../concepts/linq/linq-and-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="9009c-236">For more information, see [LINQ and Strings](../concepts/linq/linq-and-strings.md).</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="9009c-237">相关主题</span><span class="sxs-lookup"><span data-stu-id="9009c-237">Related Topics</span></span>  
  
|<span data-ttu-id="9009c-238">主题</span><span class="sxs-lookup"><span data-stu-id="9009c-238">Topic</span></span>|<span data-ttu-id="9009c-239">描述</span><span class="sxs-lookup"><span data-stu-id="9009c-239">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="9009c-240">如何修改字符串内容</span><span class="sxs-lookup"><span data-stu-id="9009c-240">How to modify string contents</span></span>](../../how-to/modify-string-contents.md)|<span data-ttu-id="9009c-241">阐明转换字符串并修改字符串内容的方法。</span><span class="sxs-lookup"><span data-stu-id="9009c-241">Illustrates techniques to transform strings and modify the contents of strings.</span></span>|  
|[<span data-ttu-id="9009c-242">如何比较字符串</span><span class="sxs-lookup"><span data-stu-id="9009c-242">How to compare strings</span></span>](../../how-to/compare-strings.md)|<span data-ttu-id="9009c-243">演示如何对字符串执行序号和特定于区域性的比较。</span><span class="sxs-lookup"><span data-stu-id="9009c-243">Shows how to perform ordinal and culture specific comparisons of strings.</span></span>|  
|[<span data-ttu-id="9009c-244">如何连接多个字符串</span><span class="sxs-lookup"><span data-stu-id="9009c-244">How to concatenate multiple strings</span></span>](../../how-to/concatenate-multiple-strings.md)|<span data-ttu-id="9009c-245">演示将多个字符串联接成一个字符串的多种方式。</span><span class="sxs-lookup"><span data-stu-id="9009c-245">Demonstrates various ways to join multiple strings into one.</span></span>|
|[<span data-ttu-id="9009c-246">如何使用 String.Split 分析字符串</span><span class="sxs-lookup"><span data-stu-id="9009c-246">How to parse strings using String.Split</span></span>](../../how-to/parse-strings-using-split.md)|<span data-ttu-id="9009c-247">包含代码示例，演示了如何使用 `String.Split` 方法来分析字符串。</span><span class="sxs-lookup"><span data-stu-id="9009c-247">Contains code examples that illustrate how to use the `String.Split` method to parse strings.</span></span>|  
|[<span data-ttu-id="9009c-248">如何搜索字符串</span><span class="sxs-lookup"><span data-stu-id="9009c-248">How to search strings</span></span>](../../how-to/search-strings.md)|<span data-ttu-id="9009c-249">说明如何在字符串中使用搜索来搜索特定的文本或模式。</span><span class="sxs-lookup"><span data-stu-id="9009c-249">Explains how to use search for specific text or patterns in strings.</span></span>|  
|[<span data-ttu-id="9009c-250">如何确定字符串是否表示数值</span><span class="sxs-lookup"><span data-stu-id="9009c-250">How to determine whether a string represents a numeric value</span></span>](./how-to-determine-whether-a-string-represents-a-numeric-value.md)|<span data-ttu-id="9009c-251">演示如何安全地分析一个字符串，以查看其是否具有有效的数值。</span><span class="sxs-lookup"><span data-stu-id="9009c-251">Shows how to safely parse a string to see whether it has a valid numeric value.</span></span>|  
|[<span data-ttu-id="9009c-252">字符串内插</span><span class="sxs-lookup"><span data-stu-id="9009c-252">String interpolation</span></span>](../../language-reference/tokens/interpolated.md)|<span data-ttu-id="9009c-253">介绍字符串内插功能，它提供了一种方便的语法来格式化字符串。</span><span class="sxs-lookup"><span data-stu-id="9009c-253">Describes the string interpolation feature that provides a convenient syntax to format strings.</span></span>|
|[<span data-ttu-id="9009c-254">基本字符串操作</span><span class="sxs-lookup"><span data-stu-id="9009c-254">Basic String Operations</span></span>](../../../standard/base-types/basic-string-operations.md)|<span data-ttu-id="9009c-255">收录了介绍如何使用 <xref:System.String?displayProperty=nameWithType> 和 <xref:System.Text.StringBuilder?displayProperty=nameWithType> 方法执行基本字符串操作的主题链接。</span><span class="sxs-lookup"><span data-stu-id="9009c-255">Provides links to topics that use <xref:System.String?displayProperty=nameWithType> and <xref:System.Text.StringBuilder?displayProperty=nameWithType> methods to perform basic string operations.</span></span>|  
|[<span data-ttu-id="9009c-256">分析字符串</span><span class="sxs-lookup"><span data-stu-id="9009c-256">Parsing Strings</span></span>](../../../standard/base-types/parsing-strings.md)|<span data-ttu-id="9009c-257">介绍如何将 .NET 基类型的字符串表示形式转换为相应类型的实例。</span><span class="sxs-lookup"><span data-stu-id="9009c-257">Describes how to convert string representations of .NET base types to instances of the corresponding types.</span></span>|  
|[<span data-ttu-id="9009c-258">分析 .NET 中的日期和时间字符串</span><span class="sxs-lookup"><span data-stu-id="9009c-258">Parsing Date and Time Strings in .NET</span></span>](../../../standard/base-types/parsing-datetime.md)|<span data-ttu-id="9009c-259">展示了如何将字符串（如“01/24/2008”）转换为 <xref:System.DateTime?displayProperty=nameWithType> 对象。</span><span class="sxs-lookup"><span data-stu-id="9009c-259">Shows how to convert a string such as "01/24/2008" to a <xref:System.DateTime?displayProperty=nameWithType> object.</span></span>|  
|[<span data-ttu-id="9009c-260">比较字符串</span><span class="sxs-lookup"><span data-stu-id="9009c-260">Comparing Strings</span></span>](../../../standard/base-types/comparing.md)|<span data-ttu-id="9009c-261">包括有关如何比较字符串的信息，并提供 C# 和 Visual Basic 中的示例。</span><span class="sxs-lookup"><span data-stu-id="9009c-261">Includes information about how to compare strings and provides examples in C# and Visual Basic.</span></span>|  
|[<span data-ttu-id="9009c-262">使用 StringBuilder 类</span><span class="sxs-lookup"><span data-stu-id="9009c-262">Using the StringBuilder Class</span></span>](../../../standard/base-types/stringbuilder.md)|<span data-ttu-id="9009c-263">介绍了如何使用 <xref:System.Text.StringBuilder> 类创建和修改动态字符串对象。</span><span class="sxs-lookup"><span data-stu-id="9009c-263">Describes how to create and modify dynamic string objects by using the <xref:System.Text.StringBuilder> class.</span></span>|  
|[<span data-ttu-id="9009c-264">LINQ 和字符串</span><span class="sxs-lookup"><span data-stu-id="9009c-264">LINQ and Strings</span></span>](../concepts/linq/linq-and-strings.md)|<span data-ttu-id="9009c-265">提供有关如何使用 LINQ 查询来执行各种字符串操作的信息。</span><span class="sxs-lookup"><span data-stu-id="9009c-265">Provides information about how to perform various string operations by using LINQ queries.</span></span>|  
|[<span data-ttu-id="9009c-266">C# 编程指南</span><span class="sxs-lookup"><span data-stu-id="9009c-266">C# Programming Guide</span></span>](../index.md)|<span data-ttu-id="9009c-267">提供介绍在 C# 中编程构造的主题的链接。</span><span class="sxs-lookup"><span data-stu-id="9009c-267">Provides links to topics that explain programming constructs in C#.</span></span>|  
