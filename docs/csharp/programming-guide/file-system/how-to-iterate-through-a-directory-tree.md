---
title: 如何循环访问目录树 - C# 编程指南
description: 了解如何循环访问目录树。 访问指定根文件夹下每个嵌套子目录中的每个文件。
ms.date: 07/20/2015
helpviewer_keywords:
- iterating through folders [C#]
- file iteration [C#]
ms.assetid: c4be4a75-6b1b-46a7-9d38-bab353091ed7
ms.openlocfilehash: c49a9d1eaea9d4d8967b105d753f2a611d80e795
ms.sourcegitcommit: 6f58a5f75ceeb936f8ee5b786e9adb81a9a3bee9
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/28/2020
ms.locfileid: "87301978"
---
# <a name="how-to-iterate-through-a-directory-tree-c-programming-guide"></a><span data-ttu-id="85a72-104">如何循环访问目录树（C# 编程指南）</span><span class="sxs-lookup"><span data-stu-id="85a72-104">How to iterate through a directory tree (C# Programming Guide)</span></span>
<span data-ttu-id="85a72-105">短语“循环访问目录树”的意思是访问特定根文件夹下的每个嵌套子目录中的每个文件，可以是任意深度。</span><span class="sxs-lookup"><span data-stu-id="85a72-105">The phrase "iterate a directory tree" means to access each file in each nested subdirectory under a specified root folder, to any depth.</span></span> <span data-ttu-id="85a72-106">不需要打开每个文件。</span><span class="sxs-lookup"><span data-stu-id="85a72-106">You do not necessarily have to open each file.</span></span> <span data-ttu-id="85a72-107">可以以 `string` 的形式只检索文件或子目录的名称，也可以以 <xref:System.IO.FileInfo?displayProperty=nameWithType> 或 <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> 对象的形式检索其他信息。</span><span class="sxs-lookup"><span data-stu-id="85a72-107">You can just retrieve the name of the file or subdirectory as a `string`, or you can retrieve additional information in the form of a <xref:System.IO.FileInfo?displayProperty=nameWithType> or <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> object.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="85a72-108">在 Windows 中，术语“目录”和“文件夹”可以互换使用。</span><span class="sxs-lookup"><span data-stu-id="85a72-108">In Windows, the terms "directory" and "folder" are used interchangeably.</span></span> <span data-ttu-id="85a72-109">大多数文档和用户界面文本使用术语“文件夹”，但 .NET 类库使用术语“目录”。</span><span class="sxs-lookup"><span data-stu-id="85a72-109">Most documentation and user interface text uses the term "folder," but .NET class libraries use the term "directory."</span></span>  
  
 <span data-ttu-id="85a72-110">在最简单的情况下，如果你确信拥有指定根目录下的所有目录的访问权限，则可以使用 `System.IO.SearchOption.AllDirectories` 标志。</span><span class="sxs-lookup"><span data-stu-id="85a72-110">In the simplest case, in which you know for certain that you have access permissions for all directories under a specified root, you can use the `System.IO.SearchOption.AllDirectories` flag.</span></span> <span data-ttu-id="85a72-111">此标志返回与指定的模式匹配的所有嵌套的子目录。</span><span class="sxs-lookup"><span data-stu-id="85a72-111">This flag returns all the nested subdirectories that match the specified pattern.</span></span> <span data-ttu-id="85a72-112">下面的示例演示如何使用此标志。</span><span class="sxs-lookup"><span data-stu-id="85a72-112">The following example shows how to use this flag.</span></span>  
  
```csharp  
root.GetDirectories("*.*", System.IO.SearchOption.AllDirectories);  
```  
  
 <span data-ttu-id="85a72-113">此方法的缺点是，如果指定根目录下的任何子目录引发 <xref:System.IO.DirectoryNotFoundException> 或 <xref:System.UnauthorizedAccessException> 异常，则整个方法失败且不返回任何目录。</span><span class="sxs-lookup"><span data-stu-id="85a72-113">The weakness in this approach is that if any one of the subdirectories under the specified root causes a <xref:System.IO.DirectoryNotFoundException> or <xref:System.UnauthorizedAccessException>, the whole method fails and returns no directories.</span></span> <span data-ttu-id="85a72-114">使用 <xref:System.IO.DirectoryInfo.GetFiles%2A> 方法时也是如此。</span><span class="sxs-lookup"><span data-stu-id="85a72-114">The same is true when you use the <xref:System.IO.DirectoryInfo.GetFiles%2A> method.</span></span> <span data-ttu-id="85a72-115">如果需要处理特定子文件夹中的异常，则必须手动遍历目录树，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="85a72-115">If you have to handle these exceptions on specific subfolders, you must manually walk the directory tree, as shown in the following examples.</span></span>  
  
 <span data-ttu-id="85a72-116">手动遍历目录树时，可以先处理子目录（前序遍历），或者先处理文件（后序遍历）。</span><span class="sxs-lookup"><span data-stu-id="85a72-116">When you manually walk a directory tree, you can handle the subdirectories first (*pre-order traversal*), or the files first (*post-order traversal*).</span></span> <span data-ttu-id="85a72-117">如果执行前序遍历，那么在遍历直接位于当前文件夹中的文件之前，先遍历此文件夹下的整棵树。</span><span class="sxs-lookup"><span data-stu-id="85a72-117">If you perform a pre-order traversal, you walk the whole tree under the current folder before iterating through the files that are directly in that folder itself.</span></span> <span data-ttu-id="85a72-118">本文档后面的示例执行的是后序遍历，但你可以轻松地修改它们以执行前序遍历。</span><span class="sxs-lookup"><span data-stu-id="85a72-118">The examples later in this document perform post-order traversal, but you can easily modify them to perform pre-order traversal.</span></span>  
  
 <span data-ttu-id="85a72-119">另一种选择是，是使用递归遍历还是基于堆栈的遍历。</span><span class="sxs-lookup"><span data-stu-id="85a72-119">Another option is whether to use recursion or a stack-based traversal.</span></span> <span data-ttu-id="85a72-120">本文档后面的示例演示了这两种方法。</span><span class="sxs-lookup"><span data-stu-id="85a72-120">The examples later in this document show both approaches.</span></span>  
  
 <span data-ttu-id="85a72-121">如果需要对文件和文件夹执行各种操作，则可以模块化这些示例，方法是将操作重构为可使用单个委托进行调用的单独的函数。</span><span class="sxs-lookup"><span data-stu-id="85a72-121">If you have to perform a variety of operations on files and folders, you can modularize these examples by refactoring the operation into separate functions that you can invoke by using a single delegate.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="85a72-122">NTFS 文件系统可以包含交接点、符号链接和硬链接等形式的重解析点。</span><span class="sxs-lookup"><span data-stu-id="85a72-122">NTFS file systems can contain *reparse points* in the form of *junction points*, *symbolic links*, and *hard links*.</span></span> <span data-ttu-id="85a72-123">诸如 <xref:System.IO.DirectoryInfo.GetFiles%2A> 和 <xref:System.IO.DirectoryInfo.GetDirectories%2A> 等 .NET 方法不会返回重分析点下的任何子目录。</span><span class="sxs-lookup"><span data-stu-id="85a72-123">.NET methods such as <xref:System.IO.DirectoryInfo.GetFiles%2A> and <xref:System.IO.DirectoryInfo.GetDirectories%2A> will not return any subdirectories under a reparse point.</span></span> <span data-ttu-id="85a72-124">当两个重解析点相互引用时，此行为可防止进入无限循环。</span><span class="sxs-lookup"><span data-stu-id="85a72-124">This behavior guards against the risk of entering into an infinite loop when two reparse points refer to each other.</span></span> <span data-ttu-id="85a72-125">通常，处理重解析点时应格外小心，以确保不会无意中修改或删除文件。</span><span class="sxs-lookup"><span data-stu-id="85a72-125">In general, you should use extreme caution when you deal with reparse points to ensure that you do not unintentionally modify or delete files.</span></span> <span data-ttu-id="85a72-126">如果需要精确控制重解析点，请使用平台调用或本机代码直接调用相应的 Win32 文件系统方法。</span><span class="sxs-lookup"><span data-stu-id="85a72-126">If you require precise control over reparse points, use platform invoke or native code to call the appropriate Win32 file system methods directly.</span></span>  
  
## <a name="example"></a><span data-ttu-id="85a72-127">示例</span><span class="sxs-lookup"><span data-stu-id="85a72-127">Example</span></span>  
 <span data-ttu-id="85a72-128">下面的示例演示如何以递归方式遍历目录树。</span><span class="sxs-lookup"><span data-stu-id="85a72-128">The following example shows how to walk a directory tree by using recursion.</span></span> <span data-ttu-id="85a72-129">递归方法是一种很好的方法，但是如果目录树较大且嵌套深度较深，则可能引起堆栈溢出异常。</span><span class="sxs-lookup"><span data-stu-id="85a72-129">The recursive approach is elegant but has the potential to cause a stack overflow exception if the directory tree is large and deeply nested.</span></span>  
  
 <span data-ttu-id="85a72-130">在每个文件或文件夹上处理的特定异常和执行的特定操作仅作为示例提供。</span><span class="sxs-lookup"><span data-stu-id="85a72-130">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="85a72-131">你可以修改此代码来满足你的特定要求。</span><span class="sxs-lookup"><span data-stu-id="85a72-131">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="85a72-132">有关详细信息，请参阅代码中的注释。</span><span class="sxs-lookup"><span data-stu-id="85a72-132">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csFilesAndFolders/CS/FileIteration.cs#1)]  
  
## <a name="example"></a><span data-ttu-id="85a72-133">示例</span><span class="sxs-lookup"><span data-stu-id="85a72-133">Example</span></span>  
 <span data-ttu-id="85a72-134">下面的示例演示如何不使用递归方式遍历目录树中的文件和文件夹。</span><span class="sxs-lookup"><span data-stu-id="85a72-134">The following example shows how to iterate through files and folders in a directory tree without using recursion.</span></span> <span data-ttu-id="85a72-135">此方法使用泛型 <xref:System.Collections.Generic.Stack%601> 集合类型，此集合类型是一个后进先出 (LIFO) 堆栈。</span><span class="sxs-lookup"><span data-stu-id="85a72-135">This technique uses the generic <xref:System.Collections.Generic.Stack%601> collection type, which is a last in first out (LIFO) stack.</span></span>  
  
 <span data-ttu-id="85a72-136">在每个文件或文件夹上处理的特定异常和执行的特定操作仅作为示例提供。</span><span class="sxs-lookup"><span data-stu-id="85a72-136">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="85a72-137">你可以修改此代码来满足你的特定要求。</span><span class="sxs-lookup"><span data-stu-id="85a72-137">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="85a72-138">有关详细信息，请参阅代码中的注释。</span><span class="sxs-lookup"><span data-stu-id="85a72-138">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csFilesAndFolders/CS/FileIteration.cs#2)]  
  
 <span data-ttu-id="85a72-139">通常，检测每个文件夹以确定应用程序是否有权限打开它是一个很费时的过程。</span><span class="sxs-lookup"><span data-stu-id="85a72-139">It is generally too time-consuming to test every folder to determine whether your application has permission to open it.</span></span> <span data-ttu-id="85a72-140">因此，此代码示例只将此部分操作封装在 `try/catch` 块中。</span><span class="sxs-lookup"><span data-stu-id="85a72-140">Therefore, the code example just encloses that part of the operation in a `try/catch` block.</span></span> <span data-ttu-id="85a72-141">你可以修改 `catch` 块，以便在拒绝访问某个文件夹时，可以尝试提升权限，然后再次访问此文件夹。</span><span class="sxs-lookup"><span data-stu-id="85a72-141">You can modify the `catch` block so that when you are denied access to a folder, you try to elevate your permissions and then access it again.</span></span> <span data-ttu-id="85a72-142">一般来说，仅捕获可以处理的、不会将应用程序置于未知状态的异常。</span><span class="sxs-lookup"><span data-stu-id="85a72-142">As a rule, only catch those exceptions that you can handle without leaving your application in an unknown state.</span></span>  
  
 <span data-ttu-id="85a72-143">如果必须在内存或磁盘上存储目录树的内容，那么最佳选择是仅存储每个文件的 <xref:System.IO.FileSystemInfo.FullName%2A> 属性（类型为 `string`）。</span><span class="sxs-lookup"><span data-stu-id="85a72-143">If you must store the contents of a directory tree, either in memory or on disk, the best option is to store only the <xref:System.IO.FileSystemInfo.FullName%2A> property (of type `string`) for each file.</span></span> <span data-ttu-id="85a72-144">然后可以根据需要使用此字符串创建新的 <xref:System.IO.FileInfo> 或 <xref:System.IO.DirectoryInfo> 对象，或打开需要进行其他处理的任何文件。</span><span class="sxs-lookup"><span data-stu-id="85a72-144">You can then use this string to create a new <xref:System.IO.FileInfo> or <xref:System.IO.DirectoryInfo> object as necessary, or open any file that requires additional processing.</span></span>  
  
## <a name="robust-programming"></a><span data-ttu-id="85a72-145">可靠编程</span><span class="sxs-lookup"><span data-stu-id="85a72-145">Robust Programming</span></span>  
 <span data-ttu-id="85a72-146">可靠的文件迭代代码必须考虑文件系统的诸多复杂性。</span><span class="sxs-lookup"><span data-stu-id="85a72-146">Robust file iteration code must take into account many complexities of the file system.</span></span> <span data-ttu-id="85a72-147">有关 Windows 文件系统的详细信息，请参阅 [NTFS 概述](/windows-server/storage/file-server/ntfs-overview)。</span><span class="sxs-lookup"><span data-stu-id="85a72-147">For more information on the Windows file system, see [NTFS overview](/windows-server/storage/file-server/ntfs-overview).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="85a72-148">请参阅</span><span class="sxs-lookup"><span data-stu-id="85a72-148">See also</span></span>

- <xref:System.IO>
- [<span data-ttu-id="85a72-149">LINQ 和文件目录</span><span class="sxs-lookup"><span data-stu-id="85a72-149">LINQ and File Directories</span></span>](../concepts/linq/linq-and-file-directories.md)
- [<span data-ttu-id="85a72-150">文件系统和注册表（C# 编程指南）</span><span class="sxs-lookup"><span data-stu-id="85a72-150">File System and the Registry (C# Programming Guide)</span></span>](./index.md)
