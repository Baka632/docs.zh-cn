---
title: SQL Server 连接池
description: 了解 ADO.NET 如何通过使用 SQL Server 连接池来最大程度地降低打开连接的成本，从而减少新连接的开销。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 7e51d44e-7c4e-4040-9332-f0190fe36f07
ms.openlocfilehash: 96d9e9a7e43f71dc30bd2d7a7f1902238941d471
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/24/2020
ms.locfileid: "91156350"
---
# <a name="sql-server-connection-pooling-adonet"></a><span data-ttu-id="a2fa1-103">SQL Server 连接池 (ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="a2fa1-103">SQL Server Connection Pooling (ADO.NET)</span></span>

<span data-ttu-id="a2fa1-104">连接到数据库服务器通常由几个需要很长时间的步骤组成。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-104">Connecting to a database server typically consists of several time-consuming steps.</span></span> <span data-ttu-id="a2fa1-105">必须建立物理通道（例如套接字或命名管道），必须与服务器进行初次握手，必须分析连接字符串信息，必须由服务器对连接进行身份验证，必须运行检查以便在当前事务中登记，等等。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-105">A physical channel such as a socket or a named pipe must be established, the initial handshake with the server must occur, the connection string information must be parsed, the connection must be authenticated by the server, checks must be run for enlisting in the current transaction, and so on.</span></span>  
  
 <span data-ttu-id="a2fa1-106">实际上，大多数应用程序仅使用一个或几个不同的连接配置。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-106">In practice, most applications use only one or a few different configurations for connections.</span></span> <span data-ttu-id="a2fa1-107">这意味着在执行应用程序期间，许多相同的连接将反复地打开和关闭。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-107">This means that during application execution, many identical connections will be repeatedly opened and closed.</span></span> <span data-ttu-id="a2fa1-108">为了最大程度地降低打开连接的成本，ADO.NET 使用一种称为 *连接池*的优化技术。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-108">To minimize the cost of opening connections, ADO.NET uses an optimization technique called *connection pooling*.</span></span>  
  
 <span data-ttu-id="a2fa1-109">连接池使新连接必须打开的次数得以减少。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-109">Connection pooling reduces the number of times that new connections must be opened.</span></span> <span data-ttu-id="a2fa1-110">*池池*维护物理连接的所有权。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-110">The *pooler* maintains ownership of the physical connection.</span></span> <span data-ttu-id="a2fa1-111">通过为每个给定的连接配置保留一组活动连接来管理连接。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-111">It manages connections by keeping alive a set of active connections for each given connection configuration.</span></span> <span data-ttu-id="a2fa1-112">每当用户在连接上调用 `Open` 时，池进程就会查找池中可用的连接。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-112">Whenever a user calls `Open` on a connection, the pooler looks for an available connection in the pool.</span></span> <span data-ttu-id="a2fa1-113">如果某个池连接可用，会将该连接返回给调用者，而不是打开新连接。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-113">If a pooled connection is available, it returns it to the caller instead of opening a new connection.</span></span> <span data-ttu-id="a2fa1-114">应用程序在该连接上调用 `Close` 时，池进程会将连接返回到活动连接池集中，而不是关闭连接。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-114">When the application calls `Close` on the connection, the pooler returns it to the pooled set of active connections instead of closing it.</span></span> <span data-ttu-id="a2fa1-115">连接返回到池中之后，即可在下一个 `Open` 调用中重复使用。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-115">Once the connection is returned to the pool, it is ready to be reused on the next `Open` call.</span></span>  
  
 <span data-ttu-id="a2fa1-116">只有配置相同的连接可以建立池连接。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-116">Only connections with the same configuration can be pooled.</span></span> <span data-ttu-id="a2fa1-117">ADO.NET 会同时保留多个池，每种配置各有一个。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-117">ADO.NET keeps several pools at the same time, one for each configuration.</span></span> <span data-ttu-id="a2fa1-118">在使用集成的安全性时，连接按照连接字符串以及 Windows 标识分到多个池中。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-118">Connections are separated into pools by connection string, and by Windows identity when integrated security is used.</span></span> <span data-ttu-id="a2fa1-119">还根据连接是否已在事务中登记来建立池连接。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-119">Connections are also pooled based on whether they are enlisted in a transaction.</span></span> <span data-ttu-id="a2fa1-120">在使用 <xref:System.Data.SqlClient.SqlConnection.ChangePassword%2A> 时，<xref:System.Data.SqlClient.SqlCredential> 实例影响连接池。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-120">When using <xref:System.Data.SqlClient.SqlConnection.ChangePassword%2A>, the <xref:System.Data.SqlClient.SqlCredential> instance affects the connection pool.</span></span> <span data-ttu-id="a2fa1-121"><xref:System.Data.SqlClient.SqlCredential> 的不同实例将使用不同的连接池，即使用户 ID 和密码相，也是如此。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-121">Different instances of <xref:System.Data.SqlClient.SqlCredential> will use different connection pools, even if the user ID and password are the same.</span></span>  
  
 <span data-ttu-id="a2fa1-122">池连接可以显著提高应用程序的性能和可缩放性。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-122">Pooling connections can significantly enhance the performance and scalability of your application.</span></span> <span data-ttu-id="a2fa1-123">默认情况下，在 ADO.NET 中启用连接池。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-123">By default, connection pooling is enabled in ADO.NET.</span></span> <span data-ttu-id="a2fa1-124">除非显式禁用，否则，在应用程序中打开和关闭连接时，池进程会对连接进行优化。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-124">Unless you explicitly disable it, the pooler optimizes the connections as they are opened and closed in your application.</span></span> <span data-ttu-id="a2fa1-125">还可以提供几个连接字符串修饰符来控制连接池的行为。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-125">You can also supply several connection string modifiers to control connection pooling behavior.</span></span> <span data-ttu-id="a2fa1-126">有关更多信息，请参见本主题后面的“使用连接字符串关键字控制连接池”。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-126">For more information, see "Controlling Connection Pooling with Connection String Keywords" later in this topic.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="a2fa1-127">启用连接池后，如果发生超时错误或其他登录错误，则将引发异常，并且在接下来的五秒内进行的后续连接尝试将失败，此段时间称为“阻塞期”。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-127">When connection pooling is enabled, and if a timeout error or other login error occurs, an exception will be thrown and subsequent connection attempts will fail for the next five seconds, the "blocking period".</span></span> <span data-ttu-id="a2fa1-128">如果应用程序尝试在阻塞期内进行连接，则将再次引发第一个异常。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-128">If the application attempts to connect within the blocking period, the first exception will be thrown again.</span></span> <span data-ttu-id="a2fa1-129">阻塞期结束后的后续失败将导致新的阻塞期，该阻塞期的持续时间是上一个阻塞期的两倍，最长为一分钟。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-129">Subsequent failures after a blocking period ends will result in a new blocking periods that is twice as long as the previous blocking period, up to a maximum of one minute.</span></span>  
  
## <a name="pool-creation-and-assignment"></a><span data-ttu-id="a2fa1-130">池的创建和分配</span><span class="sxs-lookup"><span data-stu-id="a2fa1-130">Pool Creation and Assignment</span></span>  

 <span data-ttu-id="a2fa1-131">在初次打开连接时，将根据完全匹配算法创建连接池，该算法将池与连接中的连接字符串关联。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-131">When a connection is first opened, a connection pool is created based on an exact matching algorithm that associates the pool with the connection string in the connection.</span></span> <span data-ttu-id="a2fa1-132">每个连接池都与一个不同的连接字符串相关联。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-132">Each connection pool is associated with a distinct connection string.</span></span> <span data-ttu-id="a2fa1-133">打开新连接时，如果连接字符串并非与现有池完全匹配，将创建一个新池。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-133">When a new connection is opened, if the connection string is not an exact match to an existing pool, a new pool is created.</span></span> <span data-ttu-id="a2fa1-134">按进程、应用程序域、连接字符串以及 Windows 标识（在使用集成的安全性时）来建立池连接。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-134">Connections are pooled per process, per application domain, per connection string and when integrated security is used, per Windows identity.</span></span> <span data-ttu-id="a2fa1-135">连接字符串还必须是完全匹配的；按不同顺序为同一连接提供的关键字将分到单独的池中。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-135">Connection strings must also be an exact match; keywords supplied in a different order for the same connection will be pooled separately.</span></span>  
  
 <span data-ttu-id="a2fa1-136">在以下 C# 示例中创建了三个新的 <xref:System.Data.SqlClient.SqlConnection> 对象，但是管理时只需要两个连接池。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-136">In the following C# example, three new <xref:System.Data.SqlClient.SqlConnection> objects are created, but only two connection pools are required to manage them.</span></span> <span data-ttu-id="a2fa1-137">注意，根据为 `Initial Catalog` 分配的值，第一个和第二个连接字符串有所不同。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-137">Note that the first and second connection strings differ by the value assigned for `Initial Catalog`.</span></span>  
  
```csharp
using (SqlConnection connection = new SqlConnection(  
  "Integrated Security=SSPI;Initial Catalog=Northwind"))  
    {  
        connection.Open();
        // Pool A is created.  
    }  
  
using (SqlConnection connection = new SqlConnection(  
  "Integrated Security=SSPI;Initial Catalog=pubs"))  
    {  
        connection.Open();
        // Pool B is created because the connection strings differ.  
    }  
  
using (SqlConnection connection = new SqlConnection(  
  "Integrated Security=SSPI;Initial Catalog=Northwind"))  
    {  
        connection.Open();
        // The connection string matches pool A.  
    }  
```  
  
 <span data-ttu-id="a2fa1-138">如果 `MinPoolSize` 在连接字符串中未指定或指定为零，池中的连接将在一段时间不活动后关闭。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-138">If `MinPoolSize` is either not specified in the connection string or is specified as zero, the connections in the pool will be closed after a period of inactivity.</span></span> <span data-ttu-id="a2fa1-139">但是，如果指定的 `MinPoolSize` 大于零，在 `AppDomain` 被卸载并且进程结束之前，连接池不会被破坏。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-139">However, if the specified `MinPoolSize` is greater than zero, the connection pool is not destroyed until the `AppDomain` is unloaded and the process ends.</span></span> <span data-ttu-id="a2fa1-140">非活动或空池的维护只需要最少的系统开销。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-140">Maintenance of inactive or empty pools involves minimal system overhead.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="a2fa1-141">当出现故障转移等错误时，会自动清除池。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-141">The pool is automatically cleared when a fatal error occurs, such as a failover.</span></span>  
  
## <a name="adding-connections"></a><span data-ttu-id="a2fa1-142">添加连接</span><span class="sxs-lookup"><span data-stu-id="a2fa1-142">Adding Connections</span></span>  

 <span data-ttu-id="a2fa1-143">连接池是为每个唯一的连接字符串创建的。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-143">A connection pool is created for each unique connection string.</span></span> <span data-ttu-id="a2fa1-144">当创建一个池后，将创建多个连接对象并将其添加到该池中，以满足最小池大小的需求。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-144">When a pool is created, multiple connection objects are created and added to the pool so that the minimum pool size requirement is satisfied.</span></span> <span data-ttu-id="a2fa1-145">连接根据需要添加到池中，但是不能超过指定的最大池大小（默认值为 100）。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-145">Connections are added to the pool as needed, up to the maximum pool size specified (100 is the default).</span></span> <span data-ttu-id="a2fa1-146">连接在关闭或断开时释放回池中。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-146">Connections are released back into the pool when they are closed or disposed.</span></span>  
  
 <span data-ttu-id="a2fa1-147">在请求 <xref:System.Data.SqlClient.SqlConnection> 对象时，如果存在可用的连接，将从池中获取该对象。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-147">When a <xref:System.Data.SqlClient.SqlConnection> object is requested, it is obtained from the pool if a usable connection is available.</span></span> <span data-ttu-id="a2fa1-148">连接要可用，必须未使用，具有匹配的事务上下文或未与任何事务上下文关联，并且具有与服务器的有效链接。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-148">To be usable, a connection must be unused, have a matching transaction context or be unassociated with any transaction context, and have a valid link to the server.</span></span>  
  
 <span data-ttu-id="a2fa1-149">连接池进程通过在连接释放回池中时重新分配连接，来满足这些连接请求。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-149">The connection pooler satisfies requests for connections by reallocating connections as they are released back into the pool.</span></span> <span data-ttu-id="a2fa1-150">如果已达到最大池大小且不存在可用的连接，则该请求将会排队。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-150">If the maximum pool size has been reached and no usable connection is available, the request is queued.</span></span> <span data-ttu-id="a2fa1-151">然后，池进程尝试重新建立任何连接，直至到达超时时间（默认值为 15 秒）。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-151">The pooler then tries to reclaim any connections until the time-out is reached (the default is 15 seconds).</span></span> <span data-ttu-id="a2fa1-152">如果池进程在连接超时之前无法满足请求，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-152">If the pooler cannot satisfy the request before the connection times out, an exception is thrown.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="a2fa1-153">我们强烈建议您在使用完连接时一定要关闭连接，以便连接可以返回池。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-153">We strongly recommend that you always close the connection when you are finished using it so that the connection will be returned to the pool.</span></span> <span data-ttu-id="a2fa1-154">您可以使用 `Close` 对象的或方法或 `Dispose` `Connection` 通过在 c # 中的语句内打开所有连接 `using` 或 `Using` Visual Basic 中的语句来执行此操作。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-154">You can do this using either the `Close` or `Dispose` methods of the `Connection` object, or by opening all connections inside a `using` statement in C#, or a `Using` statement in Visual Basic.</span></span> <span data-ttu-id="a2fa1-155">不是显式关闭的连接可能不会添加或返回到池中。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-155">Connections that are not explicitly closed might not be added or returned to the pool.</span></span> <span data-ttu-id="a2fa1-156">有关详细信息，请参阅 [Using 语句](../../../csharp/language-reference/keywords/using-statement.md) 或 [如何：处置 Visual Basic 的系统资源](../../../visual-basic/programming-guide/language-features/control-flow/how-to-dispose-of-a-system-resource.md) 。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-156">For more information, see [using Statement](../../../csharp/language-reference/keywords/using-statement.md) or [How to: Dispose of a System Resource](../../../visual-basic/programming-guide/language-features/control-flow/how-to-dispose-of-a-system-resource.md) for Visual Basic.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="a2fa1-157">不要在类的 `Close` 方法中对 `Dispose`、`Connection` 或任何其他托管对象调用 `DataReader` 或 `Finalize`。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-157">Do not call `Close` or `Dispose` on a `Connection`, a `DataReader`, or any other managed object in the `Finalize` method of your class.</span></span> <span data-ttu-id="a2fa1-158">在终结器中，仅释放类直接拥有的非托管资源。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-158">In a finalizer, only release unmanaged resources that your class owns directly.</span></span> <span data-ttu-id="a2fa1-159">如果类不拥有任何非托管资源，则不要在类定义中包含 `Finalize` 方法。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-159">If your class does not own any unmanaged resources, do not include a `Finalize` method in your class definition.</span></span> <span data-ttu-id="a2fa1-160">有关详细信息，请参阅 [垃圾回收](../../../standard/garbage-collection/index.md)。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-160">For more information, see [Garbage Collection](../../../standard/garbage-collection/index.md).</span></span>  
  
<span data-ttu-id="a2fa1-161">有关与打开和关闭连接相关联的事件的详细信息，请参阅 SQL Server 文档中的 [Audit Login 事件类](/sql/relational-databases/event-classes/audit-login-event-class) 和 [audit 注销事件类](/sql/relational-databases/event-classes/audit-logout-event-class) 。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-161">For more info about the events associated with opening and closing connections, see [Audit Login Event Class](/sql/relational-databases/event-classes/audit-login-event-class) and [Audit Logout Event Class](/sql/relational-databases/event-classes/audit-logout-event-class) in the SQL Server documentation.</span></span>  
  
## <a name="removing-connections"></a><span data-ttu-id="a2fa1-162">移除连接</span><span class="sxs-lookup"><span data-stu-id="a2fa1-162">Removing Connections</span></span>  

 <span data-ttu-id="a2fa1-163">如果空闲时间达到大约 4-8 分钟，或池进程检测到与服务器的连接已断开，连接池进程会将该连接从池中移除。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-163">The connection pooler removes a connection from the pool after it has been idle for approximately 4-8 minutes, or if the pooler detects that the connection with the server has been severed.</span></span> <span data-ttu-id="a2fa1-164">注意，只有在尝试与服务器进行通信之后才能检测到断开的连接。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-164">Note that a severed connection can be detected only after attempting to communicate with the server.</span></span> <span data-ttu-id="a2fa1-165">如果发现某连接不再连接到服务器，则会将其标记为无效。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-165">If a connection is found that is no longer connected to the server, it is marked as invalid.</span></span> <span data-ttu-id="a2fa1-166">无效连接只有在关闭或重新建立后，才会从连接池中移除。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-166">Invalid connections are removed from the connection pool only when they are closed or reclaimed.</span></span>  
  
 <span data-ttu-id="a2fa1-167">如果存在一个与已消失的服务器的连接，即使连接池进程尚未检测到断开的连接，也可以从池中取出此连接并将连接标记为无效。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-167">If a connection exists to a server that has disappeared, this connection can be drawn from the pool even if the connection pooler has not detected the severed connection and marked it as invalid.</span></span> <span data-ttu-id="a2fa1-168">这种情况是因为检查连接是否仍有效的系统开销将造成与服务器的另一次往返，从而抵消了池进程的优势。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-168">This is the case because the overhead of checking that the connection is still valid would eliminate the benefits of having a pooler by causing another round trip to the server to occur.</span></span> <span data-ttu-id="a2fa1-169">发生此情况时，初次尝试使用该连接将检测连接是否曾断开，并引发异常。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-169">When this occurs, the first attempt to use the connection will detect that the connection has been severed, and an exception is thrown.</span></span>  
  
## <a name="clearing-the-pool"></a><span data-ttu-id="a2fa1-170">清除池</span><span class="sxs-lookup"><span data-stu-id="a2fa1-170">Clearing the Pool</span></span>  

 <span data-ttu-id="a2fa1-171">ADO.NET 2.0 引入了两种新的方法来清除池： <xref:System.Data.SqlClient.SqlConnection.ClearAllPools%2A> 和 <xref:System.Data.SqlClient.SqlConnection.ClearPool%2A> 。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-171">ADO.NET 2.0 introduced two new methods to clear the pool: <xref:System.Data.SqlClient.SqlConnection.ClearAllPools%2A> and <xref:System.Data.SqlClient.SqlConnection.ClearPool%2A>.</span></span> <span data-ttu-id="a2fa1-172">`ClearAllPools` 清除指定提供程序的连接池，`ClearPool` 清除与特定连接关联的连接池。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-172">`ClearAllPools` clears the connection pools for a given provider, and `ClearPool` clears the connection pool that is associated with a specific connection.</span></span> <span data-ttu-id="a2fa1-173">如果在调用时连接正在使用，将对它们进行相应的标记。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-173">If there are connections being used at the time of the call, they are marked appropriately.</span></span> <span data-ttu-id="a2fa1-174">连接关闭时，将被丢弃，而不是返回池中。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-174">When they are closed, they are discarded instead of being returned to the pool.</span></span>  
  
## <a name="transaction-support"></a><span data-ttu-id="a2fa1-175">事务支持</span><span class="sxs-lookup"><span data-stu-id="a2fa1-175">Transaction Support</span></span>  

 <span data-ttu-id="a2fa1-176">连接是根据事务上下文来从池中取出并进行分配的。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-176">Connections are drawn from the pool and assigned based on transaction context.</span></span> <span data-ttu-id="a2fa1-177">除非在连接字符串中指定了 `Enlist=false`，否则连接池将确保连接在 <xref:System.Transactions.Transaction.Current%2A> 上下文中登记。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-177">Unless `Enlist=false` is specified in the connection string, the connection pool makes sure that the connection is enlisted in the <xref:System.Transactions.Transaction.Current%2A> context.</span></span> <span data-ttu-id="a2fa1-178">如果连接使用登记的 `System.Transactions` 事务关闭并返回到池中，连接将保留在池中，以便使用相同 `System.Transactions` 事务对该连接池的下一次请求将返回相同的连接（如果可用）。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-178">When a connection is closed and returned to the pool with an enlisted `System.Transactions` transaction, it is set aside in such a way that the next request for that connection pool with the same `System.Transactions` transaction will return the same connection if it is available.</span></span> <span data-ttu-id="a2fa1-179">如果发出这样的请求，而没有可用的池连接，则会从池的非事务性部分取出一个连接并登记。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-179">If such a request is issued, and there are no pooled connections available, a connection is drawn from the non-transacted part of the pool and enlisted.</span></span> <span data-ttu-id="a2fa1-180">如果在池的每个区域都没有可用的连接，则会创建一个新的连接并登记。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-180">If no connections are available in either area of the pool, a new connection is created and enlisted.</span></span>  
  
 <span data-ttu-id="a2fa1-181">当连接关闭时，它将被释放回池中，并根据其事务上下文放入相应的子部分。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-181">When a connection is closed, it is released back into the pool and into the appropriate subdivision based on its transaction context.</span></span> <span data-ttu-id="a2fa1-182">因此，即使分布式事务仍然挂起，仍可以关闭该连接而不会生成错误。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-182">Therefore, you can close the connection without generating an error, even though a distributed transaction is still pending.</span></span> <span data-ttu-id="a2fa1-183">这样，你就可以在之后提交或中止分布式事务。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-183">This allows you to commit or abort the distributed transaction later.</span></span>  
  
## <a name="controlling-connection-pooling-with-connection-string-keywords"></a><span data-ttu-id="a2fa1-184">使用连接字符串关键字控制连接池</span><span class="sxs-lookup"><span data-stu-id="a2fa1-184">Controlling Connection Pooling with Connection String Keywords</span></span>  

 <span data-ttu-id="a2fa1-185">`ConnectionString` 对象的 <xref:System.Data.SqlClient.SqlConnection> 属性支持连接字符串键/值对，可以用于调整连接池逻辑的行为。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-185">The `ConnectionString` property of the <xref:System.Data.SqlClient.SqlConnection> object supports connection string key/value pairs that can be used to adjust the behavior of the connection pooling logic.</span></span> <span data-ttu-id="a2fa1-186">有关详细信息，请参阅 <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-186">For more information, see <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>.</span></span>  
  
## <a name="pool-fragmentation"></a><span data-ttu-id="a2fa1-187">池碎片</span><span class="sxs-lookup"><span data-stu-id="a2fa1-187">Pool Fragmentation</span></span>  

 <span data-ttu-id="a2fa1-188">池碎片是许多 Web 应用程序中的一个常见问题，应用程序可能会创建大量在进程退出后才会释放的池。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-188">Pool fragmentation is a common problem in many Web applications where the application can create a large number of pools that are not freed until the process exits.</span></span> <span data-ttu-id="a2fa1-189">这样，将打开大量的连接，占用许多内存，从而导致性能降低。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-189">This leaves a large number of connections open and consuming memory, which results in poor performance.</span></span>  
  
### <a name="pool-fragmentation-due-to-integrated-security"></a><span data-ttu-id="a2fa1-190">因为集成安全性产生的池碎片</span><span class="sxs-lookup"><span data-stu-id="a2fa1-190">Pool Fragmentation Due to Integrated Security</span></span>  

 <span data-ttu-id="a2fa1-191">连接根据连接字符串以及用户标识来建立池连接。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-191">Connections are pooled according to the connection string plus the user identity.</span></span> <span data-ttu-id="a2fa1-192">因此，如果使用网站上的基本身份验证或 Windows 身份验证以及集成的安全登录，每个用户将获得一个池。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-192">Therefore, if you use Basic authentication or Windows Authentication on the Web site and an integrated security login, you get one pool per user.</span></span> <span data-ttu-id="a2fa1-193">尽管这样可以提高单个用户的后续数据库请求的性能，但是该用户无法利用其他用户建立的连接。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-193">Although this improves the performance of subsequent database requests for a single user, that user cannot take advantage of connections made by other users.</span></span> <span data-ttu-id="a2fa1-194">这样还使每个用户至少产生一个与数据库服务器的连接。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-194">It also results in at least one connection per user to the database server.</span></span> <span data-ttu-id="a2fa1-195">这对特定 Web 应用程序结构会产生副作用，因为开发人员必须衡量安全性和审计要求。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-195">This is a side effect of a particular Web application architecture that developers must weigh against security and auditing requirements.</span></span>  
  
### <a name="pool-fragmentation-due-to-many-databases"></a><span data-ttu-id="a2fa1-196">因为许多数据库产生的池碎片</span><span class="sxs-lookup"><span data-stu-id="a2fa1-196">Pool Fragmentation Due to Many Databases</span></span>  

 <span data-ttu-id="a2fa1-197">许多 Internet 服务提供商在一台服务器上托管多个网站。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-197">Many Internet service providers host several Web sites on a single server.</span></span> <span data-ttu-id="a2fa1-198">他们可能使用单个数据库确认窗体身份验证登录，然后为该用户或用户组打开与特定数据库的连接。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-198">They may use a single database to confirm a Forms authentication login and then open a connection to a specific database for that user or group of users.</span></span> <span data-ttu-id="a2fa1-199">与身份验证数据库的连接将建立池连接，供每个用户使用。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-199">The connection to the authentication database is pooled and used by everyone.</span></span> <span data-ttu-id="a2fa1-200">但是，每个数据库的连接存在一个独立的池，这会增加与服务器的连接数。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-200">However, there is a separate pool of connections to each database, which increase the number of connections to the server.</span></span>  
  
 <span data-ttu-id="a2fa1-201">这也会对应用程序设计产生副作用。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-201">This is also a side-effect of the application design.</span></span> <span data-ttu-id="a2fa1-202">但是，可以通过一个相对简单的方式避免此副作用，而又不会影响连接 SQL Server 时的安全性。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-202">There is a relatively simple way to avoid this side effect without compromising security when you connect to SQL Server.</span></span> <span data-ttu-id="a2fa1-203">不是为每个用户或组连接独立的数据库，而是连接到服务器上的相同数据库，然后执行 Transact-SQL USE 语句来切换为所需的数据库。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-203">Instead of connecting to a separate database for each user or group, connect to the same database on the server and then execute the Transact-SQL USE statement to change to the desired database.</span></span> <span data-ttu-id="a2fa1-204">以下代码段演示如何创建与 `master` 数据库的初始连接，然后切换到 `databaseName` 字符串变量中指定的所需数据库。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-204">The following code fragment demonstrates creating an initial connection to the `master` database and then switching to the desired database specified in the `databaseName` string variable.</span></span>  
  
```vb  
' Assumes that command is a valid SqlCommand object and that  
' connectionString connects to master.  
    command.Text = "USE DatabaseName"  
Using connection As New SqlConnection(connectionString)  
    connection.Open()  
    command.ExecuteNonQuery()  
End Using  
```  
  
```csharp  
// Assumes that command is a SqlCommand object and that  
// connectionString connects to master.  
command.Text = "USE DatabaseName";  
using (SqlConnection connection = new SqlConnection(  
  connectionString))  
  {  
    connection.Open();  
    command.ExecuteNonQuery();  
  }  
```  
  
## <a name="application-roles-and-connection-pooling"></a><span data-ttu-id="a2fa1-205">应用程序角色和连接池</span><span class="sxs-lookup"><span data-stu-id="a2fa1-205">Application Roles and Connection Pooling</span></span>  

 <span data-ttu-id="a2fa1-206">通过调用 `sp_setapprole` 系统存储过程激活了 SQL Server 应用程序角色之后，该连接的安全上下文无法重置。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-206">After a SQL Server application role has been activated by calling the `sp_setapprole` system stored procedure, the security context of that connection cannot be reset.</span></span> <span data-ttu-id="a2fa1-207">但是，如果启用了池，连接将返回池，在重复使用池连接时会出错。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-207">However, if pooling is enabled, the connection is returned to the pool, and an error occurs when the pooled connection is reused.</span></span> <span data-ttu-id="a2fa1-208">有关详细信息，请参阅知识库文章 "[OLE DB 资源池的 SQL 应用程序角色错误](https://support.microsoft.com/default.aspx?scid=KB;EN-US;Q229564)"。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-208">For more information, see the Knowledge Base article, "[SQL application role errors with OLE DB resource pooling](https://support.microsoft.com/default.aspx?scid=KB;EN-US;Q229564)."</span></span>  
  
### <a name="application-role-alternatives"></a><span data-ttu-id="a2fa1-209">应用程序角色替代项</span><span class="sxs-lookup"><span data-stu-id="a2fa1-209">Application Role Alternatives</span></span>  

 <span data-ttu-id="a2fa1-210">建议您利用可以使用的安全机制，而不使用应用程序角色。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-210">We recommend that you take advantage of security mechanisms that you can use instead of application roles.</span></span> <span data-ttu-id="a2fa1-211">有关详细信息，请参阅 [在 SQL Server 中创建应用程序角色](./sql/creating-application-roles-in-sql-server.md)。</span><span class="sxs-lookup"><span data-stu-id="a2fa1-211">For more information, see [Creating Application Roles in SQL Server](./sql/creating-application-roles-in-sql-server.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a2fa1-212">请参阅</span><span class="sxs-lookup"><span data-stu-id="a2fa1-212">See also</span></span>

- [<span data-ttu-id="a2fa1-213">连接池</span><span class="sxs-lookup"><span data-stu-id="a2fa1-213">Connection Pooling</span></span>](connection-pooling.md)
- [<span data-ttu-id="a2fa1-214">SQL Server 和 ADO.NET</span><span class="sxs-lookup"><span data-stu-id="a2fa1-214">SQL Server and ADO.NET</span></span>](./sql/index.md)
- [<span data-ttu-id="a2fa1-215">性能计数器</span><span class="sxs-lookup"><span data-stu-id="a2fa1-215">Performance Counters</span></span>](performance-counters.md)
- [<span data-ttu-id="a2fa1-216">ADO.NET 概述</span><span class="sxs-lookup"><span data-stu-id="a2fa1-216">ADO.NET Overview</span></span>](ado-net-overview.md)
