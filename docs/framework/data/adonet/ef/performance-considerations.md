---
title: 性能注意事项（实体框架）
description: 了解 ADO.NET 的性能特征实体框架和注意事项，以帮助提高实体框架应用程序的性能。
ms.date: 03/30/2017
ms.assetid: 61913f3b-4f42-4d9b-810f-2a13c2388a4a
ms.openlocfilehash: 799ceff8b0bc370e929f2a4ad99b64a4fde4226a
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/24/2020
ms.locfileid: "91156718"
---
# <a name="performance-considerations-entity-framework"></a><span data-ttu-id="0e0de-103">性能注意事项（实体框架）</span><span class="sxs-lookup"><span data-stu-id="0e0de-103">Performance Considerations (Entity Framework)</span></span>

<span data-ttu-id="0e0de-104">本主题介绍 ADO.NET 实体框架的性能特征，并提供一些注意事项帮助改善实体框架应用程序的性能。</span><span class="sxs-lookup"><span data-stu-id="0e0de-104">This topic describes performance characteristics of the ADO.NET Entity Framework and provides some considerations to help improve the performance of Entity Framework applications.</span></span>  
  
## <a name="stages-of-query-execution"></a><span data-ttu-id="0e0de-105">查询执行的各个阶段</span><span class="sxs-lookup"><span data-stu-id="0e0de-105">Stages of Query Execution</span></span>  

 <span data-ttu-id="0e0de-106">为了更好地了解查询在实体框架中的性能，了解当查询针对概念模型执行并将数据作为对象返回时发生的操作将很有帮助。</span><span class="sxs-lookup"><span data-stu-id="0e0de-106">In order to better understand the performance of queries in the Entity Framework, it is helpful to understand the operations that occur when a query executes against a conceptual model and returns data as objects.</span></span> <span data-ttu-id="0e0de-107">下表描述这一系列操作。</span><span class="sxs-lookup"><span data-stu-id="0e0de-107">The following table describes this series of operations.</span></span>  
  
|<span data-ttu-id="0e0de-108">操作</span><span class="sxs-lookup"><span data-stu-id="0e0de-108">Operation</span></span>|<span data-ttu-id="0e0de-109">相对成本</span><span class="sxs-lookup"><span data-stu-id="0e0de-109">Relative Cost</span></span>|<span data-ttu-id="0e0de-110">频率</span><span class="sxs-lookup"><span data-stu-id="0e0de-110">Frequency</span></span>|<span data-ttu-id="0e0de-111">注释</span><span class="sxs-lookup"><span data-stu-id="0e0de-111">Comments</span></span>|  
|---------------|-------------------|---------------|--------------|  
|<span data-ttu-id="0e0de-112">加载元数据</span><span class="sxs-lookup"><span data-stu-id="0e0de-112">Loading metadata</span></span>|<span data-ttu-id="0e0de-113">中等</span><span class="sxs-lookup"><span data-stu-id="0e0de-113">Moderate</span></span>|<span data-ttu-id="0e0de-114">在每个应用程序域中一次。</span><span class="sxs-lookup"><span data-stu-id="0e0de-114">Once in each application domain.</span></span>|<span data-ttu-id="0e0de-115">实体框架使用的模型和映射元数据加载到 <xref:System.Data.Metadata.Edm.MetadataWorkspace> 中。</span><span class="sxs-lookup"><span data-stu-id="0e0de-115">Model and mapping metadata used by the Entity Framework is loaded into a <xref:System.Data.Metadata.Edm.MetadataWorkspace>.</span></span> <span data-ttu-id="0e0de-116">此元数据全局缓存，并可用于同一个应用程序域中的其他 <xref:System.Data.Objects.ObjectContext> 实例。</span><span class="sxs-lookup"><span data-stu-id="0e0de-116">This metadata is cached globally and is available to other instances of <xref:System.Data.Objects.ObjectContext> in the same application domain.</span></span>|  
|<span data-ttu-id="0e0de-117">打开数据库连接</span><span class="sxs-lookup"><span data-stu-id="0e0de-117">Opening the database connection</span></span>|<span data-ttu-id="0e0de-118">中等<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="0e0de-118">Moderate<sup>1</sup></span></span>|<span data-ttu-id="0e0de-119">根据需要。</span><span class="sxs-lookup"><span data-stu-id="0e0de-119">As needed.</span></span>|<span data-ttu-id="0e0de-120">由于与数据库的开放式连接会占用宝贵的资源，因此实体框架会根据需要打开和关闭数据库连接。</span><span class="sxs-lookup"><span data-stu-id="0e0de-120">Because an open connection to the database consumes a valuable resource, the Entity Framework opens and closes the database connection only as needed.</span></span> <span data-ttu-id="0e0de-121">还可以显式打开连接。</span><span class="sxs-lookup"><span data-stu-id="0e0de-121">You can also explicitly open the connection.</span></span> <span data-ttu-id="0e0de-122">有关详细信息，请参阅 [管理连接和事务](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="0e0de-122">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>|  
|<span data-ttu-id="0e0de-123">生成视图</span><span class="sxs-lookup"><span data-stu-id="0e0de-123">Generating views</span></span>|<span data-ttu-id="0e0de-124">高</span><span class="sxs-lookup"><span data-stu-id="0e0de-124">High</span></span>|<span data-ttu-id="0e0de-125">在每个应用程序域中一次。</span><span class="sxs-lookup"><span data-stu-id="0e0de-125">Once in each application domain.</span></span> <span data-ttu-id="0e0de-126">（可以预生成。）</span><span class="sxs-lookup"><span data-stu-id="0e0de-126">(Can be pre-generated.)</span></span>|<span data-ttu-id="0e0de-127">在实体框架可以针对概念模型执行查询或将更改保存到数据源之前，它必须生成一组本地查询视图才能访问数据库。</span><span class="sxs-lookup"><span data-stu-id="0e0de-127">Before the Entity Framework can execute a query against a conceptual model or save changes to the data source, it must generate a set of local query views to access the database.</span></span> <span data-ttu-id="0e0de-128">由于生成这些视图会产生很高的成本，因此，您可以在设计时预生成视图并将它们添加到项目。</span><span class="sxs-lookup"><span data-stu-id="0e0de-128">Because of the high cost of generating these views, you can pre-generate the views and add them to the project at design-time.</span></span> <span data-ttu-id="0e0de-129">有关详细信息，请参阅 [如何：预生成视图以提高查询性能](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="0e0de-129">For more information, see [How to: Pre-Generate Views to Improve Query Performance](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>|  
|<span data-ttu-id="0e0de-130">准备查询</span><span class="sxs-lookup"><span data-stu-id="0e0de-130">Preparing the query</span></span>|<span data-ttu-id="0e0de-131">中等<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="0e0de-131">Moderate<sup>2</sup></span></span>|<span data-ttu-id="0e0de-132">每个唯一查询一次。</span><span class="sxs-lookup"><span data-stu-id="0e0de-132">Once for each unique query.</span></span>|<span data-ttu-id="0e0de-133">包括编写查询命令、基于模型和映射元数据生成命令树和定义所返回数据的形状的成本。</span><span class="sxs-lookup"><span data-stu-id="0e0de-133">Includes the costs to compose the query command, generate a command tree based on model and mapping metadata, and define the shape of the returned data.</span></span> <span data-ttu-id="0e0de-134">因为实体 SQL查询命令和 LINQ 查询现已缓存，所以，以后执行相同查询所需的时间较少。</span><span class="sxs-lookup"><span data-stu-id="0e0de-134">Because now both Entity SQL query commands and LINQ queries are cached, later executions of the same query take less time.</span></span> <span data-ttu-id="0e0de-135">您仍可以使用已编译的 LINQ 查询来降低后续执行中的这一开销，编译的查询比自动缓存的 LINQ 查询效率更高。</span><span class="sxs-lookup"><span data-stu-id="0e0de-135">You can still use compiled LINQ queries to reduce this cost in later executions and compiled queries can be more efficient than LINQ queries that are automatically cached.</span></span> <span data-ttu-id="0e0de-136">有关详细信息，请参阅 [)  (LINQ to Entities 的编译查询 ](./language-reference/compiled-queries-linq-to-entities.md)。</span><span class="sxs-lookup"><span data-stu-id="0e0de-136">For more information, see [Compiled Queries  (LINQ to Entities)](./language-reference/compiled-queries-linq-to-entities.md).</span></span> <span data-ttu-id="0e0de-137">有关 LINQ 查询执行的常规信息，请参阅 [LINQ to Entities](./language-reference/linq-to-entities.md)。</span><span class="sxs-lookup"><span data-stu-id="0e0de-137">For general information about LINQ query execution, see [LINQ to Entities](./language-reference/linq-to-entities.md).</span></span> <span data-ttu-id="0e0de-138">**注意：** `Enumerable.Contains` 不自动缓存将运算符应用于内存中集合的 LINQ to Entities 查询。</span><span class="sxs-lookup"><span data-stu-id="0e0de-138">**Note:**  LINQ to Entities queries that apply the `Enumerable.Contains` operator to in-memory collections are not automatically cached.</span></span> <span data-ttu-id="0e0de-139">此外，不允许在已编译的 LINQ 查询中参数化内存中的集合。</span><span class="sxs-lookup"><span data-stu-id="0e0de-139">Also parameterizing in-memory collections in compiled LINQ queries is not allowed.</span></span>|  
|<span data-ttu-id="0e0de-140">执行查询</span><span class="sxs-lookup"><span data-stu-id="0e0de-140">Executing the query</span></span>|<span data-ttu-id="0e0de-141">低<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="0e0de-141">Low<sup>2</sup></span></span>|<span data-ttu-id="0e0de-142">每个查询一次。</span><span class="sxs-lookup"><span data-stu-id="0e0de-142">Once for each query.</span></span>|<span data-ttu-id="0e0de-143">使用 ADO.NET 数据提供程序对数据源执行命令的成本。</span><span class="sxs-lookup"><span data-stu-id="0e0de-143">The cost of executing the command against the data source by using the ADO.NET data provider.</span></span> <span data-ttu-id="0e0de-144">因为大多数数据源缓存查询计划，所以，以后执行相同查询所需的时间可能较少。</span><span class="sxs-lookup"><span data-stu-id="0e0de-144">Because most data sources cache query plans, later executions of the same query may take even less time.</span></span>|  
|<span data-ttu-id="0e0de-145">加载和验证类型</span><span class="sxs-lookup"><span data-stu-id="0e0de-145">Loading and validating types</span></span>|<span data-ttu-id="0e0de-146">低<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="0e0de-146">Low<sup>3</sup></span></span>|<span data-ttu-id="0e0de-147">每个 <xref:System.Data.Objects.ObjectContext> 实例一次。</span><span class="sxs-lookup"><span data-stu-id="0e0de-147">Once for each <xref:System.Data.Objects.ObjectContext> instance.</span></span>|<span data-ttu-id="0e0de-148">将加载类型，并针对概念模型定义的类型对其进行验证。</span><span class="sxs-lookup"><span data-stu-id="0e0de-148">Types are loaded and validated against the types that the conceptual model defines.</span></span>|  
|<span data-ttu-id="0e0de-149">跟踪</span><span class="sxs-lookup"><span data-stu-id="0e0de-149">Tracking</span></span>|<span data-ttu-id="0e0de-150">低<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="0e0de-150">Low<sup>3</sup></span></span>|<span data-ttu-id="0e0de-151">对于查询返回的每个对象执行一次。</span><span class="sxs-lookup"><span data-stu-id="0e0de-151">Once for each object that a query returns.</span></span> <span data-ttu-id="0e0de-152"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="0e0de-152"><sup>4</sup></span></span>|<span data-ttu-id="0e0de-153">如果查询使用 <xref:System.Data.Objects.MergeOption.NoTracking> 合并选项，则此阶段不影响性能。</span><span class="sxs-lookup"><span data-stu-id="0e0de-153">If a query uses the <xref:System.Data.Objects.MergeOption.NoTracking> merge option, this stage does not affect performance.</span></span><br /><br /> <span data-ttu-id="0e0de-154">如果查询使用 <xref:System.Data.Objects.MergeOption.AppendOnly>、<xref:System.Data.Objects.MergeOption.PreserveChanges> 或 <xref:System.Data.Objects.MergeOption.OverwriteChanges> 合并选项，则将在 <xref:System.Data.Objects.ObjectStateManager> 中跟踪查询结果。</span><span class="sxs-lookup"><span data-stu-id="0e0de-154">If the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> merge option, query results are tracked in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="0e0de-155">将为查询返回的每个跟踪对象生成一个 <xref:System.Data.EntityKey>，并用于在 <xref:System.Data.Objects.ObjectStateEntry> 中创建 <xref:System.Data.Objects.ObjectStateManager>。</span><span class="sxs-lookup"><span data-stu-id="0e0de-155">An <xref:System.Data.EntityKey> is generated for each tracked object that the query returns and is used to create an <xref:System.Data.Objects.ObjectStateEntry> in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="0e0de-156">如果对于 <xref:System.Data.Objects.ObjectStateEntry> 可以找到现有 <xref:System.Data.EntityKey>，则返回现有对象。</span><span class="sxs-lookup"><span data-stu-id="0e0de-156">If an existing <xref:System.Data.Objects.ObjectStateEntry> can be found for the <xref:System.Data.EntityKey>, the existing object is returned.</span></span> <span data-ttu-id="0e0de-157">如果使用 <xref:System.Data.Objects.MergeOption.PreserveChanges> 或 <xref:System.Data.Objects.MergeOption.OverwriteChanges> 选项，则首先更新对象，然后返回此对象。</span><span class="sxs-lookup"><span data-stu-id="0e0de-157">If the <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> option is used, the object is updated before it is returned.</span></span><br /><br /> <span data-ttu-id="0e0de-158">有关详细信息，请参阅 [标识解析、状态管理和更改跟踪](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="0e0de-158">For more information, see [Identity Resolution, State Management, and Change Tracking](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
|<span data-ttu-id="0e0de-159">使对象具体化</span><span class="sxs-lookup"><span data-stu-id="0e0de-159">Materializing the objects</span></span>|<span data-ttu-id="0e0de-160">中等<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="0e0de-160">Moderate<sup>3</sup></span></span>|<span data-ttu-id="0e0de-161">对于查询返回的每个对象执行一次。</span><span class="sxs-lookup"><span data-stu-id="0e0de-161">Once for each object that a query returns.</span></span> <span data-ttu-id="0e0de-162"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="0e0de-162"><sup>4</sup></span></span>|<span data-ttu-id="0e0de-163">读取返回的 <xref:System.Data.Common.DbDataReader> 对象、创建对象以及设置属性值（这些值基于 <xref:System.Data.Common.DbDataRecord> 类的每个实例中的值）的过程。</span><span class="sxs-lookup"><span data-stu-id="0e0de-163">The process of reading the returned <xref:System.Data.Common.DbDataReader> object and creating objects and setting property values that are based on the values in each instance of the <xref:System.Data.Common.DbDataRecord> class.</span></span> <span data-ttu-id="0e0de-164">如果对象已存在于 <xref:System.Data.Objects.ObjectContext> 中且查询使用 <xref:System.Data.Objects.MergeOption.AppendOnly> 或 <xref:System.Data.Objects.MergeOption.PreserveChanges> 合并选项，则此阶段不影响性能。</span><span class="sxs-lookup"><span data-stu-id="0e0de-164">If the object already exists in the <xref:System.Data.Objects.ObjectContext> and the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly> or <xref:System.Data.Objects.MergeOption.PreserveChanges> merge options, this stage does not affect performance.</span></span> <span data-ttu-id="0e0de-165">有关详细信息，请参阅 [标识解析、状态管理和更改跟踪](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="0e0de-165">For more information, see [Identity Resolution, State Management, and Change Tracking](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
  
 <span data-ttu-id="0e0de-166"><sup>1</sup> 当数据源提供程序实现连接池时，打开连接的成本分布在整个池中。</span><span class="sxs-lookup"><span data-stu-id="0e0de-166"><sup>1</sup> When a data source provider implements connection pooling, the cost of opening a connection is distributed across the pool.</span></span> <span data-ttu-id="0e0de-167">SQL Server 的 .NET 提供程序支持连接池。</span><span class="sxs-lookup"><span data-stu-id="0e0de-167">The .NET Provider for SQL Server supports connection pooling.</span></span>  
  
 <span data-ttu-id="0e0de-168"><sup>2</sup> 增加了查询复杂性，增加了开销。</span><span class="sxs-lookup"><span data-stu-id="0e0de-168"><sup>2</sup> Cost increases with increased query complexity.</span></span>  
  
 <span data-ttu-id="0e0de-169"><sup>3</sup> 总成本随着查询返回的对象数的增加而增加。</span><span class="sxs-lookup"><span data-stu-id="0e0de-169"><sup>3</sup> Total cost increases proportional to the number of objects returned by the query.</span></span>  
  
 <span data-ttu-id="0e0de-170"><sup>4</sup> EntityClient 查询不需要此开销，因为 EntityClient 查询返回的 <xref:System.Data.EntityClient.EntityDataReader> 是而不是对象。</span><span class="sxs-lookup"><span data-stu-id="0e0de-170"><sup>4</sup> This overhead is not required for EntityClient queries because EntityClient queries return an <xref:System.Data.EntityClient.EntityDataReader> instead of objects.</span></span> <span data-ttu-id="0e0de-171">有关详细信息，请参阅 [用于 Entity Framework 的 EntityClient 提供程序](entityclient-provider-for-the-entity-framework.md)。</span><span class="sxs-lookup"><span data-stu-id="0e0de-171">For more information, see [EntityClient Provider for the Entity Framework](entityclient-provider-for-the-entity-framework.md).</span></span>  
  
## <a name="additional-considerations"></a><span data-ttu-id="0e0de-172">其他注意事项</span><span class="sxs-lookup"><span data-stu-id="0e0de-172">Additional Considerations</span></span>  

 <span data-ttu-id="0e0de-173">下面是可能影响实体框架应用程序的性能的其他注意事项。</span><span class="sxs-lookup"><span data-stu-id="0e0de-173">The following are other considerations that may affect the performance of Entity Framework applications.</span></span>  
  
### <a name="query-execution"></a><span data-ttu-id="0e0de-174">查询执行</span><span class="sxs-lookup"><span data-stu-id="0e0de-174">Query Execution</span></span>  

 <span data-ttu-id="0e0de-175">因为查询可能消耗大量资源，所以请考虑一下在代码中的哪个点以及在哪台计算机上执行查询。</span><span class="sxs-lookup"><span data-stu-id="0e0de-175">Because queries can be resource intensive, consider at what point in your code and on what computer a query is executed.</span></span>  
  
#### <a name="deferred-versus-immediate-execution"></a><span data-ttu-id="0e0de-176">延迟执行与立即执行</span><span class="sxs-lookup"><span data-stu-id="0e0de-176">Deferred versus immediate execution</span></span>  

 <span data-ttu-id="0e0de-177">当您创建 <xref:System.Data.Objects.ObjectQuery%601> 或 LINQ 查询时，查询可能并不立即执行。</span><span class="sxs-lookup"><span data-stu-id="0e0de-177">When you create an <xref:System.Data.Objects.ObjectQuery%601> or LINQ query, the query may not be executed immediately.</span></span> <span data-ttu-id="0e0de-178">查询延迟执行，直到您需要结果，例如，在 `foreach` (C#) 或 `For Each` (Visual Basic) 枚举期间或当分配此查询以填充 <xref:System.Collections.Generic.List%601> 集合时。</span><span class="sxs-lookup"><span data-stu-id="0e0de-178">Query execution is deferred until the results are needed, such as during a `foreach` (C#) or `For Each` (Visual Basic) enumeration or when it is assigned to fill a <xref:System.Collections.Generic.List%601> collection.</span></span> <span data-ttu-id="0e0de-179">当您对 <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> 调用 <xref:System.Data.Objects.ObjectQuery%601> 方法时，或当您调用返回单一查询（如 <xref:System.Linq.Enumerable.First%2A> 或 <xref:System.Linq.Enumerable.Any%2A>）的 LINQ 方法时，将立即开始执行查询。</span><span class="sxs-lookup"><span data-stu-id="0e0de-179">Query execution begins immediately when you call the <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> method on an <xref:System.Data.Objects.ObjectQuery%601> or when you call a LINQ method that returns a singleton query, such as <xref:System.Linq.Enumerable.First%2A> or <xref:System.Linq.Enumerable.Any%2A>.</span></span> <span data-ttu-id="0e0de-180">有关详细信息，请参阅[ (LINQ to Entities) ](./language-reference/query-execution.md)的[对象查询](/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100))和查询执行。</span><span class="sxs-lookup"><span data-stu-id="0e0de-180">For more information, see [Object Queries](/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) and [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
#### <a name="client-side-execution-of-linq-queries"></a><span data-ttu-id="0e0de-181">客户端执行 LINQ 查询</span><span class="sxs-lookup"><span data-stu-id="0e0de-181">Client-side execution of LINQ queries</span></span>  

 <span data-ttu-id="0e0de-182">尽管 LINQ 查询执行发生在承载数据源的计算机上，但 LINQ 查询的某些部分可能在客户端计算机上进行计算。</span><span class="sxs-lookup"><span data-stu-id="0e0de-182">Although the execution of a LINQ query occurs on the computer that hosts the data source, some parts of a LINQ query may be evaluated on the client computer.</span></span> <span data-ttu-id="0e0de-183">有关详细信息，请参阅 " [查询执行" (LINQ to Entities) ](./language-reference/query-execution.md)的 "存储执行" 部分。</span><span class="sxs-lookup"><span data-stu-id="0e0de-183">For more information, see the Store Execution section of [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
### <a name="query-and-mapping-complexity"></a><span data-ttu-id="0e0de-184">查询和映射复杂性</span><span class="sxs-lookup"><span data-stu-id="0e0de-184">Query and Mapping Complexity</span></span>  

 <span data-ttu-id="0e0de-185">实体模型中各个查询以及映射的复杂性对查询性能具有重大影响。</span><span class="sxs-lookup"><span data-stu-id="0e0de-185">The complexity of individual queries and of the mapping in the entity model will have a significant effect on query performance.</span></span>  
  
#### <a name="mapping-complexity"></a><span data-ttu-id="0e0de-186">映射复杂性</span><span class="sxs-lookup"><span data-stu-id="0e0de-186">Mapping complexity</span></span>  

 <span data-ttu-id="0e0de-187">比概念模型中实体之间和存储模型中表之间的简单一对一映射更复杂的模型与具有一对一映射的模型相比，前者将生成更复杂的命令。</span><span class="sxs-lookup"><span data-stu-id="0e0de-187">Models that are more complex than a simple one-to-one mapping between entities in the conceptual model and tables in the storage model generate more complex commands than models that have a one-to-one mapping.</span></span>  
  
#### <a name="query-complexity"></a><span data-ttu-id="0e0de-188">查询复杂性</span><span class="sxs-lookup"><span data-stu-id="0e0de-188">Query complexity</span></span>  

 <span data-ttu-id="0e0de-189">在针对数据源执行的命令或返回大量数据的命令中需要大量联接的查询可能会在以下几个方面影响性能：</span><span class="sxs-lookup"><span data-stu-id="0e0de-189">Queries that require a large number of joins in the commands that are executed against the data source or that return a large amount of data may affect performance in the following ways:</span></span>  
  
- <span data-ttu-id="0e0de-190">看似简单的针对概念模型的查询可能导致对数据源执行更复杂的查询。</span><span class="sxs-lookup"><span data-stu-id="0e0de-190">Queries against a conceptual model that seem simple may result in the execution of more complex queries against the data source.</span></span> <span data-ttu-id="0e0de-191">因为实体框架将针对概念模型的查询转换为针对数据源的等效查询，所以可能发生上述情况。</span><span class="sxs-lookup"><span data-stu-id="0e0de-191">This can occur because the Entity Framework translates a query against a conceptual model into an equivalent query against the data source.</span></span> <span data-ttu-id="0e0de-192">当概念模型中的单个实体集映射到数据源中的多个表时，或当实体之间的关系映射到联接表时，针对数据源查询执行的查询命令可能需要一个或多个联接。</span><span class="sxs-lookup"><span data-stu-id="0e0de-192">When a single entity set in the conceptual model maps to more than one table in the data source, or when a relationship between entities is mapped to a join table, the query command executed against the data source query may require one or more joins.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="0e0de-193">使用 <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> 或 <xref:System.Data.Objects.ObjectQuery%601> 类的 <xref:System.Data.EntityClient.EntityCommand> 方法可以查看针对给定查询的数据源执行的命令。</span><span class="sxs-lookup"><span data-stu-id="0e0de-193">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method of the <xref:System.Data.Objects.ObjectQuery%601> or <xref:System.Data.EntityClient.EntityCommand> classes to view the commands that are executed against the data source for a given query.</span></span> <span data-ttu-id="0e0de-194">有关详细信息，请参阅 [如何：查看存储命令](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="0e0de-194">For more information, see [How to: View the Store Commands](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
- <span data-ttu-id="0e0de-195">嵌套的 Entity SQL 查询可能在服务器上创建联接，并可能返回大量的行。</span><span class="sxs-lookup"><span data-stu-id="0e0de-195">Nested Entity SQL queries may create joins on the server and can return a large number of rows.</span></span>  
  
     <span data-ttu-id="0e0de-196">下面是投影子句中嵌套查询的示例：</span><span class="sxs-lookup"><span data-stu-id="0e0de-196">The following is an example of a nested query in a projection clause:</span></span>  
  
    ```sql  
    SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2
        FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1
        FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
    ```  
  
     <span data-ttu-id="0e0de-197">此外，此类查询还会导致查询管道生成单个查询并在各嵌套查询间复制对象。</span><span class="sxs-lookup"><span data-stu-id="0e0de-197">In addition, such queries cause the query pipeline to generate a single query with duplication of objects across nested queries.</span></span> <span data-ttu-id="0e0de-198">因此，单一列可能会复制多次。</span><span class="sxs-lookup"><span data-stu-id="0e0de-198">Because of this, a single column may be duplicated multiple times.</span></span> <span data-ttu-id="0e0de-199">在某些数据库（包括 SQL Server）中，这可能导致 TempDB 表增长过大，而降低服务器性能。</span><span class="sxs-lookup"><span data-stu-id="0e0de-199">On some databases, including SQL Server, this can cause the TempDB table to grow very large, which can decrease server performance.</span></span> <span data-ttu-id="0e0de-200">当执行嵌套查询时，应务必小心。</span><span class="sxs-lookup"><span data-stu-id="0e0de-200">Care should be taken when you execute nested queries.</span></span>  
  
- <span data-ttu-id="0e0de-201">如果客户端执行的操作所消耗的资源与结果集的大小成正比，则返回大量数据的任何查询都可能导致性能下降。</span><span class="sxs-lookup"><span data-stu-id="0e0de-201">Any queries that return a large amount of data can cause decreased performance if the client is performing operations that consume resources in a way that is proportional to the size of the result set.</span></span> <span data-ttu-id="0e0de-202">在此类情况下，应考虑限制查询返回的数据量。</span><span class="sxs-lookup"><span data-stu-id="0e0de-202">In such cases, you should consider limiting the amount of data returned by the query.</span></span> <span data-ttu-id="0e0de-203">有关详细信息，请参阅 [如何：对查询结果进行分页](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="0e0de-203">For more information, see [How to: Page Through Query Results](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
 <span data-ttu-id="0e0de-204">实体框架自动生成的任何命令都可能比数据库开发人员显式编写的类似命令更复杂。</span><span class="sxs-lookup"><span data-stu-id="0e0de-204">Any commands automatically generated by the Entity Framework may be more complex than similar commands written explicitly by a database developer.</span></span> <span data-ttu-id="0e0de-205">如果您需要对针对数据源执行的命令进行显式控制，请考虑对表值函数或存储过程定义映射。</span><span class="sxs-lookup"><span data-stu-id="0e0de-205">If you need explicit control over the commands executed against your data source, consider defining a mapping to a table-valued function or stored procedure.</span></span>  
  
#### <a name="relationships"></a><span data-ttu-id="0e0de-206">关系</span><span class="sxs-lookup"><span data-stu-id="0e0de-206">Relationships</span></span>  

 <span data-ttu-id="0e0de-207">若要获得最佳查询性能，必须将实体之间的关系同时定义为实体模型中的关联和数据源中的逻辑关系。</span><span class="sxs-lookup"><span data-stu-id="0e0de-207">For optimal query performance, you must define relationships between entities both as associations in the entity model and as logical relationships in the data source.</span></span>  
  
### <a name="query-paths"></a><span data-ttu-id="0e0de-208">查询路径</span><span class="sxs-lookup"><span data-stu-id="0e0de-208">Query Paths</span></span>  

 <span data-ttu-id="0e0de-209">默认情况下，当您执行 <xref:System.Data.Objects.ObjectQuery%601> 时，并不返回相关对象（但返回表示关系自身的对象）。</span><span class="sxs-lookup"><span data-stu-id="0e0de-209">By default, when you execute an <xref:System.Data.Objects.ObjectQuery%601>, related objects are not returned (although objects that represent the relationships themselves are).</span></span> <span data-ttu-id="0e0de-210">可以采用以下三种方法之一加载相关对象：</span><span class="sxs-lookup"><span data-stu-id="0e0de-210">You can load related objects in one of three ways:</span></span>  
  
1. <span data-ttu-id="0e0de-211">在执行 <xref:System.Data.Objects.ObjectQuery%601> 前设置查询路径。</span><span class="sxs-lookup"><span data-stu-id="0e0de-211">Set the query path before the <xref:System.Data.Objects.ObjectQuery%601> is executed.</span></span>  
  
2. <span data-ttu-id="0e0de-212">对于对象公开的导航属性调用 `Load` 方法。</span><span class="sxs-lookup"><span data-stu-id="0e0de-212">Call the `Load` method on the navigation property that the object exposes.</span></span>  
  
3. <span data-ttu-id="0e0de-213">将 <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> 上的 <xref:System.Data.Objects.ObjectContext> 选项设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="0e0de-213">Set the <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> option on the <xref:System.Data.Objects.ObjectContext> to `true`.</span></span> <span data-ttu-id="0e0de-214">请注意，当你通过 [实体数据模型设计器](/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100))生成对象层代码时，会自动执行此操作。</span><span class="sxs-lookup"><span data-stu-id="0e0de-214">Note that this is done automatically when you generate object-layer code with the [Entity Data Model Designer](/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)).</span></span> <span data-ttu-id="0e0de-215">有关详细信息，请参阅 [生成的代码概述](/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="0e0de-215">For more information see [Generated Code Overview](/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span></span>  
  
 <span data-ttu-id="0e0de-216">在考虑要使用哪个选项时，请注意在对数据库的请求数与单个查询中返回的数据量之间进行权衡。</span><span class="sxs-lookup"><span data-stu-id="0e0de-216">When you consider which option to use, be aware that there is a tradeoff between the number of requests against the database and the amount of data returned in a single query.</span></span> <span data-ttu-id="0e0de-217">有关详细信息，请参阅 [加载相关对象](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="0e0de-217">For more information, see [Loading Related Objects](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
#### <a name="using-query-paths"></a><span data-ttu-id="0e0de-218">使用查询路径</span><span class="sxs-lookup"><span data-stu-id="0e0de-218">Using query paths</span></span>  

 <span data-ttu-id="0e0de-219">查询路径定义查询返回的对象的图。</span><span class="sxs-lookup"><span data-stu-id="0e0de-219">Query paths define the graph of objects that a query returns.</span></span> <span data-ttu-id="0e0de-220">当定义查询路径时，仅需对数据库请求一次，即可返回该路径定义的所有对象。</span><span class="sxs-lookup"><span data-stu-id="0e0de-220">When you define a query path, only a single request against the database is required to return all objects that the path defines.</span></span> <span data-ttu-id="0e0de-221">如果使用查询路径，看似简单的对象查询也可能需要对数据源执行复杂的命令。</span><span class="sxs-lookup"><span data-stu-id="0e0de-221">Using query paths can result in complex commands being executed against the data source from seemingly simple object queries.</span></span> <span data-ttu-id="0e0de-222">这是因为，在单个查询中返回相关对象需要一个或多个联接。</span><span class="sxs-lookup"><span data-stu-id="0e0de-222">This occurs because one or more joins are required to return related objects in a single query.</span></span> <span data-ttu-id="0e0de-223">对复杂实体模型（如具有继承关系的实体或包含多对多关系的路径）进行的查询的复杂性将进一步加大。</span><span class="sxs-lookup"><span data-stu-id="0e0de-223">This complexity is greater in queries against a complex entity model, such as an entity with inheritance or a path that includes many-to-many relationships.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0e0de-224">使用 <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> 方法可以查看将由 <xref:System.Data.Objects.ObjectQuery%601> 生成的命令。</span><span class="sxs-lookup"><span data-stu-id="0e0de-224">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method to see the command that will be generated by an <xref:System.Data.Objects.ObjectQuery%601>.</span></span> <span data-ttu-id="0e0de-225">有关详细信息，请参阅 [如何：查看存储命令](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="0e0de-225">For more information, see [How to: View the Store Commands](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
 <span data-ttu-id="0e0de-226">如果查询路径包含过多相关对象，或对象包含过多行数据，数据源可能无法完成查询。</span><span class="sxs-lookup"><span data-stu-id="0e0de-226">When a query path includes too many related objects or the objects contain too much row data, the data source might be unable to complete the query.</span></span> <span data-ttu-id="0e0de-227">如果查询所需的中间临时存储区超过数据源的容量，则会出现这种情况。</span><span class="sxs-lookup"><span data-stu-id="0e0de-227">This occurs if the query requires intermediate temporary storage that exceeds the capabilities of the data source.</span></span> <span data-ttu-id="0e0de-228">出现这种情况时，通过显式加载相关对象可以降低数据源查询的复杂性。</span><span class="sxs-lookup"><span data-stu-id="0e0de-228">When this occurs, you can reduce the complexity of the data source query by explicitly loading related objects.</span></span>  
  
#### <a name="explicitly-loading-related-objects"></a><span data-ttu-id="0e0de-229">显式加载相关对象</span><span class="sxs-lookup"><span data-stu-id="0e0de-229">Explicitly loading related objects</span></span>  

 <span data-ttu-id="0e0de-230">通过对返回 `Load` 或 <xref:System.Data.Objects.DataClasses.EntityCollection%601> 的导航属性调用 <xref:System.Data.Objects.DataClasses.EntityReference%601> 方法，可以显式加载相关对象。</span><span class="sxs-lookup"><span data-stu-id="0e0de-230">You can explicitly load related objects by calling the `Load` method on a navigation property that returns an <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601>.</span></span> <span data-ttu-id="0e0de-231">显式加载对象要求每次调用 `Load` 时都往返一次数据库。</span><span class="sxs-lookup"><span data-stu-id="0e0de-231">Explicitly loading objects requires a round-trip to the database every time `Load` is called.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0e0de-232">如果在循环访问所返回对象的集合时调用 `Load`，例如，当您使用 `foreach` 语句（在 Visual Basic 中为 `For Each`）时，数据源特定的提供程序必须在单个连接上支持多个活动的结果集。</span><span class="sxs-lookup"><span data-stu-id="0e0de-232">if you call `Load` while looping through a collection of returned objects, such as when you use the `foreach` statement (`For Each` in Visual Basic), the data source-specific provider must support multiple active results sets on a single connection.</span></span> <span data-ttu-id="0e0de-233">对于 SQL Server 数据库，必须在提供程序连接字符串中指定 `MultipleActiveResultSets = true` 值。</span><span class="sxs-lookup"><span data-stu-id="0e0de-233">For a SQL Server database, you must specify a value of `MultipleActiveResultSets = true` in the provider connection string.</span></span>  
  
 <span data-ttu-id="0e0de-234">当实体没有 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> 或 <xref:System.Data.Objects.DataClasses.EntityCollection%601> 属性时，还可以使用 <xref:System.Data.Objects.DataClasses.EntityReference%601> 方法。</span><span class="sxs-lookup"><span data-stu-id="0e0de-234">You can also use the <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> method when there is no <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601> properties on entities.</span></span> <span data-ttu-id="0e0de-235">这在使用 POCO 实体时非常有用。</span><span class="sxs-lookup"><span data-stu-id="0e0de-235">This is useful when you are using POCO entities.</span></span>  
  
 <span data-ttu-id="0e0de-236">尽管显式加载相关对象将减少联接数并减少冗余数据量，但 `Load` 要求与数据库之间进行重复的连接，这在显式加载大量对象时可能会带来很高的成本。</span><span class="sxs-lookup"><span data-stu-id="0e0de-236">Although explicitly loading related objects will reduce the number of joins and reduced the amount of redundant data, `Load` requires repeated connections to the database, which can become costly when explicitly loading a large number of objects.</span></span>  
  
### <a name="saving-changes"></a><span data-ttu-id="0e0de-237">保存更改</span><span class="sxs-lookup"><span data-stu-id="0e0de-237">Saving Changes</span></span>  

 <span data-ttu-id="0e0de-238">当您对 <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> 调用 <xref:System.Data.Objects.ObjectContext> 方法时，将为上下文中每个添加、更新或删除的对象生成一个单独的创建、更新或删除命令。</span><span class="sxs-lookup"><span data-stu-id="0e0de-238">When you call the <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> method on an <xref:System.Data.Objects.ObjectContext>, a separate create, update, or delete command is generated for every added, updated, or deleted object in the context.</span></span> <span data-ttu-id="0e0de-239">这些命令在单个事务中针对数据源执行。</span><span class="sxs-lookup"><span data-stu-id="0e0de-239">These commands are executed on the data source in a single transaction.</span></span> <span data-ttu-id="0e0de-240">对于查询，创建、更新和删除操作的性能取决于概念模型中映射的复杂性。</span><span class="sxs-lookup"><span data-stu-id="0e0de-240">As with queries, the performance of create, update, and delete operations depends on the complexity of the mapping in the conceptual model.</span></span>  
  
### <a name="distributed-transactions"></a><span data-ttu-id="0e0de-241">分布式事务</span><span class="sxs-lookup"><span data-stu-id="0e0de-241">Distributed Transactions</span></span>  

 <span data-ttu-id="0e0de-242">在显式事务中执行的、需要由分布式事务处理协调器 (DTC) 管理的资源的操作与不需要 DTC 的相似操作相比，前者的成本要高得多。</span><span class="sxs-lookup"><span data-stu-id="0e0de-242">Operations in an explicit transaction that require resources that are managed by the distributed transaction coordinator (DTC) will be much more expensive than a similar operation that does not require the DTC.</span></span> <span data-ttu-id="0e0de-243">在以下情况下，将需要提升到 DTC：</span><span class="sxs-lookup"><span data-stu-id="0e0de-243">Promotion to the DTC will occur in the following situations:</span></span>  
  
- <span data-ttu-id="0e0de-244">具有对 SQL Server 2000 数据库执行的操作的显式事务，或始终将显式事务提升到 DTC 的其他数据源。</span><span class="sxs-lookup"><span data-stu-id="0e0de-244">An explicit transaction with an operation against a SQL Server 2000 database or other data source that always promote explicit transactions to the DTC.</span></span>  
  
- <span data-ttu-id="0e0de-245">当通过实体框架管理连接时，具有针对 SQL Server 2005 的操作的显式事务。</span><span class="sxs-lookup"><span data-stu-id="0e0de-245">An explicit transaction with an operation against SQL Server 2005 when the connection is managed by the Entity Framework.</span></span> <span data-ttu-id="0e0de-246">出现这种情况的原因是，每当关闭并在单个事务中重新打开连接时，SQL Server 2005 升级到 DTC，这是实体框架的默认行为。</span><span class="sxs-lookup"><span data-stu-id="0e0de-246">This occurs because SQL Server 2005 promotes to a DTC whenever a connection is closed and reopened within a single transaction, which is the default behavior of the Entity Framework.</span></span> <span data-ttu-id="0e0de-247">当使用 SQL Server 2008 时，不会发生这种 DTC 提升的现象。</span><span class="sxs-lookup"><span data-stu-id="0e0de-247">This DTC promotion does not occur when using SQL Server 2008.</span></span> <span data-ttu-id="0e0de-248">为了避免在使用 SQL Server 2005 时出现此提升，必须在事务中显式打开和关闭连接。</span><span class="sxs-lookup"><span data-stu-id="0e0de-248">To avoid this promotion when using SQL Server 2005, you must explicitly open and close the connection within the transaction.</span></span> <span data-ttu-id="0e0de-249">有关详细信息，请参阅 [管理连接和事务](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="0e0de-249">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
 <span data-ttu-id="0e0de-250">当在 <xref:System.Transactions> 事务内执行了一个或多个操作时，将使用显式事务。</span><span class="sxs-lookup"><span data-stu-id="0e0de-250">An explicit transaction is used when one or more operations are executed inside a <xref:System.Transactions> transaction.</span></span> <span data-ttu-id="0e0de-251">有关详细信息，请参阅 [管理连接和事务](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="0e0de-251">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="strategies-for-improving-performance"></a><span data-ttu-id="0e0de-252">改善性能的策略</span><span class="sxs-lookup"><span data-stu-id="0e0de-252">Strategies for Improving Performance</span></span>  

 <span data-ttu-id="0e0de-253">您可以通过以下策略改进实体框架中查询的总体性能：</span><span class="sxs-lookup"><span data-stu-id="0e0de-253">You can improve the overall performance of queries in the Entity Framework by using the following strategies.</span></span>  
  
#### <a name="pre-generate-views"></a><span data-ttu-id="0e0de-254">预生成视图</span><span class="sxs-lookup"><span data-stu-id="0e0de-254">Pre-generate views</span></span>  

 <span data-ttu-id="0e0de-255">当应用程序首次执行查询时，基于实体模型生成视图需要很高的成本。</span><span class="sxs-lookup"><span data-stu-id="0e0de-255">Generating views based on an entity model is a significant cost the first time that an application executes a query.</span></span> <span data-ttu-id="0e0de-256">使用 EdmGen.exe 实用工具可以将视图预生成为 Visual Basic 或 C# 代码文件，此文件可以在设计期间添加到项目中。</span><span class="sxs-lookup"><span data-stu-id="0e0de-256">Use the EdmGen.exe utility to pre-generate views as a Visual Basic or C# code file that can be added to the project during design.</span></span> <span data-ttu-id="0e0de-257">还可以使用文本模板转换工具包生成预编译的视图。</span><span class="sxs-lookup"><span data-stu-id="0e0de-257">You could also use the Text Template Transformation Toolkit to generate pre-compiled views.</span></span> <span data-ttu-id="0e0de-258">预生成的视图在运行时进行验证，以确保这些视图与指定实体模型的当前版本保持一致。</span><span class="sxs-lookup"><span data-stu-id="0e0de-258">Pre-generated views are validated at runtime to ensure that they are consistent with the current version of the specified entity model.</span></span> <span data-ttu-id="0e0de-259">有关详细信息，请参阅 [如何：预生成视图以提高查询性能](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="0e0de-259">For more information, see [How to: Pre-Generate Views to Improve Query Performance](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>
  
 <span data-ttu-id="0e0de-260">在使用非常大的模型时，适用以下注意事项：</span><span class="sxs-lookup"><span data-stu-id="0e0de-260">When working with very large models, the following consideration applies:</span></span>  
  
 <span data-ttu-id="0e0de-261">.NET 元数据格式将一个给定的二进制文件中的用户字符串字符数限定为 16,777,215 (0xFFFFFF)。</span><span class="sxs-lookup"><span data-stu-id="0e0de-261">The .NET metadata format limits the number of user string characters in a given binary to 16,777,215 (0xFFFFFF).</span></span> <span data-ttu-id="0e0de-262">如果你正在为非常大的模型生成视图，并且该视图文件达到此大小限制，则你将收到 "没有剩余的逻辑空间来创建更多用户字符串。"</span><span class="sxs-lookup"><span data-stu-id="0e0de-262">If you are generating views for a very large model and the view file reaches this size limit, you will get the "No logical space left to create more user strings."</span></span> <span data-ttu-id="0e0de-263">编译错误。</span><span class="sxs-lookup"><span data-stu-id="0e0de-263">compile error.</span></span> <span data-ttu-id="0e0de-264">此大小限制适用于所有托管二进制文件。</span><span class="sxs-lookup"><span data-stu-id="0e0de-264">This size limitation applies to all managed binaries.</span></span> <span data-ttu-id="0e0de-265">有关详细信息，请参阅 [博客](/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) ，其中演示了在处理大型和复杂模型时如何避免此错误。</span><span class="sxs-lookup"><span data-stu-id="0e0de-265">For more information see the [blog](/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) that demonstrates how to avoid the error when working with large and complex models.</span></span>  
  
#### <a name="consider-using-the-notracking-merge-option-for-queries"></a><span data-ttu-id="0e0de-266">考虑对查询使用 NoTracking 合并选项</span><span class="sxs-lookup"><span data-stu-id="0e0de-266">Consider using the NoTracking merge option for queries</span></span>  

 <span data-ttu-id="0e0de-267">跟踪对象上下文中返回的对象会引发成本。</span><span class="sxs-lookup"><span data-stu-id="0e0de-267">There is a cost required to track returned objects in the object context.</span></span> <span data-ttu-id="0e0de-268">检测对象更改以及确保对于同一个逻辑实体的多个请求返回相同的对象实例均要求将对象附加到 <xref:System.Data.Objects.ObjectContext> 实例。</span><span class="sxs-lookup"><span data-stu-id="0e0de-268">Detecting changes to objects and ensuring that multiple requests for the same logical entity return the same object instance requires that objects be attached to an <xref:System.Data.Objects.ObjectContext> instance.</span></span> <span data-ttu-id="0e0de-269">如果不打算对对象进行更新或删除操作，并且不需要标识管理，请考虑在 <xref:System.Data.Objects.MergeOption.NoTracking> 执行查询时使用合并选项。</span><span class="sxs-lookup"><span data-stu-id="0e0de-269">If you do not plan to make updates or deletes to objects and do not require identity management, consider using the <xref:System.Data.Objects.MergeOption.NoTracking> merge options when you execute queries.</span></span>  
  
#### <a name="return-the-correct-amount-of-data"></a><span data-ttu-id="0e0de-270">返回正确的数据量</span><span class="sxs-lookup"><span data-stu-id="0e0de-270">Return the correct amount of data</span></span>  

 <span data-ttu-id="0e0de-271">在某些方案下，使用 <xref:System.Data.Objects.ObjectQuery%601.Include%2A> 方法指定查询路径要快得多，因为它要求与数据库之间的往返次数较少。</span><span class="sxs-lookup"><span data-stu-id="0e0de-271">In some scenarios, specifying a query path using the <xref:System.Data.Objects.ObjectQuery%601.Include%2A> method is much faster because it requires fewer round trips to the database.</span></span> <span data-ttu-id="0e0de-272">然而，在其他方案中，加载相关对象时增加与数据库之间的往返次数可能会更快，因为联接较少的较为简单的查询会使数据冗余程度下降。</span><span class="sxs-lookup"><span data-stu-id="0e0de-272">However, in other scenarios, additional round trips to the database to load related objects may be faster because the simpler queries with fewer joins result in less redundancy of data.</span></span> <span data-ttu-id="0e0de-273">因此，我们建议你测试用于检索相关对象的不同方法的性能。</span><span class="sxs-lookup"><span data-stu-id="0e0de-273">Because of this, we recommend that you test the performance of various ways to retrieve related objects.</span></span> <span data-ttu-id="0e0de-274">有关详细信息，请参阅 [加载相关对象](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="0e0de-274">For more information, see [Loading Related Objects](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
 <span data-ttu-id="0e0de-275">为了避免在单个查询中返回过多的数据，请考虑将查询结果分页为多个可管理的组。</span><span class="sxs-lookup"><span data-stu-id="0e0de-275">To avoid returning too much data in a single query, consider paging the results of the query into more manageable groups.</span></span> <span data-ttu-id="0e0de-276">有关详细信息，请参阅 [如何：对查询结果进行分页](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="0e0de-276">For more information, see [How to: Page Through Query Results](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
#### <a name="limit-the-scope-of-the-objectcontext"></a><span data-ttu-id="0e0de-277">限制 ObjectContext 的作用域</span><span class="sxs-lookup"><span data-stu-id="0e0de-277">Limit the scope of the ObjectContext</span></span>  

 <span data-ttu-id="0e0de-278">在大多数情况下，应在 <xref:System.Data.Objects.ObjectContext> 语句（在 Visual Basic 中为 `using`）内创建一个 `Using…End Using` 实例。</span><span class="sxs-lookup"><span data-stu-id="0e0de-278">In most cases, you should create an <xref:System.Data.Objects.ObjectContext> instance within a `using` statement (`Using…End Using` in Visual Basic).</span></span> <span data-ttu-id="0e0de-279">这样，通过确保当代码退出语句块时自动释放与对象上下文关联的资源，可以提高性能。</span><span class="sxs-lookup"><span data-stu-id="0e0de-279">This can increase performance by ensuring that the resources associated with the object context are disposed automatically when the code exits the statement block.</span></span> <span data-ttu-id="0e0de-280">但是，当控制权绑定到由对象上下文管理的对象时，只要需要绑定并手动释放它，就应维护 <xref:System.Data.Objects.ObjectContext> 实例。</span><span class="sxs-lookup"><span data-stu-id="0e0de-280">However, when controls are bound to objects managed by the object context, the <xref:System.Data.Objects.ObjectContext> instance should be maintained as long as the binding is needed and disposed of manually.</span></span> <span data-ttu-id="0e0de-281">有关详细信息，请参阅 [管理连接和事务](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="0e0de-281">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
#### <a name="consider-opening-the-database-connection-manually"></a><span data-ttu-id="0e0de-282">考虑手动打开数据库连接</span><span class="sxs-lookup"><span data-stu-id="0e0de-282">Consider opening the database connection manually</span></span>  

 <span data-ttu-id="0e0de-283">当应用程序执行一系列对象查询或频繁调用 <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> 来持续对数据源执行创建、更新和删除操作时，实体框架必须连续打开并关闭与数据源的连接。</span><span class="sxs-lookup"><span data-stu-id="0e0de-283">When your application executes a series of object queries or frequently calls <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> to persist create, update, and delete operations to the data source, the Entity Framework must continuously open and close the connection to the data source.</span></span> <span data-ttu-id="0e0de-284">在这类情况下，请考虑在开始这些操作时手动打开连接，并在操作完成后关闭或释放连接。</span><span class="sxs-lookup"><span data-stu-id="0e0de-284">In these situations, consider manually opening the connection at the start of these operations and either closing or disposing of the connection when the operations are complete.</span></span> <span data-ttu-id="0e0de-285">有关详细信息，请参阅 [管理连接和事务](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="0e0de-285">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="performance-data"></a><span data-ttu-id="0e0de-286">性能数据</span><span class="sxs-lookup"><span data-stu-id="0e0de-286">Performance Data</span></span>  

 <span data-ttu-id="0e0de-287">[ADO.NET 团队博客](/archive/blogs/adonet/)上的以下文章中发布了实体框架的一些性能数据：</span><span class="sxs-lookup"><span data-stu-id="0e0de-287">Some performance data for the Entity Framework is published in the following posts on the [ADO.NET team blog](/archive/blogs/adonet/):</span></span>  
  
- [<span data-ttu-id="0e0de-288">Exploring the Performance of the ADO.NET Entity Framework - Part 1（探索 ADO.NET 实体框架的性能 - 第 1 部分）</span><span class="sxs-lookup"><span data-stu-id="0e0de-288">Exploring the Performance of the ADO.NET Entity Framework - Part 1</span></span>](/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1)  
  
- [<span data-ttu-id="0e0de-289">Exploring the Performance of the ADO.NET Entity Framework – Part 2（探索 ADO.NET 实体框架的性能 - 第 2 部分）</span><span class="sxs-lookup"><span data-stu-id="0e0de-289">Exploring the Performance of the ADO.NET Entity Framework – Part 2</span></span>](/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-2)  
  
- [<span data-ttu-id="0e0de-290">ADO.NET Entity Framework Performance Comparison（ADO.NET 实体框架性能比较）</span><span class="sxs-lookup"><span data-stu-id="0e0de-290">ADO.NET Entity Framework Performance Comparison</span></span>](/archive/blogs/adonet/ado-net-entity-framework-performance-comparison)  
  
## <a name="see-also"></a><span data-ttu-id="0e0de-291">请参阅</span><span class="sxs-lookup"><span data-stu-id="0e0de-291">See also</span></span>

- [<span data-ttu-id="0e0de-292">开发和部署注意事项</span><span class="sxs-lookup"><span data-stu-id="0e0de-292">Development and Deployment Considerations</span></span>](development-and-deployment-considerations.md)
