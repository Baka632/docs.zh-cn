---
title: 查询执行
description: 了解 LINQ to Entities 查询运行的不同方法，包括延迟的查询执行、即时查询执行和存储执行。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c0e6cf23-63ac-47dd-bfe9-d5bdca826fac
ms.openlocfilehash: e5961330eab5f25508319f276df1e9b4572f49ee
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/24/2020
ms.locfileid: "91189300"
---
# <a name="query-execution"></a><span data-ttu-id="db1c6-103">查询执行</span><span class="sxs-lookup"><span data-stu-id="db1c6-103">Query Execution</span></span>

<span data-ttu-id="db1c6-104">在用户创建 LINQ 查询后，该查询将转换为一个命令目录树。</span><span class="sxs-lookup"><span data-stu-id="db1c6-104">After a LINQ query is created by a user, it is converted to a command tree.</span></span> <span data-ttu-id="db1c6-105">命令目录树是与实体框架兼容的查询表示形式。</span><span class="sxs-lookup"><span data-stu-id="db1c6-105">A command tree is a representation of a query that is compatible with the Entity Framework.</span></span> <span data-ttu-id="db1c6-106">然后，针对数据源执行该命令目录树。</span><span class="sxs-lookup"><span data-stu-id="db1c6-106">The command tree is then executed against the data source.</span></span> <span data-ttu-id="db1c6-107">在执行查询时，将计算所有查询表达式（即查询的所有组成部分），包括在结果具体化中使用的那些表达式。</span><span class="sxs-lookup"><span data-stu-id="db1c6-107">At query execution time, all query expressions (that is, all components of the query) are evaluated, including those expressions that are used in result materialization.</span></span>  
  
 <span data-ttu-id="db1c6-108">执行查询表达式的时间点可能会有所不同。</span><span class="sxs-lookup"><span data-stu-id="db1c6-108">At what point query expressions are executed can vary.</span></span> <span data-ttu-id="db1c6-109">LINQ 查询始终在循环访问查询变量时执行，而不是在创建查询变量时执行。</span><span class="sxs-lookup"><span data-stu-id="db1c6-109">LINQ queries are always executed when the query variable is iterated over, not when the query variable is created.</span></span> <span data-ttu-id="db1c6-110">这称为 " *延迟执行*"。</span><span class="sxs-lookup"><span data-stu-id="db1c6-110">This is called *deferred execution*.</span></span> <span data-ttu-id="db1c6-111">您也可以强制立即执行查询，这对于缓存查询结果很有用。</span><span class="sxs-lookup"><span data-stu-id="db1c6-111">You can also force a query to execute immediately, which is useful for caching query results.</span></span> <span data-ttu-id="db1c6-112">本主题稍后将对此进行介绍。</span><span class="sxs-lookup"><span data-stu-id="db1c6-112">This is described later in this topic.</span></span>  
  
 <span data-ttu-id="db1c6-113">当执行 LINQ to Entities 查询时，查询中的有些表达式可能在服务器上执行，而有些部分可能在客户端上本地执行。</span><span class="sxs-lookup"><span data-stu-id="db1c6-113">When a LINQ to Entities query is executed, some expressions in the query might be executed on the server and some parts might be executed locally on the client.</span></span> <span data-ttu-id="db1c6-114">表达式的客户端计算发生于在服务器上执行查询之前。</span><span class="sxs-lookup"><span data-stu-id="db1c6-114">Client-side evaluation of an expression takes place before the query is executed on the server.</span></span> <span data-ttu-id="db1c6-115">如果在客户端上计算表达式，则该计算的结果将替换查询中的表达式，然后在服务器上执行查询。</span><span class="sxs-lookup"><span data-stu-id="db1c6-115">If an expression is evaluated on the client, the result of that evaluation is substituted for the expression in the query, and the query is then executed on the server.</span></span> <span data-ttu-id="db1c6-116">由于是在数据源上执行查询，因此数据源配置将覆盖客户端中指定的行为。</span><span class="sxs-lookup"><span data-stu-id="db1c6-116">Because queries are executed on the data source, the data source configuration overrides the behavior specified in the client.</span></span> <span data-ttu-id="db1c6-117">例如，null 值处理和数值精度取决于服务器设置。</span><span class="sxs-lookup"><span data-stu-id="db1c6-117">For example, null value handling and numerical precision depend on the server settings.</span></span> <span data-ttu-id="db1c6-118">在查询执行期间在服务器上引发的任何异常都将直接向上传递到客户端。</span><span class="sxs-lookup"><span data-stu-id="db1c6-118">Any exceptions thrown during query execution on the server are passed directly up to the client.</span></span>  

> [!TIP]
> <span data-ttu-id="db1c6-119">若要获取表格式的查询运算符（可用于快速标识运算符的执行行为）的简单摘要，请参阅 [标准查询运算符分类通过执行 (c # ) 的方式 ](../../../../../csharp/programming-guide/concepts/linq/classification-of-standard-query-operators-by-manner-of-execution.md)。</span><span class="sxs-lookup"><span data-stu-id="db1c6-119">For a convenient summary of query operators in table format, which lets you quickly identify an operator's execution behavior, see [Classification of Standard Query Operators by Manner of Execution (C#)](../../../../../csharp/programming-guide/concepts/linq/classification-of-standard-query-operators-by-manner-of-execution.md).</span></span>

## <a name="deferred-query-execution"></a><span data-ttu-id="db1c6-120">延迟执行查询</span><span class="sxs-lookup"><span data-stu-id="db1c6-120">Deferred query execution</span></span>  

 <span data-ttu-id="db1c6-121">在返回一系列值的查询中，查询变量本身从不保存查询结果，它只存储查询命令。</span><span class="sxs-lookup"><span data-stu-id="db1c6-121">In a query that returns a sequence of values, the query variable itself never holds the query results and only stores the query commands.</span></span> <span data-ttu-id="db1c6-122">查询的执行将推迟到在 `foreach` 或 `For Each` 循环中循环访问查询变量之后进行。</span><span class="sxs-lookup"><span data-stu-id="db1c6-122">Execution of the query is deferred until the query variable is iterated over in a `foreach` or `For Each` loop.</span></span> <span data-ttu-id="db1c6-123">这称为 " *延迟执行*";也就是说，在构造查询后，将执行查询。</span><span class="sxs-lookup"><span data-stu-id="db1c6-123">This is known as *deferred execution*; that is, query execution occurs some time after the query is constructed.</span></span> <span data-ttu-id="db1c6-124">这意味着您可以根据需要频繁地执行查询。</span><span class="sxs-lookup"><span data-stu-id="db1c6-124">This means that you can execute a query as frequently as you want to.</span></span> <span data-ttu-id="db1c6-125">例如，当您的数据库由其他应用程序不断更新时，此功能将会很有用。</span><span class="sxs-lookup"><span data-stu-id="db1c6-125">This is useful when, for example, you have a database that is being updated by other applications.</span></span> <span data-ttu-id="db1c6-126">在您的应用程序中，您可以创建查询以检索最新信息并重复执行查询，每次返回更新的信息。</span><span class="sxs-lookup"><span data-stu-id="db1c6-126">In your application, you can create a query to retrieve the latest information and repeatedly execute the query, returning the updated information every time.</span></span>  
  
 <span data-ttu-id="db1c6-127">延迟执行可使多个查询组合在一起或使查询得到扩展。</span><span class="sxs-lookup"><span data-stu-id="db1c6-127">Deferred execution enables multiple queries to be combined or a query to be extended.</span></span> <span data-ttu-id="db1c6-128">扩展查询时，将修改查询以包括新操作，最终执行将反映这些更改。</span><span class="sxs-lookup"><span data-stu-id="db1c6-128">When a query is extended, it is modified to include the new operations, and the eventual execution will reflect the changes.</span></span> <span data-ttu-id="db1c6-129">在下面的示例中，第一个查询返回所有产品。</span><span class="sxs-lookup"><span data-stu-id="db1c6-129">In the following example, the first query returns all the products.</span></span> <span data-ttu-id="db1c6-130">第二个查询通过使用 `Where` 扩展第一个查询，以返回大小为“L”的所有产品：</span><span class="sxs-lookup"><span data-stu-id="db1c6-130">The second query extends the first by using `Where` to return all the products of size "L":</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#Composing1](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#composing1)]
 [!code-vb[DP L2E Conceptual Examples#Composing1](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#composing1)]  
  
 <span data-ttu-id="db1c6-131">在执行查询后，所有后续查询都将使用内存中的 LINQ 运算符。</span><span class="sxs-lookup"><span data-stu-id="db1c6-131">After a query has been executed all successive queries will use the in-memory LINQ operators.</span></span> <span data-ttu-id="db1c6-132">通过使用 `foreach` 或 `For Each` 语句或者调用某个 LINQ 转换运算符来循环访问查询变量会使查询立即执行。</span><span class="sxs-lookup"><span data-stu-id="db1c6-132">Iterating over the query variable by using a `foreach` or `For Each` statement or by calling one of the LINQ conversion operators will cause immediate execution.</span></span> <span data-ttu-id="db1c6-133">这些转换运算符包括：<xref:System.Linq.Enumerable.ToList%2A>、<xref:System.Linq.Enumerable.ToArray%2A>、<xref:System.Linq.Enumerable.ToLookup%2A> 和 <xref:System.Linq.Enumerable.ToDictionary%2A>。</span><span class="sxs-lookup"><span data-stu-id="db1c6-133">These conversion operators include the following: <xref:System.Linq.Enumerable.ToList%2A>, <xref:System.Linq.Enumerable.ToArray%2A>, <xref:System.Linq.Enumerable.ToLookup%2A>, and <xref:System.Linq.Enumerable.ToDictionary%2A>.</span></span>  
  
## <a name="immediate-query-execution"></a><span data-ttu-id="db1c6-134">立即执行查询</span><span class="sxs-lookup"><span data-stu-id="db1c6-134">Immediate Query Execution</span></span>  

 <span data-ttu-id="db1c6-135">与返回一系列值的延迟执行查询相反，返回单一实例值的查询将立即执行。</span><span class="sxs-lookup"><span data-stu-id="db1c6-135">In contrast to the deferred execution of queries that produce a sequence of values, queries that return a singleton value are executed immediately.</span></span> <span data-ttu-id="db1c6-136"><xref:System.Linq.Enumerable.Average%2A>、<xref:System.Linq.Enumerable.Count%2A>、<xref:System.Linq.Enumerable.First%2A> 和 <xref:System.Linq.Enumerable.Max%2A> 是单一实例查询的一些示例。</span><span class="sxs-lookup"><span data-stu-id="db1c6-136">Some examples of singleton queries are <xref:System.Linq.Enumerable.Average%2A>, <xref:System.Linq.Enumerable.Count%2A>, <xref:System.Linq.Enumerable.First%2A>, and <xref:System.Linq.Enumerable.Max%2A>.</span></span> <span data-ttu-id="db1c6-137">这些查询立即执行，因为查询必须生成序列才能计算单一实例结果。</span><span class="sxs-lookup"><span data-stu-id="db1c6-137">These execute immediately because the query must produce a sequence to calculate the singleton result.</span></span> <span data-ttu-id="db1c6-138">您也可以强制立即执行。</span><span class="sxs-lookup"><span data-stu-id="db1c6-138">You can also force immediate execution.</span></span> <span data-ttu-id="db1c6-139">如果要缓存查询结果，这么做十分有用。</span><span class="sxs-lookup"><span data-stu-id="db1c6-139">This is useful when you want to cache the results of a query.</span></span> <span data-ttu-id="db1c6-140">若要强制立即执行不生成单一实例值的查询，可以对查询或查询变量调用 <xref:System.Linq.Enumerable.ToList%2A>、<xref:System.Linq.Enumerable.ToDictionary%2A> 或 <xref:System.Linq.Enumerable.ToArray%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="db1c6-140">To force immediate execution of a query that does not produce a singleton value, you can call the <xref:System.Linq.Enumerable.ToList%2A> method, the <xref:System.Linq.Enumerable.ToDictionary%2A> method, or the <xref:System.Linq.Enumerable.ToArray%2A> method on a query or query variable.</span></span> <span data-ttu-id="db1c6-141">以下示例使用 <xref:System.Linq.Enumerable.ToArray%2A> 方法以立即将序列转换为数组。</span><span class="sxs-lookup"><span data-stu-id="db1c6-141">The following example uses the <xref:System.Linq.Enumerable.ToArray%2A> method to immediately evaluate a sequence into an array.</span></span>  
  
 [!code-csharp[DP L2E Examples#ToArray](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Examples/CS/Program.cs#toarray)]
 [!code-vb[DP L2E Examples#ToArray](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Examples/VB/Module1.vb#toarray)]  
  
 <span data-ttu-id="db1c6-142">通过在查询表达式之后紧随 `foreach` 或 `For Each` 循环，也可以强制执行，而通过调用 <xref:System.Linq.Enumerable.ToList%2A> 或 <xref:System.Linq.Enumerable.ToArray%2A>，可以缓存单个集合对象中的所有数据。</span><span class="sxs-lookup"><span data-stu-id="db1c6-142">You could also force execution by putting the `foreach` or `For Each` loop immediately after the query expression, but by calling <xref:System.Linq.Enumerable.ToList%2A> or <xref:System.Linq.Enumerable.ToArray%2A> you cache all the data in a single collection object.</span></span>  
  
## <a name="store-execution"></a><span data-ttu-id="db1c6-143">存储区执行</span><span class="sxs-lookup"><span data-stu-id="db1c6-143">Store Execution</span></span>  

 <span data-ttu-id="db1c6-144">通常，LINQ to Entities 中的表达式将在服务器上计算，表达式的行为不会遵循公共语言运行库 (CLR) 语义，而是遵循数据源的语义。</span><span class="sxs-lookup"><span data-stu-id="db1c6-144">In general, expressions in LINQ to Entities are evaluated on the server, and the behavior of the expression should not be expected to follow common language runtime (CLR) semantics, but those of the data source.</span></span> <span data-ttu-id="db1c6-145">但存在一些例外情况，例如，在客户端上执行表达式时。</span><span class="sxs-lookup"><span data-stu-id="db1c6-145">There are exceptions to this, however, such as when the expression is executed on the client.</span></span> <span data-ttu-id="db1c6-146">这可能会导致意外结果，例如，服务器和客户端位于不同的时区时。</span><span class="sxs-lookup"><span data-stu-id="db1c6-146">This could cause unexpected results, for example when the server and client are in different time zones.</span></span>  
  
 <span data-ttu-id="db1c6-147">查询中的某些表达式可能在客户端上执行。</span><span class="sxs-lookup"><span data-stu-id="db1c6-147">Some expressions in the query might be executed on the client.</span></span> <span data-ttu-id="db1c6-148">通常，大多数查询表达式应在服务器上执行。</span><span class="sxs-lookup"><span data-stu-id="db1c6-148">In general, most query execution is expected to occur on the server.</span></span> <span data-ttu-id="db1c6-149">除了对映射到数据源的查询元素所执行的方法之外，查询中通常还有一些表达式可在本地执行。</span><span class="sxs-lookup"><span data-stu-id="db1c6-149">Aside from methods executed against query elements mapped to the data source, there are often expressions in the query that can be executed locally.</span></span> <span data-ttu-id="db1c6-150">本地执行查询表达式会生成一个可在查询执行或结果构造中使用的值。</span><span class="sxs-lookup"><span data-stu-id="db1c6-150">Local execution of a query expression yields a value that can be used in the query execution or result construction.</span></span>  
  
 <span data-ttu-id="db1c6-151">某些操作始终在客户端上执行，例如，闭包中值、子表达式、子查询的绑定以及将对象具体化到查询结果等。</span><span class="sxs-lookup"><span data-stu-id="db1c6-151">Certain operations are always executed on the client, such as binding of values, sub expressions, sub queries from closures, and materialization of objects into query results.</span></span> <span data-ttu-id="db1c6-152">这种做法的最终结果是，这些元素（如参数值）不能在执行期间更新。</span><span class="sxs-lookup"><span data-stu-id="db1c6-152">The net effect of this is that these elements (for example, parameter values) cannot be updated during the execution.</span></span> <span data-ttu-id="db1c6-153">匿名类型可以在数据源上以内联方式构造，但不应假定可以这样做。</span><span class="sxs-lookup"><span data-stu-id="db1c6-153">Anonymous types can be constructed inline on the data source, but should not be assumed to do so.</span></span> <span data-ttu-id="db1c6-154">也可以在数据源中构造内联分组，但不应假定在所有情况下都可以这样做。</span><span class="sxs-lookup"><span data-stu-id="db1c6-154">Inline groupings can be constructed in the data source, as well, but this should not be assumed in every instance.</span></span> <span data-ttu-id="db1c6-155">总之，最好不要对于哪些内容是在服务器上构造的进行假定。</span><span class="sxs-lookup"><span data-stu-id="db1c6-155">In general, it is best not to make any assumptions about what is constructed on the server.</span></span>  
  
 <span data-ttu-id="db1c6-156">本节介绍在客户端本地执行代码的方案。</span><span class="sxs-lookup"><span data-stu-id="db1c6-156">This section describes the scenarios in which code is executed locally on the client.</span></span> <span data-ttu-id="db1c6-157">有关本地执行的表达式类型的详细信息，请参阅 [LINQ to Entities 查询中的表达式](expressions-in-linq-to-entities-queries.md)。</span><span class="sxs-lookup"><span data-stu-id="db1c6-157">For more information about which types of expressions are executed locally, see [Expressions in LINQ to Entities Queries](expressions-in-linq-to-entities-queries.md).</span></span>  
  
### <a name="literals-and-parameters"></a><span data-ttu-id="db1c6-158">文本和参数</span><span class="sxs-lookup"><span data-stu-id="db1c6-158">Literals and Parameters</span></span>  

 <span data-ttu-id="db1c6-159">本地变量（如下例中的 `orderID` 变量）是在客户端上计算的。</span><span class="sxs-lookup"><span data-stu-id="db1c6-159">Local variables, such as the `orderID` variable in the following example, are evaluated on the client.</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#LiteralParameter1](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#literalparameter1)]
 [!code-vb[DP L2E Conceptual Examples#LiteralParameter1](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#literalparameter1)]  
  
 <span data-ttu-id="db1c6-160">方法参数也是在客户端上计算的。</span><span class="sxs-lookup"><span data-stu-id="db1c6-160">Method parameters are also evaluated on the client.</span></span> <span data-ttu-id="db1c6-161">传入以下 `orderID` 方法的 `MethodParameterExample` 参数就是一个示例。</span><span class="sxs-lookup"><span data-stu-id="db1c6-161">The `orderID` parameter passed into the `MethodParameterExample` method, below, is an example.</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#MethodParameterExample](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#methodparameterexample)]
 [!code-vb[DP L2E Conceptual Examples#MethodParameterExample](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#methodparameterexample)]  
  
### <a name="casting-literals-on-the-client"></a><span data-ttu-id="db1c6-162">在客户端上强制转换文本</span><span class="sxs-lookup"><span data-stu-id="db1c6-162">Casting Literals on the Client</span></span>  

 <span data-ttu-id="db1c6-163">在客户端上执行从 `null` 到 CLR 类型的强制转换：</span><span class="sxs-lookup"><span data-stu-id="db1c6-163">Casting from `null` to a CLR type is executed on the client:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#NullCastToString](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#nullcasttostring)]
 [!code-vb[DP L2E Conceptual Examples#NullCastToString](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#nullcasttostring)]  
  
 <span data-ttu-id="db1c6-164">在客户端上执行到某一类型（如可以为 null 的 <xref:System.Decimal>）的强制转换：</span><span class="sxs-lookup"><span data-stu-id="db1c6-164">Casting to a type, such as a nullable <xref:System.Decimal>, is executed on the client:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#CastToNullable](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#casttonullable)]
 [!code-vb[DP L2E Conceptual Examples#CastToNullable](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#casttonullable)]  
  
### <a name="constructors-for-literals"></a><span data-ttu-id="db1c6-165">用于文本的构造函数</span><span class="sxs-lookup"><span data-stu-id="db1c6-165">Constructors for Literals</span></span>  

 <span data-ttu-id="db1c6-166">可映射到概念模型类型的新 CLR 类型是在客户端上执行的：</span><span class="sxs-lookup"><span data-stu-id="db1c6-166">New CLR types that can be mapped to conceptual model types are executed on the client:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#ConstructorForLiteral](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#constructorforliteral)]
 [!code-vb[DP L2E Conceptual Examples#ConstructorForLiteral](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#constructorforliteral)]  
  
 <span data-ttu-id="db1c6-167">新数组也是在客户端上执行的。</span><span class="sxs-lookup"><span data-stu-id="db1c6-167">New arrays are also executed on the client.</span></span>  
  
## <a name="store-exceptions"></a><span data-ttu-id="db1c6-168">存储区异常</span><span class="sxs-lookup"><span data-stu-id="db1c6-168">Store Exceptions</span></span>  

 <span data-ttu-id="db1c6-169">执行查询时出现的任何存储区错误都会向上传递到客户端，不会进行映射或处理。</span><span class="sxs-lookup"><span data-stu-id="db1c6-169">Any store errors that are encountered during query execution are passed up to the client, and are not mapped or handled.</span></span>  
  
## <a name="store-configuration"></a><span data-ttu-id="db1c6-170">存储区配置</span><span class="sxs-lookup"><span data-stu-id="db1c6-170">Store Configuration</span></span>  

 <span data-ttu-id="db1c6-171">在存储区上执行查询时，存储区配置将覆盖所有客户端行为，并用存储区语义表示所有运算和表达式。</span><span class="sxs-lookup"><span data-stu-id="db1c6-171">When the query executes on the store, the store configuration overrides all client behaviors, and store semantics are expressed for all operations and expressions.</span></span> <span data-ttu-id="db1c6-172">这可能导致 CLR 与存储区执行之间的行为在某些方面存在差异，例如 null 比较、GUID 排序、涉及非精确数据类型（如浮点类型或 <xref:System.DateTime>）运算的准确性以及字符串运算等。</span><span class="sxs-lookup"><span data-stu-id="db1c6-172">This can result in a difference in behavior between CLR and store execution in areas such as null comparisons, GUID ordering, precision and accuracy of operations involving non-precise data types (such as floating point types or <xref:System.DateTime>), and string operations.</span></span> <span data-ttu-id="db1c6-173">检查查询结果时，请务必注意这一点。</span><span class="sxs-lookup"><span data-stu-id="db1c6-173">It is important to keep this in mind when examining query results.</span></span>  
  
 <span data-ttu-id="db1c6-174">例如，以下是一些 CLR 和 SQL Server 之间的行为差异：</span><span class="sxs-lookup"><span data-stu-id="db1c6-174">For example, the following are some differences in behavior between the CLR and SQL Server:</span></span>  
  
- <span data-ttu-id="db1c6-175">在 GUID 排序方式上，SQL Server 不同于 CLR。</span><span class="sxs-lookup"><span data-stu-id="db1c6-175">SQL Server orders GUIDs differently than the CLR.</span></span>  
  
- <span data-ttu-id="db1c6-176">在处理 SQL Server 十进制类型时，这两者在结果精度方面也存在差异。</span><span class="sxs-lookup"><span data-stu-id="db1c6-176">There can also be differences in result precision when dealing with the Decimal type on SQL Server.</span></span> <span data-ttu-id="db1c6-177">这是因为 SQL Server 十进制类型具有固定精度要求。</span><span class="sxs-lookup"><span data-stu-id="db1c6-177">This is due to the fixed precision requirements of the SQL Server decimal type.</span></span> <span data-ttu-id="db1c6-178">例如，在客户端内存中，<xref:System.Decimal> 值 0.0、0.0 和 1.0 的平均值为 0.3333333333333333333333333333，而在存储区中则为 0.333333（基于 SQL Server 的十进制类型的默认精度）。</span><span class="sxs-lookup"><span data-stu-id="db1c6-178">For example, the average of <xref:System.Decimal> values 0.0, 0.0, and 1.0 is 0.3333333333333333333333333333 in memory on the client, but 0.333333 in the store (based on the default precision for SQL Server’s decimal type).</span></span>  
  
- <span data-ttu-id="db1c6-179">在处理一些字符串比较运算的方式上，SQL Server 也不同于 CLR。</span><span class="sxs-lookup"><span data-stu-id="db1c6-179">Some string comparison operations are also handled differently in SQL Server than in the CLR.</span></span> <span data-ttu-id="db1c6-180">在服务器上，字符串比较行为取决于排序规则设置。</span><span class="sxs-lookup"><span data-stu-id="db1c6-180">String comparison behavior depends on the collation settings on the server.</span></span>  
  
- <span data-ttu-id="db1c6-181">函数或方法调用如果包含在 LINQ to Entities 查询中，则会先映射到实体框架中的规范函数，然后再转换为 Transact-SQL 并针对 SQL Server 数据库执行。</span><span class="sxs-lookup"><span data-stu-id="db1c6-181">Function or method calls, when included in a LINQ to Entities query, are mapped to canonical functions in the Entity Framework, which are then translated to Transact-SQL and executed on the SQL Server database.</span></span> <span data-ttu-id="db1c6-182">在有些情况下，这些映射函数的行为可能不同于基类库中的实现。</span><span class="sxs-lookup"><span data-stu-id="db1c6-182">There are cases when the behavior these mapped functions exhibit might differ from the implementation in the base class libraries.</span></span> <span data-ttu-id="db1c6-183">例如，将一个空字符串用作参数调用 <xref:System.String.Contains%2A>、<xref:System.String.StartsWith%2A> 和 <xref:System.String.EndsWith%2A> 方法时，如果在 CLR 中执行，会返回 `true`；如果在 SQL Server 中执行，则会返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="db1c6-183">For example, calling the <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, and <xref:System.String.EndsWith%2A> methods with an empty string as a parameter will return `true` when executed in the CLR, but will return `false` when executed in SQL Server.</span></span> <span data-ttu-id="db1c6-184">如果两个字符串只有尾随空格不同，SQL Server 认为它们相等，而 CLR 认为它们不相等，因此 <xref:System.String.EndsWith%2A> 方法也会返回不同的结果。</span><span class="sxs-lookup"><span data-stu-id="db1c6-184">The <xref:System.String.EndsWith%2A> method can also return different results because SQL Server considers two strings to be equal if they only differ in trailing white space, whereas the CLR considers them to be not equal.</span></span> <span data-ttu-id="db1c6-185">下面的示例对此进行演示：</span><span class="sxs-lookup"><span data-stu-id="db1c6-185">This is illustrated by the following example:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#CanonicalFuncVsCLRBaseType](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#canonicalfuncvsclrbasetype)]
 [!code-vb[DP L2E Conceptual Examples#CanonicalFuncVsCLRBaseType](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#canonicalfuncvsclrbasetype)]
