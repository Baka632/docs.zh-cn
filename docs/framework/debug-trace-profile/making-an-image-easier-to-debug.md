---
title: 使映像更易于在 .NET 中进行调试
description: 了解如何配置可执行映像，以便使用 IDE 开关和命令行选项更轻松地进行调试。
ms.date: 08/30/2018
helpviewer_keywords:
- images [.NET Framework], debugging
- executable image for debugging
- debugging [.NET Framework], executable images for
ms.assetid: 7d90ea7a-150f-4f97-98a7-f9c26541b9a3
ms.openlocfilehash: a3305dc864e7852c2336009503732a51868410d2
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/15/2020
ms.locfileid: "90558506"
---
# <a name="making-an-image-easier-to-debug-in-net"></a><span data-ttu-id="888b4-103">使映像更易于在 .NET 中进行调试</span><span class="sxs-lookup"><span data-stu-id="888b4-103">Making an image easier to debug in .NET</span></span>

<span data-ttu-id="888b4-104">编译非托管代码时，可以通过设置 IDE 开关或命令线选项来配置可执行映像进行调试。</span><span class="sxs-lookup"><span data-stu-id="888b4-104">When compiling unmanaged code, you can configure an executable image for debugging by setting IDE switches or command-line options.</span></span> <span data-ttu-id="888b4-105">例如，可以使用 Visual C++ 中的 /Zi 命令行选项，使其发出调试符号文件（文件扩展名为 .pdb）\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="888b4-105">For example, you can use the /**Zi** command-line option in Visual C++ to ask it to emit debug symbol files (file extension .pdb).</span></span> <span data-ttu-id="888b4-106">同样，/Od 命令行选项告知编译器禁用优化\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="888b4-106">Similarly, the /**Od** command-line option tells the compiler to disable optimization.</span></span> <span data-ttu-id="888b4-107">生成的代码运行速度变慢，但调试起来更容易，但这是必需的。</span><span class="sxs-lookup"><span data-stu-id="888b4-107">The resulting code runs more slowly, but it's easier to debug, should this be necessary.</span></span>

<span data-ttu-id="888b4-108">在编译 .NET Framework 托管代码时，编译器（如 Visual C++、Visual Basic 和 c #）会将其源程序编译为 Microsoft 中间语言 (MSIL) 。</span><span class="sxs-lookup"><span data-stu-id="888b4-108">When compiling .NET Framework managed code, compilers such as Visual C++, Visual Basic, and C# compile their source program into Microsoft intermediate language (MSIL).</span></span> <span data-ttu-id="888b4-109">然后，在执行之前将 MSIL 编译为本机代码。</span><span class="sxs-lookup"><span data-stu-id="888b4-109">MSIL is then JIT-compiled, just before execution, into native machine code.</span></span> <span data-ttu-id="888b4-110">与非托管代码一样，可以通过设置 IDE 开关或命令行选项来配置可执行映像进行调试。</span><span class="sxs-lookup"><span data-stu-id="888b4-110">As with unmanaged code, you can configure an executable image for debugging by setting IDE switches or command-line options.</span></span> <span data-ttu-id="888b4-111">你还可以配置 JIT 编译以便进行调试，其方式大致相同。</span><span class="sxs-lookup"><span data-stu-id="888b4-111">You can also configure the JIT compilation for debugging in much the same way.</span></span>

<span data-ttu-id="888b4-112">这种 JIT 配置具有两个方面：</span><span class="sxs-lookup"><span data-stu-id="888b4-112">This JIT configuration has two aspects:</span></span>

- <span data-ttu-id="888b4-113">可以请求 JIT 编译器生成跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="888b4-113">You can request the JIT compiler to generate tracking information.</span></span> <span data-ttu-id="888b4-114">这使调试程序能将 MSIL 链与其机器码对应项相匹配，并跟踪存储本地变量和函数参数的位置。</span><span class="sxs-lookup"><span data-stu-id="888b4-114">This makes it possible for the debugger to match up a chain of MSIL with its machine code counterpart, and to track where local variables and function arguments are stored.</span></span> <span data-ttu-id="888b4-115">从 .NET Framework 版本2.0 开始，JIT 编译器将始终生成跟踪信息，因此无需对其进行请求。</span><span class="sxs-lookup"><span data-stu-id="888b4-115">Starting with the .NET Framework version 2.0, the JIT compiler always generates tracking information, so there is no need to request it.</span></span>

- <span data-ttu-id="888b4-116">可以请求 JIT 编译器不优化生成的计算机代码。</span><span class="sxs-lookup"><span data-stu-id="888b4-116">You can request the JIT compiler to not optimize the resulting machine code.</span></span>

<span data-ttu-id="888b4-117">通常，生成 MSIL 的编译器会根据你指定的 IDE 开关或命令行选项（例如/**Od**）适当地设置这些 JIT 编译器选项。</span><span class="sxs-lookup"><span data-stu-id="888b4-117">Normally, the compiler that generates the MSIL sets these JIT compiler options appropriately, based upon the IDE switches or command-line options you specify, for example, /**Od**.</span></span>

<span data-ttu-id="888b4-118">某些情况下，可能需要更改 JIT 编译器的行为，使其生成的机器码更易于调试。</span><span class="sxs-lookup"><span data-stu-id="888b4-118">In some cases, you might want to change the behavior of the JIT compiler so that the machine code it generates is easier to debug.</span></span> <span data-ttu-id="888b4-119">例如，可能希望为零售版本或控制优化生成实时跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="888b4-119">For example, you might want to generate JIT tracking information for a retail build or control optimization.</span></span> <span data-ttu-id="888b4-120">可以使用初始化 (.ini) 文件来执行此操作。</span><span class="sxs-lookup"><span data-stu-id="888b4-120">You can do so with an initialization (.ini) file.</span></span>

<span data-ttu-id="888b4-121">例如，如果您想要调试的程序集*MyApp.exe*调用，则可以在*MyApp.exe*所在的同一文件夹中创建一个名为*MyApp.ini*的文本文件，该文件包含以下三行：</span><span class="sxs-lookup"><span data-stu-id="888b4-121">For example, if the assembly you want to debug is called *MyApp.exe*, then you can create a text file named *MyApp.ini*, in the same folder as *MyApp.exe*, which contains these three lines:</span></span>

```ini
[.NET Framework Debugging Control]
GenerateTrackingInfo=1
AllowOptimize=0
```

<span data-ttu-id="888b4-122">可将每个选项的值设置为 0 或 1，任何不存在选项默认为 0。</span><span class="sxs-lookup"><span data-stu-id="888b4-122">You can set the value of each option to 0 or 1, and any absent option defaults to 0.</span></span> <span data-ttu-id="888b4-123">将 `GenerateTrackingInfo` 设为 1、`AllowOptimize` 设为 0，这可提供最简单的调试。</span><span class="sxs-lookup"><span data-stu-id="888b4-123">Setting `GenerateTrackingInfo` to 1 and `AllowOptimize` to 0 provides the easiest debugging.</span></span>

<span data-ttu-id="888b4-124">从 .NET Framework 版本2.0 开始，JIT 编译器将始终生成跟踪信息，而不考虑的值 `GenerateTrackingInfo` ; 但是， `AllowOptimize` 该值仍有效果。</span><span class="sxs-lookup"><span data-stu-id="888b4-124">Starting with the .NET Framework version 2.0, the JIT compiler always generates tracking information regardless of the value for `GenerateTrackingInfo`; however, the `AllowOptimize` value still has an effect.</span></span> <span data-ttu-id="888b4-125">如果使用 [Ngen.exe（本机映像生成器）](../tools/ngen-exe-native-image-generator.md)预编译本机映像而不进行优化，Ngen.exe 执行时 .ini 文件必须存在于 `AllowOptimize=0` 的目标文件夹。</span><span class="sxs-lookup"><span data-stu-id="888b4-125">When using the [Ngen.exe (Native Image Generator)](../tools/ngen-exe-native-image-generator.md) to precompile the native image without optimization, the .ini file must be present in the target folder with `AllowOptimize=0` when Ngen.exe executes.</span></span> <span data-ttu-id="888b4-126">如果在未优化的情况下预编译程序集，则必须先使用 NGen.exe **/uninstall** 选项删除预编译代码，然后再重新运行 Ngen.exe 将代码预编译为优化。</span><span class="sxs-lookup"><span data-stu-id="888b4-126">If you have precompiled an assembly without optimization, you must remove the precompiled code using NGen.exe **/uninstall** option before rerunning Ngen.exe to precompile the code as optimized.</span></span> <span data-ttu-id="888b4-127">如果文件中不存在 .ini 文件，则默认情况下 Ngen.exe 将代码预编译为优化。</span><span class="sxs-lookup"><span data-stu-id="888b4-127">If the .ini file isn't present in the folder, by default Ngen.exe precompiles the code as optimized.</span></span>

<span data-ttu-id="888b4-128"><xref:System.Diagnostics.DebuggableAttribute?displayProperty=nameWithType> 控制程序集的设置。</span><span class="sxs-lookup"><span data-stu-id="888b4-128">The <xref:System.Diagnostics.DebuggableAttribute?displayProperty=nameWithType> controls the settings for an assembly.</span></span> <span data-ttu-id="888b4-129">**DebuggableAttribute** 包含两个字段，用于控制 JIT 编译器是否应优化和/或生成跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="888b4-129">**DebuggableAttribute** includes two fields that control whether the JIT compiler should optimize and/or generate tracking information.</span></span> <span data-ttu-id="888b4-130">从 .NET Framework 版本2.0 开始，JIT 编译器将始终生成跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="888b4-130">Starting with the .NET Framework version 2.0, the JIT compiler always generates tracking information.</span></span>

<span data-ttu-id="888b4-131">对于零售版本，编译器不会设置任何 **DebuggableAttribute**。</span><span class="sxs-lookup"><span data-stu-id="888b4-131">For a retail build, compilers don't set any **DebuggableAttribute**.</span></span> <span data-ttu-id="888b4-132">默认情况下，JIT 编译器将生成最高性能，最难调试计算机代码。</span><span class="sxs-lookup"><span data-stu-id="888b4-132">By default, the JIT compiler generates the highest performance, hardest to debug machine code.</span></span> <span data-ttu-id="888b4-133">启用实时跟踪会稍微降低性能，禁用优化会极大降低性能。</span><span class="sxs-lookup"><span data-stu-id="888b4-133">Enabling JIT tracking lowers performance a little, and disabling optimization lowers performance a lot.</span></span>

<span data-ttu-id="888b4-134">DebuggableAttribute 一次应用于整个程序集，而不是应用于程序集中的单个模块\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="888b4-134">The **DebuggableAttribute** applies to a whole assembly at a time, not to individual modules within the assembly.</span></span> <span data-ttu-id="888b4-135">因此，开发工具必须将自定义属性附加到程序集元数据令牌，如果已经创建程序集，则附加到名为 System.Runtime.CompilerServices.AssemblyAttributesGoHere 的类\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="888b4-135">Development tools must therefore attach custom attributes to the assembly metadata token, if an assembly has already been created, or to the class called **System.Runtime.CompilerServices.AssemblyAttributesGoHere**.</span></span> <span data-ttu-id="888b4-136">然后，ALink 工具会将每个模块中的这些 **DebuggableAttribute** 属性升级到它们所属的程序集。</span><span class="sxs-lookup"><span data-stu-id="888b4-136">The ALink tool then promotes these **DebuggableAttribute** attributes from each module to the assembly they become a part of.</span></span> <span data-ttu-id="888b4-137">如果存在冲突，则 ALink 操作将失败。</span><span class="sxs-lookup"><span data-stu-id="888b4-137">If there's a conflict, the ALink operation fails.</span></span>

> [!NOTE]
> <span data-ttu-id="888b4-138">在 .NET Framework 1.0 版本中，当指定 /clr 和 /Zi 编译器选项时，Microsoft Visual C++ 编译器将添加 DebuggableAttribute\*\*\*\*\*\*\*\*\*\*\*\*。</span><span class="sxs-lookup"><span data-stu-id="888b4-138">In version 1.0 of the .NET Framework, the Microsoft Visual C++ compiler adds the **DebuggableAttribute** when the **/clr** and **/Zi** compiler options are specified.</span></span> <span data-ttu-id="888b4-139">在 .NET Framework 版本1.1 中，你必须在代码中手动添加 **DebuggableAttribute** ，或使用 **/ASSEMBLYDEBUG** 链接器选项。</span><span class="sxs-lookup"><span data-stu-id="888b4-139">In version 1.1 of the .NET Framework, you must either add the **DebuggableAttribute** manually in your code or use the **/ASSEMBLYDEBUG** linker option.</span></span>

## <a name="see-also"></a><span data-ttu-id="888b4-140">请参阅</span><span class="sxs-lookup"><span data-stu-id="888b4-140">See also</span></span>

- [<span data-ttu-id="888b4-141">调试、跟踪和分析</span><span class="sxs-lookup"><span data-stu-id="888b4-141">Debugging, Tracing, and Profiling</span></span>](index.md)
- [<span data-ttu-id="888b4-142">启用 JIT 附加调试</span><span class="sxs-lookup"><span data-stu-id="888b4-142">Enabling JIT-Attach Debugging</span></span>](enabling-jit-attach-debugging.md)
- <span data-ttu-id="888b4-143">[启用分析](/previous-versions/dotnet/netframework-4.0/s5ec0es1(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="888b4-143">[Enabling Profiling](/previous-versions/dotnet/netframework-4.0/s5ec0es1(v=vs.100))</span></span>
