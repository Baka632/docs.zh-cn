---
title: 可靠性最佳做法
description: 请参阅基于 .NET 主机的服务器应用程序中的可靠性的最佳实践，例如 SQL Server。 阻止它们泄漏资源或关闭。
ms.date: 03/30/2017
helpviewer_keywords:
- marking locks
- rebooting databases
- denial of service attacks
- back-out code
- SQL Server [.NET Framework], reliability
- synchronization, reliability
- single-threaded COM components
- slow leaks
- suspending threads
- asynchronous exception handling
- leaked resources [.NET Framework]
- unmanaged memory
- memory, reliability
- threading [.NET Framework], reliability
- process-wide domain shared states
- shared states
- SafeHandle class, reliability
- reliability contracts [.NET Framework]
- cleanup operations
- constrained execution regions
- CERs
- finalizers, reliability
- reliability [.NET Framework]
- blocks, reliability
- finally clauses
- cross-application domain shared states
- catch blocks
- identifying locks
- writing reliable code
- impersonation
- GC.KeepAlive method
- managed threading
- locks, reliability
- STA-dependent features
- fibers
ms.assetid: cf624c1f-c160-46a1-bb2b-213587688da7
ms.openlocfilehash: 134b71153f95dffd4525f307d291ce4389e0ce60
ms.sourcegitcommit: cf5a800a33de64d0aad6d115ffcc935f32375164
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/20/2020
ms.locfileid: "86474236"
---
# <a name="reliability-best-practices"></a><span data-ttu-id="6c6a4-104">可靠性最佳做法</span><span class="sxs-lookup"><span data-stu-id="6c6a4-104">Reliability Best Practices</span></span>

<span data-ttu-id="6c6a4-105">以下可靠性规则是面向 SQL Server 的；但是，它们也适用于任何基于主机的服务器应用程序。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-105">The following reliability rules are oriented to SQL Server; however, they also apply to any host-based server application.</span></span> <span data-ttu-id="6c6a4-106">对 SQL Server 等服务器而言，不泄露资源且不会遭遇停机是极其重要的。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-106">It is extremely important that servers such as SQL Server not leak resources and not be brought down.</span></span>  <span data-ttu-id="6c6a4-107">然而，这不能通过为改变对象状态的每个方法写入退出代码来实现。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-107">However, that cannot be done by writing back-out code for every method that alters an object’s state.</span></span>  <span data-ttu-id="6c6a4-108">目标不在于编写出将结合退出代码从每个位置的错误进行恢复的 100% 可靠的托管代码。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-108">The goal is not to write 100 percent reliable managed code that will recover from any errors in every location with back-out code.</span></span>  <span data-ttu-id="6c6a4-109">那将是一项艰巨的任务，并且成功的可能性较小。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-109">That would be a daunting task with little chance of success.</span></span>  <span data-ttu-id="6c6a4-110">公共语言运行时 (CLR) 无法轻松地向托管代码提供足够强大的保证以使编写出完美的代码成为可行的做法。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-110">The common language runtime (CLR) cannot easily provide strong enough guarantees to managed code to make writing perfect code feasible.</span></span>  <span data-ttu-id="6c6a4-111">请注意，不同于 ASP.NET，SQL Server 仅使用一个进程，在没有将数据库关闭相当长的一段时间的情况下，此进程是无法被回收的。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-111">Note that unlike ASP.NET, SQL Server uses only one process that cannot be recycled without taking a database down for an unacceptably long time.</span></span>

<span data-ttu-id="6c6a4-112">由于这些较弱的保证以及在单个进程中运行的情况，因此，可靠性基于在必要时终止线程或回收应用程序域并采取预防措施以确保操作系统资源（如句柄或内存）不会泄露。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-112">With these weaker guarantees and running in a single process, reliability is based on terminating threads or recycling application domains when necessary and taking precautions to ensure operating system resources such as handles or memory are not leaked.</span></span>  <span data-ttu-id="6c6a4-113">即使有此更简单的可靠性约束，但还是存在相当重要的可靠性要求：</span><span class="sxs-lookup"><span data-stu-id="6c6a4-113">Even with this simpler reliability constraint, there is still a significant reliability requirement:</span></span>

- <span data-ttu-id="6c6a4-114">绝不泄露操作系统资源。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-114">Never leak operating system resources.</span></span>

- <span data-ttu-id="6c6a4-115">识别针对 CLR 的各种形式的所有托管锁。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-115">Identify all managed locks in all forms to the CLR.</span></span>

- <span data-ttu-id="6c6a4-116">绝不中断跨应用程序域的共享状态，使 <xref:System.AppDomain> 回收能够平稳运行。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-116">Never break cross-application domain shared state, allowing <xref:System.AppDomain> recycling to function smoothly.</span></span>

<span data-ttu-id="6c6a4-117">虽然，编写托管代码来处理 <xref:System.Threading.ThreadAbortException>、<xref:System.StackOverflowException> 和 <xref:System.OutOfMemoryException> 异常在理论上是可能的，但是指望开发人员在开发整个应用程序的过程中编写此类可靠的代码是不切实际的。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-117">Although it is theoretically possible to write managed code to handle <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException> exceptions, expecting developers to write such robust code throughout an entire application is unreasonable.</span></span>  <span data-ttu-id="6c6a4-118">因此，带外异常会导致正在执行的线程被终止；如果此被终止的线程正在编辑共享状态（可由此线程是否持有锁来确定），那么 <xref:System.AppDomain> 会被卸载。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-118">For that reason, out-of-band exceptions result in the executing thread being terminated; and if the terminated thread was editing shared state, which can be determined by whether the thread holds a lock, then the <xref:System.AppDomain> is unloaded.</span></span>  <span data-ttu-id="6c6a4-119">当正在编辑共享状态的方法被终止后，此状态将被损坏，因为无法为共享状态的更新编写出可靠的退出代码。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-119">When a method that is editing shared state is terminated, the state will be corrupt because it is not possible to write reliable back-out code for updates to shared state.</span></span>

<span data-ttu-id="6c6a4-120">在 .NET Framework 版本 2.0 中，唯一需要可靠性的主机是 SQL Server。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-120">In the .NET Framework version 2.0, the only host that requires reliability is SQL Server.</span></span>  <span data-ttu-id="6c6a4-121">如果程序集将在 SQL Server 上运行，则应该为此程序集的每部分执行可靠性操作，即使对于在数据库中运行时会被禁用的特定功能来说也不例外。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-121">If your assembly will be run on SQL Server you should do the reliability work for every part of that assembly, even if there are specific features that are disabled when running in the database.</span></span>  <span data-ttu-id="6c6a4-122">这是必需的操作，因为代码分析引擎是在程序集级别检查代码的，并且无法区分禁用的代码。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-122">This is required because the code analysis engine examines code at the assembly level and cannot differentiate disabled code.</span></span> <span data-ttu-id="6c6a4-123">另一个 SQL Server 编程注意事项是 SQL Server 在一个进程中运行所有内容，并且 <xref:System.AppDomain> 回收是用于清理如内存和操作系统句柄等所有资源的。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-123">Another SQL Server programming consideration is that SQL Server runs everything in one process, and <xref:System.AppDomain> recycling is used for cleaning up all resources such as memory and operating system handles.</span></span>

<span data-ttu-id="6c6a4-124">不能依赖终结器、析构函数或 `try/finally` 块来执行退出代码。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-124">You cannot depend on finalizers or destructors or `try/finally` blocks for back-out code.</span></span> <span data-ttu-id="6c6a4-125">它们可能会被中断或不受调用。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-125">They might be interrupted or not called.</span></span>

<span data-ttu-id="6c6a4-126">异步异常会在意外的位置中被引发，可能由每个计算机指令所引发：<xref:System.Threading.ThreadAbortException>、<xref:System.StackOverflowException> 和 <xref:System.OutOfMemoryException>。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-126">Asynchronous exceptions can be thrown in unexpected locations, possibly every machine instruction: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException>.</span></span>

<span data-ttu-id="6c6a4-127">托管线程在 SQL 中不一定是 Win32 线程；它们可能是纤程。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-127">Managed threads are not necessarily Win32 threads in SQL; they might be fibers.</span></span>

<span data-ttu-id="6c6a4-128">要安全地更改进程范围或跨应用程序域的可变共享状态是极其困难的，并且应尽可能地避免进行更改。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-128">Process-wide or cross-application domain mutable shared state is extremely difficult to alter safely and should be avoided whenever possible.</span></span>

<span data-ttu-id="6c6a4-129">内存不足的情况在 SQL Server 中并不少见。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-129">Out-of-memory conditions are not rare in SQL Server.</span></span>

<span data-ttu-id="6c6a4-130">如果托管在 SQL Server 中的库没有正确地更新其共享状态，那么极有可能代码将在数据库重新启动之后才恢复。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-130">If libraries hosted in SQL Server do not correctly update their shared state, there is a high probability that the code will not recover until the database has been restarted.</span></span>  <span data-ttu-id="6c6a4-131">此外，在某些极端情况下，这可能会导致 SQL Server 进程失败，从而导致数据库重启。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-131">Additionally, in some extreme cases, it is possible this might cause the SQL Server process to fail, causing the database to reboot.</span></span>  <span data-ttu-id="6c6a4-132">重启数据库可能会使网站关闭或者影响到公司运营，从而损害可用性。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-132">Rebooting the database can take down a Web site or affect company operations, hurting availability.</span></span>  <span data-ttu-id="6c6a4-133">操作系统资源（如内存或句柄）缓慢的泄露可能导致服务器最终出现分配失败的情况，并且无法进行恢复；或者可能会导致服务器的性能缓慢下降并降低客户的应用程序可用性。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-133">A slow leak of operating system resources such as memory or handles may cause the server to eventually fail allocating handles with no possibility of recovery, or potentially the server may slowly degrade in performance and reduces a customer’s application availability.</span></span>  <span data-ttu-id="6c6a4-134">显然，我们希望避免出现这类情况。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-134">Clearly we want to avoid these scenarios.</span></span>

## <a name="best-practice-rules"></a><span data-ttu-id="6c6a4-135">最佳做法规则</span><span class="sxs-lookup"><span data-stu-id="6c6a4-135">Best practice rules</span></span>

<span data-ttu-id="6c6a4-136">重点介绍对在服务器中运行的托管代码进行的代码评审需要抓住哪些方面以提高框架的稳定性和可靠性。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-136">The introduction focused on what the code review for the managed code that runs in the server would have to catch to increase the stability and reliability of the framework.</span></span> <span data-ttu-id="6c6a4-137">一般来说，所有这些检查都是好的做法，并且是绝对必须在服务器上进行的。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-137">All these checks are good practice in general and an absolute must on the server.</span></span>

<span data-ttu-id="6c6a4-138">面对死锁或资源约束时，SQL Server 将中止线程或关闭 <xref:System.AppDomain>。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-138">In the face of a dead lock or resource constraint, SQL Server will abort a thread or tear down an <xref:System.AppDomain>.</span></span>  <span data-ttu-id="6c6a4-139">在此情况下，只能保证运行受约束的执行区域 (CER) 中的退出代码。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-139">When this happens, only back-out code in a constrained execution region (CER) is guaranteed to be run.</span></span>

### <a name="use-safehandle-to-avoid-resource-leaks"></a><span data-ttu-id="6c6a4-140">使用 SafeHandle 避免资源泄漏</span><span class="sxs-lookup"><span data-stu-id="6c6a4-140">Use SafeHandle to avoid resource leaks</span></span>

<span data-ttu-id="6c6a4-141">在 <xref:System.AppDomain> 卸载的情况下，无法依赖正在被执行的 `finally` 块或终结器，因此，通过 <xref:System.Runtime.InteropServices.SafeHandle> 类（而非 <xref:System.IntPtr>、<xref:System.Runtime.InteropServices.HandleRef> 或相似的类）抽象所有操作系统资源访问是很重要的。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-141">In the case of an <xref:System.AppDomain> unload, you cannot depend on `finally` blocks or finalizers being executed, so it is important to abstract all operating system resource access through the <xref:System.Runtime.InteropServices.SafeHandle> class rather than <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, or similar classes.</span></span> <span data-ttu-id="6c6a4-142">这样使 CLR 能够跟踪和关闭你使用的句柄，即使在 <xref:System.AppDomain> 关闭的情况下也不例外。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-142">This allows the CLR to track and close the handles you use even in the <xref:System.AppDomain> tear-down case.</span></span>  <span data-ttu-id="6c6a4-143"><xref:System.Runtime.InteropServices.SafeHandle> 将使用 CLR 将始终运行的一个关键终结器。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-143"><xref:System.Runtime.InteropServices.SafeHandle> will be using a critical finalizer which the CLR will always run.</span></span>

<span data-ttu-id="6c6a4-144">操作系统句柄从被创建开始到被释放之前都存储在安全句柄中。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-144">The operating system handle is stored in the safe handle from the moment it is created until the moment it is released.</span></span>  <span data-ttu-id="6c6a4-145">在此期间不会出现发生 <xref:System.Threading.ThreadAbortException> 以泄露句柄的情况。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-145">There is no window during which a <xref:System.Threading.ThreadAbortException> can occur to leak a handle.</span></span>  <span data-ttu-id="6c6a4-146">此外，平台调用将引用计数句柄，这样可以关闭对句柄生存期的跟踪，防止 `Dispose` 和正在使用句柄的方法之间出现争用条件的安全问题。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-146">Additionally, platform invoke will reference-count the handle, which allows close tracking of the lifetime of the handle, preventing a security issue with a race condition between `Dispose` and a method that is currently using the handle.</span></span>

<span data-ttu-id="6c6a4-147">目前具有终结器以简单清理操作系统句柄的大多数类将不再需要终结器了。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-147">Most classes that currently have a finalizer to simply clean up an operating system handle will not need the finalizer anymore.</span></span> <span data-ttu-id="6c6a4-148">相反，终结器将位于 <xref:System.Runtime.InteropServices.SafeHandle> 派生类上。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-148">Instead, the finalizer will be on the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span>

<span data-ttu-id="6c6a4-149">请注意，<xref:System.Runtime.InteropServices.SafeHandle> 不能取代 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-149">Note that <xref:System.Runtime.InteropServices.SafeHandle> is not a replacement for <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span></span>  <span data-ttu-id="6c6a4-150">显示释放操作系统资源仍然有潜在的资源争用和性能优势。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-150">There are still potential resource contention and performance advantages to explicitly dispose operating system resources.</span></span>  <span data-ttu-id="6c6a4-151">但要知道显示释放资源的 `finally` 块可能不会执行到完成。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-151">Just realize that `finally` blocks that do explicitly dispose of resources may not execute to completion.</span></span>

<span data-ttu-id="6c6a4-152"><xref:System.Runtime.InteropServices.SafeHandle> 使你能够实现自己的 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 方法，此方法可执行工作以释放句柄，例如将状态传递到操作系统句柄释放例程或释放循环中的句柄集。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-152"><xref:System.Runtime.InteropServices.SafeHandle> allows you to implement your own <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method that performs the work to free the handle, such as passing state to an operating system handle freeing routine or freeing a set of handles in a loop.</span></span>  <span data-ttu-id="6c6a4-153">CLR 会保证此方法的运行。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-153">The CLR guarantees that this method is run.</span></span>  <span data-ttu-id="6c6a4-154">在任何情况下，实现 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 以确保句柄被释放是创建者的责任。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-154">It is the responsibility of the author of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation to ensure that the handle is released in all circumstances.</span></span> <span data-ttu-id="6c6a4-155">如果不能做到这点将导致句柄泄露，这通常会导致与句柄相关的本机资源泄露。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-155">Failure to do so will cause the handle to be leaked, which often results in the leakage of native resources associated with the handle.</span></span> <span data-ttu-id="6c6a4-156">因此，构建 <xref:System.Runtime.InteropServices.SafeHandle> 派生类是至关重要的，如此一来，<xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 实现便不需要任何在调用时可能不可用的资源分配。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-156">Therefore it is critical to structure <xref:System.Runtime.InteropServices.SafeHandle> derived classes such that the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation does not require the allocation of any resources that may not be available at invocation time.</span></span> <span data-ttu-id="6c6a4-157">请注意，调用在实现 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 中可能失败的方法是允许的，只要你的代码可以处理此类失败并且完成协议以释放本机句柄即可。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-157">Note that it is permissible to call methods that may fail within the implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> provided that your code can handle such failures and complete the contract to release the native handle.</span></span> <span data-ttu-id="6c6a4-158">出于调试目的，<xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 具有一个 <xref:System.Boolean> 返回值，如果遇到阻止资源释放的灾难性错误，此值可能会被设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-158">For debugging purposes, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> has a <xref:System.Boolean> return value which may be set to `false` if a catastrophic error is encountered which prevents release of the resource.</span></span> <span data-ttu-id="6c6a4-159">这样做将激活 [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA（如果已启用）以辅助确定问题。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-159">Doing so will activate the [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA, if enabled, to aid in identifying the problem.</span></span> <span data-ttu-id="6c6a4-160">它不会以其他任何方式影响运行时；<xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 将不会为同一资源再次被调用，并且因此将导致句柄泄露。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-160">It does not affect the runtime in any other way; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> will not be called again for the same resource and consequently the handle will be leaked.</span></span>

<span data-ttu-id="6c6a4-161"><xref:System.Runtime.InteropServices.SafeHandle> 在某些上下文中是不合适的。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-161"><xref:System.Runtime.InteropServices.SafeHandle> is not appropriate in certain contexts.</span></span>  <span data-ttu-id="6c6a4-162">由于可以在 <xref:System.GC> 终结器线程上运行 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 方法，因此，不应将任何需要在特定线程上释放的句柄包装在 <xref:System.Runtime.InteropServices.SafeHandle> 中。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-162">Since the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method can be run on a <xref:System.GC> finalizer thread, any handles that are required to be freed on a particular thread should not be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>

<span data-ttu-id="6c6a4-163">在没有其他代码的情况下，运行时可调用包装器 (RCW) 可以由 CLR 清理。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-163">Runtime callable wrappers (RCWs) can be cleaned by the CLR without additional code.</span></span>  <span data-ttu-id="6c6a4-164">对于使用平台调用并将 COM 对象视为 `IUnknown*` 或 <xref:System.IntPtr> 的代码，应重新编写此代码才能使用 RCW。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-164">For code that uses platform invoke and treats a COM object as an `IUnknown*` or an <xref:System.IntPtr>, the code should be rewritten to use an RCW.</span></span>  <span data-ttu-id="6c6a4-165">由于非托管的释放方法可能回调到托管代码中，因此 <xref:System.Runtime.InteropServices.SafeHandle> 可能不适用于此方案。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-165"><xref:System.Runtime.InteropServices.SafeHandle> may not be adequate for this scenario due to the possibility of an unmanaged release method calling back into managed code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="6c6a4-166">代码分析规则</span><span class="sxs-lookup"><span data-stu-id="6c6a4-166">Code analysis rule</span></span>

<span data-ttu-id="6c6a4-167">使用 <xref:System.Runtime.InteropServices.SafeHandle> 以封装操作系统资源。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-167">Use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate operating system resources.</span></span> <span data-ttu-id="6c6a4-168">不要使用 <xref:System.Runtime.InteropServices.HandleRef> 或 <xref:System.IntPtr> 类型的字段。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-168">Do not use <xref:System.Runtime.InteropServices.HandleRef> or fields of type <xref:System.IntPtr>.</span></span>

### <a name="ensure-finalizers-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="6c6a4-169">确保不需要运行终结器来防止操作系统资源泄露</span><span class="sxs-lookup"><span data-stu-id="6c6a4-169">Ensure finalizers do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="6c6a4-170">仔细检查终结器以确保即使它们不运行，关键的操作系统资源也不会泄露。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-170">Review your finalizers carefully to ensure that even if they do not run, a critical operating system resource is not leaked.</span></span>  <span data-ttu-id="6c6a4-171">与应用程序正以稳定状态执行或服务器（如 SQL Server）关闭时的普通 <xref:System.AppDomain> 卸载不同，在突然发生的 <xref:System.AppDomain> 卸载期间，对象不会被终结。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-171">Unlike a normal <xref:System.AppDomain> unload when the application is executing in a steady state or when a server such as SQL Server shuts down, objects are not finalized during an abrupt <xref:System.AppDomain> unload.</span></span>  <span data-ttu-id="6c6a4-172">请确保出现突然发生的卸载时资源不会泄露，因为虽然无法保证应用程序的正确性，但是要维持服务器的完整性必须保证资源不被泄露。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-172">Ensure resources are not leaked in the case of an abrupt unload, since an application's correctness cannot be guaranteed, but the integrity of the server must be maintained by not leaking resources.</span></span>  <span data-ttu-id="6c6a4-173">使用 <xref:System.Runtime.InteropServices.SafeHandle> 以释放任何操作系统资源。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-173">Use <xref:System.Runtime.InteropServices.SafeHandle> to free any operating system resources.</span></span>

### <a name="ensure-that-finally-clauses-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="6c6a4-174">确保不需要运行 finally 子句来防止操作系统资源泄露</span><span class="sxs-lookup"><span data-stu-id="6c6a4-174">Ensure that finally clauses do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="6c6a4-175">由于不保证 `finally` 子句可以在 CER 外部运行，因此要求库开发人员不要依赖 `finally` 块中的代码来释放非托管资源。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-175">`finally` clauses are not guaranteed to run outside of CERs, requiring library developers to not rely on code within a `finally` block to free unmanaged resources.</span></span>  <span data-ttu-id="6c6a4-176">建议的解决方案是使用 <xref:System.Runtime.InteropServices.SafeHandle>。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-176">Using <xref:System.Runtime.InteropServices.SafeHandle> is the recommended solution.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="6c6a4-177">代码分析规则</span><span class="sxs-lookup"><span data-stu-id="6c6a4-177">Code analysis rule</span></span>

<span data-ttu-id="6c6a4-178">使用 <xref:System.Runtime.InteropServices.SafeHandle> 清理操作系统资源，而不是使用 `Finalize`。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-178">Use <xref:System.Runtime.InteropServices.SafeHandle> for cleaning up operating system resources instead of `Finalize`.</span></span> <span data-ttu-id="6c6a4-179">不要使用 <xref:System.IntPtr>；使用 <xref:System.Runtime.InteropServices.SafeHandle> 以封装资源。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-179">Do not use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate resources.</span></span> <span data-ttu-id="6c6a4-180">如果 finally 子句必须运行，请将其放在 CER 中。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-180">If the finally clause must run, place it in a CER.</span></span>

### <a name="all-locks-should-go-through-existing-managed-locking-code"></a><span data-ttu-id="6c6a4-181">所有锁都应通过现有托管锁定代码</span><span class="sxs-lookup"><span data-stu-id="6c6a4-181">All locks should go through existing managed locking code</span></span>

<span data-ttu-id="6c6a4-182">CLR 必须知道代码何时在锁中，这样它便知道关闭 <xref:System.AppDomain>，而不仅仅是中止线程。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-182">The CLR must know when code is in a lock so that it will know to tear down the <xref:System.AppDomain> rather than just aborting the thread.</span></span>  <span data-ttu-id="6c6a4-183">中止线程可能是危险的操作，因为可能会使由线程运行的数据处于不一致的状态。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-183">Aborting the thread could be dangerous as the data operated on by the thread could be left in an inconsistent state.</span></span> <span data-ttu-id="6c6a4-184">因此，必须回收整个 <xref:System.AppDomain>。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-184">Therefore, the entire <xref:System.AppDomain> has to be recycled.</span></span>  <span data-ttu-id="6c6a4-185">未能成功识别锁可能导致死锁或者出现不正确的结果。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-185">The consequences of failing to identify a lock can be either deadlocks or incorrect results.</span></span> <span data-ttu-id="6c6a4-186">使用方法 <xref:System.Threading.Thread.BeginCriticalRegion%2A> 和 <xref:System.Threading.Thread.EndCriticalRegion%2A> 以识别锁定区域。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-186">Use the methods <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> to identify lock regions.</span></span>  <span data-ttu-id="6c6a4-187">它们是仅应用于当前线程的 <xref:System.Threading.Thread> 类上的静态方法，帮助防止某个线程编辑另一线程的锁计数。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-187">They are static methods on the <xref:System.Threading.Thread> class that only apply to the current thread, helping to prevent one thread from editing another thread’s lock count.</span></span>

<span data-ttu-id="6c6a4-188"><xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A> 内置有此 CLR 通知，所以建议使用它们，并且也建议采用使用这些方法的 [lock 语句](../../csharp/language-reference/keywords/lock-statement.md)。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-188"><xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> have this CLR notification built in, so their usage is recommended as well as the use of the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md), which uses these methods.</span></span>

<span data-ttu-id="6c6a4-189">其他锁定机制（如旋转锁和 <xref:System.Threading.AutoResetEvent>）必须调用这些方法才能对 CLR 发出正在进入临界区的通知。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-189">Other locking mechanisms such as spin locks and <xref:System.Threading.AutoResetEvent> must call these methods to notify the CLR that a critical section is being entered.</span></span>  <span data-ttu-id="6c6a4-190">这些方法不采用任何锁；它们通知 CLR 代码正在临界区中执行，中止线程可能导致共享状态不一致。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-190">These methods do not take any locks; they inform the CLR that code is executing in a critical section and aborting the thread could leave shared state inconsistent.</span></span>  <span data-ttu-id="6c6a4-191">如果定义了自己的锁类型（如自定义 <xref:System.Threading.ReaderWriterLock> 类），那么则使用这些锁计数方法。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-191">If you have defined your own lock type, such as a custom <xref:System.Threading.ReaderWriterLock> class, use these lock count methods.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="6c6a4-192">代码分析规则</span><span class="sxs-lookup"><span data-stu-id="6c6a4-192">Code analysis rule</span></span>

<span data-ttu-id="6c6a4-193">使用 <xref:System.Threading.Thread.BeginCriticalRegion%2A> 和 <xref:System.Threading.Thread.EndCriticalRegion%2A> 标记并识别所有锁。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-193">Mark and identify all locks using <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span></span> <span data-ttu-id="6c6a4-194">不要在循环中使用 <xref:System.Threading.Interlocked.CompareExchange%2A>、<xref:System.Threading.Interlocked.Increment%2A> 和 <xref:System.Threading.Interlocked.Decrement%2A>。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-194">Do not use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, and <xref:System.Threading.Interlocked.Decrement%2A> in a loop.</span></span>  <span data-ttu-id="6c6a4-195">不要对这些方法的 Win32 变量执行平台调用。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-195">Do not do a platform invoke of the Win32 variants of these methods.</span></span>  <span data-ttu-id="6c6a4-196">不要在循环中使用 <xref:System.Threading.Thread.Sleep%2A>。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-196">Do not use <xref:System.Threading.Thread.Sleep%2A> in a loop.</span></span>  <span data-ttu-id="6c6a4-197">不要使用可变字段。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-197">Do not use volatile fields.</span></span>

### <a name="cleanup-code-must-be-in-a-finally-or-a-catch-block-not-following-a-catch"></a><span data-ttu-id="6c6a4-198">清理代码必须位于 finally 或 catch 块中，但不在 catch</span><span class="sxs-lookup"><span data-stu-id="6c6a4-198">Cleanup code must be in a finally or a catch block, Not following a catch</span></span>

<span data-ttu-id="6c6a4-199">清理代码不能位于 `catch` 块之后；它应该在 `finally` 或 `catch` 块中。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-199">Cleanup code should never follow a `catch` block; it should be in a `finally` or in the `catch` block itself.</span></span> <span data-ttu-id="6c6a4-200">这应该是普通的良好做法。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-200">This should be a normal good practice.</span></span> <span data-ttu-id="6c6a4-201">通常首选使用 `finally` 块，因为在引发异常时以及在一般情况下达到 `try` 块的末尾时它都运行相同的代码。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-201">A `finally` block is generally preferred because it runs the same code both when an exception is thrown and when the end of the `try` block is normally encountered.</span></span>  <span data-ttu-id="6c6a4-202">在引发意外异常的情况下（例如 <xref:System.Threading.ThreadAbortException>），清理代码将不会运行。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-202">In the event of an unexpected exception being thrown, for example a <xref:System.Threading.ThreadAbortException>, the cleanup code will not run.</span></span>  <span data-ttu-id="6c6a4-203">理想情况下，要在 `finally` 中清理的任何非托管资源应该包装在 <xref:System.Runtime.InteropServices.SafeHandle> 中以防止泄露。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-203">Any unmanaged resources that you would clean up in a `finally` should ideally be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle> to prevent leaks.</span></span>  <span data-ttu-id="6c6a4-204">请注意，可以有效地使用 C# `using` 键释放对象，包括句柄。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-204">Note the C# `using` keyword can be used effectively to dispose of objects, including handles.</span></span>

<span data-ttu-id="6c6a4-205">虽然 <xref:System.AppDomain> 回收可以清理终结器线程上的资源，但是将清理代码放在正确的位置中仍然是很重要的。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-205">Although <xref:System.AppDomain> recycling can clean up resources on the finalizer thread, it is still important to put cleanup code in the correct place.</span></span> <span data-ttu-id="6c6a4-206">请注意，如果线程在未持有锁的情况下接收异步异常，那么 CLR 将尝试自己终止线程，而无需回收 <xref:System.AppDomain>。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-206">Note that if a thread receives an asynchronous exception without holding a lock, the CLR attempts to end the thread itself without having to recycle the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="6c6a4-207">通过提供更多可用的资源以及进行更好的生命期管理，有助于确保尽早地清理资源。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-207">Ensuring that resources are cleaned up sooner rather than later helps by making more resources available, and by better managing the lifetime.</span></span> <span data-ttu-id="6c6a4-208">如果不显示关闭指向某些错误代码路径中的文件的句柄，并且等待 <xref:System.Runtime.InteropServices.SafeHandle> 终结器进行清理，那么下一次你的代码运行时，如果终结器尚未运行，代码尝试访问同一文件可能会失败。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-208">If you do not explicitly close a handle to a file in some error code path then wait for the <xref:System.Runtime.InteropServices.SafeHandle> finalizer to clean it up, the next time your code runs it may fail trying to access the exact same file if the finalizer has not already run.</span></span>  <span data-ttu-id="6c6a4-209">因此，确保清理代码存在并能够正常工作将有助于更彻底、更快速地从失败中恢复，即使这并非绝对必要的操作。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-209">For this reason, ensuring that cleanup code exists and works correctly will help recover from failures more cleanly and quickly, even though it is not strictly necessary.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="6c6a4-210">代码分析规则</span><span class="sxs-lookup"><span data-stu-id="6c6a4-210">Code analysis rule</span></span>

<span data-ttu-id="6c6a4-211">`catch` 后面的清理代码需要在 `finally` 块中。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-211">Cleanup code after `catch` needs to be in a `finally` block.</span></span> <span data-ttu-id="6c6a4-212">将要进行释放的调用放置在 finally 块中。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-212">Place calls to dispose in a finally block.</span></span> <span data-ttu-id="6c6a4-213">`catch` 块应以引发或再次引发结束。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-213">`catch` blocks should end in a throw or rethrow.</span></span> <span data-ttu-id="6c6a4-214">虽然将出现异常，例如代码检测是否可以建立网络连接，在此情况下可能会出现大量的异常，但是，正常情况下，任何需要捕获大量异常的代码应该指示应对代码进行测试以检查它是否将成功。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-214">While there will be exceptions, such as code detecting whether a network connection can be established where you might get any of a large number of exceptions, any code that requires the catching of a number of exceptions under normal circumstances should give an indication that the code should be tested to see if it will succeed.</span></span>

### <a name="process-wide-mutable-shared-state-between-application-domains-should-be-eliminated-or-use-a-constrained-execution-region"></a><span data-ttu-id="6c6a4-215">应该消除应用程序域之间进程范围的可变共享状态，或使用受约束的执行区域</span><span class="sxs-lookup"><span data-stu-id="6c6a4-215">Process-Wide mutable shared state between application domains should be eliminated or use a constrained execution region</span></span>

<span data-ttu-id="6c6a4-216">如简介中所述，以可靠方式编写监视应用程序域之间进程范围的共享状态的托管代码是非常困难的。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-216">As described in the introduction, it can be very difficult to write managed code that monitors process-wide shared state across application domains in a reliable manner.</span></span>  <span data-ttu-id="6c6a4-217">进程范围的共享状态是在应用程序域之间共享的任何种类的数据结构，可以在 Win32 代码中、CLR 内部或者在使用远程处理的托管代码中。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-217">Process-wide shared state is any sort of data structure shared between application domains, either in Win32 code, inside the CLR, or in managed code using remoting.</span></span>  <span data-ttu-id="6c6a4-218">在托管代码中正确地编写可变的共享状态是非常困难的，并且处理任何静态的共享状态时必须极其小心。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-218">Any mutable shared state is very difficult to correctly write in managed code, and any static shared state might be done only with great care.</span></span>  <span data-ttu-id="6c6a4-219">如果有进程范围或计算机范围的共享状态，请找到方法消除它或使用受约束的执行区域 (CER) 保护此共享状态。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-219">If you have process-wide or machine-wide shared state, find some way to eliminate it or protect the shared state using a constrained execution region (CER).</span></span>  <span data-ttu-id="6c6a4-220">请注意，具有任何未识别并未更正的共享状态的库可能导致需要清理 <xref:System.AppDomain> 卸载的主机（如 SQL Server） 崩溃。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-220">Note that any library with shared state that is not identified and corrected could cause a host, such as SQL Server, that requires clean <xref:System.AppDomain> unloading to crash.</span></span>

<span data-ttu-id="6c6a4-221">如果代码使用 COM 对象，请避免在应用程序域之间共享此 COM 对象。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-221">If code uses a COM object, avoid sharing that COM object between application domains.</span></span>

### <a name="locks-do-not-work-process-wide-or-between-application-domains"></a><span data-ttu-id="6c6a4-222">锁定在进程范围内或应用程序域之间不起作用。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-222">Locks do not work process-wide or between application domains.</span></span>

<span data-ttu-id="6c6a4-223">过去，<xref:System.Threading.Monitor.Enter%2A> 和 [lock 语句](../../csharp/language-reference/keywords/lock-statement.md)用于创建全局进程锁定。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-223">In the past, <xref:System.Threading.Monitor.Enter%2A> and the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md) have been used to create global process locks.</span></span>  <span data-ttu-id="6c6a4-224">例如，在对 <xref:System.AppDomain> 敏捷类进行锁定时会发生这种情况，例如来自非共享程序集的 <xref:System.Type> 实例、<xref:System.Threading.Thread> 对象、暂存的字符串以及某些使用远程处理跨应用程序域共享的字符串。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-224">For example, this occurs when locking on <xref:System.AppDomain> agile classes, such as <xref:System.Type> instances from non-shared assemblies, <xref:System.Threading.Thread> objects, interned strings, and some strings shared across application domains using remoting.</span></span>  <span data-ttu-id="6c6a4-225">这些锁不再属于进程范围。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-225">These locks are no longer process-wide.</span></span>  <span data-ttu-id="6c6a4-226">若要识别进程范围的应用程序间域锁的存在，请确定锁中的代码是否使用任何外部持久化资源，如磁盘上的文件或者可能使用一个数据库。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-226">To identify the presence of a process-wide interapplication domain lock, determine if the code within the lock uses any external, persisted resource such as a file on disk or possibly a database.</span></span>

<span data-ttu-id="6c6a4-227">请注意，如果受保护的代码使用了外部资源，那么在 <xref:System.AppDomain> 中采用锁可能导致出现问题，因为该代码可能同时跨多个应用程序域运行。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-227">Note that taking a lock within an <xref:System.AppDomain> might cause problems if the protected code uses an external resource because that code may run simultaneously across multiple application domains.</span></span>  <span data-ttu-id="6c6a4-228">在写入到一个日志文件或绑定到整个进程的套接字时，这可能是个问题。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-228">This can be a problem when writing to one log file or binding to a socket for the entire process.</span></span>  <span data-ttu-id="6c6a4-229">这些更改意味着除了使用命名的 <xref:System.Threading.Mutex> 或 <xref:System.Threading.Semaphore> 实例外，没有简单的方法使用托管代码来获取全局进程的锁。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-229">These changes mean there is no easy way, using managed code, to get a process-global lock, other than using a named <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> instance.</span></span>  <span data-ttu-id="6c6a4-230">创建不在两个应用程序域中同时运行的代码，或使用 <xref:System.Threading.Mutex> 或 <xref:System.Threading.Semaphore> 类。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-230">Create code that does not run in two application domains simultaneously, or use the <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> classes.</span></span>  <span data-ttu-id="6c6a4-231">如果无法更改现有代码，请不要使用 Win32 命名的互斥以实现此同步，因为在纤程模式中运行意味着无法保证同一操作系统线程将获取并释放互斥。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-231">If existing code cannot be changed, do not use a Win32 named mutex to achieve this synchronization because running in fiber mode means you cannot guarantee the same operating system thread will acquire and release a mutex.</span></span>  <span data-ttu-id="6c6a4-232">必须使用托管 <xref:System.Threading.Mutex> 类、命名的 <xref:System.Threading.ManualResetEvent>、<xref:System.Threading.AutoResetEvent>，或 <xref:System.Threading.Semaphore>，以 CLR 能识别的方式同步代码锁，而不是使用非托管代码进行同步。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-232">You must use the managed <xref:System.Threading.Mutex> class, or a named <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, or a <xref:System.Threading.Semaphore> to synchronize the code lock in a manner that the CLR is aware of instead of synchronizing the lock using unmanaged code.</span></span>

#### <a name="avoid-locktypeofmytype"></a><span data-ttu-id="6c6a4-233">避免 lock(typeof(MyType))</span><span class="sxs-lookup"><span data-stu-id="6c6a4-233">Avoid lock(typeof(MyType))</span></span>

<span data-ttu-id="6c6a4-234">仅具有一个跨所有应用程序域共享的代码副本的共享程序集中的私有和公用 <xref:System.Type> 对象也存在问题。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-234">Private and public <xref:System.Type> objects in shared assemblies with only one copy of the code shared across all application domains also present problems.</span></span>  <span data-ttu-id="6c6a4-235">对于共享程序集，每个进程只有一个 <xref:System.Type> 实例，意味着多个应用程序域共享同一 <xref:System.Type> 实例。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-235">For shared assemblies, there is only one instance of a <xref:System.Type> per process, meaning that multiple application domains share the exact same <xref:System.Type> instance.</span></span>  <span data-ttu-id="6c6a4-236">在 <xref:System.Type> 实例上采用锁是采用影响整个进程而不仅仅是影响 <xref:System.AppDomain> 的锁。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-236">Taking a lock on a <xref:System.Type> instance takes a lock that affects the entire process, not just the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="6c6a4-237">如果一个 <xref:System.AppDomain> 在 <xref:System.Type> 对象上采用锁，接着该线程突然被中止，那么它将不会释放锁。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-237">If one <xref:System.AppDomain> takes a lock on a <xref:System.Type> object then that thread gets abruptly aborted, it will not release the lock.</span></span>  <span data-ttu-id="6c6a4-238">此锁随后可能导致其他应用程序域出现死锁的情况。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-238">This lock then may cause other application domains to deadlock.</span></span>

<span data-ttu-id="6c6a4-239">以静态方法采用锁的一个好方法是将静态的内部同步对象添加到代码中。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-239">A good way to take locks in static methods involves adding a static internal synchronization object to the code.</span></span>  <span data-ttu-id="6c6a4-240">可以在类构造函数（如果存在）中对其进行初始化；但是，如果不存在，则可以按以下方式对其进行初始化：</span><span class="sxs-lookup"><span data-stu-id="6c6a4-240">This could be initialized in the class constructor if one is present, but if not it can be initialized like this:</span></span>

```csharp
private static Object s_InternalSyncObject;
private static Object InternalSyncObject
{
    get
    {
        if (s_InternalSyncObject == null)
        {
            Object o = new Object();
            Interlocked.CompareExchange(
                ref s_InternalSyncObject, o, null);
        }
        return s_InternalSyncObject;
    }
}
```

<span data-ttu-id="6c6a4-241">然后在采用锁时，使用 `InternalSyncObject` 属性获取要在其上进行锁定的对象。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-241">Then when taking a lock, use the `InternalSyncObject` property to obtain an object to lock on.</span></span>  <span data-ttu-id="6c6a4-242">如果已在类构造函数中初始化了内部同步对象，则不需要使用此属性。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-242">You do not need to use the property if you have initialized the internal synchronization object in your class constructor.</span></span>  <span data-ttu-id="6c6a4-243">仔细检查锁初始化代码的方法应如下例所示：</span><span class="sxs-lookup"><span data-stu-id="6c6a4-243">The double checking lock initialization code should look like this example:</span></span>

```csharp
public static MyClass SingletonProperty
{
    get
    {
        if (s_SingletonProperty == null)
        {
            lock(InternalSyncObject)
            {
                // Do not use lock(typeof(MyClass))
                if (s_SingletonProperty == null)
                {
                    MyClass tmp = new MyClass(…);
                    // Do all initialization before publishing
                    s_SingletonProperty = tmp;
                }
            }
        }
        return s_SingletonProperty;
    }
}
```

#### <a name="a-note-about-lockthis"></a><span data-ttu-id="6c6a4-244">有关锁的说明（this）</span><span class="sxs-lookup"><span data-stu-id="6c6a4-244">A note about lock(this)</span></span>

<span data-ttu-id="6c6a4-245">通常，在可公开访问的单个对象上采用锁是可以接受的。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-245">It is generally acceptable to take a lock on an individual object that is publicly accessible.</span></span>  <span data-ttu-id="6c6a4-246">但是，如果对象是可能导致整个子系统出现死锁的单一对象，也可以考虑使用以上设计模式。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-246">However, if the object is a singleton object that might cause an entire subsystem to deadlock, consider using the above design pattern as well.</span></span>  <span data-ttu-id="6c6a4-247">例如，<xref:System.Security.SecurityManager> 对象上的锁可能导致 <xref:System.AppDomain> 内出现死锁，从而使整个 <xref:System.AppDomain> 不可用。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-247">For example, a lock on the one <xref:System.Security.SecurityManager> object could cause a deadlock within the <xref:System.AppDomain> making the entire <xref:System.AppDomain> unusable.</span></span> <span data-ttu-id="6c6a4-248">好的做法是不在此类可公开访问的对象上采用锁。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-248">It is good practice to not take a lock on a publicly accessible object of this type.</span></span>  <span data-ttu-id="6c6a4-249">但是，单个集合或数组上的锁通常不存在此问题。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-249">However a lock on an individual collection or array should generally not present a problem.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="6c6a4-250">代码分析规则</span><span class="sxs-lookup"><span data-stu-id="6c6a4-250">Code analysis rule</span></span>

<span data-ttu-id="6c6a4-251">不要在可跨应用程序域使用或不能明确进行标识的类型上采用锁。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-251">Do not take locks on types that might be used across application domains or do not have a strong sense of identity.</span></span> <span data-ttu-id="6c6a4-252">不要在 <xref:System.Type>、<xref:System.Reflection.MethodInfo>、<xref:System.Reflection.PropertyInfo>、<xref:System.String>、<xref:System.ValueType>、<xref:System.Threading.Thread> 或任何派生自 <xref:System.MarshalByRefObject> 的对象上调用 <xref:System.Threading.Monitor.Enter%2A>。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-252">Do not call <xref:System.Threading.Monitor.Enter%2A> on a <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, or any object that derives from <xref:System.MarshalByRefObject>.</span></span>

### <a name="remove-gckeepalive-calls"></a><span data-ttu-id="6c6a4-253">删除 GC。KeepAlive 调用</span><span class="sxs-lookup"><span data-stu-id="6c6a4-253">Remove GC.KeepAlive calls</span></span>

<span data-ttu-id="6c6a4-254">大量现有代码在应该使用 <xref:System.GC.KeepAlive%2A> 时不使用或在不适合的时候使用它。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-254">A significant amount of existing code either does not use <xref:System.GC.KeepAlive%2A> when it should or uses it when it is not appropriate.</span></span>  <span data-ttu-id="6c6a4-255">在转换成 <xref:System.Runtime.InteropServices.SafeHandle> 后，类不需要调用 <xref:System.GC.KeepAlive%2A>，即假设它们没有终结器但是依赖于 <xref:System.Runtime.InteropServices.SafeHandle> 以终结操作系统句柄。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-255">After converting to <xref:System.Runtime.InteropServices.SafeHandle>, classes do not need to call <xref:System.GC.KeepAlive%2A>, assuming they do not have a finalizer but rely on <xref:System.Runtime.InteropServices.SafeHandle> to finalize the operating system handles.</span></span>  <span data-ttu-id="6c6a4-256">虽然保留对 <xref:System.GC.KeepAlive%2A> 调用的性能成本可以忽略不计，但是调用 <xref:System.GC.KeepAlive%2A> 是必需或足以解决可能不再存在的生存期问题的方法，这样使代码更难以维护。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-256">While the performance cost of retaining a call to <xref:System.GC.KeepAlive%2A> may be negligible, the perception that a call to <xref:System.GC.KeepAlive%2A> is either necessary or sufficient to solve a lifetime issue that may no longer exist makes the code more difficult to maintain.</span></span>  <span data-ttu-id="6c6a4-257">但是，当使用 COM 互操作 CLR 可调用包装器 (RCW) 时，代码还是需要 <xref:System.GC.KeepAlive%2A>。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-257">However, when using the COM interop CLR callable wrappers (RCWs), <xref:System.GC.KeepAlive%2A> is still required by code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="6c6a4-258">代码分析规则</span><span class="sxs-lookup"><span data-stu-id="6c6a4-258">Code analysis rule</span></span>

<span data-ttu-id="6c6a4-259">删除 <xref:System.GC.KeepAlive%2A>。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-259">Remove <xref:System.GC.KeepAlive%2A>.</span></span>

### <a name="use-the-hostprotection-attribute"></a><span data-ttu-id="6c6a4-260">使用 HostProtection 特性</span><span class="sxs-lookup"><span data-stu-id="6c6a4-260">Use the HostProtection Attribute</span></span>

<span data-ttu-id="6c6a4-261"><xref:System.Security.Permissions.HostProtectionAttribute> (HPA) 允许使用声明性安全操作来决定主机保护需求，使主机甚至能够阻止完全信任的代码调用不适用于给定主机的某些方法，例如针对 SQL Server 的 <xref:System.Environment.Exit%2A> 或 <xref:System.Windows.Forms.MessageBox.Show%2A>。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-261">The <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) provides the use of declarative security actions to determine host protection requirements, allowing the host to prevent even fully trusted code from calling certain methods which are inappropriate for the given host, such as <xref:System.Environment.Exit%2A> or <xref:System.Windows.Forms.MessageBox.Show%2A> for SQL Server.</span></span>

<span data-ttu-id="6c6a4-262">HPA 仅影响可托管公共语言运行时且实现主机保护的非托管应用程序，如 SQL Server。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-262">The HPA affects only unmanaged applications that host the common language runtime and implement host protection, such as SQL Server.</span></span> <span data-ttu-id="6c6a4-263">应用后，安全性操作会导致基于类或方法公开的主机资源而创建链接要求。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-263">When applied, the security action results in the creation of a link demand based on the host resources the class or method exposes.</span></span> <span data-ttu-id="6c6a4-264">如果代码在客户端应用程序中运行或在非主机保护的服务器上运行，此特性则会“蒸发”；由于它不会被检测到，因此不会被应用。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-264">If the code is run in a client application or on a server that is not host-protected, the attribute "evaporates"; it is not detected and therefore not applied.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="6c6a4-265">此特性的目的在于强制执行特定于主机的编程模型准则，而非安全行为。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-265">The purpose of this attribute is to enforce host-specific programming model guidelines, not security behavior.</span></span>  <span data-ttu-id="6c6a4-266">虽然链接要求是用于检查是否符合编程模型要求，但 <xref:System.Security.Permissions.HostProtectionAttribute> 不是安全权限。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-266">Although a link demand is used to check for conformance to programming model requirements, the <xref:System.Security.Permissions.HostProtectionAttribute> is not a security permission.</span></span>

<span data-ttu-id="6c6a4-267">如果此主机没有编程模型要求，则不会出现链接要求。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-267">If the host does not have programming model requirements, the link demands do not occur.</span></span>

<span data-ttu-id="6c6a4-268">此特性可以标识以下各项：</span><span class="sxs-lookup"><span data-stu-id="6c6a4-268">This attribute identifies the following:</span></span>

- <span data-ttu-id="6c6a4-269">不适合主机编程模型，但属于良性的方法或类。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-269">Methods or classes that do not fit the host programming model, but are otherwise benign.</span></span>

- <span data-ttu-id="6c6a4-270">不适合主机编程模型且可能导致破坏服务器托管的用户代码稳定性的方法或类。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-270">Methods or classes that do not fit the host programming model and could lead to destabilizing server-managed user code.</span></span>

- <span data-ttu-id="6c6a4-271">不适合主机编程模型且可能导致破坏服务器进程自身稳定性的方法或类。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-271">Methods or classes that do not fit the host programming model and could lead to a destabilization of the server process itself.</span></span>

> [!NOTE]
> <span data-ttu-id="6c6a4-272">如果要创建由可能在主机保护的环境中执行的应用程序调用的类库，则应该将此特性应用于公开 <xref:System.Security.Permissions.HostProtectionResource> 资源类别的成员。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-272">If you are creating a class library that is to be called by applications that may execute in a host protected environment, you should apply this attribute to members that expose <xref:System.Security.Permissions.HostProtectionResource> resource categories.</span></span> <span data-ttu-id="6c6a4-273">具有此特性的 .NET Framework 类库成员会导致仅对直接调用方进行检查。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-273">The .NET Framework class library members with this attribute cause only the immediate caller to be checked.</span></span>  <span data-ttu-id="6c6a4-274">你的库成员也必须使用同一方法对其直接调用方进行检查。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-274">Your library member must also cause a check of its immediate caller in the same manner.</span></span>

<span data-ttu-id="6c6a4-275">有关 HPA 的详细信息，请参阅 <xref:System.Security.Permissions.HostProtectionAttribute>。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-275">Please find more information on HPA in <xref:System.Security.Permissions.HostProtectionAttribute>.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="6c6a4-276">代码分析规则</span><span class="sxs-lookup"><span data-stu-id="6c6a4-276">Code analysis rule</span></span>

<span data-ttu-id="6c6a4-277">对于 SQL Server，所有用于引入同步或线程的方法必须使用 HPA 识别。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-277">For SQL Server, all methods used to introduce synchronization or threading must identified with the HPA.</span></span> <span data-ttu-id="6c6a4-278">这包括共享状态、被同步或管理外部进程的方法。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-278">This includes methods that share state, are synchronized, or manage external processes.</span></span> <span data-ttu-id="6c6a4-279">影响 SQL Server 的 <xref:System.Security.Permissions.HostProtectionResource> 值是 <xref:System.Security.Permissions.HostProtectionResource.SharedState>、<xref:System.Security.Permissions.HostProtectionResource.Synchronization> 和 <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-279">The <xref:System.Security.Permissions.HostProtectionResource> values that impact SQL Server are <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, and <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span></span> <span data-ttu-id="6c6a4-280">但是，任何公开任意 <xref:System.Security.Permissions.HostProtectionResource> 的方法都应由 HPA 识别，而不只是使用影响 SQL 的资源的那些方法。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-280">However, any method that exposes any <xref:System.Security.Permissions.HostProtectionResource> should be identified by a HPA, not just those using resources affecting SQL.</span></span>

### <a name="do-not-block-indefinitely-in-unmanaged-code"></a><span data-ttu-id="6c6a4-281">不要在非托管代码中无限期阻止</span><span class="sxs-lookup"><span data-stu-id="6c6a4-281">Do not block indefinitely in unmanaged code</span></span>

<span data-ttu-id="6c6a4-282">在非托管代码中而不是在托管代码中阻塞可能导致拒绝服务攻击，因为 CLR 无法中止线程。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-282">Blocking in unmanaged code instead of in managed code can cause a denial of service attack because the CLR is not able to abort the thread.</span></span>  <span data-ttu-id="6c6a4-283">已阻塞的线程会阻止 CLR 卸载 <xref:System.AppDomain>，至少是在没有执行某些极端不安全操作的情况下。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-283">A blocked thread prevents the CLR from unloading the <xref:System.AppDomain>, at least without doing some extremely unsafe operations.</span></span>  <span data-ttu-id="6c6a4-284">使用 Windows 同步基元进行阻止是我们无法允许的一个清晰的示例。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-284">Blocking using a Windows synchronization primitive is a clear example of something we cannot allow.</span></span>  <span data-ttu-id="6c6a4-285">如果可能，应尽可能避免在对套接字的调用中进行阻止 `ReadFile` ，理想情况下，WINDOWS API 应为此类操作提供一种机制来超时。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-285">Blocking in a call to `ReadFile` on a socket should be avoided if possible — ideally the Windows API should provide a mechanism for an operation like this to time out.</span></span>

<span data-ttu-id="6c6a4-286">理想情况下，任何调入本机的方法应使用具有合理、有限的超时的 Win32 调用。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-286">Any method that calls into native should ideally use a Win32 call with a reasonable, finite timeout.</span></span>  <span data-ttu-id="6c6a4-287">如果允许用户指定超时，则在没有某些特定安全权限的情况下，不应该允许用户指定无限期的超时。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-287">If the user is allowed to specify the timeout, the user should not be allowed to specify an infinite timeout without some specific security permission.</span></span>  <span data-ttu-id="6c6a4-288">按照一般准则，如果方法将阻塞超过 10 秒，你则需要使用支持超时的版本，或需要其他的 CLR 支持。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-288">As a guideline, if a method will block for more than ~10 seconds, you need to be using a version that supports timeouts or you need additional CLR support.</span></span>

<span data-ttu-id="6c6a4-289">下面是一些有问题的 Api 的示例。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-289">Here are some examples of problematic APIs.</span></span>  <span data-ttu-id="6c6a4-290">虽然在超时的情况下可以创建管道（匿名和命名管道皆可）；但是，代码必须确保它永不使用 NMPWAIT_WAIT_FOREVER 调用 `CreateNamedPipe` 或 `WaitNamedPipe`。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-290">Pipes (both anonymous and named) can be created with a timeout; however, code must ensure it never calls `CreateNamedPipe` nor `WaitNamedPipe` with NMPWAIT_WAIT_FOREVER.</span></span>  <span data-ttu-id="6c6a4-291">此外，即使指定了超时也可能出现意外的阻塞。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-291">Additionally, there can be unexpected blocking even if a timeout is specified.</span></span>  <span data-ttu-id="6c6a4-292">在匿名管道上调用 `WriteFile` 将会在全部字节被写入之前阻塞，这意味着如果缓冲区在其中有未读数据，那么在读取器释放管道缓冲区中的空间之前，`WriteFile` 调用将阻塞。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-292">Calling `WriteFile` on an anonymous pipe will block until all bytes are written, meaning if the buffer has unread data in it, the `WriteFile` call will block until the reader has freed up space in the pipe’s buffer.</span></span>  <span data-ttu-id="6c6a4-293">套接字应该始终使用一些提供超时机制的 API。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-293">Sockets should always use some API that honors a timeout mechanism.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="6c6a4-294">代码分析规则</span><span class="sxs-lookup"><span data-stu-id="6c6a4-294">Code analysis rule</span></span>

<span data-ttu-id="6c6a4-295">在非托管代码中在没有超时的情况下进行阻塞是拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-295">Blocking without a timeout in unmanaged code is a denial of service attack.</span></span> <span data-ttu-id="6c6a4-296">不要执行对 `WaitForSingleObject`、`WaitForSingleObjectEx`、`WaitForMultipleObjects`、`MsgWaitForMultipleObjects` 和 `MsgWaitForMultipleObjectsEx` 的平台调用。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-296">Do not perform platform invoke calls to `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, and `MsgWaitForMultipleObjectsEx`.</span></span>  <span data-ttu-id="6c6a4-297">不要使用 NMPWAIT_WAIT_FOREVER。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-297">Do not use NMPWAIT_WAIT_FOREVER.</span></span>

### <a name="identify-any-sta-dependent-features"></a><span data-ttu-id="6c6a4-298">确定任何依赖于 STA 的功能</span><span class="sxs-lookup"><span data-stu-id="6c6a4-298">Identify any STA-Dependent features</span></span>

<span data-ttu-id="6c6a4-299">识别任何使用 COM 单线程单元 (STA) 的代码。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-299">Identify any code that uses COM single-threaded apartments (STAs).</span></span>  <span data-ttu-id="6c6a4-300">STA 在 SQL Server 进程中是被禁用的。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-300">STAs are disabled in the SQL Server process.</span></span>  <span data-ttu-id="6c6a4-301">必须在 SQL Server 中禁用依赖 `CoInitialize` 的功能，如性能计数器或剪贴板。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-301">Features that depend on `CoInitialize`, such as performance counters or the clipboard, must be disabled within SQL Server.</span></span>

### <a name="ensure-finalizers-are-free-of-synchronization-problems"></a><span data-ttu-id="6c6a4-302">确保终结器无同步问题</span><span class="sxs-lookup"><span data-stu-id="6c6a4-302">Ensure finalizers are free of synchronization problems</span></span>

<span data-ttu-id="6c6a4-303">多个终结器线程可能在 .NET Framework 的未来版本中存在，这意味着针对同一类型的不同实例的终结器会同时运行。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-303">Multiple finalizer threads might exist in future versions of the .NET Framework, meaning the finalizers for different instances of the same type run simultaneously.</span></span>  <span data-ttu-id="6c6a4-304">它们不需要是完全线程安全的；垃圾回收器保证只有一个线程将针对给定的对象实例运行终结器。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-304">They do not have to be completely thread safe; the garbage collector guarantees that only one thread will run the finalizer for a given object instance.</span></span>  <span data-ttu-id="6c6a4-305">但是，必须对终结器进行编码以避免同时在多个不同的对象示例上运行时出现争用条件和死锁的情况。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-305">However, the finalizers must be coded to avoid race conditions and deadlocks when running simultaneously on multiple different object instances.</span></span>  <span data-ttu-id="6c6a4-306">当在终结器中使用任何外部状态（如写入日志文件）时，必须解决线程问题。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-306">When using any external state, such as writing to a log file, in a finalizer, threading issues must be handled.</span></span>  <span data-ttu-id="6c6a4-307">不要依赖终结来提供线程安全性。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-307">Do not rely on finalization to provide thread safety.</span></span> <span data-ttu-id="6c6a4-308">不要使用线程本地存储（托管的或本机的）在终结器线程上存储状态。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-308">Do not use thread local storage, managed or native, to store state on the finalizer thread.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="6c6a4-309">代码分析规则</span><span class="sxs-lookup"><span data-stu-id="6c6a4-309">Code analysis rule</span></span>

<span data-ttu-id="6c6a4-310">终结器不得存在同步问题。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-310">Finalizers must be free of synchronization problems.</span></span> <span data-ttu-id="6c6a4-311">不要在终结器中使用静态的可变状态。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-311">Do not use a static mutable state in a finalizer.</span></span>

### <a name="avoid-unmanaged-memory-if-possible"></a><span data-ttu-id="6c6a4-312">如果可能，请避免非托管内存</span><span class="sxs-lookup"><span data-stu-id="6c6a4-312">Avoid unmanaged memory if possible</span></span>

<span data-ttu-id="6c6a4-313">非托管内存可能会被泄露，正如操作系统句柄一样。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-313">Unmanaged memory can be leaked, just like an operating system handle.</span></span> <span data-ttu-id="6c6a4-314">如有可能，请使用 [stackalloc](../../csharp/language-reference/operators/stackalloc.md) 或固定的托管对象（如 [fixed 语句](../../csharp/language-reference/keywords/fixed-statement.md)或使用 byte[] 的 <xref:System.Runtime.InteropServices.GCHandle>）在堆栈上尝试使用内存。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-314">If possible, try to use memory on the stack using [stackalloc](../../csharp/language-reference/operators/stackalloc.md) or a pinned managed object such as the [fixed Statement](../../csharp/language-reference/keywords/fixed-statement.md) or a <xref:System.Runtime.InteropServices.GCHandle> using a byte[].</span></span> <span data-ttu-id="6c6a4-315"><xref:System.GC> 最终会清理这些内容。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-315">The <xref:System.GC> eventually cleans these up.</span></span> <span data-ttu-id="6c6a4-316">但是，如果必须要分配非托管内存，请考虑使用派生自 <xref:System.Runtime.InteropServices.SafeHandle> 的类以包装内存分配。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-316">However, if you must allocate unmanaged memory, consider using a class that derives from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the memory allocation.</span></span>

<span data-ttu-id="6c6a4-317">请注意，至少存在一种 <xref:System.Runtime.InteropServices.SafeHandle> 不适用的情况。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-317">Note that there is at least one case where <xref:System.Runtime.InteropServices.SafeHandle> is not adequate.</span></span> <span data-ttu-id="6c6a4-318">对于分配或释放内存的 COM 方法调用，通常是一个 DLL 通过 `CoTaskMemAlloc` 分配内存，然后另一个 DLL 使用 `CoTaskMemFree` 释放内存。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-318">For COM method calls that allocate or free memory, it is common for one DLL to allocate memory via `CoTaskMemAlloc` then another DLL frees that memory with `CoTaskMemFree`.</span></span>  <span data-ttu-id="6c6a4-319">在这些位置中使用 <xref:System.Runtime.InteropServices.SafeHandle> 可能不适合，因为它会尝试将非托管内存的生存期绑定到 <xref:System.Runtime.InteropServices.SafeHandle> 的生存期，而不是允许其他 DLL 控制内存的生存期。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-319">Using <xref:System.Runtime.InteropServices.SafeHandle> in these places would be inappropriate since it will attempt to tie the lifetime of the unmanaged memory to the lifetime of the <xref:System.Runtime.InteropServices.SafeHandle> instead of allowing the other DLL control the lifetime of the memory.</span></span>

### <a name="review-all-uses-of-catchexception"></a><span data-ttu-id="6c6a4-320">查看 catch 的所有使用情况（异常）</span><span class="sxs-lookup"><span data-stu-id="6c6a4-320">Review all uses of catch(Exception)</span></span>

<span data-ttu-id="6c6a4-321">捕获所有异常而不是捕获某个特定异常的 catch 块现在也将捕获异步异常。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-321">Catch blocks that catch all exceptions instead of one specific exception will now catch the asynchronous exceptions as well.</span></span> <span data-ttu-id="6c6a4-322">检查每个 catch(Exception) 块，以确认没有重要的资源释放、可能被跳过的退出代码以及用于处理 <xref:System.Threading.ThreadAbortException>、<xref:System.StackOverflowException> 或 <xref:System.OutOfMemoryException> 的 catch 块自身中潜在的不正确行为。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-322">Examine every catch(Exception) block, looking for no important resource releasing or backout code that might be skipped, as well as potentially incorrect behavior within the catch block itself for handling a <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, or <xref:System.OutOfMemoryException>.</span></span>  <span data-ttu-id="6c6a4-323">请注意，此代码可能会记录或作出它只能发现特定异常的假设，或者假设无论异常何时发生，它的失败都是由同一特定原因所导致的。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-323">Note that it is possible this code might be logging or making some assumptions that it may only see certain exceptions, or that whenever an exception happens it failed for exactly one particular reason.</span></span>  <span data-ttu-id="6c6a4-324">可能需要对这些假设进行更新以将 <xref:System.Threading.ThreadAbortException> 包括在内。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-324">These assumptions may need to be updated to include <xref:System.Threading.ThreadAbortException>.</span></span>

<span data-ttu-id="6c6a4-325">请考虑更改捕获所有异常的所有位置以捕获期待将引发的特定类型的异常，例如来自字符串格式化方法的 <xref:System.FormatException>。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-325">Consider changing all places that catch all exceptions to catching a specific type of exception that you expect will be thrown, such as a <xref:System.FormatException> from string formatting methods.</span></span>  <span data-ttu-id="6c6a4-326">这将阻止 catch 块针对意外异常运行，并且将帮助确保代码不会通过捕获意外异常来隐藏 bug。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-326">This prevents the catch block from running on unexpected exceptions and will help ensure the code does not hide bugs by catching unexpected exceptions.</span></span>  <span data-ttu-id="6c6a4-327">按照一般规则，绝不要在库代码中处理异常（要求你捕获异常的代码可能指示正在调用的代码中存在设计缺陷）。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-327">As a general rule never handle an exception in library code (code that requires you to catch an exception may indicate a design flaw in the code you are calling).</span></span>  <span data-ttu-id="6c6a4-328">在某些情况下，你可能想捕获异常并且引发不同的异常类型以提供更多的数据。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-328">In some cases you may want to catch an exception and throw a different exception type to provide more data.</span></span>  <span data-ttu-id="6c6a4-329">在此情况下则使用嵌套异常，以将失败的真实原因存储在新异常的 <xref:System.Exception.InnerException%2A> 属性中。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-329">Use nested exceptions in this case, storing the real cause of the failure in the <xref:System.Exception.InnerException%2A> property of the new exception.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="6c6a4-330">代码分析规则</span><span class="sxs-lookup"><span data-stu-id="6c6a4-330">Code analysis rule</span></span>

<span data-ttu-id="6c6a4-331">查看托管代码中捕获所有对象或捕获所有异常的所有 catch 块。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-331">Review all catch blocks in managed code that catch all objects or catch all exceptions.</span></span>  <span data-ttu-id="6c6a4-332">在 c # 中，这意味着标记 `catch` {} 和 `catch(Exception)` {} 。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-332">In C#, this means flagging both `catch` {} and `catch(Exception)` {}.</span></span>  <span data-ttu-id="6c6a4-333">请考虑将异常类型描述得非常具体，或者查看代码以确保在它捕获到意外异常类型时不会以错误的方式执行。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-333">Consider making the exception type very specific, or review the code to ensure it does not act in a bad way if it catches an unexpected exception type.</span></span>

### <a name="do-not-assume-a-managed-thread-is-a-win32-thread--it-is-a-fiber"></a><span data-ttu-id="6c6a4-334">不要假设托管线程是一个 Win32 线程–它是一个纤程</span><span class="sxs-lookup"><span data-stu-id="6c6a4-334">Do not assume a managed thread is a Win32 thread – It is a Fiber</span></span>

<span data-ttu-id="6c6a4-335">虽然使用托管线程本地存储的确有效，但你不能再次使用非托管线程本地存储或再次假设代码将在当前操作系统线程上运行。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-335">Using managed thread local storage does work, but you may not use unmanaged thread local storage or assume the code will run on the current operating system thread again.</span></span> <span data-ttu-id="6c6a4-336">不要更改如线程的区域设置等设置。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-336">Do not change settings like the thread’s locale.</span></span> <span data-ttu-id="6c6a4-337">不要通过平台调用对 `InitializeCriticalSection` 或 `CreateMutex` 进行调用，因为它们要求进入锁的操作系统线程也能退出锁。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-337">Do not call `InitializeCriticalSection` or `CreateMutex` via platform invoke because they require the operating system thread that enters a lock also exit the lock.</span></span> <span data-ttu-id="6c6a4-338">由于使用纤程时将不存在此问题，所以不能直接在 SQL 中使用 Win32 临界区和互斥。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-338">Since this will not be the case when using fibers, Win32 critical sections and mutexes cannot be used in SQL directly.</span></span>  <span data-ttu-id="6c6a4-339">请注意，托管 <xref:System.Threading.Mutex> 类不会处理这些线程关联问题。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-339">Note that the managed <xref:System.Threading.Mutex> class does not handle these thread affinity concerns.</span></span>

<span data-ttu-id="6c6a4-340">可以在托管 <xref:System.Threading.Thread> 对象上安全使用大部分状态，包括托管线程本地存储和线程当前的 UI 区域性。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-340">You can safely use most of the state on a managed <xref:System.Threading.Thread> object, including managed thread local storage and the thread’s current UI culture.</span></span> <span data-ttu-id="6c6a4-341">还可以使用 <xref:System.ThreadStaticAttribute>，这将使现有静态变量的值只能由当前托管线程访问（这是在 CLR 中执行纤程本地存储的另一种方法）。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-341">You can also use the <xref:System.ThreadStaticAttribute>, which makes the value of an existing static variable accessible only by the current managed thread (this is another way of doing fiber local storage in the CLR).</span></span> <span data-ttu-id="6c6a4-342">出于编程模型的原因，在 SQL 中运行时不能更改线程当前的区域性。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-342">For programming model reasons, you can not change the current culture of a thread when running in SQL.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="6c6a4-343">代码分析规则</span><span class="sxs-lookup"><span data-stu-id="6c6a4-343">Code analysis rule</span></span>

<span data-ttu-id="6c6a4-344">SQL Server 在纤程模式中运行；不要使用线程本地存储。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-344">SQL Server runs in fiber mode; do not use thread local storage.</span></span> <span data-ttu-id="6c6a4-345">请避免执行对 `TlsAlloc`、`TlsFree`、`TlsGetValue` 和 `TlsSetValue.` 的平台调用</span><span class="sxs-lookup"><span data-stu-id="6c6a4-345">Avoid platform invoke calls to `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue.`</span></span>

### <a name="let-sql-server-handle-impersonation"></a><span data-ttu-id="6c6a4-346">让 SQL Server 处理模拟</span><span class="sxs-lookup"><span data-stu-id="6c6a4-346">Let SQL Server handle impersonation</span></span>

<span data-ttu-id="6c6a4-347">由于模拟在线程级别上进行操作且 SQL 可以在纤程模式中运行，因此托管代码不应该模拟用户，并且不应该调用 `RevertToSelf`。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-347">Since impersonation operates on the thread level and SQL can run in fiber mode, managed code should not impersonate users, and should not call `RevertToSelf`.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="6c6a4-348">代码分析规则</span><span class="sxs-lookup"><span data-stu-id="6c6a4-348">Code analysis rule</span></span>

<span data-ttu-id="6c6a4-349">让 SQL Server 处理模拟。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-349">Let SQL Server handle impersonation.</span></span> <span data-ttu-id="6c6a4-350">不要使用 `RevertToSelf`、`ImpersonateAnonymousToken`、`DdeImpersonateClient`、`ImpersonateDdeClientWindow`、`ImpersonateLoggedOnUser`、`ImpersonateNamedPipeClient`、`ImpersonateSelf`、`RpcImpersonateClient`、`RpcRevertToSelf`、`RpcRevertToSelfEx` 或 `SetThreadToken`。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-350">Do not use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, or `SetThreadToken`.</span></span>

### <a name="do-not-call-threadsuspend"></a><span data-ttu-id="6c6a4-351">不调用 Thread：：挂起</span><span class="sxs-lookup"><span data-stu-id="6c6a4-351">Do not call Thread::Suspend</span></span>

<span data-ttu-id="6c6a4-352">挂起线程的功能可能在一个简单的操作中实现，但是它可能会导致死锁。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-352">The ability to suspend a thread may appear a simple operation, but it can cause deadlocks.</span></span>  <span data-ttu-id="6c6a4-353">如果持有锁的线程由另一个线程挂起，后者又尝试采用相同的锁，则会发生死锁。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-353">If a thread holding a lock gets suspended by a second thread and then the second thread tries taking the same lock, a deadlock occurs.</span></span>  <span data-ttu-id="6c6a4-354"><xref:System.Threading.Thread.Suspend%2A> 当前会对安全性、类加载、远程处理和反射造成干扰。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-354"><xref:System.Threading.Thread.Suspend%2A> can interfere with security, class loading, remoting, and reflection currently.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="6c6a4-355">代码分析规则</span><span class="sxs-lookup"><span data-stu-id="6c6a4-355">Code analysis rule</span></span>

<span data-ttu-id="6c6a4-356">不要调用 <xref:System.Threading.Thread.Suspend%2A>。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-356">Do not call <xref:System.Threading.Thread.Suspend%2A>.</span></span> <span data-ttu-id="6c6a4-357">请考虑改为使用真正的同步基元，如 <xref:System.Threading.Semaphore> 或 <xref:System.Threading.ManualResetEvent>。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-357">Consider using a real synchronization primitive instead, such as a <xref:System.Threading.Semaphore> or <xref:System.Threading.ManualResetEvent> .</span></span>

### <a name="protect-critical-operations-with-constrained-execution-regions-and-reliability-contracts"></a><span data-ttu-id="6c6a4-358">通过受约束的执行区域和可靠性协定保护关键操作</span><span class="sxs-lookup"><span data-stu-id="6c6a4-358">Protect critical operations with constrained execution regions and reliability contracts</span></span>

<span data-ttu-id="6c6a4-359">在执行更新共享状态或需要确定性的完全成功或完全失败的复杂操作时，请确保此操作受到受约束的执行区域 (CER) 的保护。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-359">When performing a complex operation that updates a shared status or that needs to deterministically either fully succeed or fully fail, be sure that it is protected by a constrained execution region (CER).</span></span> <span data-ttu-id="6c6a4-360">这将保证代码在所有情况下都可运行，甚至在线程突然中止或 <xref:System.AppDomain> 突然卸载的情况下也不例外。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-360">This guarantees that the code runs in every case, even an abrupt thread abort or an abrupt <xref:System.AppDomain> unload.</span></span>

<span data-ttu-id="6c6a4-361">一个 CER 是 `try/finally` 调用后面紧跟的一个特定 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> 块。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-361">A CER is a particular `try/finally` block immediately preceded by a call to <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span></span>

<span data-ttu-id="6c6a4-362">这样做将指示实时编译器首先在 finally 块中准备所有代码，然后才运行 `try` 块。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-362">Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the `try` block.</span></span> <span data-ttu-id="6c6a4-363">这保证代码会在 finally 块中生成并且将在所有情况下运行。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-363">This guarantees that the code in the finally block is built and will run in all cases.</span></span> <span data-ttu-id="6c6a4-364">CER 中具有空 `try` 块的情况并不罕见。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-364">It is not uncommon in a CER to have an empty `try` block.</span></span> <span data-ttu-id="6c6a4-365">使用 CER 防止出现异步线程中止和内存不足异常。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-365">Using a CER protects against asynchronous thread aborts and out-of-memory exceptions.</span></span> <span data-ttu-id="6c6a4-366">有关进一步为极深代码处理堆栈溢出的 CER 形式，请参阅 <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A>。</span><span class="sxs-lookup"><span data-stu-id="6c6a4-366">See <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> for a form of a CER that additionally handles stack overflows for exceedingly deep code.</span></span>

## <a name="see-also"></a><span data-ttu-id="6c6a4-367">另请参阅</span><span class="sxs-lookup"><span data-stu-id="6c6a4-367">See also</span></span>

- <xref:System.Runtime.ConstrainedExecution>
- [<span data-ttu-id="6c6a4-368">SQL Server 编程和宿主保护特性</span><span class="sxs-lookup"><span data-stu-id="6c6a4-368">SQL Server Programming and Host Protection Attributes</span></span>](sql-server-programming-and-host-protection-attributes.md)
