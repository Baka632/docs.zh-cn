---
title: 保护包装代码
description: 查看如何保护包装代码，这可能会打开一组独特的安全漏洞，尤其当包装的信任度高于使用它的代码时。
ms.date: 03/30/2017
helpviewer_keywords:
- security [.NET Framework], wrapper code
- wrapper code, securing
- secure coding, wrapper code
- code security, wrapper code
ms.assetid: 1df6c516-5bba-48bd-b450-1070e04b7389
ms.openlocfilehash: f448cbf55f3ad992ba9dcc53d5be70b364038744
ms.sourcegitcommit: c37e8d4642fef647ebab0e1c618ecc29ddfe2a0f
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/06/2020
ms.locfileid: "87855746"
---
# <a name="securing-wrapper-code"></a><span data-ttu-id="1cbd7-103">保护包装代码</span><span class="sxs-lookup"><span data-stu-id="1cbd7-103">Securing Wrapper Code</span></span>

[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]  
  
 <span data-ttu-id="1cbd7-104">包装代码，特别是在包装的信任级别比使用它的代码的信任级别更高时，可以打开一组唯一的安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-104">Wrapper code, especially where the wrapper has higher trust than code that uses it, can open a unique set of security weaknesses.</span></span> <span data-ttu-id="1cbd7-105">代表调用方完成的任何操作都是被利用的潜在漏洞，其中进行适当安全检查时不包括调用方的有限权限。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-105">Anything done on behalf of a caller, where the caller's limited permissions are not included in the appropriate security check, is a potential weakness to be exploited.</span></span>  
  
 <span data-ttu-id="1cbd7-106">请勿通过包装启用调用方无法自行执行的任何操作。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-106">Never enable something through the wrapper that the caller could not do itself.</span></span> <span data-ttu-id="1cbd7-107">相对于完整堆栈遍历需求，在进行牵涉到限制安全性检查的操作时，这项操作特别危险。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-107">This is a special danger when doing something that involves a limited security check, as opposed to a full stack walk demand.</span></span> <span data-ttu-id="1cbd7-108">当涉及到单级别检查时，在实际调用方和正在讨论的 API 元素之间干预包装代码很容易导致本应失败的安全检查成功，从而便削弱了安全性。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-108">When single-level checks are involved, interposing the wrapper code between the real caller and the API element in question can easily cause the security check to succeed when it should not, thereby weakening security.</span></span>  
  
## <a name="delegates"></a><span data-ttu-id="1cbd7-109">委托</span><span class="sxs-lookup"><span data-stu-id="1cbd7-109">Delegates</span></span>  
 <span data-ttu-id="1cbd7-110">委托安全性因 .NET Framework 的版本而异。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-110">Delegate security differs between versions of the .NET Framework.</span></span>  <span data-ttu-id="1cbd7-111">本节介绍了不同的委托行为和相关的安全注意事项。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-111">This section describes the different delegate behaviors and associated security considerations.</span></span>  
  
### <a name="in-version-10-and-11-of-the-net-framework"></a><span data-ttu-id="1cbd7-112">.NET Framework 1.0 版和 1.1 版</span><span class="sxs-lookup"><span data-stu-id="1cbd7-112">In version 1.0 and 1.1 of the .NET Framework</span></span>  
 <span data-ttu-id="1cbd7-113">.NET Framework 1.0 版和 1.1 版可执行以下针对委托创建者和委托调用方的安全性操作。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-113">Version 1.0 and 1.1 of the .NET Framework perform the following security actions against a delegate creator and a delegate caller.</span></span>  
  
- <span data-ttu-id="1cbd7-114">当创建委托时，将针对委托创建者的权限集执行对委托目标方法的安全链接要求。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-114">When a delegate is created, security link demands on the delegate target method are performed against the grant set of the delegate creator.</span></span>  <span data-ttu-id="1cbd7-115">未遵循安全操作将导致 <xref:System.Security.SecurityException>。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-115">Failure to satisfy the security action results in a <xref:System.Security.SecurityException>.</span></span>  
  
- <span data-ttu-id="1cbd7-116">当调用委托时，将执行对委托调用方的任何现有的安全需求。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-116">When the delegate is invoked, any existing security demands on the delegate caller are performed.</span></span>  
  
 <span data-ttu-id="1cbd7-117">无论何时，当代码从可能调用它的不太受信任代码中提取 <xref:System.Delegate> 时，确保不会启用不太受信任代码提升其权限。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-117">Whenever your code takes a <xref:System.Delegate> from less-trusted code that might call it, make sure that you are not enabling the less-trusted code to escalate its permissions.</span></span> <span data-ttu-id="1cbd7-118">如果提取委托想在以后使用，则创建委托的代码不会出现在调用堆栈之上，并且其权限也得不到测试（如果委托中或以下的代码尝试执行受保护操作）。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-118">If you take a delegate and use it later, the code that created the delegate is not on the call stack and its permissions will not be tested if code in or under the delegate attempts a protected operation.</span></span> <span data-ttu-id="1cbd7-119">如果你的代码和调用方的代码其特权比创建者更高，则创建者可以安排调用路径，使其不作为调用堆栈的一部分。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-119">If your code and the caller code have higher privileges than the creator, the creator can orchestrate the call path without being part of the call stack.</span></span>  
  
### <a name="in-version-20-and-later-versions-of-the-net-framework"></a><span data-ttu-id="1cbd7-120">在版本2.0 及更高版本的 .NET Framework</span><span class="sxs-lookup"><span data-stu-id="1cbd7-120">In version 2.0 and later versions of the .NET Framework</span></span>  
 <span data-ttu-id="1cbd7-121">与早期版本不同的是，版本2.0 和更高版本的 .NET Framework 在创建和调用委托时对委托创建者执行安全操作。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-121">Unlike previous versions, version 2.0 and later versions of the .NET Framework performs security action against the delegate creator when the delegate is created and called.</span></span>  
  
- <span data-ttu-id="1cbd7-122">当创建委托时，将针对委托创建者的权限集执行对委托目标方法的安全链接要求。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-122">When a delegate is created, security link demands on the delegate target method are performed against the grant set of the delegate creator.</span></span>  <span data-ttu-id="1cbd7-123">未遵循安全操作将导致 <xref:System.Security.SecurityException>。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-123">Failure to satisfy the security action results in a <xref:System.Security.SecurityException>.</span></span>  
  
- <span data-ttu-id="1cbd7-124">在创建委托期间还会捕获委托创建者的权限集并存储在委托中。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-124">The delegate creator's grant set is also captured during delegate creation and stored with the delegate.</span></span>  
  
- <span data-ttu-id="1cbd7-125">待用委托时，如果委托创建者和调用方属于不同的程序集，则将针对当前内容中的任何需求首先评估委托创建者捕获的权限集。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-125">When the delegate is invoked, the delegate creator's captured grant set is first evaluated against any demands in the current context if the delegate creator and caller belong to different assemblies.</span></span>  <span data-ttu-id="1cbd7-126">然后才是执行针对委托调用方的现有安全需求。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-126">Next, any existing security demands on the delegate caller are performed.</span></span>  
  
## <a name="link-demands-and-wrappers"></a><span data-ttu-id="1cbd7-127">链接需求和包装</span><span class="sxs-lookup"><span data-stu-id="1cbd7-127">Link demands and wrappers</span></span>  
 <span data-ttu-id="1cbd7-128">在安全性基础结构中，已经对链接需求加强了特殊保护，但它依然是代码中潜在的漏洞源。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-128">A special protection case with link demands has been strengthened in the security infrastructure, but it is still a source of possible weakness in your code.</span></span>  
  
 <span data-ttu-id="1cbd7-129">如果完全受信任的代码调用由[linkdemand](link-demands.md)保护的属性、事件或方法，则在满足调用方的**LinkDemand**权限检查时，调用将成功。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-129">If fully trusted code calls a property, event, or method protected by a [LinkDemand](link-demands.md), the call succeeds if the **LinkDemand** permission check for the caller is satisfied.</span></span> <span data-ttu-id="1cbd7-130">此外，如果完全受信任的代码公开一个类，该类采用属性的名称并使用反射调用其**get**访问器，则即使用户代码没有访问此属性的权限，也会成功调用**get**访问器。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-130">Additionally, if the fully trusted code exposes a class that takes the name of a property and calls its **get** accessor using reflection, that call to the **get** accessor succeeds even though the user code does not have the right to access this property.</span></span> <span data-ttu-id="1cbd7-131">这是因为**LinkDemand**仅检查直接调用方，这是完全受信任的代码。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-131">This is because the **LinkDemand** checks only the immediate caller, which is the fully trusted code.</span></span> <span data-ttu-id="1cbd7-132">从根本上而言，完全受信任的代码可代表用户代码发出特权调用，而无需确保用户代码是否有权发出该调用。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-132">In essence, the fully trusted code is making a privileged call on behalf of user code without making sure that the user code has the right to make that call.</span></span>  
  
 <span data-ttu-id="1cbd7-133">为了帮助防止此类安全漏洞，公共语言运行时将检查扩展到完全堆栈遍历请求中，对对由**LinkDemand**保护的方法、构造函数、属性或事件的任何间接调用。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-133">To help prevent such security holes, the common language runtime extends the check into a full stack-walking demand on any indirect call to a method, constructor, property, or event protected by a **LinkDemand**.</span></span> <span data-ttu-id="1cbd7-134">这种保护会带来一些性能损失，并更改安全检查语义；完整的堆栈遍历需求可能会失败，其中会通过速度更快的单一级别检查。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-134">This protection incurs some performance costs and changes the semantics of the security check; the full stack-walk demand might fail where the faster, one-level check would have passed.</span></span>  
  
## <a name="assembly-loading-wrappers"></a><span data-ttu-id="1cbd7-135">加载包装的程序集</span><span class="sxs-lookup"><span data-stu-id="1cbd7-135">Assembly loading wrappers</span></span>  
 <span data-ttu-id="1cbd7-136">用于加载托管代码的几种方法，包括 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>使用调用方的证据加载程序集。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-136">Several methods used to load managed code, including <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>, load assemblies with the evidence of the caller.</span></span> <span data-ttu-id="1cbd7-137">如果包装任何这些方法，安全系统将使用代码的授予权限（而不是使用包装其调用方的权限）加载程序集。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-137">If you wrap any of these methods, the security system could use your code's permission grant, instead of the permissions of the caller to your wrapper, to load the assemblies.</span></span> <span data-ttu-id="1cbd7-138">请勿允许不受信任的代码加载的代码的权限高于包装的调用方的权限。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-138">Don't allow less-trusted code to load code that is granted higher permissions than those of the caller to your wrapper.</span></span>  
  
 <span data-ttu-id="1cbd7-139">否则，将会降低任何具有完全信任或比潜在调用方（）的信任程度明显更高的代码的安全性。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-139">Any code that has full trust or significantly higher trust than a potential caller (including an Internet-permissions-level caller) could weaken security in this way.</span></span> <span data-ttu-id="1cbd7-140">如果你的代码有一个公共方法，该方法采用字节数组，并将其传递给**assembly**，因此，它代表调用方创建一个程序集，这可能会破坏安全性。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-140">If your code has a public method that takes a byte array and passes it to **Assembly.Load**, thereby creating an assembly on the caller's behalf, it might break security.</span></span>  
  
 <span data-ttu-id="1cbd7-141">此问题适用于以下 API 元素：</span><span class="sxs-lookup"><span data-stu-id="1cbd7-141">This issue applies to the following API elements:</span></span>  
  
- <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType>  
  
- <xref:System.AppDomain.Load%2A?displayProperty=nameWithType>  
  
- <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>  
  
- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>  
  
## <a name="demand-vs-linkdemand"></a><span data-ttu-id="1cbd7-142">Demand VS LinkDemand</span><span class="sxs-lookup"><span data-stu-id="1cbd7-142">Demand vs. LinkDemand</span></span>  
 <span data-ttu-id="1cbd7-143">声明性安全提供了两种类型的安全检查。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-143">Declarative security offers two kinds of security checks that are similar but perform different checks.</span></span> <span data-ttu-id="1cbd7-144">最好同时理解这两种形式，因为错误的选择可能会导致安全或性能下降。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-144">It's good to understand both forms, because the wrong choice can result in weak security or performance loss.</span></span>  
  
 <span data-ttu-id="1cbd7-145">声明性安全提供了下列安全检查：</span><span class="sxs-lookup"><span data-stu-id="1cbd7-145">Declarative security offers the following security checks:</span></span>  
  
- <span data-ttu-id="1cbd7-146"><xref:System.Security.Permissions.SecurityAction.Demand> 指示代码访问安全堆栈审核。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-146"><xref:System.Security.Permissions.SecurityAction.Demand> specifies the code access security stack walk.</span></span> <span data-ttu-id="1cbd7-147">堆栈上的所有调用方必须具有特定权限或标识才能通过。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-147">All callers on the stack must have the specified permission or identity to pass.</span></span> <span data-ttu-id="1cbd7-148">每次调用都会发生**需求**，因为堆栈可能包含不同的调用方。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-148">**Demand** occurs on every call because the stack might contain different callers.</span></span> <span data-ttu-id="1cbd7-149">如果重复调用一种方法，则每次都会执行安全检查。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-149">If you call a method repeatedly, this security check occurs each time.</span></span> <span data-ttu-id="1cbd7-150">**需求**是应对引诱攻击的良好保护;检测到未经授权的代码。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-150">**Demand** is good protection against luring attacks; unauthorized code trying to get through it will be detected.</span></span>  
  
- <span data-ttu-id="1cbd7-151">[LinkDemand](link-demands.md)在实时 (JIT) 编译时间发生，并仅检查直接调用方。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-151">[LinkDemand](link-demands.md) happens at just-in-time (JIT) compilation time and checks only the immediate caller.</span></span> <span data-ttu-id="1cbd7-152">这种安全检查不会检查调用方的调用方。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-152">This security check does not check the caller's caller.</span></span> <span data-ttu-id="1cbd7-153">一旦此项检查成功，无论调用方调用的次数为多少，都无需任何其他安全性开销。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-153">Once this check passes, there is no additional security overhead no matter how many times the caller might call.</span></span> <span data-ttu-id="1cbd7-154">但是，这种方法没有对引诱攻击提供保护。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-154">However, there is also no protection from luring attacks.</span></span> <span data-ttu-id="1cbd7-155">使用**LinkDemand**，通过允许恶意代码使用授权代码调用，通过测试并可以引用代码的任何代码都可能会破坏安全性。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-155">With **LinkDemand**, any code that passes the test and can reference your code can potentially break security by allowing malicious code to call using the authorized code.</span></span> <span data-ttu-id="1cbd7-156">因此，请不要使用**LinkDemand** ，除非可以彻底避免所有可能的漏洞。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-156">Therefore, do not use **LinkDemand** unless all the possible weaknesses can be thoroughly avoided.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="1cbd7-157">在 .NET Framework 4 中，已将链接要求替换为 <xref:System.Security.SecurityCriticalAttribute> <xref:System.Security.SecurityRuleSet.Level2> 程序集中的特性。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-157">In the .NET Framework 4, link demands have been replaced by the <xref:System.Security.SecurityCriticalAttribute> attribute in <xref:System.Security.SecurityRuleSet.Level2> assemblies.</span></span> <span data-ttu-id="1cbd7-158"><xref:System.Security.SecurityCriticalAttribute>等效于完全信任的链接要求; 但是，它也会影响继承规则。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-158">The <xref:System.Security.SecurityCriticalAttribute> is equivalent to a link demand for full trust; however, it also affects inheritance rules.</span></span> <span data-ttu-id="1cbd7-159">有关此更改的详细信息，请参阅[安全透明代码，级别 2](security-transparent-code-level-2.md)。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-159">For more information about this change, see [Security-Transparent Code, Level 2](security-transparent-code-level-2.md).</span></span>  
  
 <span data-ttu-id="1cbd7-160">使用**LinkDemand**时所需的额外注意事项必须单独进行编程;安全系统可以帮助实施。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-160">The extra precautions required when using **LinkDemand** must be programmed individually; the security system can help with enforcement.</span></span> <span data-ttu-id="1cbd7-161">任何错误都会打开安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-161">Any mistake opens a security weakness.</span></span> <span data-ttu-id="1cbd7-162">利用你的代码的所有授权代码都必须负责执行以下操作实现其他安全性：</span><span class="sxs-lookup"><span data-stu-id="1cbd7-162">All authorized code that uses your code must be responsible for implementing additional security by doing the following:</span></span>  
  
- <span data-ttu-id="1cbd7-163">限制调用代码对类或程序集的访问权限。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-163">Restricting the calling code's access to the class or assembly.</span></span>  
  
- <span data-ttu-id="1cbd7-164">对显示在将被调用的代码上的调用代码施行相同的安全检查并负责让其调用方也执行这种检查。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-164">Placing the same security checks on the calling code that appear on the code being called and obligating its callers to do so.</span></span> <span data-ttu-id="1cbd7-165">例如，如果你编写的代码调用的方法使用的是具有指定标志**LinkDemand**的的 linkdemand <xref:System.Security.Permissions.SecurityPermission> ，则 <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> 你的方法还应为该权限更**LinkDemand**强的)  (或**要求**。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-165">For example, if you write code that calls a method that is protected with a **LinkDemand** for the <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> flag specified, your method should also make a **LinkDemand** (or **Demand**, which is stronger) for this permission.</span></span> <span data-ttu-id="1cbd7-166">这种情况的例外是，如果你的代码以有限的方式使用受**LinkDemand**保护的方法，则在考虑到其他安全保护机制 (例如，在代码中) 需求。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-166">The exception is if your code uses the **LinkDemand**-protected method in a limited way that you decide is safe, given other security protection mechanisms (such as demands) in your code.</span></span> <span data-ttu-id="1cbd7-167">对于这种例外情况，调用方需对削弱基础代码的安全性保护负责。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-167">In this exceptional case, the caller takes responsibility in weakening the security protection on the underlying code.</span></span>  
  
- <span data-ttu-id="1cbd7-168">确保你的代码调用方无法欺骗你的代码代表自己调用受保护的代码。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-168">Ensuring that your code's callers cannot trick your code into calling the protected code on their behalf.</span></span> <span data-ttu-id="1cbd7-169">换言之，调用方不能强制授权代码向受保护的代码传递特定参数，或从受保护的代码中得到返回结果。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-169">In other words, callers cannot force the authorized code to pass specific parameters to the protected code, or to get results back from it.</span></span>  
  
### <a name="interfaces-and-link-demands"></a><span data-ttu-id="1cbd7-170">接口和链接需求</span><span class="sxs-lookup"><span data-stu-id="1cbd7-170">Interfaces and Link Demands</span></span>  
 <span data-ttu-id="1cbd7-171">如果具有**LinkDemand**的虚拟方法、属性或事件重写了基类方法，则基类方法还必须具有相同的已重写方法的**LinkDemand** ，才能使其生效。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-171">If a virtual method, property, or event with **LinkDemand** overrides a base class method, the base class method must also have the same **LinkDemand** for the overridden method in order to be effective.</span></span> <span data-ttu-id="1cbd7-172">当然，恶意代码重新强制转换为基类并调用基类方法的这种情况也是有可能的。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-172">It is possible for malicious code to cast back to the base type and call the base class method.</span></span> <span data-ttu-id="1cbd7-173">另请注意，可以将链接需求以隐式方式添加到不包含 <xref:System.Security.AllowPartiallyTrustedCallersAttribute> 程序集级别属性的程序集。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-173">Also note that link demands can be added implicitly to assemblies that do not have the <xref:System.Security.AllowPartiallyTrustedCallersAttribute> assembly-level attribute.</span></span>  
  
 <span data-ttu-id="1cbd7-174">当接口方法也具有链接需求时，使用链接需求实现保护方法也是不错的选择。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-174">It is a good practice to protect method implementations with link demands when interface methods also have link demands.</span></span> <span data-ttu-id="1cbd7-175">请注意下列有关使用链接需求的接口：</span><span class="sxs-lookup"><span data-stu-id="1cbd7-175">Note the following about using link demands with interfaces:</span></span>  
  
- <span data-ttu-id="1cbd7-176">如果您将一个**LinkDemand**置于实现接口方法的类的公共方法上，则不会强制执行**linkdemand** ，前提是强制转换为接口并调用方法。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-176">If you place a **LinkDemand** on a public method of a class that implements an interface method, the **LinkDemand** will not be enforced if you then cast to the interface and call the method.</span></span> <span data-ttu-id="1cbd7-177">在这种情况下，由于您是根据接口进行链接的，因此只接受接口上的**LinkDemand** 。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-177">In this case, because you linked against the interface, only the **LinkDemand** on the interface is honored.</span></span>  
  
 <span data-ttu-id="1cbd7-178">审阅安全性问题的以下各项：</span><span class="sxs-lookup"><span data-stu-id="1cbd7-178">Review the following items for security issues:</span></span>  
  
- <span data-ttu-id="1cbd7-179">接口方法上的显式链接需求。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-179">Explicit link demands on interface methods.</span></span> <span data-ttu-id="1cbd7-180">确保这些链接需求提供预期保护。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-180">Make sure these link demands offer the expected protection.</span></span> <span data-ttu-id="1cbd7-181">确定恶意代码是否可以使用强制转换来避开链接需求，如前面所述。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-181">Determine whether malicious code can use a cast to get around the link demands as described previously.</span></span>  
  
- <span data-ttu-id="1cbd7-182">应用了包含链接需求的虚拟方法。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-182">Virtual methods with link demands applied.</span></span>  
  
- <span data-ttu-id="1cbd7-183">它们实现的类型和接口。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-183">Types and the interfaces they implement.</span></span> <span data-ttu-id="1cbd7-184">这些应使用相一致的链接需求。</span><span class="sxs-lookup"><span data-stu-id="1cbd7-184">These should use link demands consistently.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1cbd7-185">另请参阅</span><span class="sxs-lookup"><span data-stu-id="1cbd7-185">See also</span></span>

- [<span data-ttu-id="1cbd7-186">安全编码准则</span><span class="sxs-lookup"><span data-stu-id="1cbd7-186">Secure Coding Guidelines</span></span>](../../standard/security/secure-coding-guidelines.md)
