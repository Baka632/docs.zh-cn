---
title: 安全性和远程处理注意事项
description: 了解远程处理的安全注意事项，该注意事项使你可以在应用程序域、进程或计算机之间设置透明调用。
ms.date: 03/30/2017
helpviewer_keywords:
- code security, remoting
- remoting, security
- security [.NET Framework], remoting
- secure coding, remoting
ms.assetid: 125d2ab8-55a4-4e5f-af36-a7d401a37ab0
ms.openlocfilehash: 883c20483c4d315a45e1f4dab959d42cbb6e3c4b
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/26/2020
ms.locfileid: "96288198"
---
# <a name="security-and-remoting-considerations"></a><span data-ttu-id="1a2eb-103">安全性和远程处理注意事项</span><span class="sxs-lookup"><span data-stu-id="1a2eb-103">Security and Remoting Considerations</span></span>

[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]

<span data-ttu-id="1a2eb-104">利用远程处理，你可以在应用程序域、进程或计算机之间设置透明的调用。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-104">Remoting allows you to set up transparent calling between application domains, processes, or computers.</span></span> <span data-ttu-id="1a2eb-105">但是，代码访问安全堆栈审核不能跨越进程边界或计算机边界（它确实应用于同一进程的不同应用程序域之间）。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-105">However, the code access security stack walk cannot cross process or machine boundaries (it does apply between application domains of the same process).</span></span>  
  
 <span data-ttu-id="1a2eb-106">任何可远程处理的类（从 <xref:System.MarshalByRefObject> 类派生）都需要对安全负责。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-106">Any class that is remotable (derived from a <xref:System.MarshalByRefObject> class) needs to take responsibility for security.</span></span> <span data-ttu-id="1a2eb-107">要么只将代码用于封闭式安全环境中，在这种环境中可以隐式信任调用代码；要么相应地设计远程处理调用，以免这些调用会让受保护代码受到可能会被恶意使用的外部侵入的影响。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-107">Either the code should be used only in closed environments where the calling code can be implicitly trusted, or remoting calls should be designed so that they do not subject protected code to outside entry that could be used maliciously.</span></span>  
  
 <span data-ttu-id="1a2eb-108">通常，不应公开受声明性 [LinkDemand](link-demands.md) 和安全检查保护的方法、属性或事件 <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> 。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-108">Generally, you should never expose methods, properties, or events that are protected by declarative [LinkDemand](link-demands.md) and <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> security checks.</span></span> <span data-ttu-id="1a2eb-109">使用远程处理时，不会强制执行这些检查。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-109">With remoting, these checks are not enforced.</span></span> <span data-ttu-id="1a2eb-110">其他安全检查（如 <xref:System.Security.Permissions.SecurityAction.Demand> 、 [断言](using-the-assert-method.md)等）在进程内的应用程序域之间工作，但不能在跨进程或跨计算机方案中运行。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-110">Other security checks, such as <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](using-the-assert-method.md), and so on, work between application domains within a process but do not work in cross-process or cross-machine scenarios.</span></span>  
  
## <a name="protected-objects"></a><span data-ttu-id="1a2eb-111">受保护的对象</span><span class="sxs-lookup"><span data-stu-id="1a2eb-111">Protected objects</span></span>  

 <span data-ttu-id="1a2eb-112">某些对象自己保持安全状态。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-112">Some objects hold security state in themselves.</span></span> <span data-ttu-id="1a2eb-113">不应将这些对象传递给不受信任的代码，否则这样的代码将会获得超越其自身权限的安全授权。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-113">These objects should not be passed to untrusted code, which would then acquire security authorization beyond its own permissions.</span></span>  
  
 <span data-ttu-id="1a2eb-114">一个示例是创建 <xref:System.IO.FileStream> 对象。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-114">One example is creating a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="1a2eb-115">在创建时将要求具有 <xref:System.Security.Permissions.FileIOPermission>，如果成功，则会返回该文件对象。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-115">The <xref:System.Security.Permissions.FileIOPermission> is demanded at the time of creation and, if it succeeds, the file object is returned.</span></span> <span data-ttu-id="1a2eb-116">但是，如果将此对象引用传递给没有文件权限的代码，则该对象就可以读写此特定文件。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-116">However, if this object reference is passed to code without file permissions, the object will be able to read and write to this particular file.</span></span>  
  
 <span data-ttu-id="1a2eb-117">此类对象的最简单防御措施就是要求使用与通过公共 API 元素实现对象引用的任何代码的相同 **FileIOPermission** 。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-117">The simplest defense for such an object is to demand the same **FileIOPermission** of any code that seeks to get the object reference through a public API element.</span></span>  
  
## <a name="application-domain-crossing-issues"></a><span data-ttu-id="1a2eb-118">跨应用程序域问题</span><span class="sxs-lookup"><span data-stu-id="1a2eb-118">Application domain crossing issues</span></span>  

 <span data-ttu-id="1a2eb-119">若要隔离托管主机环境中的代码，通常使用可以降低各种程序集的权限级别的显式策略来生成多个子应用程序域。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-119">To isolate code in managed hosting environments, it is common to generate multiple child application domains with explicit policy reducing the permission levels for various assemblies.</span></span> <span data-ttu-id="1a2eb-120">但是，这些程序集的策略在默认的应用程序域中保持不变。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-120">However, the policy for those assemblies remains unchanged in the default application domain.</span></span> <span data-ttu-id="1a2eb-121">如果其中一个子应用程序域可以强制默认的应用程序域加载一个程序集，则代码隔离就会失去作用，强制加载的程序集中的类型将能够以较高的信任级别运行代码。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-121">If one of the child application domains can force the default application domain to load an assembly, the effect of code isolation is lost and types in the forcibly loaded assembly will be able to run code at a higher level of trust.</span></span>  
  
 <span data-ttu-id="1a2eb-122">一个应用程序域可以强制另一个应用程序域加载程序集，并通过调用托管在另一个应用程序域中的某个对象的代理来运行该程序集中所包含的代码。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-122">An application domain can force another application domain to load an assembly and run code contained therein by calling a proxy to an object hosted in the other application domain.</span></span> <span data-ttu-id="1a2eb-123">若要获取跨应用程序域的代理，托管该对象的应用程序域必须通过方法调用参数来分发代理，或者是返回值。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-123">To obtain a cross-application-domain proxy, the application domain hosting the object must distribute one through a method call parameter or return value.</span></span> <span data-ttu-id="1a2eb-124">或者，如果该应用程序域刚刚创建，则在默认情况下，创建者将具有 <xref:System.AppDomain> 对象的代理。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-124">Or, if the application domain was just created, the creator has a proxy to the <xref:System.AppDomain> object by default.</span></span> <span data-ttu-id="1a2eb-125">因此，为了避免破坏代码隔离，在具有较高信任级别的应用程序域中，不应将对引用封送对象的引用分发给信任级别较低的应用程序域，其中引用封送对象指从 <xref:System.MarshalByRefObject> 派生的类的实例。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-125">Thus, to avoid breaking code isolation, an application domain with a higher level of trust should not distribute references to marshaled-by-reference objects (instances of classes derived from <xref:System.MarshalByRefObject>) in its domain to application domains with lower levels of trust.</span></span>  
  
 <span data-ttu-id="1a2eb-126">通常，默认的应用程序域将创建子应用程序域，每一个子域中带有一个控件对象。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-126">Usually, the default application domain creates the child application domains with a control object in each one.</span></span> <span data-ttu-id="1a2eb-127">控件对象管理新的应用程序域，它有时从默认应用程序域接受命令，但实际上它不能直接与该域联系。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-127">The control object manages the new application domain and occasionally takes orders from the default application domain, but it cannot actually contact the domain directly.</span></span> <span data-ttu-id="1a2eb-128">有时，默认的应用程序域将针对控件对象调用其代理。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-128">Occasionally, the default application domain calls its proxy to the control object.</span></span> <span data-ttu-id="1a2eb-129">但是，有时候控件对象可能需要回调到默认的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-129">However, there might be cases in which it is necessary for the control object to call back to the default application domain.</span></span> <span data-ttu-id="1a2eb-130">在这些情况下，默认的应用程序域向控件对象的构造函数传递一个引用封送回调对象。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-130">In these cases, the default application domain passes a marshal-by-reference callback object to the constructor of the control object.</span></span> <span data-ttu-id="1a2eb-131">控件对象负责保护此代理。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-131">It is the responsibility of the control object to protect this proxy.</span></span> <span data-ttu-id="1a2eb-132">如果控件对象将代理放在公共类的公共静态字段上，或以其他方式公开了代理，则会打开一个危险的机制，使其他代码能够回调到默认的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-132">If the control object placed the proxy on a public static field of a public class or otherwise publicly exposed the proxy, a dangerous mechanism for other code to call back into the default application domain would be opened up.</span></span> <span data-ttu-id="1a2eb-133">因此，为使代理保持为私有的，总是隐式信任控件对象。</span><span class="sxs-lookup"><span data-stu-id="1a2eb-133">For this reason, control objects are always implicitly trusted to keep the proxy private.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1a2eb-134">另请参阅</span><span class="sxs-lookup"><span data-stu-id="1a2eb-134">See also</span></span>

- [<span data-ttu-id="1a2eb-135">安全编码准则</span><span class="sxs-lookup"><span data-stu-id="1a2eb-135">Secure Coding Guidelines</span></span>](../../standard/security/secure-coding-guidelines.md)
