---
title: 适用于程序集加载的最佳做法
description: 了解 .NET 中适用于程序集加载的最佳做法。 避免类型标识问题，这些问题可能导致转换无效、缺少方法和其他异常。
ms.date: 03/30/2017
helpviewer_keywords:
- assemblies,binding
- LoadFrom method
- default load context
- TypeLoadException class,causes
- assembly loading errors
- load contexts
- assemblies,loading
- LoadWithPartialName method
- load-from context
ms.assetid: 68d1c539-6a47-4614-ab59-4b071c9d4b4c
ms.openlocfilehash: 03d2cacea4d2c0e7452240df30350d93ce79282d
ms.sourcegitcommit: 1e8382d0ce8b5515864f8fbb178b9fd692a7503f
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/10/2020
ms.locfileid: "89656140"
---
# <a name="best-practices-for-assembly-loading"></a><span data-ttu-id="e73d3-104">适用于程序集加载的最佳做法</span><span class="sxs-lookup"><span data-stu-id="e73d3-104">Best Practices for Assembly Loading</span></span>
<span data-ttu-id="e73d3-105">本文讨论避免类型标识问题的方法，从而避免发生 <xref:System.InvalidCastException>、<xref:System.MissingMethodException> 以及其他错误。</span><span class="sxs-lookup"><span data-stu-id="e73d3-105">This article discusses ways to avoid problems of type identity that can lead to <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, and other errors.</span></span> <span data-ttu-id="e73d3-106">本文讨论以下建议：</span><span class="sxs-lookup"><span data-stu-id="e73d3-106">The article discusses the following recommendations:</span></span>  
  
- [<span data-ttu-id="e73d3-107">了解加载上下文的优点和缺点</span><span class="sxs-lookup"><span data-stu-id="e73d3-107">Understand the advantages and disadvantages of load contexts</span></span>](#load_contexts)  
  
- [<span data-ttu-id="e73d3-108">避免对部分程序集名称进行绑定</span><span class="sxs-lookup"><span data-stu-id="e73d3-108">Avoid binding on partial assembly names</span></span>](#avoid_partial_names)  
  
- [<span data-ttu-id="e73d3-109">避免将一个程序集加载到多个上下文中</span><span class="sxs-lookup"><span data-stu-id="e73d3-109">Avoid loading an assembly into multiple contexts</span></span>](#avoid_loading_into_multiple_contexts)  
  
- [<span data-ttu-id="e73d3-110">避免将一个程序集的多个版本加载到同一上下文中</span><span class="sxs-lookup"><span data-stu-id="e73d3-110">Avoid loading multiple versions of an assembly into the same context</span></span>](#avoid_loading_multiple_versions)  
  
- [<span data-ttu-id="e73d3-111">考虑切换到默认加载上下文</span><span class="sxs-lookup"><span data-stu-id="e73d3-111">Consider switching to the default load context</span></span>](#switch_to_default)  
  
 <span data-ttu-id="e73d3-112">第一个建议（即[了解加载上下文的优点和缺点](#load_contexts)）为其他建议提供了背景信息，因为这些建议都依赖于对加载上下文的了解。</span><span class="sxs-lookup"><span data-stu-id="e73d3-112">The first recommendation, [understand the advantages and disadvantages of load contexts](#load_contexts), provides background information for the other recommendations, because they all depend on a knowledge of load contexts.</span></span>  
  
<a name="load_contexts"></a>
## <a name="understand-the-advantages-and-disadvantages-of-load-contexts"></a><span data-ttu-id="e73d3-113">了解加载上下文的优点和缺点</span><span class="sxs-lookup"><span data-stu-id="e73d3-113">Understand the Advantages and Disadvantages of Load Contexts</span></span>  
 <span data-ttu-id="e73d3-114">在应用程序域中，可以将程序集加载到以下三个上下文之一中，也可以在没有上下文的情况下加载它们：</span><span class="sxs-lookup"><span data-stu-id="e73d3-114">Within an application domain, assemblies can be loaded into one of three contexts, or they can be loaded without context:</span></span>  
  
- <span data-ttu-id="e73d3-115">默认加载上下文包含通过探测全局程序集缓存找到的程序集、（如果托管了运行时）主机程序集存储区（例如在 SQL Server 中）以及应用程序域的 <xref:System.AppDomainSetup.ApplicationBase%2A> 和 <xref:System.AppDomainSetup.PrivateBinPath%2A>。</span><span class="sxs-lookup"><span data-stu-id="e73d3-115">The default load context contains assemblies found by probing the global assembly cache, the host assembly store if the runtime is hosted (for example, in SQL Server), and the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="e73d3-116"><xref:System.Reflection.Assembly.Load%2A> 方法的大多数重载都将程序集加载到此上下文中。</span><span class="sxs-lookup"><span data-stu-id="e73d3-116">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
- <span data-ttu-id="e73d3-117">加载位置上下文包含从加载程序未搜索的位置加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="e73d3-117">The load-from context contains assemblies that are loaded from locations that are not searched by the loader.</span></span> <span data-ttu-id="e73d3-118">例如，外接程序可能安装在一个不在应用程序路径下的目录中。</span><span class="sxs-lookup"><span data-stu-id="e73d3-118">For example, add-ins might be installed in a directory that is not under the application path.</span></span> <span data-ttu-id="e73d3-119"><xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>、<xref:System.AppDomain.CreateInstanceFrom%2A?displayProperty=nameWithType> 和 <xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType> 都是通过路径加载的方法的示例。</span><span class="sxs-lookup"><span data-stu-id="e73d3-119"><xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>, <xref:System.AppDomain.CreateInstanceFrom%2A?displayProperty=nameWithType>, and <xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType> are examples of methods that load by path.</span></span>  
  
- <span data-ttu-id="e73d3-120">仅反射上下文包含使用 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 和 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 方法加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="e73d3-120">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods.</span></span> <span data-ttu-id="e73d3-121">由于无法执行此上下文中的代码，因此在这里不对其进行讨论。</span><span class="sxs-lookup"><span data-stu-id="e73d3-121">Code in this context cannot be executed, so it is not discussed here.</span></span> <span data-ttu-id="e73d3-122">有关详细信息，请参阅[如何：将程序集加载到仅反射上下文中](../reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)。</span><span class="sxs-lookup"><span data-stu-id="e73d3-122">For more information, see [How to: Load Assemblies into the Reflection-Only Context](../reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
- <span data-ttu-id="e73d3-123">如果使用反射发出生成了一个瞬态动态程序集，则该程序集不在任何上下文中。</span><span class="sxs-lookup"><span data-stu-id="e73d3-123">If you generated a transient dynamic assembly by using reflection emit, the assembly is not in any context.</span></span> <span data-ttu-id="e73d3-124">此外，使用 <xref:System.Reflection.Assembly.LoadFile%2A> 方法加载的大多数程序集都是在没有上下文的情况下加载的，并且从字节数组加载的程序集也是在没有上下文的情况下加载的，除非这些程序集的标识（在应用策略后）证实它们位于全局程序集缓存中。</span><span class="sxs-lookup"><span data-stu-id="e73d3-124">In addition, most assemblies that are loaded by using the <xref:System.Reflection.Assembly.LoadFile%2A> method are loaded without context, and assemblies that are loaded from byte arrays are loaded without context unless their identity (after policy is applied) establishes that they are in the global assembly cache.</span></span>  
  
 <span data-ttu-id="e73d3-125">以下各节将讨论执行上下文的优点和缺点。</span><span class="sxs-lookup"><span data-stu-id="e73d3-125">The execution contexts have advantages and disadvantages, as discussed in the following sections.</span></span>  
  
### <a name="default-load-context"></a><span data-ttu-id="e73d3-126">默认加载上下文</span><span class="sxs-lookup"><span data-stu-id="e73d3-126">Default Load Context</span></span>  
 <span data-ttu-id="e73d3-127">将程序集加载到默认加载上下文中时，会自动加载其依赖项。</span><span class="sxs-lookup"><span data-stu-id="e73d3-127">When assemblies are loaded into the default load context, their dependencies are loaded automatically.</span></span> <span data-ttu-id="e73d3-128">将自动为默认加载上下文或加载位置上下文中的程序集查找加载到默认加载上下文中的依赖项。</span><span class="sxs-lookup"><span data-stu-id="e73d3-128">Dependencies that are loaded into the default load context are found automatically for assemblies in the default load context or the load-from context.</span></span> <span data-ttu-id="e73d3-129">按程序集标识进行加载可确保不使用未知版本的程序集，从而提高应用程序的稳定性（请参阅[避免对部分程序集名称进行绑定](#avoid_partial_names)一节）。</span><span class="sxs-lookup"><span data-stu-id="e73d3-129">Loading by assembly identity increases the stability of applications by ensuring that unknown versions of assemblies are not used (see the [Avoid Binding on Partial Assembly Names](#avoid_partial_names) section).</span></span>  
  
 <span data-ttu-id="e73d3-130">使用默认加载上下文具有以下缺点：</span><span class="sxs-lookup"><span data-stu-id="e73d3-130">Using the default load context has the following disadvantages:</span></span>  
  
- <span data-ttu-id="e73d3-131">加载到其他上下文中的依赖项将不可用。</span><span class="sxs-lookup"><span data-stu-id="e73d3-131">Dependencies that are loaded into other contexts are not available.</span></span>  
  
- <span data-ttu-id="e73d3-132">不能将位于探测路径外部位置的程序集加载到默认加载上下文中。</span><span class="sxs-lookup"><span data-stu-id="e73d3-132">You cannot load assemblies from locations outside the probing path into the default load context.</span></span>  
  
### <a name="load-from-context"></a><span data-ttu-id="e73d3-133">加载位置上下文</span><span class="sxs-lookup"><span data-stu-id="e73d3-133">Load-From Context</span></span>  
 <span data-ttu-id="e73d3-134">利用加载位置上下文，可从不在应用程序路径下（因此不包含在探测路径中）的某个路径加载程序集。</span><span class="sxs-lookup"><span data-stu-id="e73d3-134">The load-from context lets you load an assembly from a path that is not under the application path, and therefore is not included in probing.</span></span> <span data-ttu-id="e73d3-135">加载位置上下文允许从该路径查找和加载依赖项，因为路径信息由上下文维护。</span><span class="sxs-lookup"><span data-stu-id="e73d3-135">It enables dependencies to be located and loaded from that path, because the path information is maintained by the context.</span></span> <span data-ttu-id="e73d3-136">另外，此上下文中的程序集可以使用加载到默认加载上下文中的依赖项。</span><span class="sxs-lookup"><span data-stu-id="e73d3-136">In addition, assemblies in this context can use dependencies that are loaded into the default load context.</span></span>  
  
 <span data-ttu-id="e73d3-137">使用 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> 方法或其他按路径加载的方法之一加载程序集具有以下缺点：</span><span class="sxs-lookup"><span data-stu-id="e73d3-137">Loading assemblies by using the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method, or one of the other methods that load by path, has the following disadvantages:</span></span>  
  
- <span data-ttu-id="e73d3-138">如果具有相同标识的程序集已加载到加载源上下文中，则即使指定了不同的路径，<xref:System.Reflection.Assembly.LoadFrom%2A> 也仍会返回已加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="e73d3-138">If an assembly with the same identity is already loaded in the load-from context, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
- <span data-ttu-id="e73d3-139">如果用 <xref:System.Reflection.Assembly.LoadFrom%2A> 加载一个程序集，随后默认加载上下文中的一个程序集尝试按显示名称加载同一程序集，则加载尝试将失败。</span><span class="sxs-lookup"><span data-stu-id="e73d3-139">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the default load context tries to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="e73d3-140">对程序集进行反序列化时，可能发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="e73d3-140">This can occur when an assembly is deserialized.</span></span>  
  
- <span data-ttu-id="e73d3-141">如果用 <xref:System.Reflection.Assembly.LoadFrom%2A> 加载一个程序集，并且探测路径包括一个具有相同标识但位置不同的程序集，则将发生 <xref:System.InvalidCastException>、<xref:System.MissingMethodException> 或其他意外行为。</span><span class="sxs-lookup"><span data-stu-id="e73d3-141">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but in a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
- <span data-ttu-id="e73d3-142"><xref:System.Reflection.Assembly.LoadFrom%2A> 需要对指定路径的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。</span><span class="sxs-lookup"><span data-stu-id="e73d3-142"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
- <span data-ttu-id="e73d3-143">如果存在程序集的本机映像，将不会使用它。</span><span class="sxs-lookup"><span data-stu-id="e73d3-143">If a native image exists for the assembly, it is not used.</span></span>  
  
- <span data-ttu-id="e73d3-144">程序集不能以非特定于域的方式加载。</span><span class="sxs-lookup"><span data-stu-id="e73d3-144">The assembly cannot be loaded as domain-neutral.</span></span>  
  
- <span data-ttu-id="e73d3-145">该策略不适用于 1.0 和 1.1 版本的 .NET Framework。</span><span class="sxs-lookup"><span data-stu-id="e73d3-145">In the .NET Framework versions 1.0 and 1.1, policy is not applied.</span></span>  
  
### <a name="no-context"></a><span data-ttu-id="e73d3-146">无上下文</span><span class="sxs-lookup"><span data-stu-id="e73d3-146">No Context</span></span>  
 <span data-ttu-id="e73d3-147">使用反射发出生成的瞬态程序集只能选择在没有下文的情况下进行加载。</span><span class="sxs-lookup"><span data-stu-id="e73d3-147">Loading without context is the only option for transient assemblies that are generated with reflection emit.</span></span> <span data-ttu-id="e73d3-148">在没有上下文的情况下进行加载是将具有同一标识的多个程序集加载到一个应用程序域中的唯一方式。</span><span class="sxs-lookup"><span data-stu-id="e73d3-148">Loading without context is the only way to load multiple assemblies that have the same identity into one application domain.</span></span> <span data-ttu-id="e73d3-149">这将省去探测成本。</span><span class="sxs-lookup"><span data-stu-id="e73d3-149">The cost of probing is avoided.</span></span>  
  
 <span data-ttu-id="e73d3-150">从字节数组加载的程序集都是在没有上下文的情况下加载的，除非程序集的标识（在应用策略后建立）与全局程序集缓存中的程序集标识匹配；在此情况下，将会从全局程序集缓存加载程序集。</span><span class="sxs-lookup"><span data-stu-id="e73d3-150">Assemblies that are loaded from byte arrays are loaded without context unless the identity of the assembly, which is established when policy is applied, matches the identity of an assembly in the global assembly cache; in that case, the assembly is loaded from the global assembly cache.</span></span>  
  
 <span data-ttu-id="e73d3-151">在没有上下文的情况下加载程序集具有以下缺点：</span><span class="sxs-lookup"><span data-stu-id="e73d3-151">Loading assemblies without context has the following disadvantages:</span></span>  
  
- <span data-ttu-id="e73d3-152">无法将其他程序集绑定到在没有上下文的情况下加载的程序集，除非处理 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 事件。</span><span class="sxs-lookup"><span data-stu-id="e73d3-152">Other assemblies cannot bind to assemblies that are loaded without context, unless you handle the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event.</span></span>  
  
- <span data-ttu-id="e73d3-153">依赖项无法自动加载。</span><span class="sxs-lookup"><span data-stu-id="e73d3-153">Dependencies are not loaded automatically.</span></span> <span data-ttu-id="e73d3-154">可以在没有上下文的情况下预加载依赖项、将依赖项预加载到默认加载上下文中或通过处理 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 事件来加载依赖项。</span><span class="sxs-lookup"><span data-stu-id="e73d3-154">You can preload them without context, preload them into the default load context, or load them by handling the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event.</span></span>  
  
- <span data-ttu-id="e73d3-155">在没有上下文的情况下加载具有同一标识的多个程序集会导致出现类型标识问题，这些问题与将具有同一标识的多个程序集加载到多个上下文中所导致的问题类似。</span><span class="sxs-lookup"><span data-stu-id="e73d3-155">Loading multiple assemblies with the same identity without context can cause type identity problems similar to those caused by loading assemblies with the same identity into multiple contexts.</span></span> <span data-ttu-id="e73d3-156">请参阅[避免将一个程序集加载到多个上下文中](#avoid_loading_into_multiple_contexts)。</span><span class="sxs-lookup"><span data-stu-id="e73d3-156">See [Avoid Loading an Assembly into Multiple Contexts](#avoid_loading_into_multiple_contexts).</span></span>  
  
- <span data-ttu-id="e73d3-157">如果存在程序集的本机映像，将不会使用它。</span><span class="sxs-lookup"><span data-stu-id="e73d3-157">If a native image exists for the assembly, it is not used.</span></span>  
  
- <span data-ttu-id="e73d3-158">程序集不能以非特定于域的方式加载。</span><span class="sxs-lookup"><span data-stu-id="e73d3-158">The assembly cannot be loaded as domain-neutral.</span></span>  
  
- <span data-ttu-id="e73d3-159">该策略不适用于 1.0 和 1.1 版本的 .NET Framework。</span><span class="sxs-lookup"><span data-stu-id="e73d3-159">In the .NET Framework versions 1.0 and 1.1, policy is not applied.</span></span>  
  
<a name="avoid_partial_names"></a>
## <a name="avoid-binding-on-partial-assembly-names"></a><span data-ttu-id="e73d3-160">避免对部分程序集名称进行绑定</span><span class="sxs-lookup"><span data-stu-id="e73d3-160">Avoid Binding on Partial Assembly Names</span></span>  
 <span data-ttu-id="e73d3-161">加载程序集时，如果仅指定程序集显示名称的一部分 (<xref:System.Reflection.Assembly.FullName%2A>)，则会发生部分名称绑定。</span><span class="sxs-lookup"><span data-stu-id="e73d3-161">Partial name binding occurs when you specify only part of the assembly display name (<xref:System.Reflection.Assembly.FullName%2A>) when you load an assembly.</span></span> <span data-ttu-id="e73d3-162">例如，可能会在调用 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 方法时仅使用程序集的简单名称，而忽略版本、区域性和公钥标记。</span><span class="sxs-lookup"><span data-stu-id="e73d3-162">For example, you might call the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method with only the simple name of the assembly, omitting the version, culture, and public key token.</span></span> <span data-ttu-id="e73d3-163">也可能会调用 <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> 方法，该方法首先调用 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 方法，再搜索全局程序集缓存（如果未能找到程序集）并加载程序集的最新可用版本。</span><span class="sxs-lookup"><span data-stu-id="e73d3-163">Or you might call the <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method, which first calls the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and, if that fails to locate the assembly, searches the global assembly cache and loads the latest available version of the assembly.</span></span>  
  
 <span data-ttu-id="e73d3-164">部分名称绑定会导致出现许多问题，其中包括：</span><span class="sxs-lookup"><span data-stu-id="e73d3-164">Partial name binding can cause many problems, including the following:</span></span>  
  
- <span data-ttu-id="e73d3-165"><xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> 方法可能会加载简单名称相同的不同程序集。</span><span class="sxs-lookup"><span data-stu-id="e73d3-165">The <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method might load a different assembly with the same simple name.</span></span> <span data-ttu-id="e73d3-166">例如，两个应用程序可能会将具有简单名称 `GraphicsLibrary` 的两个完全不同的程序集安装到全局程序集缓存中。</span><span class="sxs-lookup"><span data-stu-id="e73d3-166">For example, two applications might install two completely different assemblies that both have the simple name `GraphicsLibrary` into the global assembly cache.</span></span>  
  
- <span data-ttu-id="e73d3-167">实际加载的程序集可能无法后向兼容。</span><span class="sxs-lookup"><span data-stu-id="e73d3-167">The assembly that is actually loaded might not be backward-compatible.</span></span> <span data-ttu-id="e73d3-168">例如，若不指定版本，加载的版本可能会比最初编写程序时指定使用的版本新很多。</span><span class="sxs-lookup"><span data-stu-id="e73d3-168">For example, not specifying the version might result in the loading of a much later version than the version your program was originally written to use.</span></span> <span data-ttu-id="e73d3-169">较新版本中的更改可能会导致应用程序中出现错误。</span><span class="sxs-lookup"><span data-stu-id="e73d3-169">Changes in the later version might cause errors in your application.</span></span>  
  
- <span data-ttu-id="e73d3-170">实际加载的程序集可能无法前向兼容。</span><span class="sxs-lookup"><span data-stu-id="e73d3-170">The assembly that is actually loaded might not be forward-compatible.</span></span> <span data-ttu-id="e73d3-171">例如，可以使用程序集的最新版本来生成并测试应用程序，但部分绑定可能会加载一个缺少应用程序所用功能的早期版本。</span><span class="sxs-lookup"><span data-stu-id="e73d3-171">For example, you might have built and tested your application with the latest version of an assembly, but partial binding might load a much earlier version that lacks features your application uses.</span></span>  
  
- <span data-ttu-id="e73d3-172">安装新的应用程序可能会损坏现有应用程序。</span><span class="sxs-lookup"><span data-stu-id="e73d3-172">Installing new applications can break existing applications.</span></span> <span data-ttu-id="e73d3-173">安装共享程序集的更新的非兼容版本会损坏使用 <xref:System.Reflection.Assembly.LoadWithPartialName%2A> 方法的应用程序。</span><span class="sxs-lookup"><span data-stu-id="e73d3-173">An application that uses the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method can be broken by installing a newer, incompatible version of a shared assembly.</span></span>  
  
- <span data-ttu-id="e73d3-174">可能发生意外的依赖项加载。</span><span class="sxs-lookup"><span data-stu-id="e73d3-174">Unexpected dependency loading can occur.</span></span> <span data-ttu-id="e73d3-175">在加载共享一个依赖项的两个程序集时，如果利用部分绑定来加载它们，则可能会导致其中一个程序集使用未用来生成或测试该程序集的组件。</span><span class="sxs-lookup"><span data-stu-id="e73d3-175">It you load two assemblies that share a dependency, loading them with partial binding might result in one assembly using a component that it was not built or tested with.</span></span>  
  
 <span data-ttu-id="e73d3-176">由于部分名称绑定会导致出现上述问题，因此已将 <xref:System.Reflection.Assembly.LoadWithPartialName%2A> 方法标记为已过时。</span><span class="sxs-lookup"><span data-stu-id="e73d3-176">Because of the problems it can cause, the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method has been marked obsolete.</span></span> <span data-ttu-id="e73d3-177">建议改用 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 方法，并指定完整的程序集显示名称。</span><span class="sxs-lookup"><span data-stu-id="e73d3-177">We recommend that you use the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method instead, and specify full assembly display names.</span></span> <span data-ttu-id="e73d3-178">请参阅[了解加载上下文的优点和缺点](#load_contexts)和[考虑切换到默认加载上下文](#switch_to_default)。</span><span class="sxs-lookup"><span data-stu-id="e73d3-178">See [Understand the Advantages and Disadvantages of Load Contexts](#load_contexts) and [Consider Switching to the Default Load Context](#switch_to_default).</span></span>  
  
 <span data-ttu-id="e73d3-179">如果希望使用 <xref:System.Reflection.Assembly.LoadWithPartialName%2A> 方法（因为此方法使程序集加载变得很轻松），请考虑在应用程序失败时提供用于标识缺失的程序集的错误消息，与自动使用程序集的未知版本（可能会导致不可预知的行为和安全漏洞）相比，这样做可能能够提供更好的用户体验。</span><span class="sxs-lookup"><span data-stu-id="e73d3-179">If you want to use the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method because it makes assembly loading easy, consider that having your application fail with an error message that identifies the missing assembly is likely to provide a better user experience than automatically using an unknown version of the assembly, which might cause unpredictable behavior and security holes.</span></span>  
  
<a name="avoid_loading_into_multiple_contexts"></a>
## <a name="avoid-loading-an-assembly-into-multiple-contexts"></a><span data-ttu-id="e73d3-180">避免将一个程序集加载到多个上下文中</span><span class="sxs-lookup"><span data-stu-id="e73d3-180">Avoid Loading an Assembly into Multiple Contexts</span></span>  
 <span data-ttu-id="e73d3-181">将一个程序集加载到多个上下文中会导致出现类型标识问题。</span><span class="sxs-lookup"><span data-stu-id="e73d3-181">Loading an assembly into multiple contexts can cause type identity problems.</span></span> <span data-ttu-id="e73d3-182">将同一个程序集中的相同类型加载到两个不同的上下文中，就像是加载具有相同名称的两个不同的类型一样。</span><span class="sxs-lookup"><span data-stu-id="e73d3-182">If the same type is loaded from the same assembly into two different contexts, it is as if two different types with the same name had been loaded.</span></span> <span data-ttu-id="e73d3-183">如果尝试将一个类型强制转换为另一个类型，则将引发 <xref:System.InvalidCastException>，并显示一条令人混淆的消息，指示不能将类型 `MyType` 强制转换为类型 `MyType`。</span><span class="sxs-lookup"><span data-stu-id="e73d3-183">An <xref:System.InvalidCastException> is thrown if you try to cast one type to the other, with the confusing message that type `MyType` cannot be cast to type `MyType`.</span></span>  
  
 <span data-ttu-id="e73d3-184">例如，假设在一个名为 `Utility` 的程序集中声明 `ICommunicate` 接口，该接口由程序及其加载的其他程序集引用。</span><span class="sxs-lookup"><span data-stu-id="e73d3-184">For example, suppose that the `ICommunicate` interface is declared in an assembly named `Utility`, which is referenced by your program and also by other assemblies that your program loads.</span></span> <span data-ttu-id="e73d3-185">这些其他程序集包含实现 `ICommunicate` 接口的类型，并允许程序使用它们。</span><span class="sxs-lookup"><span data-stu-id="e73d3-185">These other assemblies contain types that implement the `ICommunicate` interface, allowing your program to use them.</span></span>  
  
 <span data-ttu-id="e73d3-186">下面来看看在程序运行时会出现的情况。</span><span class="sxs-lookup"><span data-stu-id="e73d3-186">Now consider what happens when your program is run.</span></span> <span data-ttu-id="e73d3-187">程序所引用的程序集将加载到默认加载上下文中。</span><span class="sxs-lookup"><span data-stu-id="e73d3-187">Assemblies that are referenced by your program are loaded into the default load context.</span></span> <span data-ttu-id="e73d3-188">如果使用 <xref:System.Reflection.Assembly.Load%2A> 方法按照目标程序集的标识来加载该程序集，则该程序集及其依赖项都将位于默认加载上下文中。</span><span class="sxs-lookup"><span data-stu-id="e73d3-188">If you load a target assembly by its identity, using the <xref:System.Reflection.Assembly.Load%2A> method, it will be in the default load context, and so will its dependencies.</span></span> <span data-ttu-id="e73d3-189">程序和目标程序集将使用同一个 `Utility` 程序集。</span><span class="sxs-lookup"><span data-stu-id="e73d3-189">Both your program and the target assembly will use the same `Utility` assembly.</span></span>  
  
 <span data-ttu-id="e73d3-190">不过，假设使用 <xref:System.Reflection.Assembly.LoadFile%2A> 方法按照目标程序集的文件路径加载该程序集。</span><span class="sxs-lookup"><span data-stu-id="e73d3-190">However, suppose you load the target assembly by its file path, using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="e73d3-191">该程序集将在没有任何上下文的情况下进行加载，因此不会自动加载其依赖项。</span><span class="sxs-lookup"><span data-stu-id="e73d3-191">The assembly is loaded without any context, so its dependencies are not automatically loaded.</span></span> <span data-ttu-id="e73d3-192">可能具有 <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> 事件的处理程序来提供依赖项，并且该处理程序可能会使用 <xref:System.Reflection.Assembly.LoadFile%2A> 方法在没有上下文的情况下加载 `Utility` 程序集。</span><span class="sxs-lookup"><span data-stu-id="e73d3-192">You might have a handler for the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event to supply the dependency, and it might load the `Utility` assembly with no context by using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="e73d3-193">此时，若创建目标程序集中包含的某个类型的实例，并尝试将该实例分配给类型 `ICommunicate` 的变量，则将引发 <xref:System.InvalidCastException>，因为运行时会将 `Utility` 程序集的两个副本中的 `ICommunicate` 接口视为不同的类型。</span><span class="sxs-lookup"><span data-stu-id="e73d3-193">Now when you create an instance of a type that is contained in the target assembly and try to assign it to a variable of type `ICommunicate`, an <xref:System.InvalidCastException> is thrown because the runtime considers the `ICommunicate` interfaces in the two copies of the `Utility` assembly to be different types.</span></span>  
  
 <span data-ttu-id="e73d3-194">在许多其他情况下，也可以将一个程序集加载到多个上下文中。</span><span class="sxs-lookup"><span data-stu-id="e73d3-194">There are many other scenarios in which an assembly can be loaded into multiple contexts.</span></span> <span data-ttu-id="e73d3-195">最佳方法是通过在应用程序路径中重新定位目标程序集，并对 <xref:System.Reflection.Assembly.Load%2A> 方法使用完整的显示名称，从而避免冲突。</span><span class="sxs-lookup"><span data-stu-id="e73d3-195">The best approach is to avoid conflicts by relocating the target assembly in your application path and using the <xref:System.Reflection.Assembly.Load%2A> method with the full display name.</span></span> <span data-ttu-id="e73d3-196">然后，将目标程序集加载到默认加载上下文中，并且两个程序集将使用同一个 `Utility` 程序集。</span><span class="sxs-lookup"><span data-stu-id="e73d3-196">The assembly is then loaded into the default load context, and both assemblies use the same `Utility` assembly.</span></span>  
  
 <span data-ttu-id="e73d3-197">如果目标程序集必须保留在应用程序路径的外部，可以使用 <xref:System.Reflection.Assembly.LoadFrom%2A> 方法将目标程序集加载到加载位置上下文中。</span><span class="sxs-lookup"><span data-stu-id="e73d3-197">If the target assembly must remain outside your application path, you can use the <xref:System.Reflection.Assembly.LoadFrom%2A> method to load it into the load-from context.</span></span> <span data-ttu-id="e73d3-198">如果编译的目标程序集中存在对应用程序的 `Utility` 程序集的引用，则目标程序集将会使用应用程序已加载到默认加载上下文中的 `Utility` 程序集。</span><span class="sxs-lookup"><span data-stu-id="e73d3-198">If the target assembly was compiled with a reference to your application's `Utility` assembly, it will use the `Utility` assembly that your application has loaded into the default load context.</span></span> <span data-ttu-id="e73d3-199">请注意，如果目标程序集依赖应用程序路径外部的 `Utility` 程序集副本，则会出现问题。</span><span class="sxs-lookup"><span data-stu-id="e73d3-199">Note that problems can occur if the target assembly has a dependency on a copy of the `Utility` assembly located outside your application path.</span></span> <span data-ttu-id="e73d3-200">如果在应用程序加载 `Utility` 程序集之前已将该程序集加载到加载位置上下文中，则应用程序的加载将失败。</span><span class="sxs-lookup"><span data-stu-id="e73d3-200">If that assembly is loaded into the load-from context before your application loads the `Utility` assembly, your application's load will fail.</span></span>  
  
 <span data-ttu-id="e73d3-201">[考虑切换到默认加载上下文](#switch_to_default)一节讨论了针对使用文件路径加载（例如 <xref:System.Reflection.Assembly.LoadFile%2A> 和 <xref:System.Reflection.Assembly.LoadFrom%2A>）的替代方法。</span><span class="sxs-lookup"><span data-stu-id="e73d3-201">The [Consider Switching to the Default Load Context](#switch_to_default) section discusses alternatives to using file path loads such as <xref:System.Reflection.Assembly.LoadFile%2A> and <xref:System.Reflection.Assembly.LoadFrom%2A>.</span></span>  
  
<a name="avoid_loading_multiple_versions"></a>
## <a name="avoid-loading-multiple-versions-of-an-assembly-into-the-same-context"></a><span data-ttu-id="e73d3-202">避免将一个程序集的多个版本加载到同一上下文中</span><span class="sxs-lookup"><span data-stu-id="e73d3-202">Avoid Loading Multiple Versions of an Assembly into the Same Context</span></span>  
 <span data-ttu-id="e73d3-203">将一个程序集的多个版本加载到一个加载上下文中会导致出现类型标识问题。</span><span class="sxs-lookup"><span data-stu-id="e73d3-203">Loading multiple versions of an assembly into one load context can cause type identity problems.</span></span> <span data-ttu-id="e73d3-204">从同一个程序集的两个版本加载同一个类型，就像是加载了具有相同名称的两个不同类型一样。</span><span class="sxs-lookup"><span data-stu-id="e73d3-204">If the same type is loaded from two versions of the same assembly, it is as if two different types with the same name had been loaded.</span></span> <span data-ttu-id="e73d3-205">如果尝试将一个类型强制转换为另一个类型，则将引发 <xref:System.InvalidCastException>，并显示一条令人混淆的消息，指示不能将类型 `MyType` 强制转换为类型 `MyType`。</span><span class="sxs-lookup"><span data-stu-id="e73d3-205">An <xref:System.InvalidCastException> is thrown if you try to cast one type to the other, with the confusing message that type `MyType` cannot be cast to type `MyType`.</span></span>  
  
 <span data-ttu-id="e73d3-206">例如，程序可能会直接加载 `Utility` 程序集的一个版本，稍后它可能会加载另一个程序集，而该程序集将加载 `Utility` 程序集的一个不同的版本。</span><span class="sxs-lookup"><span data-stu-id="e73d3-206">For example, your program might load one version of the `Utility` assembly directly, and later it might load another assembly that loads a different version of the `Utility` assembly.</span></span> <span data-ttu-id="e73d3-207">或者，编码错误可能会导致应用程序中两个不同的代码路径加载一个程序集的不同版本。</span><span class="sxs-lookup"><span data-stu-id="e73d3-207">Or a coding error might cause two different code paths in your application to load different versions of an assembly.</span></span>  
  
 <span data-ttu-id="e73d3-208">在默认加载上下文中，如果使用 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 方法并指定包含不同版本号的完整程序集显示名称，则会出现此问题。</span><span class="sxs-lookup"><span data-stu-id="e73d3-208">In the default load context, this problem can occur when you use the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and specify complete assembly display names that include different version numbers.</span></span> <span data-ttu-id="e73d3-209">对于在没有上下文的情况下加载的程序集来说，若使用 <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> 方法从不同的路径加载同一程序集，则会出现此问题。</span><span class="sxs-lookup"><span data-stu-id="e73d3-209">For assemblies that are loaded without context, the problem can be caused by using the <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> method to load the same assembly from different paths.</span></span> <span data-ttu-id="e73d3-210">运行时会将从不同的路径加载的两个程序集视为不同的程序集，即使这两个程序集的标识相同也是如此。</span><span class="sxs-lookup"><span data-stu-id="e73d3-210">The runtime considers two assemblies that are loaded from different paths to be different assemblies, even if their identities are the same.</span></span>  
  
 <span data-ttu-id="e73d3-211">除了类型标识问题之外，如果将从程序集的一个版本加载的类型传递给需要来自不同版本的类型的代码，则多个程序集版本还会导致 <xref:System.MissingMethodException>。</span><span class="sxs-lookup"><span data-stu-id="e73d3-211">In addition to type identity problems, multiple versions of an assembly can cause a <xref:System.MissingMethodException> if a type that is loaded from one version of the assembly is passed to code that expects that type from a different version.</span></span> <span data-ttu-id="e73d3-212">例如，此代码可能需要已添加到更高版本的方法。</span><span class="sxs-lookup"><span data-stu-id="e73d3-212">For example, the code might expect a method that was added to the later version.</span></span>  
  
 <span data-ttu-id="e73d3-213">如果版本之间的类型行为发生更改，则会出现更多的细微错误。</span><span class="sxs-lookup"><span data-stu-id="e73d3-213">More subtle errors can occur if the behavior of the type changed between versions.</span></span> <span data-ttu-id="e73d3-214">例如，某个方法可能会引发意外的异常或返回意外的值。</span><span class="sxs-lookup"><span data-stu-id="e73d3-214">For example, a method might throw an unexpected exception or return an unexpected value.</span></span>  
  
 <span data-ttu-id="e73d3-215">请认真检查代码，确保仅加载程序集的一个版本。</span><span class="sxs-lookup"><span data-stu-id="e73d3-215">Carefully review your code to ensure that only one version of an assembly is loaded.</span></span> <span data-ttu-id="e73d3-216">可以使用 <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> 方法确定在任何给定时间加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="e73d3-216">You can use the <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> method to determine which assemblies are loaded at any given time.</span></span>  
  
<a name="switch_to_default"></a>
## <a name="consider-switching-to-the-default-load-context"></a><span data-ttu-id="e73d3-217">考虑切换到默认加载上下文</span><span class="sxs-lookup"><span data-stu-id="e73d3-217">Consider Switching to the Default Load Context</span></span>  
 <span data-ttu-id="e73d3-218">检查应用程序的程序集加载和部署模式。</span><span class="sxs-lookup"><span data-stu-id="e73d3-218">Examine your application's assembly loading and deployment patterns.</span></span> <span data-ttu-id="e73d3-219">是否能够消除从字节数组加载的程序集？</span><span class="sxs-lookup"><span data-stu-id="e73d3-219">Can you eliminate assemblies that are loaded from byte arrays?</span></span> <span data-ttu-id="e73d3-220">是否能够将程序集移动到探测路径中？</span><span class="sxs-lookup"><span data-stu-id="e73d3-220">Can you move assemblies into the probing path?</span></span> <span data-ttu-id="e73d3-221">如果程序集位于全局程序集缓存中或应用程序域的探测路径（即 <xref:System.AppDomainSetup.ApplicationBase%2A> 和 <xref:System.AppDomainSetup.PrivateBinPath%2A>）中，则可以按照程序集的标识来加载程序集。</span><span class="sxs-lookup"><span data-stu-id="e73d3-221">If assemblies are located in the global assembly cache or in the application domain's probing path (that is, its <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A>), you can load the assembly by its identity.</span></span>  
  
 <span data-ttu-id="e73d3-222">如果无法将所有程序集放入探测路径中，请考虑替代方式，例如使用 .NET Framework 外接程序模型，将程序集放置到全局程序集缓存中或创建应用程序域。</span><span class="sxs-lookup"><span data-stu-id="e73d3-222">If it is not possible to put all your assemblies in the probing path, consider alternatives such as using the .NET Framework add-in model, placing assemblies into the global assembly cache, or creating application domains.</span></span>  
  
### <a name="consider-using-the-net-framework-add-in-model"></a><span data-ttu-id="e73d3-223">考虑使用 .NET Framework 外接程序模型</span><span class="sxs-lookup"><span data-stu-id="e73d3-223">Consider Using the .NET Framework Add-In Model</span></span>  
 <span data-ttu-id="e73d3-224">如果使用加载位置上下文来实现外接程序（它们通常未安装在应用程序基中），请使用 .NET Framework 外接程序模型。</span><span class="sxs-lookup"><span data-stu-id="e73d3-224">If you are using the load-from context to implement add-ins, which typically are not installed in the application base, use the .NET Framework add-in model.</span></span> <span data-ttu-id="e73d3-225">此模型提供应用程序域或进程级别的隔离，无需自行管理应用程序域。</span><span class="sxs-lookup"><span data-stu-id="e73d3-225">This model provides isolation at the application domain or process level, without requiring you to manage application domains yourself.</span></span> <span data-ttu-id="e73d3-226">有关外接程序模型的信息，请参阅[外接程序和扩展性](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))。</span><span class="sxs-lookup"><span data-stu-id="e73d3-226">For information about the add-in model, see [Add-ins and Extensibility](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).</span></span>  
  
### <a name="consider-using-the-global-assembly-cache"></a><span data-ttu-id="e73d3-227">考虑使用全局程序集缓存</span><span class="sxs-lookup"><span data-stu-id="e73d3-227">Consider Using the Global Assembly Cache</span></span>  
 <span data-ttu-id="e73d3-228">将程序集置于全局程序集缓存中，不但可以获得位于应用程序基外部的共享程序集路径的好处，而且不会丧失默认加载上下文的优点，也不会承袭其他上下文的缺点。</span><span class="sxs-lookup"><span data-stu-id="e73d3-228">Place assemblies in the global assembly cache to get the benefit of a shared assembly path that is outside the application base, without losing the advantages of the default load context or taking on the disadvantages of the other contexts.</span></span>  
  
### <a name="consider-using-application-domains"></a><span data-ttu-id="e73d3-229">考虑使用应用程序域</span><span class="sxs-lookup"><span data-stu-id="e73d3-229">Consider Using Application Domains</span></span>  
 <span data-ttu-id="e73d3-230">如果确定无法在应用程序的探测路径中部署某些程序集，请考虑为这些程序集创建新的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="e73d3-230">If you determine that some of your assemblies cannot be deployed in the application's probing path, consider creating a new application domain for those assemblies.</span></span> <span data-ttu-id="e73d3-231">使用 <xref:System.AppDomainSetup> 可创建新的应用程序域，而使用 <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> 属性可指定包含要加载的程序集的路径。</span><span class="sxs-lookup"><span data-stu-id="e73d3-231">Use an <xref:System.AppDomainSetup> to create the new application domain, and use the <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> property to specify the path that contains the assemblies you want to load.</span></span> <span data-ttu-id="e73d3-232">如果要探测多个目录，则可以将 <xref:System.AppDomainSetup.ApplicationBase%2A> 设置为根目录，并使用 <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> 属性标识要探测的子目录。</span><span class="sxs-lookup"><span data-stu-id="e73d3-232">If you have multiple directories to probe, you can set the <xref:System.AppDomainSetup.ApplicationBase%2A> to a root directory and use the <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> property to identify the subdirectories to probe.</span></span> <span data-ttu-id="e73d3-233">或者，可以创建多个应用程序域，并将每个应用程序域的 <xref:System.AppDomainSetup.ApplicationBase%2A> 设置为其程序集的相应路径。</span><span class="sxs-lookup"><span data-stu-id="e73d3-233">Alternatively, you can create multiple application domains and set the <xref:System.AppDomainSetup.ApplicationBase%2A> of each application domain to the appropriate path for its assemblies.</span></span>  
  
 <span data-ttu-id="e73d3-234">请注意，可以使用 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> 方法加载这些程序集。</span><span class="sxs-lookup"><span data-stu-id="e73d3-234">Note that you can use the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method to load these assemblies.</span></span> <span data-ttu-id="e73d3-235">由于这些程序集此时位于探测路径中，因此会将它们加载到默认加载上下文（而非加载位置上下文）中。</span><span class="sxs-lookup"><span data-stu-id="e73d3-235">Because they are now in the probing path, they will be loaded into the default load context instead of the load-from context.</span></span> <span data-ttu-id="e73d3-236">不过，建议切换到 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> 方法并提供完整的程序集显示名称，从而确保始终使用正确的版本。</span><span class="sxs-lookup"><span data-stu-id="e73d3-236">However, we recommend that you switch to the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and supply full assembly display names to ensure that correct versions are always used.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e73d3-237">请参阅</span><span class="sxs-lookup"><span data-stu-id="e73d3-237">See also</span></span>

- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType>
- <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>
