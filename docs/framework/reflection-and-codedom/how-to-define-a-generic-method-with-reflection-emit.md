---
title: 如何：用反射发出定义泛型方法
description: 使用反射发出定义泛型方法。 一个示例创建具有两个类型参数的泛型方法。 第二个示例演示如何发出方法主体。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- generics [.NET Framework], reflection emit
- reflection emit, generic methods
- generics [.NET Framework], dynamic types
ms.assetid: 93892fa4-90b3-4ec4-b147-4bec9880de2b
ms.openlocfilehash: 3b85fb480e5862daa3b2800f75392adbe92348f2
ms.sourcegitcommit: 3d84eac0818099c9949035feb96bbe0346358504
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/21/2020
ms.locfileid: "86865133"
---
# <a name="how-to-define-a-generic-method-with-reflection-emit"></a><span data-ttu-id="38948-105">如何：用反射发出定义泛型方法</span><span class="sxs-lookup"><span data-stu-id="38948-105">How to: Define a Generic Method with Reflection Emit</span></span>

<span data-ttu-id="38948-106">第一个过程演示如何使用两个类型参数创建简单的泛型方法，以及如何将类约束、接口约束和特殊约束应用于类型参数。</span><span class="sxs-lookup"><span data-stu-id="38948-106">The first procedure shows how to create a simple generic method with two type parameters, and how to apply class constraints, interface constraints, and special constraints to the type parameters.</span></span>

<span data-ttu-id="38948-107">第二个过程演示如何发出方法主体，以及如何使用泛型方法的类型参数创建泛型类型的实例和调用其方法。</span><span class="sxs-lookup"><span data-stu-id="38948-107">The second procedure shows how to emit the method body, and how to use the type parameters of the generic method to create instances of generic types and to call their methods.</span></span>

<span data-ttu-id="38948-108">第三个过程演示如何调用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="38948-108">The third procedure shows how to invoke the generic method.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="38948-109">某方法只要属于泛型类型，且使用该类型的类型参数，就不是泛型方法。</span><span class="sxs-lookup"><span data-stu-id="38948-109">A method is not generic just because it belongs to a generic type and uses the type parameters of that type.</span></span> <span data-ttu-id="38948-110">只有当方法有属于自己的类型参数列表时才是泛型方法。</span><span class="sxs-lookup"><span data-stu-id="38948-110">A method is generic only if it has its own type parameter list.</span></span> <span data-ttu-id="38948-111">泛型方法可在非泛型类型上出现，如本示例中所示。</span><span class="sxs-lookup"><span data-stu-id="38948-111">A generic method can appear on a nongeneric type, as in this example.</span></span> <span data-ttu-id="38948-112">有关泛型类型上的非泛型方法示例，请参阅[如何：使用反射发出定义泛型类型](how-to-define-a-generic-type-with-reflection-emit.md)。</span><span class="sxs-lookup"><span data-stu-id="38948-112">For an example of a nongeneric method on a generic type, see [How to: Define a Generic Type with Reflection Emit](how-to-define-a-generic-type-with-reflection-emit.md).</span></span>

### <a name="to-define-a-generic-method"></a><span data-ttu-id="38948-113">定义泛型方法</span><span class="sxs-lookup"><span data-stu-id="38948-113">To define a generic method</span></span>

1. <span data-ttu-id="38948-114">开始前，最好先研究下在使用高级语言编写时泛型方法的出现方式。</span><span class="sxs-lookup"><span data-stu-id="38948-114">Before beginning, it is useful to look at how the generic method appears when written using a high-level language.</span></span> <span data-ttu-id="38948-115">以下代码与调用泛型方法的代码一起包含在此主题的示例代码中。</span><span class="sxs-lookup"><span data-stu-id="38948-115">The following code is included in the example code for this topic, along with code to call the generic method.</span></span> <span data-ttu-id="38948-116">该方法具有两个类型参数：`TInput` 和 `TOutput`。其中第二个参数必须具备以下条件：是引用类型 (`class`)；具有无参数构造函数 (`new`)；实现 `ICollection(Of TInput)`（在 C# 中为 `ICollection<TInput>`）。</span><span class="sxs-lookup"><span data-stu-id="38948-116">The method has two type parameters, `TInput` and `TOutput`, the second of which must be a reference type (`class`), must have a parameterless constructor (`new`), and must implement `ICollection(Of TInput)` (`ICollection<TInput>` in C#).</span></span> <span data-ttu-id="38948-117">此接口约束确保可使用 <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> 方法将元素添加到该方法创建的 `TOutput` 集合。</span><span class="sxs-lookup"><span data-stu-id="38948-117">This interface constraint ensures that the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> method can be used to add elements to the `TOutput` collection that the method creates.</span></span> <span data-ttu-id="38948-118">该方法具有一个形参 `input`，它是 `TInput` 的数组。</span><span class="sxs-lookup"><span data-stu-id="38948-118">The method has one formal parameter, `input`, which is an array of `TInput`.</span></span> <span data-ttu-id="38948-119">该方法将创建一个 `TOutput` 类型的集合，并将 `input` 的元素复制到该集合。</span><span class="sxs-lookup"><span data-stu-id="38948-119">The method creates a collection of type `TOutput` and copies the elements of `input` to the collection.</span></span>

    [!code-csharp[GenericMethodHowTo#20](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#20)]
    [!code-vb[GenericMethodHowTo#20](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#20)]

2. <span data-ttu-id="38948-120">定义动态程序集和动态模块，以包含泛型方法所属类型。</span><span class="sxs-lookup"><span data-stu-id="38948-120">Define a dynamic assembly and a dynamic module to contain the type the generic method belongs to.</span></span> <span data-ttu-id="38948-121">在这种情况下，程序集仅有一个模块 `DemoMethodBuilder1`，模块名称为该程序集名称加上扩展名。</span><span class="sxs-lookup"><span data-stu-id="38948-121">In this case, the assembly has only one module, named `DemoMethodBuilder1`, and the module name is the same as the assembly name plus an extension.</span></span> <span data-ttu-id="38948-122">在此示例中，因为要将程序集保存在磁盘并执行，所以指定了 <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="38948-122">In this example, the assembly is saved to disk and also executed, so <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> is specified.</span></span> <span data-ttu-id="38948-123">可以使用 [Ildasm.exe（IL 反汇编程序）](../tools/ildasm-exe-il-disassembler.md)检查 DemoMethodBuilder1.dll，并将其与步骤 1 中所示方法的 Microsoft 中间语言 (MSIL) 比较。</span><span class="sxs-lookup"><span data-stu-id="38948-123">You can use the [Ildasm.exe (IL Disassembler)](../tools/ildasm-exe-il-disassembler.md) to examine DemoMethodBuilder1.dll and to compare it to the Microsoft intermediate language (MSIL) for the method shown in step 1.</span></span>

    [!code-csharp[GenericMethodHowTo#2](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#2)]
    [!code-vb[GenericMethodHowTo#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#2)]

3. <span data-ttu-id="38948-124">定义泛型方法所属类型。</span><span class="sxs-lookup"><span data-stu-id="38948-124">Define the type the generic method belongs to.</span></span> <span data-ttu-id="38948-125">该类型不一定是泛型类型。</span><span class="sxs-lookup"><span data-stu-id="38948-125">The type does not have to be generic.</span></span> <span data-ttu-id="38948-126">泛型方法可以属于泛型或非泛型类型。</span><span class="sxs-lookup"><span data-stu-id="38948-126">A generic method can belong to either a generic or nongeneric type.</span></span> <span data-ttu-id="38948-127">在此示例中，类型是一个名为 `DemoType` 类，不是泛型类型。</span><span class="sxs-lookup"><span data-stu-id="38948-127">In this example, the type is a class, is not generic, and is named `DemoType`.</span></span>

    [!code-csharp[GenericMethodHowTo#3](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#3)]
    [!code-vb[GenericMethodHowTo#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#3)]

4. <span data-ttu-id="38948-128">定义泛型方法。</span><span class="sxs-lookup"><span data-stu-id="38948-128">Define the generic method.</span></span> <span data-ttu-id="38948-129">如果泛型方法的泛型类型参数指定了泛型方法的形参类型，则使用 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> 方法重载来定义该方法。</span><span class="sxs-lookup"><span data-stu-id="38948-129">If the types of a generic method's formal parameters are specified by generic type parameters of the generic method, use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> method overload to define the method.</span></span> <span data-ttu-id="38948-130">由于尚未定义该方法的泛型类型参数，因此不能在对 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A> 的调用中指定方法的形参类型。</span><span class="sxs-lookup"><span data-stu-id="38948-130">The generic type parameters of the method are not yet defined, so you cannot specify the types of the method's formal parameters in the call to <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A>.</span></span> <span data-ttu-id="38948-131">在此示例中，该方法名为 `Factory`。</span><span class="sxs-lookup"><span data-stu-id="38948-131">In this example, the method is named `Factory`.</span></span> <span data-ttu-id="38948-132">该方法是 public 和 `static` 方法（在 Visual Basic 中是 `Shared` 方法）。</span><span class="sxs-lookup"><span data-stu-id="38948-132">The method is public and `static` (`Shared` in Visual Basic).</span></span>

    [!code-csharp[GenericMethodHowTo#4](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#4)]
    [!code-vb[GenericMethodHowTo#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#4)]

5. <span data-ttu-id="38948-133">通过将包含参数名称的字符串数组传递给 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> 方法来定义 `DemoMethod` 的泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="38948-133">Define the generic type parameters of `DemoMethod` by passing an array of strings containing the names of the parameters to the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="38948-134">这使该方法成为泛型方法。</span><span class="sxs-lookup"><span data-stu-id="38948-134">This makes the method a generic method.</span></span> <span data-ttu-id="38948-135">以下代码可以将 `Factory` 变为具有类型参数 `TInput` 和 `TOutput` 的泛型方法。</span><span class="sxs-lookup"><span data-stu-id="38948-135">The following code makes `Factory` a generic method with type parameters `TInput` and `TOutput`.</span></span> <span data-ttu-id="38948-136">为了更加方便阅读代码，采用以上名称创建变量，以保留表示这两个类型参数的 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 对象。</span><span class="sxs-lookup"><span data-stu-id="38948-136">To make the code easier to read, variables with these names are created to hold the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objects representing the two type parameters.</span></span>

    [!code-csharp[GenericMethodHowTo#5](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#5)]
    [!code-vb[GenericMethodHowTo#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#5)]

6. <span data-ttu-id="38948-137">可以选择向类型参数添加特殊约束。</span><span class="sxs-lookup"><span data-stu-id="38948-137">Optionally add special constraints to the type parameters.</span></span> <span data-ttu-id="38948-138">使用 <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> 方法添加特殊约束。</span><span class="sxs-lookup"><span data-stu-id="38948-138">Special constraints are added using the <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> method.</span></span> <span data-ttu-id="38948-139">在此示例中，约束 `TOutput` 作为引用类型并且具有无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="38948-139">In this example, `TOutput` is constrained to be a reference type and to have a parameterless constructor.</span></span>

    [!code-csharp[GenericMethodHowTo#6](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#6)]
    [!code-vb[GenericMethodHowTo#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#6)]

7. <span data-ttu-id="38948-140">可以选择向类型参数添加类约束和接口约束。</span><span class="sxs-lookup"><span data-stu-id="38948-140">Optionally add class and interface constraints to the type parameters.</span></span> <span data-ttu-id="38948-141">在此示例中，约束类型参数 `TOutput` 为实现 `ICollection(Of TInput)`（C# 中为 `ICollection<TInput>`）接口的类型。</span><span class="sxs-lookup"><span data-stu-id="38948-141">In this example, type parameter `TOutput` is constrained to types that implement the `ICollection(Of TInput)` (`ICollection<TInput>` in C#) interface.</span></span> <span data-ttu-id="38948-142">这样确保了可以使用 <xref:System.Collections.Generic.ICollection%601.Add%2A> 方法来添加元素。</span><span class="sxs-lookup"><span data-stu-id="38948-142">This ensures that the <xref:System.Collections.Generic.ICollection%601.Add%2A> method can be used to add elements.</span></span>

    [!code-csharp[GenericMethodHowTo#7](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#7)]
    [!code-vb[GenericMethodHowTo#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#7)]

8. <span data-ttu-id="38948-143">使用 <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> 方法定义方法的形参。</span><span class="sxs-lookup"><span data-stu-id="38948-143">Define the formal parameters of the method, using the <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> method.</span></span> <span data-ttu-id="38948-144">在此示例中，`Factory` 方法具有一个参数，它是 `TInput` 的数组。</span><span class="sxs-lookup"><span data-stu-id="38948-144">In this example, the `Factory` method has one parameter, an array of `TInput`.</span></span> <span data-ttu-id="38948-145">通过调用表示 `TInput` 的 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 上的 <xref:System.Type.MakeArrayType%2A> 方法创建此类型。</span><span class="sxs-lookup"><span data-stu-id="38948-145">This type is created by calling the <xref:System.Type.MakeArrayType%2A> method on the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> that represents `TInput`.</span></span> <span data-ttu-id="38948-146"><xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> 的参数是 <xref:System.Type> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="38948-146">The argument of <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> is an array of <xref:System.Type> objects.</span></span>

    [!code-csharp[GenericMethodHowTo#8](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#8)]
    [!code-vb[GenericMethodHowTo#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#8)]

9. <span data-ttu-id="38948-147">使用 <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> 方法定义该方法的返回类型。</span><span class="sxs-lookup"><span data-stu-id="38948-147">Define the return type for the method, using the <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> method.</span></span> <span data-ttu-id="38948-148">在此示例中，将返回 `TOutput` 的实例。</span><span class="sxs-lookup"><span data-stu-id="38948-148">In this example, an instance of `TOutput` is returned.</span></span>

    [!code-csharp[GenericMethodHowTo#9](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#9)]
    [!code-vb[GenericMethodHowTo#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#9)]

10. <span data-ttu-id="38948-149">使用 <xref:System.Reflection.Emit.ILGenerator> 发出方法主体。</span><span class="sxs-lookup"><span data-stu-id="38948-149">Emit the method body, using <xref:System.Reflection.Emit.ILGenerator>.</span></span> <span data-ttu-id="38948-150">有关详细信息，请参阅附带的用于发出方法体的过程。</span><span class="sxs-lookup"><span data-stu-id="38948-150">For details, see the accompanying procedure for emitting the method body.</span></span>

    > [!IMPORTANT]
    > <span data-ttu-id="38948-151">如果发出对泛型类型方法的调用，并且这些类型的类型参数是泛型方法的类型参数，则必须使用 <xref:System.Reflection.Emit.TypeBuilder> 类的 `static`<xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29>、<xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29> 和 <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29> 方法重载来获取方法的构造窗体。</span><span class="sxs-lookup"><span data-stu-id="38948-151">When you emit calls to methods of generic types, and the type arguments of those types are type parameters of the generic method, you must use the `static`<xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, and <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29> method overloads of the <xref:System.Reflection.Emit.TypeBuilder> class to obtain constructed forms of the methods.</span></span> <span data-ttu-id="38948-152">发出方法主体的附带过程提供了相关演示。</span><span class="sxs-lookup"><span data-stu-id="38948-152">The accompanying procedure for emitting the method body demonstrates this.</span></span>

11. <span data-ttu-id="38948-153">完成包含该方法的类型，并保存程序集。</span><span class="sxs-lookup"><span data-stu-id="38948-153">Complete the type that contains the method and save the assembly.</span></span> <span data-ttu-id="38948-154">附带的泛型方法调用过程演示了调用完整方法的两种方式。</span><span class="sxs-lookup"><span data-stu-id="38948-154">The accompanying procedure for invoking the generic method shows two ways to invoke the completed method.</span></span>

    [!code-csharp[GenericMethodHowTo#14](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#14)]
    [!code-vb[GenericMethodHowTo#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#14)]

<a name="procedureSection1"></a>

### <a name="to-emit-the-method-body"></a><span data-ttu-id="38948-155">发出方法主体</span><span class="sxs-lookup"><span data-stu-id="38948-155">To emit the method body</span></span>

1. <span data-ttu-id="38948-156">获取代码生成器，并声明局部变量和标签。</span><span class="sxs-lookup"><span data-stu-id="38948-156">Get a code generator and declare local variables and labels.</span></span> <span data-ttu-id="38948-157"><xref:System.Reflection.Emit.ILGenerator.DeclareLocal%2A> 方法用于声明局部变量。</span><span class="sxs-lookup"><span data-stu-id="38948-157">The <xref:System.Reflection.Emit.ILGenerator.DeclareLocal%2A> method is used to declare local variables.</span></span> <span data-ttu-id="38948-158">`Factory` 方法具有四个局部变量：`retVal`，用于保留该方法返回的新 `TOutput`；`ic`，用于在 `TOutput` 强制转换成 `ICollection(Of TInput)`（在 C# 中为 `ICollection<TInput>`） 时进行保留；`input`，用于保留 `TInput` 对象的输入数组；`index`，用于循环访问数组。</span><span class="sxs-lookup"><span data-stu-id="38948-158">The `Factory` method has four local variables: `retVal` to hold the new `TOutput` that is returned by the method, `ic` to hold the `TOutput` when it is cast to `ICollection(Of TInput)` (`ICollection<TInput>` in C#), `input` to hold the input array of `TInput` objects, and `index` to iterate through the array.</span></span> <span data-ttu-id="38948-159">该方法还具有两个标签，一个用于进入循环 (`enterLoop`)，另一个用于循环的顶部 (`loopAgain`)，这两个标签均使用 <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> 方法定义。</span><span class="sxs-lookup"><span data-stu-id="38948-159">The method also has two labels, one to enter the loop (`enterLoop`) and one for the top of the loop (`loopAgain`), defined using the <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> method.</span></span>

    <span data-ttu-id="38948-160">该方法执行的第一个操作是使用 <xref:System.Reflection.Emit.OpCodes.Ldarg_0> 操作码加载其参数，并使用 <xref:System.Reflection.Emit.OpCodes.Stloc_S> 操作码将参数存储到局部变量 `input`。</span><span class="sxs-lookup"><span data-stu-id="38948-160">The first thing the method does is to load its argument using <xref:System.Reflection.Emit.OpCodes.Ldarg_0> opcode and to store it in the local variable `input` using <xref:System.Reflection.Emit.OpCodes.Stloc_S> opcode.</span></span>

    [!code-csharp[GenericMethodHowTo#10](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#10)]
    [!code-vb[GenericMethodHowTo#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#10)]

2. <span data-ttu-id="38948-161">使用 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 方法的泛型方法重载，发出代码，创建 `TOutput` 的实例。</span><span class="sxs-lookup"><span data-stu-id="38948-161">Emit code to create an instance of `TOutput`, using the generic method overload of the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="38948-162">使用此重载要求指定的类型具有无参数构造函数，因此需向 `TOutput` 添加该约束。</span><span class="sxs-lookup"><span data-stu-id="38948-162">Using this overload requires the specified type to have a parameterless constructor, which is the reason for adding that constraint to `TOutput`.</span></span> <span data-ttu-id="38948-163">通过将 `TOutput` 传递到 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> 来创建构造泛型方法。</span><span class="sxs-lookup"><span data-stu-id="38948-163">Create the constructed generic method by passing `TOutput` to <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>.</span></span> <span data-ttu-id="38948-164">发出代码调用方法后，使用 <xref:System.Reflection.Emit.OpCodes.Stloc_S> 发出代码，将其存储在局部变量 `retVal`</span><span class="sxs-lookup"><span data-stu-id="38948-164">After emitting code to call the method, emit code to store it in the local variable `retVal` using <xref:System.Reflection.Emit.OpCodes.Stloc_S></span></span>

    [!code-csharp[GenericMethodHowTo#11](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#11)]
    [!code-vb[GenericMethodHowTo#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#11)]

3. <span data-ttu-id="38948-165">发出代码，将新的 `TOutput` 对象强制转换为 `ICollection(Of TInput)`，并将其存储在局部变量 `ic`。</span><span class="sxs-lookup"><span data-stu-id="38948-165">Emit code to cast the new `TOutput` object to `ICollection(Of TInput)` and store it in the local variable `ic`.</span></span>

    [!code-csharp[GenericMethodHowTo#31](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#31)]
    [!code-vb[GenericMethodHowTo#31](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#31)]

4. <span data-ttu-id="38948-166">获取表示 <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> 方法的 <xref:System.Reflection.MethodInfo>。</span><span class="sxs-lookup"><span data-stu-id="38948-166">Get a <xref:System.Reflection.MethodInfo> representing the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="38948-167">此方法作用于 `ICollection(Of TInput)`（在 C# 中为 `ICollection<TInput>`），因此必须获取特定于该构造类型的 `Add` 方法。</span><span class="sxs-lookup"><span data-stu-id="38948-167">The method is acting on an `ICollection(Of TInput)` (`ICollection<TInput>` in C#), so it is necessary to get the `Add` method specific to that constructed type.</span></span> <span data-ttu-id="38948-168">不能使用 <xref:System.Type.GetMethod%2A> 方法直接从 `icollOfTInput` 获取 <xref:System.Reflection.MethodInfo>，因为 <xref:System.Type.GetMethod%2A> 在已使用 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 构造的类型上不受支持。</span><span class="sxs-lookup"><span data-stu-id="38948-168">You cannot use the <xref:System.Type.GetMethod%2A> method to get this <xref:System.Reflection.MethodInfo> directly from `icollOfTInput`, because <xref:System.Type.GetMethod%2A> is not supported on a type that has been constructed with a <xref:System.Reflection.Emit.GenericTypeParameterBuilder>.</span></span> <span data-ttu-id="38948-169">而应该在包含 <xref:System.Collections.Generic.ICollection%601> 泛型接口的泛型类型定义的 `icoll` 上调用 <xref:System.Type.GetMethod%2A>。</span><span class="sxs-lookup"><span data-stu-id="38948-169">Instead, call <xref:System.Type.GetMethod%2A> on `icoll`, which contains the generic type definition for the <xref:System.Collections.Generic.ICollection%601> generic interface.</span></span> <span data-ttu-id="38948-170">然后，使用 <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>`static` 方法生成该构造类型的 <xref:System.Reflection.MethodInfo>。</span><span class="sxs-lookup"><span data-stu-id="38948-170">Then use the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>`static` method to produce the <xref:System.Reflection.MethodInfo> for the constructed type.</span></span> <span data-ttu-id="38948-171">下面的代码对此进行了演示。</span><span class="sxs-lookup"><span data-stu-id="38948-171">The following code demonstrates this.</span></span>

    [!code-csharp[GenericMethodHowTo#12](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#12)]
    [!code-vb[GenericMethodHowTo#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#12)]

5. <span data-ttu-id="38948-172">通过加载 32 位整数 0 并将其存储在变量中，发出代码，初始化 `index` 变量。</span><span class="sxs-lookup"><span data-stu-id="38948-172">Emit code to initialize the `index` variable, by loading a 32-bit integer 0 and storing it in the variable.</span></span> <span data-ttu-id="38948-173">发出代码，分支到标签 `enterLoop`。</span><span class="sxs-lookup"><span data-stu-id="38948-173">Emit code to branch to the label `enterLoop`.</span></span> <span data-ttu-id="38948-174">因为此标签位于循环内，所以尚未标记。</span><span class="sxs-lookup"><span data-stu-id="38948-174">This label has not yet been marked, because it is inside the loop.</span></span> <span data-ttu-id="38948-175">循环的代码在下一步发出。</span><span class="sxs-lookup"><span data-stu-id="38948-175">Code for the loop is emitted in the next step.</span></span>

    [!code-csharp[GenericMethodHowTo#32](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#32)]
    [!code-vb[GenericMethodHowTo#32](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#32)]

6. <span data-ttu-id="38948-176">发出该循环的代码。</span><span class="sxs-lookup"><span data-stu-id="38948-176">Emit code for the loop.</span></span> <span data-ttu-id="38948-177">第一步是通过 `loopAgain` 标签调用 <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>，标记循环的顶部。</span><span class="sxs-lookup"><span data-stu-id="38948-177">The first step is to mark the top of the loop, by calling <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> with the `loopAgain` label.</span></span> <span data-ttu-id="38948-178">使用该标签的分支语句现在将分支到代码中的这个点。</span><span class="sxs-lookup"><span data-stu-id="38948-178">Branch statements that use the label will now branch to this point in the code.</span></span> <span data-ttu-id="38948-179">下一步是将强制转换为 `ICollection(Of TInput)` 的 `TOutput` 对象推入堆栈。</span><span class="sxs-lookup"><span data-stu-id="38948-179">The next step is to push the `TOutput` object, cast to `ICollection(Of TInput)`, onto the stack.</span></span> <span data-ttu-id="38948-180">无需立即进行此操作，但需要在调用 `Add` 方法之前完成。</span><span class="sxs-lookup"><span data-stu-id="38948-180">It is not needed immediately, but needs to be in position for calling the `Add` method.</span></span> <span data-ttu-id="38948-181">接下来，依次将输入数组和包含该数组的当前索引的 `index` 变量推入堆栈。</span><span class="sxs-lookup"><span data-stu-id="38948-181">Next the input array is pushed onto the stack, then the `index` variable containing the current index into the array.</span></span> <span data-ttu-id="38948-182"><xref:System.Reflection.Emit.OpCodes.Ldelem> 操作码从堆栈中弹出该索引和数组，然后将索引数组元素推入堆栈。</span><span class="sxs-lookup"><span data-stu-id="38948-182">The <xref:System.Reflection.Emit.OpCodes.Ldelem> opcode pops the index and the array off the stack and pushes the indexed array element onto the stack.</span></span> <span data-ttu-id="38948-183">堆栈现已准备好调用 <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> 方法，该方法从堆栈中弹出集合和新元素，并将该元素添加到该集合中。</span><span class="sxs-lookup"><span data-stu-id="38948-183">The stack is now ready for the call to the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> method, which pops the collection and the new element off the stack and adds the element to the collection.</span></span>

    <span data-ttu-id="38948-184">循环中的其余代码会递增索引并测试以查看循环是否已完成：将索引和 32 位整数 1 压入堆栈并添加，将总和留在堆栈上；总和存储在 `index` 中。</span><span class="sxs-lookup"><span data-stu-id="38948-184">The rest of the code in the loop increments the index and tests to see whether the loop is finished: The index and a 32-bit integer 1 are pushed onto the stack and added, leaving the sum on the stack; the sum is stored in `index`.</span></span> <span data-ttu-id="38948-185">调用 <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>，将该点设置为循环的入口点。</span><span class="sxs-lookup"><span data-stu-id="38948-185"><xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> is called to set this point as the entry point for the loop.</span></span> <span data-ttu-id="38948-186">再次加载该索引。</span><span class="sxs-lookup"><span data-stu-id="38948-186">The index is loaded again.</span></span> <span data-ttu-id="38948-187">将输入数组推入堆栈，然后发出 <xref:System.Reflection.Emit.OpCodes.Ldlen>，获取其长度。</span><span class="sxs-lookup"><span data-stu-id="38948-187">The input array is pushed on the stack, and <xref:System.Reflection.Emit.OpCodes.Ldlen> is emitted to get its length.</span></span> <span data-ttu-id="38948-188">索引和长度现位于堆栈中，发出 <xref:System.Reflection.Emit.OpCodes.Clt> 对二者进行比较。</span><span class="sxs-lookup"><span data-stu-id="38948-188">The index and the length are now on the stack, and <xref:System.Reflection.Emit.OpCodes.Clt> is emitted to compare them.</span></span> <span data-ttu-id="38948-189">如果索引小于该长度，<xref:System.Reflection.Emit.OpCodes.Brtrue_S> 会从分支返回到循环的起始点。</span><span class="sxs-lookup"><span data-stu-id="38948-189">If the index is less than the length, <xref:System.Reflection.Emit.OpCodes.Brtrue_S> branches back to the beginning of the loop.</span></span>

    [!code-csharp[GenericMethodHowTo#13](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#13)]
    [!code-vb[GenericMethodHowTo#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#13)]

7. <span data-ttu-id="38948-190">发出代码，将 `TOutput` 对象推入堆栈，并从该方法返回。</span><span class="sxs-lookup"><span data-stu-id="38948-190">Emit code to push the `TOutput` object onto the stack and return from the method.</span></span> <span data-ttu-id="38948-191">局部变量 `retVal` 和 `ic` 均包含对新的 `TOutput` 的引用；`ic` 仅用于访问 <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="38948-191">The local variables `retVal` and `ic` both contain references to the new `TOutput`; `ic` is used only to access the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> method.</span></span>

    [!code-csharp[GenericMethodHowTo#33](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#33)]
    [!code-vb[GenericMethodHowTo#33](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#33)]

<a name="procedureSection2"></a>

### <a name="to-invoke-the-generic-method"></a><span data-ttu-id="38948-192">调用泛型方法</span><span class="sxs-lookup"><span data-stu-id="38948-192">To invoke the generic method</span></span>

1. <span data-ttu-id="38948-193">`Factory` 是泛型方法定义。</span><span class="sxs-lookup"><span data-stu-id="38948-193">`Factory` is a generic method definition.</span></span> <span data-ttu-id="38948-194">若要调用泛型方法，必须向其泛型类型参数分配类型。</span><span class="sxs-lookup"><span data-stu-id="38948-194">In order to invoke it, you must assign types to its generic type parameters.</span></span> <span data-ttu-id="38948-195">可使用 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> 方法完成此操作。</span><span class="sxs-lookup"><span data-stu-id="38948-195">Use the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method to do this.</span></span> <span data-ttu-id="38948-196">下面的代码通过为 `TInput` 指定 <xref:System.String> 并为 `TOutput` 指定 `List(Of String)`（在 C# 中为 `List<string>`）创建构造泛型方法，并显示该方法的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="38948-196">The following code creates a constructed generic method, specifying <xref:System.String> for `TInput` and `List(Of String)` (`List<string>` in C#) for `TOutput`, and displays a string representation of the method.</span></span>

    [!code-csharp[GenericMethodHowTo#21](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#21)]
    [!code-vb[GenericMethodHowTo#21](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#21)]

2. <span data-ttu-id="38948-197">若要以后期绑定的形式调用该方法，请使用 <xref:System.Reflection.MethodBase.Invoke%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="38948-197">To invoke the method late-bound, use the <xref:System.Reflection.MethodBase.Invoke%2A> method.</span></span> <span data-ttu-id="38948-198">以下代码可创建 <xref:System.Object> 的数组（其中包含的唯一元素为字符串数组），并将其作为泛型方法的参数列表传递。</span><span class="sxs-lookup"><span data-stu-id="38948-198">The following code creates an array of <xref:System.Object>, containing as its only element an array of strings, and passes it as the argument list for the generic method.</span></span> <span data-ttu-id="38948-199"><xref:System.Reflection.MethodBase.Invoke%2A> 的第一个参数是空引用，因为该方法为 `static`。</span><span class="sxs-lookup"><span data-stu-id="38948-199">The first parameter of <xref:System.Reflection.MethodBase.Invoke%2A> is a null reference because the method is `static`.</span></span> <span data-ttu-id="38948-200">将返回值强制转换为 `List(Of String)`，并显示它的第一个元素。</span><span class="sxs-lookup"><span data-stu-id="38948-200">The return value is cast to `List(Of String)`, and its first element is displayed.</span></span>

    [!code-csharp[GenericMethodHowTo#22](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#22)]
    [!code-vb[GenericMethodHowTo#22](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#22)]

3. <span data-ttu-id="38948-201">若要使用委托调用该方法，必须具有与该构造泛型方法的签名匹配的委托。</span><span class="sxs-lookup"><span data-stu-id="38948-201">To invoke the method using a delegate, you must have a delegate that matches the signature of the constructed generic method.</span></span> <span data-ttu-id="38948-202">实现上述目标的一种简便方式是创建一个泛型委托。</span><span class="sxs-lookup"><span data-stu-id="38948-202">An easy way to do this is to create a generic delegate.</span></span> <span data-ttu-id="38948-203">以下代码使用 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType> 方法重载来创建示例代码中定义的泛型委托 `D` 的实例，然后调用该委托。</span><span class="sxs-lookup"><span data-stu-id="38948-203">The following code creates an instance of the generic delegate `D` defined in the example code, using the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType> method overload, and invokes the delegate.</span></span> <span data-ttu-id="38948-204">委托的性能优于后期绑定调用的性能。</span><span class="sxs-lookup"><span data-stu-id="38948-204">Delegates perform better than late-bound calls.</span></span>

    [!code-csharp[GenericMethodHowTo#23](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#23)]
    [!code-vb[GenericMethodHowTo#23](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#23)]

4. <span data-ttu-id="38948-205">也可以从引用保存的程序集的程序调用发出的方法。</span><span class="sxs-lookup"><span data-stu-id="38948-205">The emitted method can also be called from a program that refers to the saved assembly.</span></span>

## <a name="example"></a><span data-ttu-id="38948-206">示例</span><span class="sxs-lookup"><span data-stu-id="38948-206">Example</span></span>

<span data-ttu-id="38948-207">下面的代码示例使用泛型方法 `Factory` 创建一个非泛型类型 `DemoType`。</span><span class="sxs-lookup"><span data-stu-id="38948-207">The following code example creates a nongeneric type, `DemoType`, with a generic method, `Factory`.</span></span> <span data-ttu-id="38948-208">此方法具有两个泛型类型参数：`TInput`，用于指定输入类型；`TOutput`，用于指定输出类型。</span><span class="sxs-lookup"><span data-stu-id="38948-208">This method has two generic type parameters, `TInput` to specify an input type and `TOutput` to specify an output type.</span></span> <span data-ttu-id="38948-209">`TOutput` 类型参数具有以下约束：实现 `ICollection<TInput>`（在 Visual Basic 中为 `ICollection(Of TInput)`）；作为引用类型；具有无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="38948-209">The `TOutput` type parameter is constrained to implement `ICollection<TInput>` (`ICollection(Of TInput)` in Visual Basic), to be a reference type, and to have a parameterless constructor.</span></span>

<span data-ttu-id="38948-210">该方法具有一个形参，它是 `TInput` 的数组。</span><span class="sxs-lookup"><span data-stu-id="38948-210">The method has one formal parameter, which is an array of `TInput`.</span></span> <span data-ttu-id="38948-211">该方法返回 `TOutput` 的实例，该实例包含输入数组的所有元素。</span><span class="sxs-lookup"><span data-stu-id="38948-211">The method returns an instance of `TOutput` that contains all the elements of the input array.</span></span> <span data-ttu-id="38948-212">`TOutput` 可以是实现 <xref:System.Collections.Generic.ICollection%601> 泛型接口的任意泛型集合类型。</span><span class="sxs-lookup"><span data-stu-id="38948-212">`TOutput` can be any generic collection type that implements the <xref:System.Collections.Generic.ICollection%601> generic interface.</span></span>

<span data-ttu-id="38948-213">执行代码时，该动态程序集会另存为 DemoGenericMethod1.dll，使用 [Ildasm.exe（IL 反汇编程序）](../tools/ildasm-exe-il-disassembler.md) 可以对其进行检查。</span><span class="sxs-lookup"><span data-stu-id="38948-213">When the code is executed, the dynamic assembly is saved as DemoGenericMethod1.dll, and can be examined using the [Ildasm.exe (IL Disassembler)](../tools/ildasm-exe-il-disassembler.md).</span></span>

> [!NOTE]
> <span data-ttu-id="38948-214">一种了解如何发出代码的好方法是编写 Visual Basic、C# 或 Visual C++ 程序，执行尝试发出的任务，然后使用反汇编程序检查编译器生成的 MSIL。</span><span class="sxs-lookup"><span data-stu-id="38948-214">A good way to learn how to emit code is to write a Visual Basic, C#, or Visual C++ program that performs the task you are trying to emit, and use the disassembler to examine the MSIL produced by the compiler.</span></span>

<span data-ttu-id="38948-215">该代码示例包含等效于发出的方法的源代码。</span><span class="sxs-lookup"><span data-stu-id="38948-215">The code example includes source code that is equivalent to the emitted method.</span></span> <span data-ttu-id="38948-216">发出的方法也是通过使用代码示例中声明的泛型委托，以后期绑定的形式调用的。</span><span class="sxs-lookup"><span data-stu-id="38948-216">The emitted method is invoked late-bound and also by using a generic delegate declared in the code example.</span></span>

[!code-csharp[GenericMethodHowTo#1](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#1)]
[!code-vb[GenericMethodHowTo#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#1)]

## <a name="see-also"></a><span data-ttu-id="38948-217">请参阅</span><span class="sxs-lookup"><span data-stu-id="38948-217">See also</span></span>

- <xref:System.Reflection.Emit.MethodBuilder>
- [<span data-ttu-id="38948-218">如何：使用反射发出定义泛型类型</span><span class="sxs-lookup"><span data-stu-id="38948-218">How to: Define a Generic Type with Reflection Emit</span></span>](how-to-define-a-generic-type-with-reflection-emit.md)
