---
title: 反射发出中的安全问题
description: 了解反射发出中的安全问题，反射发出是通过动态程序集或者与现有程序集关联的动态方法或匿名托管的动态方法完成的。
ms.date: 03/30/2017
helpviewer_keywords:
- partially trusted code
- emitting dynamic assemblies, security
- reflection emit, security
- reflection emit, partial trust scenarios
- partial trust,emitting dynamic methods
- anonymously hosted dynamic methods [.NET Framework]
- emitting dynamic assemblies,partial trust scenarios
- dynamic assemblies, security
ms.assetid: 0f8bf8fa-b993-478f-87ab-1a1a7976d298
ms.openlocfilehash: d0ca26a1d0964c935137b0a30a5d7c78f93c597b
ms.sourcegitcommit: 3d84eac0818099c9949035feb96bbe0346358504
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/21/2020
ms.locfileid: "86865237"
---
# <a name="security-issues-in-reflection-emit"></a><span data-ttu-id="62d15-103">反射发出中的安全问题</span><span class="sxs-lookup"><span data-stu-id="62d15-103">Security Issues in Reflection Emit</span></span>
<span data-ttu-id="62d15-104">.NET Framework 提供了三种发出 Microsoft 中间语言 (MSIL) 的方式，每种方式都有其自身的安全问题：</span><span class="sxs-lookup"><span data-stu-id="62d15-104">The .NET Framework provides three ways to emit Microsoft intermediate language (MSIL), each with its own security issues:</span></span>  
  
- [<span data-ttu-id="62d15-105">动态程序集</span><span class="sxs-lookup"><span data-stu-id="62d15-105">Dynamic assemblies</span></span>](#Dynamic_Assemblies)  
  
- [<span data-ttu-id="62d15-106">匿名托管的动态方法</span><span class="sxs-lookup"><span data-stu-id="62d15-106">Anonymously hosted dynamic methods</span></span>](#Anonymously_Hosted_Dynamic_Methods)  
  
- [<span data-ttu-id="62d15-107">与现有程序集关联的动态方法</span><span class="sxs-lookup"><span data-stu-id="62d15-107">Dynamic methods associated with existing assemblies</span></span>](#Dynamic_Methods_Associated_with_Existing_Assemblies)  
  
 <span data-ttu-id="62d15-108">无论采用何种方式生成动态代码，执行生成的代码都需要生成代码使用的类型和方法所需的所有权限。</span><span class="sxs-lookup"><span data-stu-id="62d15-108">Regardless of the way you generate dynamic code, executing the generated code requires all the permissions that are required by the types and methods the generated code uses.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="62d15-109">反射和发出代码所需的权限已在 .NET Framework 的后续版本中更改。</span><span class="sxs-lookup"><span data-stu-id="62d15-109">The permissions that are required for reflecting on code and emitting code have changed with succeeding releases of the .NET Framework.</span></span> <span data-ttu-id="62d15-110">请参阅本主题后面的[版本信息](#Version_Information)。</span><span class="sxs-lookup"><span data-stu-id="62d15-110">See [Version Information](#Version_Information), later in this topic.</span></span>  
  
<a name="Dynamic_Assemblies"></a>
## <a name="dynamic-assemblies"></a><span data-ttu-id="62d15-111">动态程序集</span><span class="sxs-lookup"><span data-stu-id="62d15-111">Dynamic Assemblies</span></span>  
 <span data-ttu-id="62d15-112">动态程序集是使用 <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType> 方法的重载创建的。</span><span class="sxs-lookup"><span data-stu-id="62d15-112">Dynamic assemblies are created by using overloads of the <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="62d15-113">此方法的大多数重载在 .NET Framework 4 中已弃用，原因是取消了计算机范围的安全策略。</span><span class="sxs-lookup"><span data-stu-id="62d15-113">Most overloads of this method are deprecated in the .NET Framework 4, because of the elimination of machine-wide security policy.</span></span> <span data-ttu-id="62d15-114">（请参阅[安全更改](https://docs.microsoft.com/previous-versions/dotnet/framework/security/security-changes)。）其余的重载可由任意代码执行，而无论其信任级别如何。</span><span class="sxs-lookup"><span data-stu-id="62d15-114">(See [Security Changes](https://docs.microsoft.com/previous-versions/dotnet/framework/security/security-changes).) The remaining overloads can be executed by any code, regardless of trust level.</span></span> <span data-ttu-id="62d15-115">这些重载分为两组：一组重载指定在创建动态程序集时要对该程序集应用的特性的列表，另一组重载则不会进行相应的指定。</span><span class="sxs-lookup"><span data-stu-id="62d15-115">These overloads fall into two groups: those that specify a list of attributes to apply to the dynamic assembly when it is created, and those that do not.</span></span> <span data-ttu-id="62d15-116">如果没有通过在创建程序集时应用 <xref:System.Security.SecurityRulesAttribute> 属性来指定程序集的透明度模型，则从发出程序集继承透明度模型。</span><span class="sxs-lookup"><span data-stu-id="62d15-116">If you do not specify the transparency model for the assembly, by applying the <xref:System.Security.SecurityRulesAttribute> attribute when you create it, the transparency model is inherited from the emitting assembly.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="62d15-117">对于在创建动态程序集之后通过使用 <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> 方法对该程序集应用的特性，只有在将该程序集保存到磁盘并再次加载到内存中之后，这些特性才会起作用。</span><span class="sxs-lookup"><span data-stu-id="62d15-117">Attributes that you apply to the dynamic assembly after it is created, by using the <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> method, do not take effect until the assembly has been saved to disk and loaded into memory again.</span></span>  
  
 <span data-ttu-id="62d15-118">动态程序集中的代码可访问其他程序集中的可见类型和成员。</span><span class="sxs-lookup"><span data-stu-id="62d15-118">Code in a dynamic assembly can access visible types and members in other assemblies.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="62d15-119">动态程序集不使用 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 标志，这些标志允许动态方法访问非公共类型和成员。</span><span class="sxs-lookup"><span data-stu-id="62d15-119">Dynamic assemblies do not use the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> and <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flags that allow dynamic methods to access nonpublic types and members.</span></span>  
  
 <span data-ttu-id="62d15-120">瞬态动态程序集在内存中创建，从不保存到磁盘中，因此它们并不需要文件访问权限。</span><span class="sxs-lookup"><span data-stu-id="62d15-120">Transient dynamic assemblies are created in memory and never saved to disk, so they require no file access permissions.</span></span> <span data-ttu-id="62d15-121">将动态程序集保存到磁盘需要带有相应标志的 <xref:System.Security.Permissions.FileIOPermission>。</span><span class="sxs-lookup"><span data-stu-id="62d15-121">Saving a dynamic assembly to disk requires <xref:System.Security.Permissions.FileIOPermission> with the appropriate flags.</span></span>  
  
### <a name="generating-dynamic-assemblies-from-partially-trusted-code"></a><span data-ttu-id="62d15-122">从部分受信任的代码生成动态程序集</span><span class="sxs-lookup"><span data-stu-id="62d15-122">Generating Dynamic Assemblies from Partially Trusted Code</span></span>  
 <span data-ttu-id="62d15-123">请考虑具有 Internet 权限的程序集可以生成瞬态动态程序集并执行其代码的条件：</span><span class="sxs-lookup"><span data-stu-id="62d15-123">Consider the conditions in which an assembly with Internet permissions can generate a transient dynamic assembly and execute its code:</span></span>  
  
- <span data-ttu-id="62d15-124">动态程序集仅使用其他程序集的公共类型和成员。</span><span class="sxs-lookup"><span data-stu-id="62d15-124">The dynamic assembly uses only public types and members of other assemblies.</span></span>  
  
- <span data-ttu-id="62d15-125">这些类型和成员所需的权限包含在部分受信任的程序集的授予集中。</span><span class="sxs-lookup"><span data-stu-id="62d15-125">The permissions demanded by those types and members are included in the grant set of the partially trusted assembly.</span></span>  
  
- <span data-ttu-id="62d15-126">程序集不保存到磁盘。</span><span class="sxs-lookup"><span data-stu-id="62d15-126">The assembly is not saved to disk.</span></span>  
  
- <span data-ttu-id="62d15-127">不生成调试符号。</span><span class="sxs-lookup"><span data-stu-id="62d15-127">Debug symbols are not generated.</span></span> <span data-ttu-id="62d15-128">（`Internet` 和 `LocalIntranet` 权限集未包括必要的权限。）</span><span class="sxs-lookup"><span data-stu-id="62d15-128">(`Internet` and `LocalIntranet` permission sets do not include the necessary permissions.)</span></span>  
  
<a name="Anonymously_Hosted_Dynamic_Methods"></a>
## <a name="anonymously-hosted-dynamic-methods"></a><span data-ttu-id="62d15-129">匿名托管的动态方法</span><span class="sxs-lookup"><span data-stu-id="62d15-129">Anonymously Hosted Dynamic Methods</span></span>  
 <span data-ttu-id="62d15-130">通过使用未指定关联类型或模块的两个 <xref:System.Reflection.Emit.DynamicMethod> 构造函数（即 <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%29> 和 <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29>）来创建匿名托管的动态方法。</span><span class="sxs-lookup"><span data-stu-id="62d15-130">Anonymously hosted dynamic methods are created by using the two <xref:System.Reflection.Emit.DynamicMethod> constructors that do not specify an associated type or module, <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%29> and <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29>.</span></span> <span data-ttu-id="62d15-131">这些构造函数将动态方法放到系统提供的完全信任的安全透明的程序集中。</span><span class="sxs-lookup"><span data-stu-id="62d15-131">These constructors place the dynamic methods in a system-provided, fully trusted, security-transparent assembly.</span></span> <span data-ttu-id="62d15-132">使用这些构造函数或发出动态方法的代码不需要任何权限。</span><span class="sxs-lookup"><span data-stu-id="62d15-132">No permissions are required to use these constructors or to emit code for the dynamic methods.</span></span>  
  
 <span data-ttu-id="62d15-133">相反，创建一个匿名托管的动态方法后，即捕获调用堆栈。</span><span class="sxs-lookup"><span data-stu-id="62d15-133">Instead, when an anonymously hosted dynamic method is created, the call stack is captured.</span></span> <span data-ttu-id="62d15-134">构造该方法时，将根据捕获的调用堆栈执行安全请求。</span><span class="sxs-lookup"><span data-stu-id="62d15-134">When the method is constructed, security demands are made against the captured call stack.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="62d15-135">从概念上来说，在方法的构造过程中执行请求。</span><span class="sxs-lookup"><span data-stu-id="62d15-135">Conceptually, demands are made during the construction of the method.</span></span> <span data-ttu-id="62d15-136">即，可在发出各 MSIL 指令时执行请求。</span><span class="sxs-lookup"><span data-stu-id="62d15-136">That is, demands could be made as each MSIL instruction is emitted.</span></span> <span data-ttu-id="62d15-137">在当前实现中，当调用 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A?displayProperty=nameWithType> 方法，或调用实时 (JIT) 编译器（如果在没有调用 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 的情况下调用此方法）时将执行所有请求。</span><span class="sxs-lookup"><span data-stu-id="62d15-137">In the current implementation, all demands are made when the <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A?displayProperty=nameWithType> method is called or when the just-in-time (JIT) compiler is invoked, if the method is invoked without calling <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>.</span></span>  
  
 <span data-ttu-id="62d15-138">如果应用程序域允许此操作，匿名托管动态方法可以跳过 JIT 可见性检查，但受到以下限制：匿名托管动态方法访问的非公共类型和成员必须位于其授予集等于发出调用堆栈的授予集或其子集中。</span><span class="sxs-lookup"><span data-stu-id="62d15-138">If the application domain permits it, anonymously hosted dynamic methods can skip JIT visibility checks, subject to the following restriction: The nonpublic types and members accessed by an anonymously hosted dynamic method must be in assemblies whose grant sets are equal to, or subsets of, the grant set of the emitting call stack.</span></span> <span data-ttu-id="62d15-139">如果应用程序域授予带有 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>，则启用此跳过 JIT 可见性检查的受限能力。</span><span class="sxs-lookup"><span data-stu-id="62d15-139">This restricted ability to skip JIT visibility checks is enabled if the application domain grants <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
- <span data-ttu-id="62d15-140">如果你的方法仅使用公共类型和成员，则在构造过程中不需要任何权限。</span><span class="sxs-lookup"><span data-stu-id="62d15-140">If your method uses only public types and members, no permissions are required during construction.</span></span>  
  
- <span data-ttu-id="62d15-141">如果指定应跳过 JIT 可见性检查，则在构造方法时执行的请求包括带有 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>，以及包含正在访问的非公共成员的程序集的授予集。</span><span class="sxs-lookup"><span data-stu-id="62d15-141">If you specify that JIT visibility checks should be skipped, the demand that is made when the method is constructed includes <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and the grant set of the assembly that contains the nonpublic member that is being accessed.</span></span>  
  
 <span data-ttu-id="62d15-142">由于考虑到非公共成员的授予集，因此被授予 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 的部分受信任代码无法通过执行受信任程序集的非公共成员来提升其特权。</span><span class="sxs-lookup"><span data-stu-id="62d15-142">Because the grant set of the nonpublic member is taken into consideration, partially trusted code that has been granted <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> cannot elevate its privileges by executing nonpublic members of trusted assemblies.</span></span>  
  
 <span data-ttu-id="62d15-143">与任何其他发出的代码一样，执行动态方法需要动态方法使用的方法所需的所有权限。</span><span class="sxs-lookup"><span data-stu-id="62d15-143">As with any other emitted code, executing the dynamic method requires whatever permissions are demanded by the methods the dynamic method uses.</span></span>  
  
 <span data-ttu-id="62d15-144">托管匿名托管的动态方法的系统程序集使用 <xref:System.Security.SecurityRuleSet.Level1?displayProperty=nameWithType> 透明度模型，这是在 .NET Framework 4 之前的 .NET Framework 中使用的透明度模型。</span><span class="sxs-lookup"><span data-stu-id="62d15-144">The system assembly that hosts anonymously-hosted dynamic methods uses the <xref:System.Security.SecurityRuleSet.Level1?displayProperty=nameWithType> transparency model, which is the transparency model that was used in the .NET Framework before the .NET Framework 4.</span></span>  
  
 <span data-ttu-id="62d15-145">有关更多信息，请参见 <xref:System.Reflection.Emit.DynamicMethod> 类。</span><span class="sxs-lookup"><span data-stu-id="62d15-145">For more information, see the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
### <a name="generating-anonymously-hosted-dynamic-methods-from-partially-trusted-code"></a><span data-ttu-id="62d15-146">从部分受信任的代码中生成匿名托管的动态方法</span><span class="sxs-lookup"><span data-stu-id="62d15-146">Generating Anonymously Hosted Dynamic Methods from Partially Trusted Code</span></span>  
 <span data-ttu-id="62d15-147">请考虑具有 Internet 权限的程序集可以生成匿名托管的动态方法并执行该方法的条件：</span><span class="sxs-lookup"><span data-stu-id="62d15-147">Consider the conditions in which an assembly with Internet permissions can generate an anonymously hosted dynamic method and execute it:</span></span>  
  
- <span data-ttu-id="62d15-148">动态方法仅使用公共类型和成员。</span><span class="sxs-lookup"><span data-stu-id="62d15-148">The dynamic method uses only public types and members.</span></span> <span data-ttu-id="62d15-149">如果动态方法的授予集包含 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>，则动态方法可以使用任何其授予集等于发出程序集的授予集（或等于发出程序集的授予集的子集）的程序集的非公共类型和成员。</span><span class="sxs-lookup"><span data-stu-id="62d15-149">If its grant set includes <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>, it can use nonpublic types and members of any assembly whose grant set is equal to, or a subset of, the grant set of the emitting assembly.</span></span>  
  
- <span data-ttu-id="62d15-150">动态方法使用的所有类型和成员所需的权限包含在部分受信任的程序集的授予集中。</span><span class="sxs-lookup"><span data-stu-id="62d15-150">The permissions that are required by all the types and members used by the dynamic method are included in the grant set of the partially trusted assembly.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="62d15-151">动态方法不支持调试符号。</span><span class="sxs-lookup"><span data-stu-id="62d15-151">Dynamic methods do not support debug symbols.</span></span>  
  
<a name="Dynamic_Methods_Associated_with_Existing_Assemblies"></a>
## <a name="dynamic-methods-associated-with-existing-assemblies"></a><span data-ttu-id="62d15-152">与现有程序集关联的动态方法</span><span class="sxs-lookup"><span data-stu-id="62d15-152">Dynamic Methods Associated with Existing Assemblies</span></span>  
 <span data-ttu-id="62d15-153">若要将动态方法与现有程序集中的某一类型或模块关联，请使用指定关联类型或模块的任一 <xref:System.Reflection.Emit.DynamicMethod> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="62d15-153">To associate a dynamic method with a type or module in an existing assembly, use any of the <xref:System.Reflection.Emit.DynamicMethod> constructors that specify the associated type or module.</span></span> <span data-ttu-id="62d15-154">调用这些构造函数所需的权限各不相同，这是因为将动态方法与现有类型或模块关联会授予该动态方法访问非公共类型和成员的权限：</span><span class="sxs-lookup"><span data-stu-id="62d15-154">The permissions that are required to call these constructors vary, because associating a dynamic method with an existing type or module gives the dynamic method access to nonpublic types and members:</span></span>  
  
- <span data-ttu-id="62d15-155">与某一类型关联的动态方法具有对该类型的所有成员（甚至私有成员）以及包含此关联类型的程序集中的所有内部类型和成员的访问权限。</span><span class="sxs-lookup"><span data-stu-id="62d15-155">A dynamic method that is associated with a type has access to all members of that type, even private members, and to all internal types and members in the assembly that contains the associated type.</span></span>  
  
- <span data-ttu-id="62d15-156">与某一模块相关联的态方法具有对该模块中的所有 `internal` 类型和成员（在 Visual Basic 中为 `Friend`，在公共语言运行时元数据中为 `assembly`）的访问权限。</span><span class="sxs-lookup"><span data-stu-id="62d15-156">A dynamic method that is associated with a module has access to all the `internal` types and members (`Friend` in Visual Basic, `assembly` in common language runtime metadata) in the module.</span></span>  
  
 <span data-ttu-id="62d15-157">此外，你可以使用一个构造函数来指定跳过 JIT 编译器的可见性检查的能力。</span><span class="sxs-lookup"><span data-stu-id="62d15-157">In addition, you can use a constructor that specifies the ability to skip the visibility checks of the JIT compiler.</span></span> <span data-ttu-id="62d15-158">执行此操作可向动态方法授予对所有程序集中的所有类型和成员的访问权限，而无论访问级别如何。</span><span class="sxs-lookup"><span data-stu-id="62d15-158">Doing so gives your dynamic method access to all types and members in all assemblies, regardless of access level.</span></span>  
  
 <span data-ttu-id="62d15-159">构造函数所需的权限取决于你决定向动态方法授予多少访问权限：</span><span class="sxs-lookup"><span data-stu-id="62d15-159">The permissions demanded by the constructor depend on how much access you decide to give your dynamic method:</span></span>  
  
- <span data-ttu-id="62d15-160">如果你的方法仅使用公共类型和成员，并且你将该方法与你自己的类型或模块关联，则不需要任何权限。</span><span class="sxs-lookup"><span data-stu-id="62d15-160">If your method uses only public types and members, and you associate it with your own type or your own module, no permissions are required.</span></span>  
  
- <span data-ttu-id="62d15-161">如果指定应跳过 JIT 可见性检查，则构造函数需要带有 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="62d15-161">If you specify that JIT visibility checks should be skipped, the constructor demands <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
- <span data-ttu-id="62d15-162">如果将动态方法与另一类型（甚至是你自己的程序集中的另一类型）关联，则构造函数需要带有 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission> 和带有 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.SecurityPermission>。</span><span class="sxs-lookup"><span data-stu-id="62d15-162">If you associate the dynamic method with another type, even another type in your own assembly, the constructor demands <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag and <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag.</span></span>  
  
- <span data-ttu-id="62d15-163">如果将动态方法与另一程序集中的类型或模块关联，则构造函数可能需要下列两项：带有 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission> 和包含其他模块的程序集的授予集。</span><span class="sxs-lookup"><span data-stu-id="62d15-163">If you associate the dynamic method with a type or module in another assembly, the constructor demands two things: <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, and the grant set of the assembly that contains the other module.</span></span> <span data-ttu-id="62d15-164">也就是说，调用堆栈必须包括目标模块的授权集中的所有权限以及 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="62d15-164">That is, your call stack must include all the permissions in the grant set of the target module, plus <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="62d15-165">为实现向后兼容性，如果对目标授予集和 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 的请求失败，构造函数将需要带有 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.SecurityPermission>。</span><span class="sxs-lookup"><span data-stu-id="62d15-165">For backward compatibility, if the demand for the target grant set plus <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> fails, the constructor demands <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="62d15-166">虽然此列表中的项是用发出程序集的授予集来描述的，但是请记住，请求是根据完整的调用堆栈（包括应用程序域边界）来执行的。</span><span class="sxs-lookup"><span data-stu-id="62d15-166">Although the items in this list are described in terms of the grant set of the emitting assembly, remember that the demands are made against the full call stack, including the application domain boundary.</span></span>  
  
 <span data-ttu-id="62d15-167">有关更多信息，请参见 <xref:System.Reflection.Emit.DynamicMethod> 类。</span><span class="sxs-lookup"><span data-stu-id="62d15-167">For more information, see the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
### <a name="generating-dynamic-methods-from-partially-trusted-code"></a><span data-ttu-id="62d15-168">从部分受信任的代码生成动态方法</span><span class="sxs-lookup"><span data-stu-id="62d15-168">Generating Dynamic Methods from Partially Trusted Code</span></span>  
  
> [!NOTE]
> <span data-ttu-id="62d15-169">从部分受信任的代码生成动态方法的推荐方式是使用[匿名托管的动态方法](#Anonymously_Hosted_Dynamic_Methods)。</span><span class="sxs-lookup"><span data-stu-id="62d15-169">The recommended way to generate dynamic methods from partially trusted code is to use [anonymously hosted dynamic methods](#Anonymously_Hosted_Dynamic_Methods).</span></span>  
  
 <span data-ttu-id="62d15-170">请考虑具有 Internet 权限的程序集可以生成并执行动态方法的条件：</span><span class="sxs-lookup"><span data-stu-id="62d15-170">Consider the conditions in which an assembly with Internet permissions can generate a dynamic method and execute it:</span></span>  
  
- <span data-ttu-id="62d15-171">动态方法要么与发出它的模块或类型相关联，要么其授予集中包含 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>，并且该方法与其授予集等于发出程序集的授予集（或者等于发出程序集的授予集的子集）的程序集中的模块关联。</span><span class="sxs-lookup"><span data-stu-id="62d15-171">Either the dynamic method is associated with the module or type that emits it, or its grant set includes <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> and it is associated with a module in an assembly whose grant set is equal to, or a subset of, the grant set of the emitting assembly.</span></span>  
  
- <span data-ttu-id="62d15-172">动态方法仅使用公共类型和成员。</span><span class="sxs-lookup"><span data-stu-id="62d15-172">The dynamic method uses only public types and members.</span></span> <span data-ttu-id="62d15-173">如果动态方法的授予集包含 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>，并且该方法与其授予集等于发出程序集的授予集（或者等于发出程序集的授予集的子集）的程序集中的模块关联，那么该方法可使用关联模块中标记为 `internal` 的类型和成员（在 Visual Basic 中为 `Friend`，在公共语言运行时元数据中为 `assembly`）。</span><span class="sxs-lookup"><span data-stu-id="62d15-173">If its grant set includes <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> and it is associated with a module in an assembly whose grant set is equal to, or a subset of, the grant set of the emitting assembly, it can use types and members marked `internal` (`Friend` in Visual Basic, `assembly` in common language runtime metadata) in the associated module.</span></span>  
  
- <span data-ttu-id="62d15-174">动态方法使用的所有类型和成员所需的权限包含在部分受信任的程序集的授予集中。</span><span class="sxs-lookup"><span data-stu-id="62d15-174">The permissions demanded by all the types and members used by the dynamic method are included in the grant set of the partially trusted assembly.</span></span>  
  
- <span data-ttu-id="62d15-175">动态方法不会跳过 JIT 可见性检查。</span><span class="sxs-lookup"><span data-stu-id="62d15-175">The dynamic method does not skip JIT visibility checks.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="62d15-176">动态方法不支持调试符号。</span><span class="sxs-lookup"><span data-stu-id="62d15-176">Dynamic methods do not support debug symbols.</span></span>  
  
<a name="Version_Information"></a>
## <a name="version-information"></a><span data-ttu-id="62d15-177">版本信息</span><span class="sxs-lookup"><span data-stu-id="62d15-177">Version Information</span></span>  
 <span data-ttu-id="62d15-178">从 .NET Framework 4 开始，已取消计算机范围的安全策略，并且安全透明度已成为默认的强制机制。</span><span class="sxs-lookup"><span data-stu-id="62d15-178">Starting with the .NET Framework 4, machine-wide security policy is eliminated and security transparency becomes the default enforcement mechanism.</span></span> <span data-ttu-id="62d15-179">请参阅[安全更改](https://docs.microsoft.com/previous-versions/dotnet/framework/security/security-changes)。</span><span class="sxs-lookup"><span data-stu-id="62d15-179">See [Security Changes](https://docs.microsoft.com/previous-versions/dotnet/framework/security/security-changes).</span></span>  
  
 <span data-ttu-id="62d15-180">从 .NET Framework 2.0 Service Pack 1 开始，在发出动态程序集和动态方法时不再需要带有 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="62d15-180">Starting with the .NET Framework 2.0 Service Pack 1, <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag is no longer required when emitting dynamic assemblies and dynamic methods.</span></span> <span data-ttu-id="62d15-181">所有早期版本的 .NET Framework 都需要此标志。</span><span class="sxs-lookup"><span data-stu-id="62d15-181">This flag is required in all earlier versions of the .NET Framework.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="62d15-182">默认情况下，带有 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission> 包含在 `FullTrust` 和 `LocalIntranet` 命名权限集中，而不是在 `Internet` 权限集中。</span><span class="sxs-lookup"><span data-stu-id="62d15-182"><xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag is included by default in the `FullTrust` and `LocalIntranet` named permission sets, but not in the `Internet` permission set.</span></span> <span data-ttu-id="62d15-183">因此，在 .NET Framework 的早期版本中，仅当库执行 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit> 的 <xref:System.Security.PermissionSet.Assert%2A> 时才能与 Internet 权限一起使用。</span><span class="sxs-lookup"><span data-stu-id="62d15-183">Therefore, in earlier versions of the .NET Framework, a library can be used with Internet permissions only if it executes an <xref:System.Security.PermissionSet.Assert%2A> for <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>.</span></span> <span data-ttu-id="62d15-184">这种库需要进行仔细的安全检查，因为编码错误可能会导致安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="62d15-184">Such libraries require careful security review because coding errors could result in security holes.</span></span> <span data-ttu-id="62d15-185">.NET Framework 2.0 SP1 允许以部分信任形式发出代码而无需发出任何安全请求，因为生成代码本身不是一项特权操作。</span><span class="sxs-lookup"><span data-stu-id="62d15-185">The .NET Framework 2.0 SP1 allows code to be emitted in partial trust scenarios without issuing any security demands, because generating code is not inherently a privileged operation.</span></span> <span data-ttu-id="62d15-186">也就是说，生成的代码不会具有比发出它的程序集更多的权限。</span><span class="sxs-lookup"><span data-stu-id="62d15-186">That is, the generated code has no more permissions than the assembly that emits it.</span></span> <span data-ttu-id="62d15-187">这使得发出代码的库是安全透明的，且不再需要断言 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>，这简化了编写安全库任务。</span><span class="sxs-lookup"><span data-stu-id="62d15-187">This allows libraries that emit code to be security transparent and removes the need to assert <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, which simplifies the task of writing a secure library.</span></span>  
  
 <span data-ttu-id="62d15-188">此外，.NET Framework 2.0 SP1 引入了 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 标志，用于从部分受信任的动态方法访问非公共类型和成员。</span><span class="sxs-lookup"><span data-stu-id="62d15-188">In addition, the .NET Framework 2.0 SP1 introduces the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag for accessing nonpublic types and members from partially trusted dynamic methods.</span></span> <span data-ttu-id="62d15-189">.NET Framework 的早期版本需要访问非公共类型和成员的动态方法的 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 标志；绝不会将该权限授予部分受信任的代码。</span><span class="sxs-lookup"><span data-stu-id="62d15-189">Earlier versions of the .NET Framework require the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag for dynamic methods that access nonpublic types and members; this is a permission that should never be granted to partially trusted code.</span></span>  
  
 <span data-ttu-id="62d15-190">最后，.NET Framework 2.0 SP1 引入了匿名托管的方法。</span><span class="sxs-lookup"><span data-stu-id="62d15-190">Finally, the .NET Framework 2.0 SP1 introduces anonymously hosted methods.</span></span>  
  
### <a name="obtaining-information-on-types-and-members"></a><span data-ttu-id="62d15-191">获取有关类型和成员的信息</span><span class="sxs-lookup"><span data-stu-id="62d15-191">Obtaining Information on Types and Members</span></span>  
 <span data-ttu-id="62d15-192">从 .NET Framework 2.0 开始，获取有关非公共类型和成员信息不再需要任何权限。</span><span class="sxs-lookup"><span data-stu-id="62d15-192">Starting with the .NET Framework 2.0, no permissions are required to obtain information about nonpublic types and members.</span></span> <span data-ttu-id="62d15-193">使用反射可获取发出动态方法所需的信息。</span><span class="sxs-lookup"><span data-stu-id="62d15-193">Reflection is used to obtain information needed to emit dynamic methods.</span></span> <span data-ttu-id="62d15-194">例如，使用 <xref:System.Reflection.MethodInfo> 对象发出方法调用。</span><span class="sxs-lookup"><span data-stu-id="62d15-194">For example, <xref:System.Reflection.MethodInfo> objects are used to emit method calls.</span></span> <span data-ttu-id="62d15-195">.NET Framework 的早期版本需要使用带有 <xref:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="62d15-195">Earlier versions of the .NET Framework require <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="62d15-196">有关详细信息，请参阅[反射的安全注意事项](security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="62d15-196">For more information, see [Security Considerations for Reflection](security-considerations-for-reflection.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="62d15-197">请参阅</span><span class="sxs-lookup"><span data-stu-id="62d15-197">See also</span></span>

- [<span data-ttu-id="62d15-198">反射的安全注意事项</span><span class="sxs-lookup"><span data-stu-id="62d15-198">Security Considerations for Reflection</span></span>](security-considerations-for-reflection.md)
- [<span data-ttu-id="62d15-199">发出动态方法和程序集</span><span class="sxs-lookup"><span data-stu-id="62d15-199">Emitting Dynamic Methods and Assemblies</span></span>](emitting-dynamic-methods-and-assemblies.md)
