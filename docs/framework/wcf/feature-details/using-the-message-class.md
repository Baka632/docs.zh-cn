---
title: 使用 Message 类
description: 了解 Message 类，它是 WCF 的基础。 只需在某些高级方案中直接使用消息类进行编程。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: d1d62bfb-2aa3-4170-b6f8-c93d3afdbbed
ms.openlocfilehash: fd19256b571727883dd877f0094f180ec47c6d63
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/26/2020
ms.locfileid: "96289381"
---
# <a name="using-the-message-class"></a><span data-ttu-id="e60f8-104">使用 Message 类</span><span class="sxs-lookup"><span data-stu-id="e60f8-104">Using the Message Class</span></span>

<span data-ttu-id="e60f8-105"><xref:System.ServiceModel.Channels.Message>类是 Windows Communication Foundation (WCF) 的基础。</span><span class="sxs-lookup"><span data-stu-id="e60f8-105">The <xref:System.ServiceModel.Channels.Message> class is fundamental to Windows Communication Foundation (WCF).</span></span> <span data-ttu-id="e60f8-106">客户端与服务之间的所有通信最终都会产生要进行发送和接收的 <xref:System.ServiceModel.Channels.Message> 实例。</span><span class="sxs-lookup"><span data-stu-id="e60f8-106">All communication between clients and services ultimately results in <xref:System.ServiceModel.Channels.Message> instances being sent and received.</span></span>  
  
 <span data-ttu-id="e60f8-107">您通常不会与 <xref:System.ServiceModel.Channels.Message> 类直接进行交互。</span><span class="sxs-lookup"><span data-stu-id="e60f8-107">You would not usually interact with the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="e60f8-108">相反，WCF 服务模型构造（如数据协定、消息协定和操作协定）用于描述传入消息和传出消息。</span><span class="sxs-lookup"><span data-stu-id="e60f8-108">Instead, WCF service model constructs, such as data contracts, message contracts, and operation contracts, are used to describe incoming and outgoing messages.</span></span> <span data-ttu-id="e60f8-109">但是，在某些高级方案中，可以直接使用 <xref:System.ServiceModel.Channels.Message> 类进行编程。</span><span class="sxs-lookup"><span data-stu-id="e60f8-109">However, in some advanced scenarios you can program using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="e60f8-110">例如，在以下情况下可能需要使用 <xref:System.ServiceModel.Channels.Message> 类：</span><span class="sxs-lookup"><span data-stu-id="e60f8-110">For example, you might want to use the <xref:System.ServiceModel.Channels.Message> class:</span></span>  
  
- <span data-ttu-id="e60f8-111">如果需要创建传出消息内容的替代方法 (例如，直接从磁盘上的文件创建消息) 而不是序列化 .NET Framework 对象。</span><span class="sxs-lookup"><span data-stu-id="e60f8-111">When you need an alternative way of creating outgoing message contents (for example, creating a message directly from a file on disk) instead of serializing .NET Framework objects.</span></span>  
  
- <span data-ttu-id="e60f8-112">如果需要使用传入消息内容的另一种方法 (例如，要将 XSLT 转换应用于原始 XML 内容) 而不是反序列化为 .NET Framework 对象。</span><span class="sxs-lookup"><span data-stu-id="e60f8-112">When you need an alternative way of using incoming message contents (for example, when you want to apply an XSLT transformation to the raw XML contents) instead of deserializing into .NET Framework objects.</span></span>  
  
- <span data-ttu-id="e60f8-113">无论消息内容怎样都需要使用常规方式来处理消息（例如，在生成路由器、负载平衡器或发布-订阅系统时对消息进行路由或转发）。</span><span class="sxs-lookup"><span data-stu-id="e60f8-113">When you need to deal with messages in a general way regardless of message contents (for example, when routing or forwarding messages when building a router, load-balancer, or a publish-subscribe system).</span></span>  
  
 <span data-ttu-id="e60f8-114">使用类之前 <xref:System.ServiceModel.Channels.Message> ，请先熟悉 [数据传输体系结构概述](data-transfer-architectural-overview.md)中的 WCF 数据传输体系结构。</span><span class="sxs-lookup"><span data-stu-id="e60f8-114">Before using the <xref:System.ServiceModel.Channels.Message> class, familiarize yourself with the WCF data transfer architecture in [Data Transfer Architectural Overview](data-transfer-architectural-overview.md).</span></span>  
  
 <span data-ttu-id="e60f8-115"><xref:System.ServiceModel.Channels.Message> 是一种通用的数据容器，但其设计严格遵循 SOAP 协议中消息的设计方式。</span><span class="sxs-lookup"><span data-stu-id="e60f8-115">A <xref:System.ServiceModel.Channels.Message> is a general-purpose container for data, but its design closely follows the design of a message in the SOAP protocol.</span></span> <span data-ttu-id="e60f8-116">就像 SOAP 中一样，消息同时具有消息正文和标头。</span><span class="sxs-lookup"><span data-stu-id="e60f8-116">Just like in SOAP, a message has both a message body and headers.</span></span> <span data-ttu-id="e60f8-117">消息正文包含实际负载数据，而标头包含其他已命名的数据容器。</span><span class="sxs-lookup"><span data-stu-id="e60f8-117">The message body contains the actual payload data, while the headers contain additional named data containers.</span></span> <span data-ttu-id="e60f8-118">用于读取和写入消息正文与标头的规则是不同的，例如，标头总是在内存中进行缓冲，并且可以按任意顺序访问任意次，而正文仅能读取一次且可以进行流式处理。</span><span class="sxs-lookup"><span data-stu-id="e60f8-118">The rules for reading and writing the body and the headers are different, for example, the headers are always buffered in memory and may be accessed in any order any number of times, while the body may be read only once and may be streamed.</span></span> <span data-ttu-id="e60f8-119">通常，使用 SOAP 时，消息正文被映射到 SOAP 正文，而消息头被映射到 SOAP 标头。</span><span class="sxs-lookup"><span data-stu-id="e60f8-119">Normally, when using SOAP, the message body is mapped to the SOAP body and the message headers are mapped to the SOAP headers.</span></span>  
  
## <a name="using-the-message-class-in-operations"></a><span data-ttu-id="e60f8-120">在操作中使用 Message 类</span><span class="sxs-lookup"><span data-stu-id="e60f8-120">Using the Message Class in Operations</span></span>  

 <span data-ttu-id="e60f8-121">可以将 <xref:System.ServiceModel.Channels.Message> 类用作操作的输入参数和/或操作的返回值。</span><span class="sxs-lookup"><span data-stu-id="e60f8-121">You can use the <xref:System.ServiceModel.Channels.Message> class as an input parameter of an operation, the return value of an operation, or both.</span></span> <span data-ttu-id="e60f8-122">只要在操作中的任何位置使用了 <xref:System.ServiceModel.Channels.Message>，就必须遵从以下限制：</span><span class="sxs-lookup"><span data-stu-id="e60f8-122">If <xref:System.ServiceModel.Channels.Message> is used anywhere in an operation, the following restrictions apply:</span></span>  
  
- <span data-ttu-id="e60f8-123">操作不能具有任何 `out` 或 `ref` 参数。</span><span class="sxs-lookup"><span data-stu-id="e60f8-123">The operation cannot have any `out` or `ref` parameters.</span></span>  
  
- <span data-ttu-id="e60f8-124">不能有一个以上的 `input` 参数。</span><span class="sxs-lookup"><span data-stu-id="e60f8-124">There cannot be more than one `input` parameter.</span></span> <span data-ttu-id="e60f8-125">如果该参数存在，其类型必须为 Message 或消息协定。</span><span class="sxs-lookup"><span data-stu-id="e60f8-125">If the parameter is present, it must be either Message or a message contract type.</span></span>  
  
- <span data-ttu-id="e60f8-126">返回类型必须为 `void`、`Message` 或消息协定类型。</span><span class="sxs-lookup"><span data-stu-id="e60f8-126">The return type must be either `void`, `Message`, or a message contract type.</span></span>  
  
 <span data-ttu-id="e60f8-127">下面的代码示例包含一个有效的操作协定。</span><span class="sxs-lookup"><span data-stu-id="e60f8-127">The following code example contains a valid operation contract.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#1)]
 [!code-vb[C_UsingTheMessageClass#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#1)]  
  
## <a name="creating-basic-messages"></a><span data-ttu-id="e60f8-128">创建基本消息</span><span class="sxs-lookup"><span data-stu-id="e60f8-128">Creating Basic Messages</span></span>  

 <span data-ttu-id="e60f8-129"><xref:System.ServiceModel.Channels.Message> 类提供了静态 `CreateMessage` 工厂方法，可以使用这些方法创建基本消息。</span><span class="sxs-lookup"><span data-stu-id="e60f8-129">The <xref:System.ServiceModel.Channels.Message> class provides static `CreateMessage` factory methods that you can use to create basic messages.</span></span>  
  
 <span data-ttu-id="e60f8-130">所有 `CreateMessage` 重载都采用一个类型为 <xref:System.ServiceModel.Channels.MessageVersion> 的版本参数，该参数指示要用于消息的 SOAP 和 WS-Addressing 版本。</span><span class="sxs-lookup"><span data-stu-id="e60f8-130">All `CreateMessage` overloads take a version parameter of type <xref:System.ServiceModel.Channels.MessageVersion> that indicates the SOAP and WS-Addressing versions to use for the message.</span></span> <span data-ttu-id="e60f8-131">如果要使用与传入消息相同的协议版本，则可以使用 <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> 实例（从 <xref:System.ServiceModel.OperationContext> 属性获取）上的 <xref:System.ServiceModel.OperationContext.Current%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="e60f8-131">If you want to use the same protocol versions as the incoming message, you can use the <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> property on the <xref:System.ServiceModel.OperationContext> instance obtained from the <xref:System.ServiceModel.OperationContext.Current%2A> property.</span></span> <span data-ttu-id="e60f8-132">大多数 `CreateMessage` 重载还具有一个字符串参数，该参数指示要用于消息的 SOAP 操作。</span><span class="sxs-lookup"><span data-stu-id="e60f8-132">Most `CreateMessage` overloads also have a string parameter that indicates the SOAP action to use for the message.</span></span> <span data-ttu-id="e60f8-133">可以将版本设置为 `None` 以禁用 SOAP 信封生成；消息仅包含正文。</span><span class="sxs-lookup"><span data-stu-id="e60f8-133">Version can be set to `None` to disable SOAP envelope generation; the message consists of only the body.</span></span>  
  
## <a name="creating-messages-from-objects"></a><span data-ttu-id="e60f8-134">从对象创建消息</span><span class="sxs-lookup"><span data-stu-id="e60f8-134">Creating Messages from Objects</span></span>  

 <span data-ttu-id="e60f8-135">仅采用一个版本和一个操作作为参数的最基本的 `CreateMessage` 重载可创建一条正文为空的消息。</span><span class="sxs-lookup"><span data-stu-id="e60f8-135">The most basic `CreateMessage` overload that takes only a version and an action creates a message with an empty body.</span></span> <span data-ttu-id="e60f8-136">另一种重载采用一个附加的 <xref:System.Object> 参数；此重载所创建的消息的正文是给定对象的序列化表示。</span><span class="sxs-lookup"><span data-stu-id="e60f8-136">Another overload takes an additional <xref:System.Object> parameter; this creates a message whose body is the serialized representation of the given object.</span></span> <span data-ttu-id="e60f8-137">请使用具有默认设置的 <xref:System.Runtime.Serialization.DataContractSerializer> 进行序列化。</span><span class="sxs-lookup"><span data-stu-id="e60f8-137">Use the <xref:System.Runtime.Serialization.DataContractSerializer> with default settings for serialization.</span></span> <span data-ttu-id="e60f8-138">如果要使用其他序列化程序，或者希望对 `DataContractSerializer` 进行不同配置，请使用也采用一个 `CreateMessage` 参数的 `XmlObjectSerializer` 重载。</span><span class="sxs-lookup"><span data-stu-id="e60f8-138">If you want to use a different serializer, or you want the `DataContractSerializer` configured differently, use the `CreateMessage` overload that also takes an `XmlObjectSerializer` parameter.</span></span>  
  
 <span data-ttu-id="e60f8-139">例如，若要在消息中返回一个对象，可以使用下面的代码。</span><span class="sxs-lookup"><span data-stu-id="e60f8-139">For example, to return an object in a message, you can use the following code.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#2)]
 [!code-vb[C_UsingTheMessageClass#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#2)]  
  
## <a name="creating-messages-from-xml-readers"></a><span data-ttu-id="e60f8-140">从 XML 读取器创建消息</span><span class="sxs-lookup"><span data-stu-id="e60f8-140">Creating Messages from XML Readers</span></span>  

 <span data-ttu-id="e60f8-141">有些 `CreateMessage` 重载采用一个 <xref:System.Xml.XmlReader> 或一个 <xref:System.Xml.XmlDictionaryReader> 而不是对象作为正文。</span><span class="sxs-lookup"><span data-stu-id="e60f8-141">There are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> for the body instead of an object.</span></span> <span data-ttu-id="e60f8-142">在这种情况下，消息的正文会包含从传递的 XML 读取器中进行读取而产生的 XML。</span><span class="sxs-lookup"><span data-stu-id="e60f8-142">In this case, the body of the message contains the XML that results from reading from the passed XML reader.</span></span> <span data-ttu-id="e60f8-143">例如，下面的代码会返回一条消息，该消息的正文内容是从一个 XML 文件中读取的。</span><span class="sxs-lookup"><span data-stu-id="e60f8-143">For example, the following code returns a message with body contents read from an XML file.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#3)]
 [!code-vb[C_UsingTheMessageClass#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#3)]  
  
 <span data-ttu-id="e60f8-144">此外，还有一些 `CreateMessage` 重载采用一个表示整个消息（而不仅仅是正文）的 <xref:System.Xml.XmlReader> 或 <xref:System.Xml.XmlDictionaryReader> 作为参数。</span><span class="sxs-lookup"><span data-stu-id="e60f8-144">Additionally, there are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> that represents the entire message and not just the body.</span></span> <span data-ttu-id="e60f8-145">这些重载还采用一个整型 `maxSizeOfHeaders` 参数。</span><span class="sxs-lookup"><span data-stu-id="e60f8-145">These overloads also take an integer `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="e60f8-146">一旦创建了消息，标头就总是在内存中进行缓冲，而此参数用于限制发生的缓冲数量。</span><span class="sxs-lookup"><span data-stu-id="e60f8-146">Headers are always buffered into memory as soon as the message is created, and this parameter limits the amount of buffering that takes place.</span></span> <span data-ttu-id="e60f8-147">如果 XML 来自不受信任的源，那么为了降低发生拒绝服务攻击的可能性，将此参数设置为安全值就变得十分重要。</span><span class="sxs-lookup"><span data-stu-id="e60f8-147">It is important to set this parameter to a safe value if the XML is coming from an untrusted source to mitigate the possibility of a denial of service attack.</span></span> <span data-ttu-id="e60f8-148">XML 读取器表示的消息的 SOAP 和 WS-Addressing 版本必须与使用版本参数指示的版本相匹配。</span><span class="sxs-lookup"><span data-stu-id="e60f8-148">The SOAP and WS-Addressing versions of the message the XML reader represents must match the versions indicated using the version parameter.</span></span>  
  
## <a name="creating-messages-with-bodywriter"></a><span data-ttu-id="e60f8-149">使用 BodyWriter 创建消息</span><span class="sxs-lookup"><span data-stu-id="e60f8-149">Creating Messages with BodyWriter</span></span>  

 <span data-ttu-id="e60f8-150">有一种 `CreateMessage` 重载采用一个 `BodyWriter` 实例来描述消息的正文。</span><span class="sxs-lookup"><span data-stu-id="e60f8-150">One `CreateMessage` overload takes a `BodyWriter` instance to describe the body of the message.</span></span> <span data-ttu-id="e60f8-151">`BodyWriter` 是一个抽象类，可以从该类派生以自定义创建消息正文的方式。</span><span class="sxs-lookup"><span data-stu-id="e60f8-151">A `BodyWriter` is an abstract class that can be derived to customize how message bodies are created.</span></span> <span data-ttu-id="e60f8-152">您可以创建自己的 `BodyWriter` 派生类，以便按照自定义方式来描述消息正文。</span><span class="sxs-lookup"><span data-stu-id="e60f8-152">You can create your own `BodyWriter` derived class to describe message bodies in a custom way.</span></span> <span data-ttu-id="e60f8-153">必须重写采用一个 `BodyWriter.OnWriteBodyContents` 作为参数的 <xref:System.Xml.XmlDictionaryWriter> 方法；此方法负责写出正文。</span><span class="sxs-lookup"><span data-stu-id="e60f8-153">You must override the `BodyWriter.OnWriteBodyContents` method that takes an <xref:System.Xml.XmlDictionaryWriter>; this method is responsible for writing out the body.</span></span>  
  
 <span data-ttu-id="e60f8-154">正文编写器可以是缓冲式的，也可以是非缓冲式的（流式）。</span><span class="sxs-lookup"><span data-stu-id="e60f8-154">Body writers can be buffered or non-buffered (streamed).</span></span> <span data-ttu-id="e60f8-155">缓冲式正文编写器可以任意次写出其内容，而流式正文编写器只能写出其内容一次。</span><span class="sxs-lookup"><span data-stu-id="e60f8-155">Buffered body writers can write out their contents any number of times, while streamed ones can write out their contents only once.</span></span> <span data-ttu-id="e60f8-156">`IsBuffered` 属性指示正文编写器是否为缓冲式的。</span><span class="sxs-lookup"><span data-stu-id="e60f8-156">The `IsBuffered` property indicates whether a body writer is buffered or not.</span></span> <span data-ttu-id="e60f8-157">通过调用受保护的 `BodyWriter` 构造函数（该构造函数采用一个 `isBuffered` 布尔参数），可以设置正文编写器的这一属性。</span><span class="sxs-lookup"><span data-stu-id="e60f8-157">You can set this for your body writer by calling the protected `BodyWriter` constructor that takes an `isBuffered` boolean parameter.</span></span> <span data-ttu-id="e60f8-158">正文编写器支持从非缓冲式正文编写器创建缓冲式正文编写器。</span><span class="sxs-lookup"><span data-stu-id="e60f8-158">Body writers support creating a buffered body writer from a non-buffered body writer.</span></span> <span data-ttu-id="e60f8-159">可以重写 `OnCreateBufferedCopy` 方法以自定义此过程。</span><span class="sxs-lookup"><span data-stu-id="e60f8-159">You can override the `OnCreateBufferedCopy` method to customize this process.</span></span> <span data-ttu-id="e60f8-160">默认情况下，使用包含由 `OnWriteBodyContents` 返回的 XML 的内存中缓冲区。</span><span class="sxs-lookup"><span data-stu-id="e60f8-160">By default, an in-memory buffer that contains the XML returned by `OnWriteBodyContents` is used.</span></span> <span data-ttu-id="e60f8-161">`OnCreateBufferedCopy` 采用一个 `maxBufferSize` 整型参数；如果重写此方法，则不得创建大于此最大大小的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="e60f8-161">`OnCreateBufferedCopy` takes a `maxBufferSize` integer parameter; if you override this method, you must not create buffers larger than this maximum size.</span></span>  
  
 <span data-ttu-id="e60f8-162">`BodyWriter` 类提供了 `WriteBodyContents` 和 `CreateBufferedCopy` 方法，这两个方法实质上分别是 `OnWriteBodyContents` 和 `OnCreateBufferedCopy` 方法的瘦包装。</span><span class="sxs-lookup"><span data-stu-id="e60f8-162">The `BodyWriter` class provides the `WriteBodyContents` and `CreateBufferedCopy` methods, which are essentially thin wrappers around `OnWriteBodyContents` and `OnCreateBufferedCopy` methods, respectively.</span></span> <span data-ttu-id="e60f8-163">这些方法执行状态检查，以确保访问非缓冲式正文编写器的次数不会超过一次。</span><span class="sxs-lookup"><span data-stu-id="e60f8-163">These methods perform state checking to ensure that a non-buffered body writer is not accessed more than once.</span></span> <span data-ttu-id="e60f8-164">仅当基于 `Message` 创建自定义 `BodyWriters` 派生类时才直接调用这些方法。</span><span class="sxs-lookup"><span data-stu-id="e60f8-164">These methods are called directly only when creating custom `Message` derived classes based on `BodyWriters`.</span></span>  
  
## <a name="creating-fault-messages"></a><span data-ttu-id="e60f8-165">创建错误消息</span><span class="sxs-lookup"><span data-stu-id="e60f8-165">Creating Fault Messages</span></span>  

 <span data-ttu-id="e60f8-166">可以使用某些 `CreateMessage` 重载创建 SOAP 错误消息。</span><span class="sxs-lookup"><span data-stu-id="e60f8-166">You can use certain `CreateMessage` overloads to create SOAP fault messages.</span></span> <span data-ttu-id="e60f8-167">其中一个最基本的重载采用一个用于描述错误的 <xref:System.ServiceModel.Channels.MessageFault> 对象作为参数。</span><span class="sxs-lookup"><span data-stu-id="e60f8-167">The most basic of these takes a <xref:System.ServiceModel.Channels.MessageFault> object that describes the fault.</span></span> <span data-ttu-id="e60f8-168">其他重载是为方便起见而提供的。</span><span class="sxs-lookup"><span data-stu-id="e60f8-168">Other overloads are provided for convenience.</span></span> <span data-ttu-id="e60f8-169">第一个这样的重载采用一个 `FaultCode` 和一个原因字符串作为参数，并使用 `MessageFault`（该方法使用这些信息）创建一个 `MessageFault.CreateFault`。</span><span class="sxs-lookup"><span data-stu-id="e60f8-169">The first such overload takes a `FaultCode` and a reason string and creates a `MessageFault` using `MessageFault.CreateFault` using this information.</span></span> <span data-ttu-id="e60f8-170">另一个重载采用一个详细信息对象作为参数，并将该对象与错误代码和原因一起传递给 `CreateFault`。</span><span class="sxs-lookup"><span data-stu-id="e60f8-170">The other overload takes a detail object and also passes it to `CreateFault` together with the fault code and the reason.</span></span> <span data-ttu-id="e60f8-171">例如，下面的操作会返回一个错误。</span><span class="sxs-lookup"><span data-stu-id="e60f8-171">For example, the following operation returns a fault.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#4)]
 [!code-vb[C_UsingTheMessageClass#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#4)]  
  
## <a name="extracting-message-body-data"></a><span data-ttu-id="e60f8-172">提取消息正文数据</span><span class="sxs-lookup"><span data-stu-id="e60f8-172">Extracting Message Body Data</span></span>  

 <span data-ttu-id="e60f8-173">`Message` 类支持多种从其正文提取信息的方式。</span><span class="sxs-lookup"><span data-stu-id="e60f8-173">The `Message` class supports multiple ways of extracting information from its body.</span></span> <span data-ttu-id="e60f8-174">它们可分为以下几类：</span><span class="sxs-lookup"><span data-stu-id="e60f8-174">These can be classified into the following categories:</span></span>  
  
- <span data-ttu-id="e60f8-175">将整个消息正文一次性写出到 XML 编写器。</span><span class="sxs-lookup"><span data-stu-id="e60f8-175">Getting the entire message body written out at once to an XML writer.</span></span> <span data-ttu-id="e60f8-176">这称为 " *写入消息*"。</span><span class="sxs-lookup"><span data-stu-id="e60f8-176">This is referred to as *writing a message*.</span></span>  
  
- <span data-ttu-id="e60f8-177">将 XML 读取器放在消息正文上。</span><span class="sxs-lookup"><span data-stu-id="e60f8-177">Getting an XML reader over the message body.</span></span> <span data-ttu-id="e60f8-178">这使您可以在以后根据需要逐段访问消息正文。</span><span class="sxs-lookup"><span data-stu-id="e60f8-178">This enables you to later access the message body piece-by-piece as required.</span></span> <span data-ttu-id="e60f8-179">这称为 " *读取消息*"。</span><span class="sxs-lookup"><span data-stu-id="e60f8-179">This is referred to as *reading a message*.</span></span>  
  
- <span data-ttu-id="e60f8-180">可以将整个消息（包括它的正文）复制到类型为 <xref:System.ServiceModel.Channels.MessageBuffer> 的内存中缓冲区。</span><span class="sxs-lookup"><span data-stu-id="e60f8-180">The entire message, including its body, can be copied to an in-memory buffer of the <xref:System.ServiceModel.Channels.MessageBuffer> type.</span></span> <span data-ttu-id="e60f8-181">这称为 " *复制消息*"。</span><span class="sxs-lookup"><span data-stu-id="e60f8-181">This is referred to as *copying a message*.</span></span>  
  
 <span data-ttu-id="e60f8-182">无论使用哪种访问方式，都只能访问 `Message` 的正文一次。</span><span class="sxs-lookup"><span data-stu-id="e60f8-182">You can access the body of a `Message` only once, regardless of how it is accessed.</span></span> <span data-ttu-id="e60f8-183">消息对象具有 `State` 属性，该属性最初设置为 Created。</span><span class="sxs-lookup"><span data-stu-id="e60f8-183">A message object has a `State` property, which is initially set to Created.</span></span> <span data-ttu-id="e60f8-184">前面列表中描述的三种访问方法分别将状态设置为 Written、Read 和 Copied。</span><span class="sxs-lookup"><span data-stu-id="e60f8-184">The three access methods described in the preceding list set the state to Written, Read, and Copied, respectively.</span></span> <span data-ttu-id="e60f8-185">此外，`Close` 方法可以在不再需要消息正文内容时将状态设置为 Closed。</span><span class="sxs-lookup"><span data-stu-id="e60f8-185">Additionally, a `Close` method can set the state to Closed when the message body contents are no longer required.</span></span> <span data-ttu-id="e60f8-186">只有当消息正文处于 Created 状态时，才能对其进行访问，并且在状态已更改后，无法返回到 Created 状态。</span><span class="sxs-lookup"><span data-stu-id="e60f8-186">The message body can be accessed only in the Created state, and there is no way to go back to the Created state after the state has changed.</span></span>  
  
## <a name="writing-messages"></a><span data-ttu-id="e60f8-187">写入消息</span><span class="sxs-lookup"><span data-stu-id="e60f8-187">Writing Messages</span></span>  

 <span data-ttu-id="e60f8-188"><xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> 方法将给定 `Message` 实例的正文内容写出到给定 XML 编写器。</span><span class="sxs-lookup"><span data-stu-id="e60f8-188">The <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method writes out the body contents of a given `Message` instance to a given XML writer.</span></span> <span data-ttu-id="e60f8-189"><xref:System.ServiceModel.Channels.Message.WriteBody%2A>方法执行相同的工作，只不过它将正文内容封装在适当的包装元素中 (例如 <`soap:body`>) 。</span><span class="sxs-lookup"><span data-stu-id="e60f8-189">The <xref:System.ServiceModel.Channels.Message.WriteBody%2A> method does the same, except that it encloses the body contents in the appropriate wrapper element (for example, <`soap:body`>).</span></span> <span data-ttu-id="e60f8-190">最后，<xref:System.ServiceModel.Channels.Message.WriteMessage%2A> 写出整个消息，包括 SOAP 包装信封和标头。</span><span class="sxs-lookup"><span data-stu-id="e60f8-190">Finally, <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> writes out the entire message, including the wrapping SOAP envelope and the headers.</span></span> <span data-ttu-id="e60f8-191">如果关闭 SOAP (<xref:System.ServiceModel.Channels.Message.Version> <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>) ，这三种方法都执行相同的操作：写出消息正文内容。</span><span class="sxs-lookup"><span data-stu-id="e60f8-191">If SOAP is turned off (<xref:System.ServiceModel.Channels.Message.Version> is <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>), all three methods do the same thing: they write out the message body contents.</span></span>  
  
 <span data-ttu-id="e60f8-192">例如，下面的代码将一个传入消息的正文写出到一个文件中。</span><span class="sxs-lookup"><span data-stu-id="e60f8-192">For example, the following code writes out the body of an incoming message to a file.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#5)]
 [!code-vb[C_UsingTheMessageClass#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#5)]  
  
 <span data-ttu-id="e60f8-193">另有两个帮助器方法可写出某些 SOAP 开始元素标记。</span><span class="sxs-lookup"><span data-stu-id="e60f8-193">Two additional helper methods write out certain SOAP start element tags.</span></span> <span data-ttu-id="e60f8-194">这些方法不访问消息正文，因而不会更改消息状态。</span><span class="sxs-lookup"><span data-stu-id="e60f8-194">These methods do not access the message body and so they do not change the message state.</span></span> <span data-ttu-id="e60f8-195">其中包括:</span><span class="sxs-lookup"><span data-stu-id="e60f8-195">These include:</span></span>  
  
- <span data-ttu-id="e60f8-196"><xref:System.ServiceModel.Channels.Message.WriteStartBody%2A> 可写入开始正文元素，如 `<soap:Body>`。</span><span class="sxs-lookup"><span data-stu-id="e60f8-196"><xref:System.ServiceModel.Channels.Message.WriteStartBody%2A> writes the start body element, for example, `<soap:Body>`.</span></span>  
  
- <span data-ttu-id="e60f8-197"><xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A> 可写入开始信封元素，如 `<soap:Envelope>`。</span><span class="sxs-lookup"><span data-stu-id="e60f8-197"><xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A> writes the start envelope element, for example, `<soap:Envelope>`.</span></span>  
  
 <span data-ttu-id="e60f8-198">若要写入相应的结束元素标记，请对相应的 XML 编写器调用 `WriteEndElement`。</span><span class="sxs-lookup"><span data-stu-id="e60f8-198">To write the corresponding end element tags, call `WriteEndElement` on the corresponding XML writer.</span></span> <span data-ttu-id="e60f8-199">直接调用这些方法的情况极少。</span><span class="sxs-lookup"><span data-stu-id="e60f8-199">These methods are rarely called directly.</span></span>  
  
## <a name="reading-messages"></a><span data-ttu-id="e60f8-200">读取消息</span><span class="sxs-lookup"><span data-stu-id="e60f8-200">Reading Messages</span></span>  

 <span data-ttu-id="e60f8-201">读取消息正文的主要方式是调用 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A>。</span><span class="sxs-lookup"><span data-stu-id="e60f8-201">The primary way to read a message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A>.</span></span> <span data-ttu-id="e60f8-202">您会取回一个 <xref:System.Xml.XmlDictionaryReader> 以便用于读取消息正文。</span><span class="sxs-lookup"><span data-stu-id="e60f8-202">You get back an <xref:System.Xml.XmlDictionaryReader> that you can use to read the message body.</span></span> <span data-ttu-id="e60f8-203">请注意，只要调用了 <xref:System.ServiceModel.Channels.Message>，<xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> 就会转换到 Read 状态，而不是在您使用返回的 XML 读取器时发生转换。</span><span class="sxs-lookup"><span data-stu-id="e60f8-203">Note that the <xref:System.ServiceModel.Channels.Message> transitions to the Read state as soon as <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> is called, and not when you use the returned XML reader.</span></span>  
  
 <span data-ttu-id="e60f8-204">使用 <xref:System.ServiceModel.Channels.Message.GetBody%2A> 方法还可以将消息正文作为类型化对象进行访问。</span><span class="sxs-lookup"><span data-stu-id="e60f8-204">The <xref:System.ServiceModel.Channels.Message.GetBody%2A> method also enables you to access the message body as a typed object.</span></span> <span data-ttu-id="e60f8-205">在内部，此方法使用 `GetReaderAtBodyContents`，因而也会将消息状态转换为 <xref:System.ServiceModel.Channels.MessageState.Read> 状态（请参见 <xref:System.ServiceModel.Channels.Message.State%2A> 属性）。</span><span class="sxs-lookup"><span data-stu-id="e60f8-205">Internally, this method uses `GetReaderAtBodyContents`, and so it also transitions the message state to the <xref:System.ServiceModel.Channels.MessageState.Read> state (see the <xref:System.ServiceModel.Channels.Message.State%2A> property).</span></span>  
  
 <span data-ttu-id="e60f8-206">最好检查一下 <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> 属性，在这种情况下消息正文为空，且 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> 会引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="e60f8-206">It is good practice to check the <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property, in which case the message body is empty and <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> throws an <xref:System.InvalidOperationException>.</span></span> <span data-ttu-id="e60f8-207">同样，如果消息为接收到的消息（如答复），也可能需要检查一下 <xref:System.ServiceModel.Channels.Message.IsFault%2A>，该属性指示消息是否包含错误。</span><span class="sxs-lookup"><span data-stu-id="e60f8-207">Also, if it is a received message (for example, the reply), you may also want to check <xref:System.ServiceModel.Channels.Message.IsFault%2A>, which indicates whether the message contains a fault.</span></span>  
  
 <span data-ttu-id="e60f8-208"><xref:System.ServiceModel.Channels.Message.GetBody%2A> 的最基本的重载使用 <xref:System.Runtime.Serialization.DataContractSerializer>（配置了默认设置且禁用了 <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> 配额）将消息正文反序列化为某个类型（由泛型参数指示）的实例。</span><span class="sxs-lookup"><span data-stu-id="e60f8-208">The most basic overload of <xref:System.ServiceModel.Channels.Message.GetBody%2A> deserializes the message body into an instance of a type (indicated by the generic parameter) using a <xref:System.Runtime.Serialization.DataContractSerializer> configured with the default settings and with the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> quota disabled.</span></span> <span data-ttu-id="e60f8-209">如果想要使用其他序列化引擎，或是通过非默认方式配置 `DataContractSerializer`，请使用采用一个 <xref:System.ServiceModel.Channels.Message.GetBody%2A> 作为参数的 <xref:System.Runtime.Serialization.XmlObjectSerializer> 重载。</span><span class="sxs-lookup"><span data-stu-id="e60f8-209">If you want to use a different serialization engine, or configure the `DataContractSerializer` in a non-default way, use the <xref:System.ServiceModel.Channels.Message.GetBody%2A> overload that takes an <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
 <span data-ttu-id="e60f8-210">例如，下面的代码从包含一个序列化 `Person` 对象的消息正文中提取数据，然后输出人员的姓名。</span><span class="sxs-lookup"><span data-stu-id="e60f8-210">For example, the following code extracts data from a message body that contains a serialized `Person` object and prints out the person’s name.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#6)]
 [!code-vb[C_UsingTheMessageClass#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#6)]  
  
## <a name="copying-a-message-into-a-buffer"></a><span data-ttu-id="e60f8-211">将消息复制到缓冲区中</span><span class="sxs-lookup"><span data-stu-id="e60f8-211">Copying a Message into a Buffer</span></span>  

 <span data-ttu-id="e60f8-212">有时需要不只一次地访问消息正文，例如，作为发行者-订户系统的一部分而将同一消息转发给多个目标。</span><span class="sxs-lookup"><span data-stu-id="e60f8-212">Sometimes it is necessary to access the message body more than once, for example, to forward the same message to multiple destinations as part of a publisher-subscriber system.</span></span> <span data-ttu-id="e60f8-213">在这种情况下，需要在内存中缓冲整个消息（包括正文）。</span><span class="sxs-lookup"><span data-stu-id="e60f8-213">In this case, it is necessary to buffer the entire message (including the body) in memory.</span></span> <span data-ttu-id="e60f8-214">可以通过调用 <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29> 达到此目的。</span><span class="sxs-lookup"><span data-stu-id="e60f8-214">You can do this by calling <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29>.</span></span> <span data-ttu-id="e60f8-215">此方法采用一个表示最大缓冲区大小的整型参数，且创建一个不大于此大小的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="e60f8-215">This method takes an integer parameter that represents the maximum buffer size, and creates a buffer not larger than this size.</span></span> <span data-ttu-id="e60f8-216">如果消息来自不受信任的源，则将此参数设置为安全值是十分重要的。</span><span class="sxs-lookup"><span data-stu-id="e60f8-216">It is important to set this to a safe value if the message is coming from an untrusted source.</span></span>  
  
 <span data-ttu-id="e60f8-217">缓冲区作为一个 <xref:System.ServiceModel.Channels.MessageBuffer> 实例返回。</span><span class="sxs-lookup"><span data-stu-id="e60f8-217">The buffer is returned as a <xref:System.ServiceModel.Channels.MessageBuffer> instance.</span></span> <span data-ttu-id="e60f8-218">可以通过几种方式访问缓冲区中的数据。</span><span class="sxs-lookup"><span data-stu-id="e60f8-218">You can access data in the buffer in several ways.</span></span> <span data-ttu-id="e60f8-219">主要方式是调用 <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> 以便从缓冲区创建 `Message` 实例。</span><span class="sxs-lookup"><span data-stu-id="e60f8-219">The primary way is to call <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> to create `Message` instances from the buffer.</span></span>  
  
 <span data-ttu-id="e60f8-220">访问缓冲区中的数据的另一种方式是实现 <xref:System.Xml.XPath.IXPathNavigable> 接口（<xref:System.ServiceModel.Channels.MessageBuffer> 类实现了该接口以直接访问基础 XML）。</span><span class="sxs-lookup"><span data-stu-id="e60f8-220">Another way to access the data in the buffer is to implement the <xref:System.Xml.XPath.IXPathNavigable> interface that the <xref:System.ServiceModel.Channels.MessageBuffer> class implements to access the underlying XML directly.</span></span> <span data-ttu-id="e60f8-221">使用某些 <xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A> 重载可以创建由节点配额（用于限制可访问的 XML 节点数）保护的 <xref:System.Xml.XPath> 导航器。</span><span class="sxs-lookup"><span data-stu-id="e60f8-221">Some <xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A> overloads allow you to create <xref:System.Xml.XPath> navigators protected by a node quota, limiting the number of XML nodes that can be visited.</span></span> <span data-ttu-id="e60f8-222">这有助于防止通过占用大量处理时间而实施的拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="e60f8-222">This helps prevent denial of service attacks based on lengthy processing time.</span></span> <span data-ttu-id="e60f8-223">默认情况下禁用此配额。</span><span class="sxs-lookup"><span data-stu-id="e60f8-223">This quote is disabled by default.</span></span> <span data-ttu-id="e60f8-224">某些 `CreateNavigator` 重载使您可以使用 <xref:System.Xml.XmlSpace> 枚举来指定应如何处理 XML 中的空白（默认设置为 `XmlSpace.None`）。</span><span class="sxs-lookup"><span data-stu-id="e60f8-224">Some `CreateNavigator` overloads allow you to specify how white space should be handled in the XML using the <xref:System.Xml.XmlSpace> enumeration, with the default being `XmlSpace.None`.</span></span>  
  
 <span data-ttu-id="e60f8-225">访问消息缓冲区内容的最后一种方式是使用 <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> 将缓冲区的内容写出到流中。</span><span class="sxs-lookup"><span data-stu-id="e60f8-225">A final way to access the contents of a message buffer is to write out its contents to a stream using <xref:System.ServiceModel.Channels.Message.WriteMessage%2A>.</span></span>  
  
 <span data-ttu-id="e60f8-226">下面的示例演示使用 `MessageBuffer` 的过程：将一个传入消息转发给多个接收方，然后将其记录到一个文件中。</span><span class="sxs-lookup"><span data-stu-id="e60f8-226">The following example demonstrates the process of working with a `MessageBuffer`: an incoming message is forwarded to multiple recipients, and then logged to a file.</span></span> <span data-ttu-id="e60f8-227">如果不进行缓冲，这将是不可能的，因为消息正文只能被访问一次。</span><span class="sxs-lookup"><span data-stu-id="e60f8-227">Without buffering, this is not possible, because the message body can then be accessed only once.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#7)]
 [!code-vb[C_UsingTheMessageClass#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#7)]  
  
 <span data-ttu-id="e60f8-228">`MessageBuffer` 类还有其他值得注意的成员。</span><span class="sxs-lookup"><span data-stu-id="e60f8-228">The `MessageBuffer` class has other members worth noting.</span></span> <span data-ttu-id="e60f8-229">当不再需要缓冲区内容时，可以调用 <xref:System.ServiceModel.Channels.MessageBuffer.Close%2A> 方法来释放资源。</span><span class="sxs-lookup"><span data-stu-id="e60f8-229">The <xref:System.ServiceModel.Channels.MessageBuffer.Close%2A> method can be called to free resources when the buffer contents are no longer required.</span></span> <span data-ttu-id="e60f8-230"><xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A> 属性返回已分配的缓冲区的大小。</span><span class="sxs-lookup"><span data-stu-id="e60f8-230">The <xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A> property returns the size of the allocated buffer.</span></span> <span data-ttu-id="e60f8-231"><xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A> 属性返回消息的 MIME 内容类型。</span><span class="sxs-lookup"><span data-stu-id="e60f8-231">The <xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A> property returns the MIME content type of the message.</span></span>  
  
## <a name="accessing-the-message-body-for-debugging"></a><span data-ttu-id="e60f8-232">访问消息正文以进行调试</span><span class="sxs-lookup"><span data-stu-id="e60f8-232">Accessing the Message Body for Debugging</span></span>  

 <span data-ttu-id="e60f8-233">出于调试目的，您可以调用 <xref:System.ServiceModel.Channels.Message.ToString%2A> 方法以获取消息的字符串表示。</span><span class="sxs-lookup"><span data-stu-id="e60f8-233">For debugging purposes, you can call the <xref:System.ServiceModel.Channels.Message.ToString%2A> method to get a representation of the message as a string.</span></span> <span data-ttu-id="e60f8-234">如果消息由文本编码器进行编码，则此表示通常与该消息在网络上的表示方式相匹配，只不过 XML 会以更好的格式表示以方便人们阅读。</span><span class="sxs-lookup"><span data-stu-id="e60f8-234">This representation generally matches the way a message would look on the wire if it were encoded with the text encoder, except that the XML would be better formatted for human readability.</span></span> <span data-ttu-id="e60f8-235">一个例外的情况是消息正文。</span><span class="sxs-lookup"><span data-stu-id="e60f8-235">The one exception to this is the message body.</span></span> <span data-ttu-id="e60f8-236">正文只能被读取一次，且 `ToString` 不会更改消息状态。</span><span class="sxs-lookup"><span data-stu-id="e60f8-236">The body can be read only once, and `ToString` does not change the message state.</span></span> <span data-ttu-id="e60f8-237">因此， `ToString` 方法可能无法访问正文，并可能用占位符替换 (例如 "..."或) 三个点，而不是消息正文。</span><span class="sxs-lookup"><span data-stu-id="e60f8-237">Therefore, the `ToString` method might not be able to access the body and might substitute a placeholder (for example, "…" or three dots) instead of the message body.</span></span> <span data-ttu-id="e60f8-238">因此，如果消息的正文内容很重要，则不要使用 `ToString` 来记录消息。</span><span class="sxs-lookup"><span data-stu-id="e60f8-238">Therefore, do not use `ToString` to log messages if the body content of the messages is important.</span></span>  
  
## <a name="accessing-other-message-parts"></a><span data-ttu-id="e60f8-239">访问其他消息部分</span><span class="sxs-lookup"><span data-stu-id="e60f8-239">Accessing Other Message Parts</span></span>  

 <span data-ttu-id="e60f8-240">该类提供了各种属性，以便访问除正文内容之外的其他与消息有关的信息。</span><span class="sxs-lookup"><span data-stu-id="e60f8-240">Various properties are provided to access information about the message other than its body contents.</span></span> <span data-ttu-id="e60f8-241">但是，一旦关闭了消息，将无法调用这些属性：</span><span class="sxs-lookup"><span data-stu-id="e60f8-241">However, these cannot be called once the message has been closed:</span></span>  
  
- <span data-ttu-id="e60f8-242"><xref:System.ServiceModel.Channels.Message.Headers%2A> 属性表示消息头。</span><span class="sxs-lookup"><span data-stu-id="e60f8-242">The <xref:System.ServiceModel.Channels.Message.Headers%2A> property represents the message headers.</span></span> <span data-ttu-id="e60f8-243">请参阅本主题后面的 "使用标头" 一节。</span><span class="sxs-lookup"><span data-stu-id="e60f8-243">See the section on "Working with Headers" later in this topic.</span></span>  
  
- <span data-ttu-id="e60f8-244"><xref:System.ServiceModel.Channels.Message.Properties%2A> 属性表示消息属性，这些属性是附加到消息的命名数据段，且通常不会在发送消息时发出。</span><span class="sxs-lookup"><span data-stu-id="e60f8-244">The <xref:System.ServiceModel.Channels.Message.Properties%2A> property represents the message properties, which are pieces of named data attached to the message that do not generally get emitted when the message is sent.</span></span> <span data-ttu-id="e60f8-245">请参见本主题稍后关于“使用属性”的部分。</span><span class="sxs-lookup"><span data-stu-id="e60f8-245">See the section on "Working with Properties" later in this topic.</span></span>  
  
- <span data-ttu-id="e60f8-246"><xref:System.ServiceModel.Channels.Message.Version%2A> 属性指示与消息相关联的 SOAP 和 WS-Addressing 版本；如果禁用了 SOAP，则该属性为 `None`。</span><span class="sxs-lookup"><span data-stu-id="e60f8-246">The <xref:System.ServiceModel.Channels.Message.Version%2A> property indicates the SOAP and WS-Addressing version associated with the message, or `None` if SOAP is disabled.</span></span>  
  
- <span data-ttu-id="e60f8-247"><xref:System.ServiceModel.Channels.Message.IsFault%2A> 属性在消息为 SOAP 错误消息时返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="e60f8-247">The <xref:System.ServiceModel.Channels.Message.IsFault%2A> property returns `true` if the message is a SOAP fault message.</span></span>  
  
- <span data-ttu-id="e60f8-248"><xref:System.ServiceModel.Channels.Message.IsEmpty%2A> 属性在消息为空时返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="e60f8-248">The <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property returns `true` if the message is empty.</span></span>  
  
 <span data-ttu-id="e60f8-249">可以使用 <xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29> 方法访问正文包装元素（如 `<soap:Body>`）上由特定名称和命名空间标识的特定属性。</span><span class="sxs-lookup"><span data-stu-id="e60f8-249">You can use the <xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29> method to access a particular attribute on the body wrapper element (for example, `<soap:Body>`) identified by a particular name and namespace.</span></span> <span data-ttu-id="e60f8-250">如果未找到这样一个属性，则返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="e60f8-250">If such an attribute is not found, `null` is returned.</span></span> <span data-ttu-id="e60f8-251">仅当 `Message` 处于 Created 状态时（即尚未访问消息正文时），才能调用此方法。</span><span class="sxs-lookup"><span data-stu-id="e60f8-251">This method can be called only when the `Message` is in the Created state (when the message body has not yet been accessed).</span></span>  
  
## <a name="working-with-headers"></a><span data-ttu-id="e60f8-252">使用标头</span><span class="sxs-lookup"><span data-stu-id="e60f8-252">Working with Headers</span></span>  

 <span data-ttu-id="e60f8-253">`Message`可以包含任意数量的命名 XML 片段，这些片段称为 *标头*。</span><span class="sxs-lookup"><span data-stu-id="e60f8-253">A `Message` can contain any number of named XML fragments, called *headers*.</span></span> <span data-ttu-id="e60f8-254">每个片断通常都映射到一个 SOAP 标头。</span><span class="sxs-lookup"><span data-stu-id="e60f8-254">Each fragment normally maps to a SOAP header.</span></span> <span data-ttu-id="e60f8-255">可以通过类型为 `Headers` 的 <xref:System.ServiceModel.Channels.MessageHeaders> 属性来访问标头。</span><span class="sxs-lookup"><span data-stu-id="e60f8-255">Headers are accessed through the `Headers` property of type <xref:System.ServiceModel.Channels.MessageHeaders>.</span></span> <span data-ttu-id="e60f8-256"><xref:System.ServiceModel.Channels.MessageHeaders> 是一个 <xref:System.ServiceModel.Channels.MessageHeaderInfo> 对象集合，可以通过其 <xref:System.Collections.IEnumerable> 接口或其索引器来访问各个标头。</span><span class="sxs-lookup"><span data-stu-id="e60f8-256"><xref:System.ServiceModel.Channels.MessageHeaders> is a collection of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects, and individual headers can be accessed through its <xref:System.Collections.IEnumerable> interface or through its indexer.</span></span> <span data-ttu-id="e60f8-257">例如，下面的代码列出了某个 `Message` 中的所有标头的名称。</span><span class="sxs-lookup"><span data-stu-id="e60f8-257">For example, the following code lists the names of all the headers in a `Message`.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#8)]
 [!code-vb[C_UsingTheMessageClass#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#8)]  
  
#### <a name="adding-removing-finding-headers"></a><span data-ttu-id="e60f8-258">添加、删除、查找标头</span><span class="sxs-lookup"><span data-stu-id="e60f8-258">Adding, Removing, Finding Headers</span></span>  

 <span data-ttu-id="e60f8-259">可以使用 <xref:System.ServiceModel.Channels.MessageHeaders.Add%2A> 方法在所有现有标头的末尾添加新的标头。</span><span class="sxs-lookup"><span data-stu-id="e60f8-259">You can add a new header at the end of all existing headers using the <xref:System.ServiceModel.Channels.MessageHeaders.Add%2A> method.</span></span> <span data-ttu-id="e60f8-260">可以使用 <xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A> 方法在特定索引处插入标头。</span><span class="sxs-lookup"><span data-stu-id="e60f8-260">You can use the <xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A> method to insert a header at a particular index.</span></span> <span data-ttu-id="e60f8-261">现有标头会发生位移，以便为插入的项腾出位置。</span><span class="sxs-lookup"><span data-stu-id="e60f8-261">Existing headers are shifted for the inserted item.</span></span> <span data-ttu-id="e60f8-262">标头按照其索引进行排序，并且第一个可用索引为 0。</span><span class="sxs-lookup"><span data-stu-id="e60f8-262">Headers are ordered according to their index, and the first available index is 0.</span></span> <span data-ttu-id="e60f8-263">您可以使用各种 <xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A> 方法重载添加其他 `Message` 或 `MessageHeaders` 实例的标头。</span><span class="sxs-lookup"><span data-stu-id="e60f8-263">You can use the various <xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A> method overloads to add headers from a different `Message` or `MessageHeaders` instance.</span></span> <span data-ttu-id="e60f8-264">某些重载复制单个标头，而其他重载则复制所有标头。</span><span class="sxs-lookup"><span data-stu-id="e60f8-264">Some overloads copy one individual header, while others copy all of them.</span></span> <span data-ttu-id="e60f8-265"><xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A> 方法可以删除所有标头。</span><span class="sxs-lookup"><span data-stu-id="e60f8-265">The <xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A> method removes all headers.</span></span> <span data-ttu-id="e60f8-266"><xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A> 方法可以删除位于特定索引处的标头（并且位移该标头之后的所有标头）。</span><span class="sxs-lookup"><span data-stu-id="e60f8-266">The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A> method removes a header at a particular index (shifting all headers after it).</span></span> <span data-ttu-id="e60f8-267"><xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A> 方法可以删除具有特定名称和命名空间的所有标头。</span><span class="sxs-lookup"><span data-stu-id="e60f8-267">The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A> method removes all headers with a particular name and namespace.</span></span>  
  
 <span data-ttu-id="e60f8-268">使用 <xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A> 方法检索特定标头。</span><span class="sxs-lookup"><span data-stu-id="e60f8-268">Retrieve a particular header using the <xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A> method.</span></span> <span data-ttu-id="e60f8-269">此方法采用要查找的标头的名称和命名空间作为参数，并返回该标头的索引。</span><span class="sxs-lookup"><span data-stu-id="e60f8-269">This method takes the name and namespace of the header to find, and returns its index.</span></span> <span data-ttu-id="e60f8-270">如果该标头出现了多次，则引发异常。</span><span class="sxs-lookup"><span data-stu-id="e60f8-270">If the header occurs more than once, an exception is thrown.</span></span> <span data-ttu-id="e60f8-271">如果未找到该标头，则返回 –1。</span><span class="sxs-lookup"><span data-stu-id="e60f8-271">If the header is not found, it returns -1.</span></span>  
  
 <span data-ttu-id="e60f8-272">在 SOAP 标头模型中，标头可以具有一个 `Actor` 值，该值指定标头的预期接收方。</span><span class="sxs-lookup"><span data-stu-id="e60f8-272">In the SOAP header model, headers can have an `Actor` value that specifies the intended recipient of the header.</span></span> <span data-ttu-id="e60f8-273">最基本的 `FindHeader` 重载仅搜索准备发送给消息的最终接收方的标头。</span><span class="sxs-lookup"><span data-stu-id="e60f8-273">The most basic `FindHeader` overload searches only headers intended for the ultimate receiver of the message.</span></span> <span data-ttu-id="e60f8-274">但是，使用另一个重载可以指定搜索中包括哪些 `Actor` 值。</span><span class="sxs-lookup"><span data-stu-id="e60f8-274">However, another overload enables you to specify which `Actor` values are included in the search.</span></span> <span data-ttu-id="e60f8-275">有关详细信息，请参阅 SOAP 规范。</span><span class="sxs-lookup"><span data-stu-id="e60f8-275">For more information, see the SOAP specification.</span></span>  
  
 <span data-ttu-id="e60f8-276">提供了 <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> 方法，以便将标头从 <xref:System.ServiceModel.Channels.MessageHeaders> 集合复制到 <xref:System.ServiceModel.Channels.MessageHeaderInfo> 对象数组。</span><span class="sxs-lookup"><span data-stu-id="e60f8-276">A <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> method is provided to copy headers from a <xref:System.ServiceModel.Channels.MessageHeaders> collection to an array of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects.</span></span>  
  
 <span data-ttu-id="e60f8-277">若要访问标头中的 XML 数据，可以调用 <xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A>，并为特定标头索引返回一个 XML 读取器。</span><span class="sxs-lookup"><span data-stu-id="e60f8-277">To access the XML data in a header, you can call <xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A> and return an XML reader for the specific header index.</span></span> <span data-ttu-id="e60f8-278">如果您希望将标头内容反序列化为对象，请使用 <xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29> 或其他重载之一。</span><span class="sxs-lookup"><span data-stu-id="e60f8-278">If you want to deserialize the header contents into an object, use <xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29> or one of the other overloads.</span></span> <span data-ttu-id="e60f8-279">最基本的重载使用以默认方式配置的 <xref:System.Runtime.Serialization.DataContractSerializer> 来反序列化标头。</span><span class="sxs-lookup"><span data-stu-id="e60f8-279">The most basic overloads deserialize headers using the <xref:System.Runtime.Serialization.DataContractSerializer> configured in the default way.</span></span> <span data-ttu-id="e60f8-280">如果您希望使用其他序列化程序或 `DataContractSerializer` 的其他配置，请使用采用一个 `XmlObjectSerializer` 作为参数的重载之一。</span><span class="sxs-lookup"><span data-stu-id="e60f8-280">If you want to use a different serializer or a different configuration of the `DataContractSerializer`, use one of the overloads that take an `XmlObjectSerializer`.</span></span> <span data-ttu-id="e60f8-281">还有一些重载采用标头名称、命名空间作为参数，还可能采用一个 `Actor` 值列表而不是一个索引作为参数；这种重载是 `FindHeader` 和 `GetHeader` 的组合。</span><span class="sxs-lookup"><span data-stu-id="e60f8-281">There are also overloads that take the header name, namespace, and optionally a list of `Actor` values instead of an index; this is a combination of `FindHeader` and `GetHeader`.</span></span>  
  
## <a name="working-with-properties"></a><span data-ttu-id="e60f8-282">使用属性</span><span class="sxs-lookup"><span data-stu-id="e60f8-282">Working with Properties</span></span>  

 <span data-ttu-id="e60f8-283">一个 `Message` 实例可以包含任意多个具有任意类型的命名对象。</span><span class="sxs-lookup"><span data-stu-id="e60f8-283">A `Message` instance can contain an arbitrary number of named objects of arbitrary types.</span></span> <span data-ttu-id="e60f8-284">此集合可以通过类型为 `Properties` 的 `MessageProperties` 属性访问。</span><span class="sxs-lookup"><span data-stu-id="e60f8-284">This collection is accessed through the `Properties` property of type `MessageProperties`.</span></span> <span data-ttu-id="e60f8-285">此集合实现了 <xref:System.Collections.Generic.IDictionary%602> 接口，并充当从 <xref:System.String> 到 <xref:System.Object> 的映射。</span><span class="sxs-lookup"><span data-stu-id="e60f8-285">The collection implements the <xref:System.Collections.Generic.IDictionary%602> interface and acts as a mapping from <xref:System.String> to <xref:System.Object>.</span></span> <span data-ttu-id="e60f8-286">通常情况下，属性值不会直接映射到线路上的任何消息部分，而是向 WCF 通道堆栈或服务框架中的各种通道提供各种消息处理提示 <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> 。</span><span class="sxs-lookup"><span data-stu-id="e60f8-286">Normally, property values do not map directly to any part of the message on the wire, but rather provide various message processing hints to the various channels in the WCF channel stack or to the <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> service framework.</span></span> <span data-ttu-id="e60f8-287">有关示例，请参阅 [数据传输体系结构概述](data-transfer-architectural-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e60f8-287">For an example, see [Data Transfer Architectural Overview](data-transfer-architectural-overview.md).</span></span>  
  
## <a name="inheriting-from-the-message-class"></a><span data-ttu-id="e60f8-288">从 Message 类继承</span><span class="sxs-lookup"><span data-stu-id="e60f8-288">Inheriting from the Message Class</span></span>  

 <span data-ttu-id="e60f8-289">如果使用 `CreateMessage` 创建的内置消息类型不能满足您的要求，请创建一个从 `Message` 类派生的类。</span><span class="sxs-lookup"><span data-stu-id="e60f8-289">If the built-in message types created using `CreateMessage` do not meet your requirements, create a class that derives from the `Message` class.</span></span>  
  
### <a name="defining-the-message-body-contents"></a><span data-ttu-id="e60f8-290">定义消息正文内容</span><span class="sxs-lookup"><span data-stu-id="e60f8-290">Defining the Message Body Contents</span></span>  

 <span data-ttu-id="e60f8-291">用于访问消息正文中的数据的技术主要有三种：写入、读取消息正文以及将其复制到缓冲区。</span><span class="sxs-lookup"><span data-stu-id="e60f8-291">Three primary techniques exist for accessing data within a message body: writing, reading, and copying it to a buffer.</span></span> <span data-ttu-id="e60f8-292">这些操作最终分别导致对 <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> 的派生类调用 <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A>、<xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> 和 `Message` 方法。</span><span class="sxs-lookup"><span data-stu-id="e60f8-292">These operations ultimately result in the <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A>, and <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> methods being called, respectively, on your derived class of `Message`.</span></span> <span data-ttu-id="e60f8-293">`Message` 基类保证对于每个 `Message` 实例仅调用这些方法中的一个，并保证每个方法的调用不会超过一次。</span><span class="sxs-lookup"><span data-stu-id="e60f8-293">The base `Message` class guarantees that only one of these methods is called for each `Message` instance, and that it is not called more than once.</span></span> <span data-ttu-id="e60f8-294">该基类还确保不会对已关闭的消息调用这些方法。</span><span class="sxs-lookup"><span data-stu-id="e60f8-294">The base class also ensures that the methods are not called on a closed message.</span></span> <span data-ttu-id="e60f8-295">在您的实现中，无需跟踪消息状态。</span><span class="sxs-lookup"><span data-stu-id="e60f8-295">There is no need to track the message state in your implementation.</span></span>  
  
 <span data-ttu-id="e60f8-296"><xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> 是一个抽象方法，必须加以实现。</span><span class="sxs-lookup"><span data-stu-id="e60f8-296"><xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> is an abstract method and must be implemented.</span></span> <span data-ttu-id="e60f8-297">定义消息正文内容的最基本的方式是使用此方法执行写入操作。</span><span class="sxs-lookup"><span data-stu-id="e60f8-297">The most basic way to define the body contents of your message is to write using this method.</span></span> <span data-ttu-id="e60f8-298">例如，下面的消息包含 100,000 个介于 1 到 20 之间的随机数。</span><span class="sxs-lookup"><span data-stu-id="e60f8-298">For example, the following message contains 100,000 random numbers from 1 to 20.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#9)]
 [!code-vb[C_UsingTheMessageClass#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#9)]  
  
 <span data-ttu-id="e60f8-299"><xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> 和 <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> 方法具有适用于大多数情况的默认实现。</span><span class="sxs-lookup"><span data-stu-id="e60f8-299">The <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> and <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> methods have default implementations that work for most cases.</span></span> <span data-ttu-id="e60f8-300">这些默认实现调用 <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>，对结果进行缓冲，并且使用得到的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="e60f8-300">The default implementations call <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, buffer the results, and work with the resulting buffer.</span></span> <span data-ttu-id="e60f8-301">但是，在某些情况下，这可能还无法满足需要。</span><span class="sxs-lookup"><span data-stu-id="e60f8-301">However, in some cases this may not be enough.</span></span> <span data-ttu-id="e60f8-302">在前面的示例中，读取消息会导致 100,000 个 XML 元素被缓冲，这可能并不是理想的结果。</span><span class="sxs-lookup"><span data-stu-id="e60f8-302">In the preceding example, reading the message results in 100,000 XML elements being buffered, which might not be desirable.</span></span> <span data-ttu-id="e60f8-303">您可能希望重写 <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> 以返回能够提供随机数的自定义 <xref:System.Xml.XmlDictionaryReader> 派生类。</span><span class="sxs-lookup"><span data-stu-id="e60f8-303">You might want to override <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> to return a custom <xref:System.Xml.XmlDictionaryReader> derived class that serves up random numbers.</span></span> <span data-ttu-id="e60f8-304">然后，可以重写 <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> 以使用该方法返回的读取器 <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> ，如下面的示例中所示。</span><span class="sxs-lookup"><span data-stu-id="e60f8-304">You can then override <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> to use the reader that the <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents> method returns, as shown in the following example.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#10)]
 [!code-vb[C_UsingTheMessageClass#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#10)]  
  
 <span data-ttu-id="e60f8-305">与此类似，您可能希望重写 `OnCreateBufferedCopy` 以返回您自己的 `MessageBuffer` 派生类。</span><span class="sxs-lookup"><span data-stu-id="e60f8-305">Similarly, you might want to override `OnCreateBufferedCopy` to return your own `MessageBuffer` derived class.</span></span>  
  
 <span data-ttu-id="e60f8-306">除了提供消息正文内容以外，您的消息派生类还必须重写 `Version`、`Headers` 和 `Properties` 属性。</span><span class="sxs-lookup"><span data-stu-id="e60f8-306">In addition to providing message body contents, your message derived class must also override the `Version`, `Headers`, and `Properties` properties.</span></span>  
  
 <span data-ttu-id="e60f8-307">请注意，如果您创建消息的副本，则该副本将使用原始消息中的消息头。</span><span class="sxs-lookup"><span data-stu-id="e60f8-307">Note that if you create a copy of a message, the copy uses the message headers from the original.</span></span>  
  
### <a name="other-members-that-can-be-overridden"></a><span data-ttu-id="e60f8-308">其他可以重写的成员</span><span class="sxs-lookup"><span data-stu-id="e60f8-308">Other Members that Can Be Overridden</span></span>  

 <span data-ttu-id="e60f8-309">您可以重写 <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A> 、 <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A> 和 <xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A> 方法，以指定如何写出 SOAP 信封、soap 标头和 soap 正文元素开始标记。它们通常对应于 `<soap:Envelope>` 、 `<soap:Header>` 和 `<soap:Body>` 。</span><span class="sxs-lookup"><span data-stu-id="e60f8-309">You can override the <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A> methods to specify how the SOAP envelope, SOAP headers, and SOAP body element start tags are written out. These normally correspond to `<soap:Envelope>`, `<soap:Header>`, and `<soap:Body>`.</span></span> <span data-ttu-id="e60f8-310">如果 <xref:System.ServiceModel.Channels.Message.Version> 属性返回 <xref:System.ServiceModel.Channels.MessageVersion.None>，则这些方法通常不应该写出任何内容。</span><span class="sxs-lookup"><span data-stu-id="e60f8-310">These methods should normally not write anything out if the <xref:System.ServiceModel.Channels.Message.Version> property returns <xref:System.ServiceModel.Channels.MessageVersion.None>.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e60f8-311">`OnGetReaderAtBodyContents` 的默认实现在调用 `OnWriteStartEnvelope` 以及缓冲结果之前调用 `OnWriteStartBody` 和 `OnWriteBodyContents`。</span><span class="sxs-lookup"><span data-stu-id="e60f8-311">The default implementation of `OnGetReaderAtBodyContents` calls `OnWriteStartEnvelope` and `OnWriteStartBody` before calling `OnWriteBodyContents` and buffering the results.</span></span> <span data-ttu-id="e60f8-312">标头不会写出。</span><span class="sxs-lookup"><span data-stu-id="e60f8-312">Headers are not written out.</span></span>  
  
 <span data-ttu-id="e60f8-313">重写 <xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A> 方法可更改从消息的各个片段构造整个消息的方式。</span><span class="sxs-lookup"><span data-stu-id="e60f8-313">Override the <xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A> method to change the way the entire message is constructed from its various pieces.</span></span> <span data-ttu-id="e60f8-314">`OnWriteMessage` 方法是从 <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> 以及默认 <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> 实现中调用的。</span><span class="sxs-lookup"><span data-stu-id="e60f8-314">The `OnWriteMessage` method is called from <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> and from the default <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> implementation.</span></span> <span data-ttu-id="e60f8-315">请注意，重写 <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> 不是最佳做法。</span><span class="sxs-lookup"><span data-stu-id="e60f8-315">Note that overriding <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> is not a best practice.</span></span> <span data-ttu-id="e60f8-316">更好的做法是重写适当的 `On` 方法（例如，<xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>、<xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A> 和 <xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A>）。</span><span class="sxs-lookup"><span data-stu-id="e60f8-316">It is better to override the appropriate `On` methods (for example, <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A>.</span></span>  
  
 <span data-ttu-id="e60f8-317">重写 <xref:System.ServiceModel.Channels.Message.OnBodyToString%2A> 可以重写在调试期间表示消息正文的方式。</span><span class="sxs-lookup"><span data-stu-id="e60f8-317">Override <xref:System.ServiceModel.Channels.Message.OnBodyToString%2A> to override how your message body is represented during debugging.</span></span> <span data-ttu-id="e60f8-318">默认方式是将消息正文表示为三个点（“…”）。</span><span class="sxs-lookup"><span data-stu-id="e60f8-318">The default is to represent it as three dots ("…").</span></span> <span data-ttu-id="e60f8-319">请注意，当消息处于除 Closed 之外的任何状态时，可以多次调用此方法。</span><span class="sxs-lookup"><span data-stu-id="e60f8-319">Note that this method can be called multiple times when the message state is anything other than Closed.</span></span> <span data-ttu-id="e60f8-320">此方法的实现在任何情况下都不应产生必须仅执行一次的操作（如从只进的流中读取）。</span><span class="sxs-lookup"><span data-stu-id="e60f8-320">An implementation of this method should never cause any action that must be performed only once (such as reading from a forward-only stream).</span></span>  
  
 <span data-ttu-id="e60f8-321">重写 <xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A> 方法可以对 SOAP 正文元素上的属性进行访问。</span><span class="sxs-lookup"><span data-stu-id="e60f8-321">Override the <xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A> method to allow access to attributes on the SOAP body element.</span></span> <span data-ttu-id="e60f8-322">此方法可以调用任意次，但 `Message` 基类型保证仅当消息处于 Created 状态时才调用此方法。</span><span class="sxs-lookup"><span data-stu-id="e60f8-322">This method can be called any number of times, but the `Message` base type guarantees that it is only called when the message is in the Created state.</span></span> <span data-ttu-id="e60f8-323">在实现中不需要检查状态。</span><span class="sxs-lookup"><span data-stu-id="e60f8-323">It is not required to check the state in an implementation.</span></span> <span data-ttu-id="e60f8-324">默认实现始终返回 `null`，这指示正文元素上不存在任何属性。</span><span class="sxs-lookup"><span data-stu-id="e60f8-324">The default implementation always returns `null`, which indicates that there are no attributes on the body element.</span></span>  
  
 <span data-ttu-id="e60f8-325">如果 `Message` 对象必须在不再需要消息正文时执行任何特殊的清理操作，则可以重写 <xref:System.ServiceModel.Channels.Message.OnClose%2A>。</span><span class="sxs-lookup"><span data-stu-id="e60f8-325">If your `Message` object must do any special cleanup when the message body is no longer required, you can override <xref:System.ServiceModel.Channels.Message.OnClose%2A>.</span></span> <span data-ttu-id="e60f8-326">默认实现不执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="e60f8-326">The default implementation does nothing.</span></span>  
  
 <span data-ttu-id="e60f8-327">`IsEmpty` 和 `IsFault` 属性可以重写。</span><span class="sxs-lookup"><span data-stu-id="e60f8-327">The `IsEmpty` and `IsFault` properties can be overridden.</span></span> <span data-ttu-id="e60f8-328">默认情况下，这两个属性都返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="e60f8-328">By default, both return `false`.</span></span>
