---
title: 限制消息分布
ms.date: 03/30/2017
ms.assetid: 8b5ec4b8-1ce9-45ef-bb90-2c840456bcc1
ms.openlocfilehash: e736aba60d7d2b39d1b8eb958a8c72e6e8d55e13
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/15/2020
ms.locfileid: "90555011"
---
# <a name="limiting-message-distribution"></a><span data-ttu-id="de08c-102">限制消息分布</span><span class="sxs-lookup"><span data-stu-id="de08c-102">Limiting Message Distribution</span></span>

<span data-ttu-id="de08c-103">对等通道设计为一个广播网格。</span><span class="sxs-lookup"><span data-stu-id="de08c-103">Peer Channel is by design a broadcast mesh.</span></span> <span data-ttu-id="de08c-104">其基本洪泛模型实现以下操作：将任意网格成员发送的每条消息均分发给该网格的所有其他成员。</span><span class="sxs-lookup"><span data-stu-id="de08c-104">Its basic flooding model involves distributing each message sent by any member of a mesh to all other members of that mesh.</span></span> <span data-ttu-id="de08c-105">在某个成员生成的每条消息都与所有其他成员相关且对他们有用的情况下（例如聊天室），这是一个理想的模型。</span><span class="sxs-lookup"><span data-stu-id="de08c-105">This is ideal in situations where every message generated by a member is relevant and useful to all other members (for example, a chat room).</span></span> <span data-ttu-id="de08c-106">但是，许多应用程序偶尔需要限制消息分发。</span><span class="sxs-lookup"><span data-stu-id="de08c-106">However, many applications have an occasional need for limiting message distribution.</span></span> <span data-ttu-id="de08c-107">例如，如果一个新成员加入网格，希望检索通过网格发送的最后一条消息，则无需将此请求群发给该网格的每个成员。</span><span class="sxs-lookup"><span data-stu-id="de08c-107">For example, if a new member joins a mesh and wants to retrieve the last message sent through the mesh, this request does not need to be flooded to every member of the mesh.</span></span> <span data-ttu-id="de08c-108">该请求可能会被限制为附近邻居，或可以筛选出本地生成的消息。还可以将消息发送到网格中的单个节点。</span><span class="sxs-lookup"><span data-stu-id="de08c-108">The request could be limited to near neighbors, or locally generated messages can be filtered out. Messages can also be sent to an individual node on the mesh.</span></span> <span data-ttu-id="de08c-109">本主题讨论如何使用跃点计数、消息传播筛选器、本地筛选器或直接连接来控制通过网格转发消息的方式，并提供有关方式选择的通用准则。</span><span class="sxs-lookup"><span data-stu-id="de08c-109">This topic discusses using Hop Count, a Message Propagation Filter, a local filter, or a direct connection to control how messages are forwarded throughout the mesh, and provides general guidelines for choosing an approach.</span></span>

## <a name="hop-counts"></a><span data-ttu-id="de08c-110">跃点计数</span><span class="sxs-lookup"><span data-stu-id="de08c-110">Hop Counts</span></span>

<span data-ttu-id="de08c-111">`PeerHopCount` 的概念与 IP 协议中使用的 TTL（生存时间）类似。</span><span class="sxs-lookup"><span data-stu-id="de08c-111">The concept of `PeerHopCount` is similar to TTL (Time-To-Live) used in IP protocol.</span></span> <span data-ttu-id="de08c-112">`PeerHopCount` 的值绑定到消息实例，该值指定在丢弃消息之前应转发多少次。</span><span class="sxs-lookup"><span data-stu-id="de08c-112">The value of `PeerHopCount` is tied to a message instance, and it specifies how many times a message should be forwarded before being dropped.</span></span> <span data-ttu-id="de08c-113">对等通道客户端每次收到消息时，都会检查该消息，确定是否指定有 `PeerHopCount`。</span><span class="sxs-lookup"><span data-stu-id="de08c-113">Each time a message is received by a Peer Channel client, the client examines the message to see if `PeerHopCount` is specified.</span></span> <span data-ttu-id="de08c-114">如果已指定，则客户端会将跃点计数值减去一，然后再将消息转发给相邻节点。</span><span class="sxs-lookup"><span data-stu-id="de08c-114">If it is specified, then the client decrements the hop count value by one before forwarding the message to neighboring nodes.</span></span> <span data-ttu-id="de08c-115">客户端在收到跃点计数值为零的消息时，将处理该消息，但不转发给邻居。</span><span class="sxs-lookup"><span data-stu-id="de08c-115">When a client receives a message with a hop count value of zero, the client processes the message, but does not forward the message to neighbors.</span></span>

<span data-ttu-id="de08c-116">可以通过将 `PeerHopCount` 作为属性 (attribute) 添加到邮件类实现中适用的属性 (property) 或字段中，来将跃点计数添加到消息中。</span><span class="sxs-lookup"><span data-stu-id="de08c-116">Hop count may be added to a message by adding `PeerHopCount` as an attribute to the applicable property or field in the implementation of the message class.</span></span> <span data-ttu-id="de08c-117">在将消息发送到网格之前，可以将该属性 (Property) 或字段设置为特定值。</span><span class="sxs-lookup"><span data-stu-id="de08c-117">You can set this to a specific value before sending the message to the mesh.</span></span> <span data-ttu-id="de08c-118">这样，您可以根据需要使用跃点计数来限制消息在整个网格内的分发，潜在避免不必要的消息复制。</span><span class="sxs-lookup"><span data-stu-id="de08c-118">In this manner, you can use hop count to limit distribution of messages throughout the mesh when necessary, potentially avoiding unnecessary message duplication.</span></span> <span data-ttu-id="de08c-119">当网格包含大量的冗余数据，或者将消息发送到近邻或相距几个跃点的邻居时，这是很有用的。</span><span class="sxs-lookup"><span data-stu-id="de08c-119">This is useful in cases where the mesh contains a high amount of redundant data, or for sending a message to immediate neighbors, or neighbors within a few hops.</span></span>

- <span data-ttu-id="de08c-120">有关代码段和相关信息，请参阅对等通道博客上的 [PeerHopCount 属性：控制消息分发](/archive/blogs/peerchan/the-peerhopcount-attribute-controlling-message-distribution) 公告。</span><span class="sxs-lookup"><span data-stu-id="de08c-120">For code snippets and related information, see the [The PeerHopCount Attribute: Controlling Message Distribution](/archive/blogs/peerchan/the-peerhopcount-attribute-controlling-message-distribution) post on the Peer Channel blog.</span></span>

## <a name="message-propagation-filter"></a><span data-ttu-id="de08c-121">消息传播筛选器</span><span class="sxs-lookup"><span data-stu-id="de08c-121">Message Propagation Filter</span></span>

<span data-ttu-id="de08c-122">`MessagePropagationFilter` 可以用于消息洪泛的自定义控制，尤其是在消息内容或其他特定方案确定传播时。</span><span class="sxs-lookup"><span data-stu-id="de08c-122">`MessagePropagationFilter` can be used for customized control of message flooding, especially when the content of the message or other specific scenarios determine propagation.</span></span> <span data-ttu-id="de08c-123">筛选器为通过节点的每个消息做出传播决定。</span><span class="sxs-lookup"><span data-stu-id="de08c-123">The filter makes propagation decisions for every message that passes through the node.</span></span> <span data-ttu-id="de08c-124">对于您的节点收到的产生自网格中其他位置的消息，以及您的应用程序创建的消息，就是这样做出决定的。</span><span class="sxs-lookup"><span data-stu-id="de08c-124">This is true for messages that originated elsewhere in the mesh that your node has received as well as messages created by your application.</span></span> <span data-ttu-id="de08c-125">筛选器可以访问消息及其来源，因此可以基于可用的完整信息做出有关转发或丢弃消息的决定。</span><span class="sxs-lookup"><span data-stu-id="de08c-125">The filter has access to both the message and its origination, so decisions about forwarding or dropping the message can be based on the full information available.</span></span>

<span data-ttu-id="de08c-126"><xref:System.ServiceModel.PeerMessagePropagationFilter> 是具有单个函数 <xref:System.ServiceModel.PeerMessagePropagationFilter.ShouldMessagePropagate%2A> 的抽象基类。</span><span class="sxs-lookup"><span data-stu-id="de08c-126"><xref:System.ServiceModel.PeerMessagePropagationFilter> is a base abstract class with a single function, <xref:System.ServiceModel.PeerMessagePropagationFilter.ShouldMessagePropagate%2A>.</span></span> <span data-ttu-id="de08c-127">方法调用的第一个参数传入消息的完整副本。</span><span class="sxs-lookup"><span data-stu-id="de08c-127">The first argument of the method call passes in a full copy of the message.</span></span> <span data-ttu-id="de08c-128">对消息所做的任何更改都不会影响实际的消息。</span><span class="sxs-lookup"><span data-stu-id="de08c-128">Any changes made to the message do not affect the actual message.</span></span> <span data-ttu-id="de08c-129">方法调用的最后一个自变量标识消息的源（`PeerMessageOrigination.Local` 或 `PeerMessageOrigination.Remote`）。</span><span class="sxs-lookup"><span data-stu-id="de08c-129">The last argument of the method call identifies the origin of the message (`PeerMessageOrigination.Local` or `PeerMessageOrigination.Remote`).</span></span> <span data-ttu-id="de08c-130">此方法的具体实现必须从 <xref:System.ServiceModel.PeerMessagePropagation> 枚举返回一个常量，以表示消息是要转发给本地应用程序 (`Local`)、转发给远程客户端 (`Remote`)、同时转发给本地应用程序和远程客户端 (`LocalAndRemote`)，还是均不转发 (`None`)。</span><span class="sxs-lookup"><span data-stu-id="de08c-130">Concrete implementations of this method must return a constant from the <xref:System.ServiceModel.PeerMessagePropagation> enumeration indicating that the message is to be forwarded to the local application (`Local`), forwarded to remote clients (`Remote`), both (`LocalAndRemote`), or neither (`None`).</span></span> <span data-ttu-id="de08c-131">可以通过访问对应的 `PeerNode` 对象，并在 `PeerNode.MessagePropagationFilter` 属性中指定所派生传播筛选器类的实例，来应用此筛选器。</span><span class="sxs-lookup"><span data-stu-id="de08c-131">This filter can be applied by accessing the corresponding `PeerNode` object and specifying an instance of the derived propagation filter class in the `PeerNode.MessagePropagationFilter` property.</span></span> <span data-ttu-id="de08c-132">请确保在打开对等通道之前附加传播筛选器。</span><span class="sxs-lookup"><span data-stu-id="de08c-132">Ensure that the propagation filter is attached before opening the Peer Channel.</span></span>

- <span data-ttu-id="de08c-133">有关代码段和相关信息，请参阅对等通道博客上的 [对等通道和 MessagePropagationFilter](/archive/blogs/peerchan/peer-channel-and-messagepropagationfilter) 公告。</span><span class="sxs-lookup"><span data-stu-id="de08c-133">For code snippets and related information, see the [Peer Channel and MessagePropagationFilter](/archive/blogs/peerchan/peer-channel-and-messagepropagationfilter) post on the Peer Channel blog.</span></span>

## <a name="contacting-an-individual-node-in-the-mesh"></a><span data-ttu-id="de08c-134">与网格中的单个节点联系</span><span class="sxs-lookup"><span data-stu-id="de08c-134">Contacting an Individual Node in the Mesh</span></span>

<span data-ttu-id="de08c-135">通过设置本地筛选器或直接连接，可以与网格中的单个节点联系。</span><span class="sxs-lookup"><span data-stu-id="de08c-135">An individual node in a mesh can be contacted by setting up a local filter, or by setting up a direct connection.</span></span>

<span data-ttu-id="de08c-136">如果网格中的每个节点均具有自己的 ID，则可以在消息的实现中指定一个目标 ID。</span><span class="sxs-lookup"><span data-stu-id="de08c-136">If the nodes in a mesh each have an individual ID, a destination ID can be specified in the implementation of your message.</span></span> <span data-ttu-id="de08c-137">可以通过在消息协定中编写一个这样的函数来设置本地筛选器：仅当消息的 ID 与指定的目标 ID 匹配时，才向当前节点显示该消息。</span><span class="sxs-lookup"><span data-stu-id="de08c-137">A local filter can be set up by writing a function in your message contract that will only display the message to the current node if its ID matches the destination ID you specified.</span></span> <span data-ttu-id="de08c-138">这样网格在传输消息时，无需产生设置新连接的开销。</span><span class="sxs-lookup"><span data-stu-id="de08c-138">The mesh transports the message, so the overhead of setting up a new connection does not have to be incurred.</span></span> <span data-ttu-id="de08c-139">但是，由于在整个网格中多次发送消息，因此存在效率损耗。</span><span class="sxs-lookup"><span data-stu-id="de08c-139">However, there is a loss of efficiency since the message is sent many times throughout the mesh.</span></span> <span data-ttu-id="de08c-140">只要消息既不过大也不过于频繁，这很适合将消息发送给网格的各个成员。</span><span class="sxs-lookup"><span data-stu-id="de08c-140">This works well for sending messages to individual members of a mesh as long as the messages are neither too big nor too frequent.</span></span>

<span data-ttu-id="de08c-141">对于持续时间很长的高带宽连接，直接连接更为可取。</span><span class="sxs-lookup"><span data-stu-id="de08c-141">For long-lasting, high-bandwidth connections, direct connections are preferable.</span></span> <span data-ttu-id="de08c-142">您可以通过网格发送连接信息，然后在选择发送/接收消息时设置一个直接连接。</span><span class="sxs-lookup"><span data-stu-id="de08c-142">You can send connection information over the mesh, and then set up a direct connection of your choosing to send/receive messages.</span></span>

## <a name="choosing-an-approach-for-limiting-message-distribution"></a><span data-ttu-id="de08c-143">选择用于限制消息分发的方法</span><span class="sxs-lookup"><span data-stu-id="de08c-143">Choosing an Approach for Limiting Message Distribution</span></span>

<span data-ttu-id="de08c-144">发现需要限制消息分发的情形时，请考虑以下问题：</span><span class="sxs-lookup"><span data-stu-id="de08c-144">When you discover a scenario in which you need to limit message distribution, ask yourself the following questions:</span></span>

- <span data-ttu-id="de08c-145">**谁** 需要接收消息？</span><span class="sxs-lookup"><span data-stu-id="de08c-145">**Who** needs to receive the message?</span></span> <span data-ttu-id="de08c-146">仅仅是一个邻居节点？</span><span class="sxs-lookup"><span data-stu-id="de08c-146">Just one neighbor node?</span></span> <span data-ttu-id="de08c-147">网格中其他位置的节点？</span><span class="sxs-lookup"><span data-stu-id="de08c-147">A node somewhere else in the mesh?</span></span> <span data-ttu-id="de08c-148">还是半个网格？</span><span class="sxs-lookup"><span data-stu-id="de08c-148">Half the mesh?</span></span>

- <span data-ttu-id="de08c-149">发送此消息的**频率如何**？</span><span class="sxs-lookup"><span data-stu-id="de08c-149">**How often** will this message be sent?</span></span>

- <span data-ttu-id="de08c-150">此消息将使用哪种 **带宽** ？</span><span class="sxs-lookup"><span data-stu-id="de08c-150">What kind of **bandwidth** will this message use?</span></span>

<span data-ttu-id="de08c-151">对这些问题的回答将帮助您确定是使用跃点计数、消息传播筛选器、本地筛选器还是直接连接。</span><span class="sxs-lookup"><span data-stu-id="de08c-151">The answers to these questions can help you determine whether to use Hop Count, a Message Propagation Filter, a local filter, or a direct connection.</span></span> <span data-ttu-id="de08c-152">请考虑以下通用准则：</span><span class="sxs-lookup"><span data-stu-id="de08c-152">Consider the following general guidelines:</span></span>

- <span data-ttu-id="de08c-153">**人士**</span><span class="sxs-lookup"><span data-stu-id="de08c-153">**Who**</span></span>

  - <span data-ttu-id="de08c-154">*单个节点*：本地筛选器或直接连接。</span><span class="sxs-lookup"><span data-stu-id="de08c-154">*Individual node*:  Local filter or direct connection.</span></span>

  - <span data-ttu-id="de08c-155">某个*邻近范围内的邻居*： PeerHopCount。</span><span class="sxs-lookup"><span data-stu-id="de08c-155">*Neighbors within a certain vicinity*:  PeerHopCount.</span></span>

  - <span data-ttu-id="de08c-156">*网格的复杂子集*： MessagePropagationFilter。</span><span class="sxs-lookup"><span data-stu-id="de08c-156">*Complex subset of the mesh*:  MessagePropagationFilter.</span></span>

- <span data-ttu-id="de08c-157">**发送频率**</span><span class="sxs-lookup"><span data-stu-id="de08c-157">**How often**</span></span>

  - <span data-ttu-id="de08c-158">*非常频繁*：直接连接、PeerHopCount、MessagePropagationFilter。</span><span class="sxs-lookup"><span data-stu-id="de08c-158">*Very frequent*:  Direct connection, PeerHopCount, MessagePropagationFilter.</span></span>

  - <span data-ttu-id="de08c-159">*偶尔*：本地筛选器。</span><span class="sxs-lookup"><span data-stu-id="de08c-159">*Occasional*:  Local filter.</span></span>

- <span data-ttu-id="de08c-160">**所用带宽**</span><span class="sxs-lookup"><span data-stu-id="de08c-160">**Bandwidth use**</span></span>

  - <span data-ttu-id="de08c-161">*高*：直接连接，不建议使用 MessagePropagationFilter 或本地筛选器。</span><span class="sxs-lookup"><span data-stu-id="de08c-161">*High*:  Direct connection, less advisable to use MessagePropagationFilter or local filter.</span></span>

  - <span data-ttu-id="de08c-162">*低*：可能不需要直接连接。</span><span class="sxs-lookup"><span data-stu-id="de08c-162">*Low*:  Any, direct connection probably not needed.</span></span>

## <a name="see-also"></a><span data-ttu-id="de08c-163">请参阅</span><span class="sxs-lookup"><span data-stu-id="de08c-163">See also</span></span>

- [<span data-ttu-id="de08c-164">生成对等通道应用程序</span><span class="sxs-lookup"><span data-stu-id="de08c-164">Building a Peer Channel Application</span></span>](building-a-peer-channel-application.md)
