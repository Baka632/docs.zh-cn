---
title: 序列化和反序列化
description: 了解 WCF 序列化引擎，该引擎可在两个方向上转换 .NET Framework 对象和 XML。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 3d71814c-bda7-424b-85b7-15084ff9377a
ms.openlocfilehash: a861ee38963f77bffe23bbca19a6f895289e372d
ms.sourcegitcommit: c4a15c6c4ecbb8a46ad4e67d9b3ab9b8b031d849
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/20/2020
ms.locfileid: "88656809"
---
# <a name="serialization-and-deserialization"></a><span data-ttu-id="b45d3-103">序列化和反序列化</span><span class="sxs-lookup"><span data-stu-id="b45d3-103">Serialization and Deserialization</span></span>
<span data-ttu-id="b45d3-104">Windows Communication Foundation (WCF) 包括新的序列化引擎 <xref:System.Runtime.Serialization.DataContractSerializer> 。</span><span class="sxs-lookup"><span data-stu-id="b45d3-104">Windows Communication Foundation (WCF) includes a new serialization engine, the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="b45d3-105"><xref:System.Runtime.Serialization.DataContractSerializer>双向 .NET Framework 对象和 XML 之间进行转换。</span><span class="sxs-lookup"><span data-stu-id="b45d3-105">The <xref:System.Runtime.Serialization.DataContractSerializer> translates between .NET Framework objects and XML, in both directions.</span></span> <span data-ttu-id="b45d3-106">本主题说明序列化程序的工作原理。</span><span class="sxs-lookup"><span data-stu-id="b45d3-106">This topic explains how the serializer works.</span></span>  
  
 <span data-ttu-id="b45d3-107">序列化 .NET Framework 对象时，序列化程序了解各种序列化编程模型，包括新的 *数据协定* 模型。</span><span class="sxs-lookup"><span data-stu-id="b45d3-107">When serializing .NET Framework objects, the serializer understands a variety of serialization programming models, including the new *data contract* model.</span></span> <span data-ttu-id="b45d3-108">有关支持类型的完整列表，请参阅 [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md)。</span><span class="sxs-lookup"><span data-stu-id="b45d3-108">For a full list of supported types, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="b45d3-109">有关数据协定的介绍，请参阅 [Using Data Contracts](using-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="b45d3-109">For an introduction to data contracts, see [Using Data Contracts](using-data-contracts.md).</span></span>  
  
 <span data-ttu-id="b45d3-110">当对 XML 进行反序列化时，序列化程序使用 <xref:System.Xml.XmlReader> 和 <xref:System.Xml.XmlWriter> 类。</span><span class="sxs-lookup"><span data-stu-id="b45d3-110">When deserializing XML, the serializer uses the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="b45d3-111">它还支持 <xref:System.Xml.XmlDictionaryReader> 和 <xref:System.Xml.XmlDictionaryWriter> 类，以便在某些情况下（例如使用 WCF 二进制 XML 格式时），使其能够生成优化的 XML。</span><span class="sxs-lookup"><span data-stu-id="b45d3-111">It also supports the <xref:System.Xml.XmlDictionaryReader> and <xref:System.Xml.XmlDictionaryWriter> classes to enable it to produce optimized XML in some cases, such as when using the WCF binary XML format.</span></span>  
  
 <span data-ttu-id="b45d3-112">WCF 还包括一个伴随序列化程序 <xref:System.Runtime.Serialization.NetDataContractSerializer> 。</span><span class="sxs-lookup"><span data-stu-id="b45d3-112">WCF also includes a companion serializer, the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="b45d3-113"><xref:System.Runtime.Serialization.NetDataContractSerializer>：</span><span class="sxs-lookup"><span data-stu-id="b45d3-113">The <xref:System.Runtime.Serialization.NetDataContractSerializer>:</span></span>

* <span data-ttu-id="b45d3-114">是 ***不*** 安全的。</span><span class="sxs-lookup"><span data-stu-id="b45d3-114">Is ***not*** secure.</span></span> <span data-ttu-id="b45d3-115">有关详细信息，请参阅 [BinaryFormatter security guide （安全指南](../../../standard/serialization/binaryformatter-security-guide.md)）。</span><span class="sxs-lookup"><span data-stu-id="b45d3-115">For more information, see the [BinaryFormatter security guide](../../../standard/serialization/binaryformatter-security-guide.md).</span></span>
* <span data-ttu-id="b45d3-116">与 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 和序列化程序类似， <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> 因为它还会发出 .NET Framework 类型名称作为序列化数据的一部分。</span><span class="sxs-lookup"><span data-stu-id="b45d3-116">Is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> serializers because it also emits .NET Framework type names as part of the serialized data.</span></span>
* <span data-ttu-id="b45d3-117">当在序列化和反序列化结束时共享相同的类型时，使用。</span><span class="sxs-lookup"><span data-stu-id="b45d3-117">Is used when the same types are shared on the serializing and the deserializing ends.</span></span>

 <span data-ttu-id="b45d3-118"><xref:System.Runtime.Serialization.DataContractSerializer>和都 <xref:System.Runtime.Serialization.NetDataContractSerializer> 派生自公共基类 <xref:System.Runtime.Serialization.XmlObjectSerializer> 。</span><span class="sxs-lookup"><span data-stu-id="b45d3-118">Both <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> derive from a common base class, <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
> [!WARNING]
> <span data-ttu-id="b45d3-119"><xref:System.Runtime.Serialization.DataContractSerializer> 将包含带小于 20 的十六进制值的控制字符序列化为 XML 实体。</span><span class="sxs-lookup"><span data-stu-id="b45d3-119">The <xref:System.Runtime.Serialization.DataContractSerializer> serializes strings containing control characters with a hexadecimal value below 20 as XML entities.</span></span> <span data-ttu-id="b45d3-120">在将此类数据发送到 WCF 服务时，这可能会导致非 WCF 客户端出现问题。</span><span class="sxs-lookup"><span data-stu-id="b45d3-120">This may cause a problem with a non-WCF client when sending such data to a WCF service.</span></span>  
  
## <a name="creating-a-datacontractserializer-instance"></a><span data-ttu-id="b45d3-121">创建 DataContractSerializer 实例</span><span class="sxs-lookup"><span data-stu-id="b45d3-121">Creating a DataContractSerializer Instance</span></span>  
 <span data-ttu-id="b45d3-122">构造 <xref:System.Runtime.Serialization.DataContractSerializer> 的实例是一个重要步骤。</span><span class="sxs-lookup"><span data-stu-id="b45d3-122">Constructing an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> is an important step.</span></span> <span data-ttu-id="b45d3-123">完成构造后，将不能够更改任何设置。</span><span class="sxs-lookup"><span data-stu-id="b45d3-123">After construction, you cannot change any of the settings.</span></span>  
  
### <a name="specifying-the-root-type"></a><span data-ttu-id="b45d3-124">指定根类型</span><span class="sxs-lookup"><span data-stu-id="b45d3-124">Specifying the Root Type</span></span>  
 <span data-ttu-id="b45d3-125">\*\* 根类型是序列化或反序列化实例的类型。</span><span class="sxs-lookup"><span data-stu-id="b45d3-125">The *root type* is the type of which instances are serialized or deserialized.</span></span> <span data-ttu-id="b45d3-126"><xref:System.Runtime.Serialization.DataContractSerializer> 有许多构造函数重载，但必须使用 `type` 参数提供至少一个根类型。</span><span class="sxs-lookup"><span data-stu-id="b45d3-126">The <xref:System.Runtime.Serialization.DataContractSerializer> has many constructor overloads, but, at a minimum, a root type must be supplied using the `type` parameter.</span></span>  
  
 <span data-ttu-id="b45d3-127">为某个根类型创建的序列化程序不能用于序列化（或反序列化）其他类型，除非该类型是从根类型派生的。</span><span class="sxs-lookup"><span data-stu-id="b45d3-127">A serializer created for a certain root type cannot be used to serialize (or deserialize) another type, unless the type is derived from the root type.</span></span> <span data-ttu-id="b45d3-128">下面的示例演示了两个类。</span><span class="sxs-lookup"><span data-stu-id="b45d3-128">The following example shows two classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#1)]
 [!code-vb[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#1)]  
  
 <span data-ttu-id="b45d3-129">此代码构造 `DataContractSerializer` 的一个实例，它仅可用于序列化或反序列化 `Person` 类的实例。</span><span class="sxs-lookup"><span data-stu-id="b45d3-129">This code constructs an instance of the `DataContractSerializer` that can be used only to serialize or deserialize instances of the `Person` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#2)]
 [!code-vb[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#2)]  
  
### <a name="specifying-known-types"></a><span data-ttu-id="b45d3-130">指定已知类型</span><span class="sxs-lookup"><span data-stu-id="b45d3-130">Specifying Known Types</span></span>  
 <span data-ttu-id="b45d3-131">如果在进行序列化的类型中涉及多态性，并且尚未使用 <xref:System.Runtime.Serialization.KnownTypeAttribute> 特性或某种其他机制进行处理，则必须使用 `knownTypes` 参数将可能的已知类型的列表传递给序列化程序的构造函数。</span><span class="sxs-lookup"><span data-stu-id="b45d3-131">If polymorphism is involved in the types being serialized that is not already handled using the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute or some other mechanism, a list of possible known types must be passed to the serializer’s constructor using the `knownTypes` parameter.</span></span> <span data-ttu-id="b45d3-132">有关已知类型的详细信息，请参阅 [数据协定已知类型](data-contract-known-types.md)。</span><span class="sxs-lookup"><span data-stu-id="b45d3-132">For more information about known types, see [Data Contract Known Types](data-contract-known-types.md).</span></span>  
  
 <span data-ttu-id="b45d3-133">下面的示例演示 `LibraryPatron`类，该类包含特定类型 `LibraryItem`的集合。</span><span class="sxs-lookup"><span data-stu-id="b45d3-133">The following example shows a class, `LibraryPatron`, that includes a collection of a specific type, the `LibraryItem`.</span></span> <span data-ttu-id="b45d3-134">第二个类定义 `LibraryItem` 类型。</span><span class="sxs-lookup"><span data-stu-id="b45d3-134">The second class defines the `LibraryItem` type.</span></span> <span data-ttu-id="b45d3-135">第三个和第四个类（`Book` 和 `Newspaper`）从 `LibraryItem` 类继承。</span><span class="sxs-lookup"><span data-stu-id="b45d3-135">The third and four classes (`Book` and `Newspaper`) inherit from the `LibraryItem` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#3)]  
 [!code-vb[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#3)]  
  
 <span data-ttu-id="b45d3-136">下面的代码构造一个使用 `knownTypes` 参数的序列化程序的实例。</span><span class="sxs-lookup"><span data-stu-id="b45d3-136">The following code constructs an instance of the serializer using the `knownTypes` parameter.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#4)]
 [!code-vb[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#4)]  
  
### <a name="specifying-the-default-root-name-and-namespace"></a><span data-ttu-id="b45d3-137">指定默认根名称和命名空间</span><span class="sxs-lookup"><span data-stu-id="b45d3-137">Specifying the Default Root Name and Namespace</span></span>  
 <span data-ttu-id="b45d3-138">通常，在对对象进行序列化时，将根据数据协定名称和命名空间确定最外面的 XML 元素的默认名称和命名空间。</span><span class="sxs-lookup"><span data-stu-id="b45d3-138">Normally, when an object is serialized, the default name and namespace of the outermost XML element are determined according to the data contract name and namespace.</span></span> <span data-ttu-id="b45d3-139">所有内部元素的名称将根据数据成员名称来确定，这些元素的命名空间是数据协定的命名空间。</span><span class="sxs-lookup"><span data-stu-id="b45d3-139">The names of all inner elements are determined from data member names, and their namespace is the data contract’s namespace.</span></span> <span data-ttu-id="b45d3-140">下面的示例设置 `Name` 和 `Namespace` 类的构造函数中的 <xref:System.Runtime.Serialization.DataContractAttribute> 和 <xref:System.Runtime.Serialization.DataMemberAttribute> 值。</span><span class="sxs-lookup"><span data-stu-id="b45d3-140">The following example sets `Name` and `Namespace` values in the constructors of the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#5)]
 [!code-vb[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#5)]  
  
 <span data-ttu-id="b45d3-141">对 `Person` 类的实例进行序列化将生成类似如下的 XML。</span><span class="sxs-lookup"><span data-stu-id="b45d3-141">Serializing an instance of the `Person` class produces XML similar to the following.</span></span>  
  
```xml  
<PersonContract xmlns="http://schemas.contoso.com">  
  <AddressMember>  
    <StreetMember>123 Main Street</StreetMember>  
   </AddressMember>  
</PersonContract>  
```  
  
 <span data-ttu-id="b45d3-142">但是，可以通过将 `rootName` 和 `rootNamespace` 参数的值传递到 <xref:System.Runtime.Serialization.DataContractSerializer> 构造函数，自定义根元素的默认名称和命名空间。</span><span class="sxs-lookup"><span data-stu-id="b45d3-142">However, you can customize the default name and namespace of the root element by passing the values of the `rootName` and `rootNamespace` parameters to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor.</span></span> <span data-ttu-id="b45d3-143">注意， `rootNamespace` 不会影响对应于数据成员的所包含元素的命名空间，</span><span class="sxs-lookup"><span data-stu-id="b45d3-143">Note that the `rootNamespace` does not affect the namespace of the contained elements that correspond to data members.</span></span> <span data-ttu-id="b45d3-144">而只是影响最外面元素的命名空间。</span><span class="sxs-lookup"><span data-stu-id="b45d3-144">It affects only the namespace of the outermost element.</span></span>  
  
 <span data-ttu-id="b45d3-145">可以作为字符串或 <xref:System.Xml.XmlDictionaryString> 类的实例来传递这些值，从而允许使用二进制 XML 格式对其进行优化。</span><span class="sxs-lookup"><span data-stu-id="b45d3-145">These values can be passed as strings or instances of the <xref:System.Xml.XmlDictionaryString> class to allow for their optimization using the binary XML format.</span></span>  
  
### <a name="setting-the-maximum-objects-quota"></a><span data-ttu-id="b45d3-146">设置最大对象配额</span><span class="sxs-lookup"><span data-stu-id="b45d3-146">Setting the Maximum Objects Quota</span></span>  
 <span data-ttu-id="b45d3-147">一些 `DataContractSerializer` 构造函数重载具有 `maxItemsInObjectGraph` 参数。</span><span class="sxs-lookup"><span data-stu-id="b45d3-147">Some `DataContractSerializer` constructor overloads have a `maxItemsInObjectGraph` parameter.</span></span> <span data-ttu-id="b45d3-148">此参数确定序列化程序在单个 <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> 方法调用中序列化或反序列化的对象的最大数目。</span><span class="sxs-lookup"><span data-stu-id="b45d3-148">This parameter determines the maximum number of objects the serializer serializes or deserializes in a single <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method call.</span></span> <span data-ttu-id="b45d3-149">（该方法总是读取一个根对象，但此对象的数据成员中可以具有其他对象。</span><span class="sxs-lookup"><span data-stu-id="b45d3-149">(The method always reads one root object, but this object may have other objects in its data members.</span></span> <span data-ttu-id="b45d3-150">这些对象可能包含其他对象，依此类推。 ) 默认值为65536。</span><span class="sxs-lookup"><span data-stu-id="b45d3-150">Those objects may have other objects, and so on.) The default is 65536.</span></span> <span data-ttu-id="b45d3-151">请注意，当序列化或反序列化数组时，每个数组项都计为一个单独的对象。</span><span class="sxs-lookup"><span data-stu-id="b45d3-151">Note that when serializing or deserializing arrays, every array entry counts as a separate object.</span></span> <span data-ttu-id="b45d3-152">此外还应注意，一些对象可以有大内存表示形式，因此，单独使用此配额可能不足以防范拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="b45d3-152">Also, note that some objects may have a large memory representation, and so this quota alone may not be sufficient to prevent a denial of service attack.</span></span> <span data-ttu-id="b45d3-153">有关详细信息，请参阅 [数据的安全注意事项](security-considerations-for-data.md)。</span><span class="sxs-lookup"><span data-stu-id="b45d3-153">For more information, see [Security Considerations for Data](security-considerations-for-data.md).</span></span> <span data-ttu-id="b45d3-154">如果需要增加此配额以至超出默认值，则一定要在发送（序列化）和接收（反序列化）方同时增加此配额，原因是在读取和写入数据时会此配额同时应用于发送方和接收方。</span><span class="sxs-lookup"><span data-stu-id="b45d3-154">If you need to increase this quota beyond the default value, it is important to do so both on the sending (serializing) and receiving (deserializing) sides because it applies to both when reading and writing data.</span></span>  
  
### <a name="round-trips"></a><span data-ttu-id="b45d3-155">往返行程</span><span class="sxs-lookup"><span data-stu-id="b45d3-155">Round Trips</span></span>  
 <span data-ttu-id="b45d3-156">在一次操作中对对象进行反序列化和重新序列化时将发生往返行程 \*\* 。</span><span class="sxs-lookup"><span data-stu-id="b45d3-156">A *round trip* occurs when an object is deserialized and re-serialized in one operation.</span></span> <span data-ttu-id="b45d3-157">因此，往返行程是从 XML 到对象实例，然后再返回到 XML 流。</span><span class="sxs-lookup"><span data-stu-id="b45d3-157">Thus, it goes from XML to an object instance, and back again into an XML stream.</span></span>  
  
 <span data-ttu-id="b45d3-158">一些 `DataContractSerializer` 构造函数重载具有 `ignoreExtensionDataObject` 参数，该参数默认设置为 `false` 。</span><span class="sxs-lookup"><span data-stu-id="b45d3-158">Some `DataContractSerializer` constructor overloads have an `ignoreExtensionDataObject` parameter, which is set to `false` by default.</span></span> <span data-ttu-id="b45d3-159">在此默认模式中，对于一个往返行程，可以将数据从数据协定的较新版本发送到较旧版本然后再返回到较新版本而不会出现任何损失，前提是数据协定实现 <xref:System.Runtime.Serialization.IExtensibleDataObject> 接口。</span><span class="sxs-lookup"><span data-stu-id="b45d3-159">In this default mode, data can be sent on a round trip from a newer version of a data contract through an older version and back to the newer version without loss, as long as the data contract implements the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="b45d3-160">例如，假设 `Person` 数据协定的版本 1 包含 `Name` 和 `PhoneNumber` 数据成员，并且版本 2 添加 `Nickname` 成员。</span><span class="sxs-lookup"><span data-stu-id="b45d3-160">For example, suppose version 1 of the `Person` data contract contains the `Name` and `PhoneNumber` data members, and version 2 adds a `Nickname` member.</span></span> <span data-ttu-id="b45d3-161">如果在从版本 2 向版本 1 发送信息时实现了 `IExtensibleDataObject` ，则会存储 `Nickname` 数据，并在再次序列化数据时重新发出这些数据，因此，在往返行程中不会出现数据丢失。</span><span class="sxs-lookup"><span data-stu-id="b45d3-161">If `IExtensibleDataObject` is implemented, when sending information from version 2 to version 1, the `Nickname` data is stored, and then re-emitted when the data is serialized again; therefore, no data is lost in the round trip.</span></span> <span data-ttu-id="b45d3-162">有关详细信息，请参阅 [向前兼容的数据协定](forward-compatible-data-contracts.md) 和 [数据协定版本控制](data-contract-versioning.md)。</span><span class="sxs-lookup"><span data-stu-id="b45d3-162">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md) and [Data Contract Versioning](data-contract-versioning.md).</span></span>  
  
#### <a name="security-and-schema-validity-concerns-with-round-trips"></a><span data-ttu-id="b45d3-163">往返行程的安全性和架构有效性问题</span><span class="sxs-lookup"><span data-stu-id="b45d3-163">Security and Schema Validity Concerns with Round Trips</span></span>  
 <span data-ttu-id="b45d3-164">往返行程可能会涉及到一些安全性问题。</span><span class="sxs-lookup"><span data-stu-id="b45d3-164">Round trips may have security implications.</span></span> <span data-ttu-id="b45d3-165">例如，反序列化和存储大量外来数据可能存在安全风险。</span><span class="sxs-lookup"><span data-stu-id="b45d3-165">For example, deserializing and storing large amounts of extraneous data may be a security risk.</span></span> <span data-ttu-id="b45d3-166">重新发出无法验证的数据可能会存在安全问题，尤其是在涉及数字签名的情况下。</span><span class="sxs-lookup"><span data-stu-id="b45d3-166">There may be security concerns about re-emitting this data that there is no way to verify, especially if digital signatures are involved.</span></span> <span data-ttu-id="b45d3-167">例如，在前面的方案中，版本 1 终结点可能会对包含恶意数据的 `Nickname` 值进行签名。</span><span class="sxs-lookup"><span data-stu-id="b45d3-167">For example, in the previous scenario, the version 1 endpoint could be signing a `Nickname` value that contains malicious data.</span></span> <span data-ttu-id="b45d3-168">最后，还可能存在架构有效性问题：终结点可能需要始终发出严格符合其声明的协定并且没有任何额外值的数据。</span><span class="sxs-lookup"><span data-stu-id="b45d3-168">Finally, there may be schema validity concerns: an endpoint may want to always emit data that strictly adheres to its stated contract and not any extra values.</span></span> <span data-ttu-id="b45d3-169">在前面的示例中，版本 1 终结点的协定声明该终结点仅发出 `Name` 和 `PhoneNumber`，并且如果正在使用构造验证，则发出额外的 `Nickname` 值将导致验证失败。</span><span class="sxs-lookup"><span data-stu-id="b45d3-169">In the previous example, the version 1 endpoint’s contract says that it emits only `Name` and `PhoneNumber`, and if schema validation is being used, emitting the extra `Nickname` value causes validation to fail.</span></span>  
  
#### <a name="enabling-and-disabling-round-trips"></a><span data-ttu-id="b45d3-170">启用和禁用往返行程</span><span class="sxs-lookup"><span data-stu-id="b45d3-170">Enabling and Disabling Round Trips</span></span>  
 <span data-ttu-id="b45d3-171">要关闭往返行程，请不要实现 <xref:System.Runtime.Serialization.IExtensibleDataObject> 接口。</span><span class="sxs-lookup"><span data-stu-id="b45d3-171">To turn off round trips, do not implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="b45d3-172">如果您无法控制相应的类型，则将 `ignoreExtensionDataObject` 参数设置为 `true` 也可获得同样的效果。</span><span class="sxs-lookup"><span data-stu-id="b45d3-172">If you have no control over the types, set the `ignoreExtensionDataObject` parameter to `true` to achieve the same effect.</span></span>  
  
### <a name="object-graph-preservation"></a><span data-ttu-id="b45d3-173">对象图保留</span><span class="sxs-lookup"><span data-stu-id="b45d3-173">Object Graph Preservation</span></span>  
 <span data-ttu-id="b45d3-174">通常，序列化程序并不关心对象标识，如在下面的代码中所示。</span><span class="sxs-lookup"><span data-stu-id="b45d3-174">Normally, the serializer does not care about object identity, as in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#6)]
 [!code-vb[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#6)]  
  
 <span data-ttu-id="b45d3-175">下面的代码创建一份订单。</span><span class="sxs-lookup"><span data-stu-id="b45d3-175">The following code creates a purchase order.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#7)]
 [!code-vb[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#7)]  
  
 <span data-ttu-id="b45d3-176">请注意，将 `billTo` 和 `shipTo` 字段设置为同一个对象实例。</span><span class="sxs-lookup"><span data-stu-id="b45d3-176">Notice that `billTo` and `shipTo` fields are set to the same object instance.</span></span> <span data-ttu-id="b45d3-177">但是，生成的 XML 会复制重复的信息，并与下面的 XML 类似。</span><span class="sxs-lookup"><span data-stu-id="b45d3-177">However, the generated XML duplicates the information duplicated, and looks similar to the following XML.</span></span>  
  
```xml  
<PurchaseOrder>  
  <billTo><street>123 Main St.</street></billTo>  
  <shipTo><street>123 Main St.</street></shipTo>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="b45d3-178">不过，此方法具有以下可能不需要的特征：</span><span class="sxs-lookup"><span data-stu-id="b45d3-178">However, this approach has the following characteristics, which may be undesirable:</span></span>  
  
- <span data-ttu-id="b45d3-179">性能。</span><span class="sxs-lookup"><span data-stu-id="b45d3-179">Performance.</span></span> <span data-ttu-id="b45d3-180">复制数据的效率低。</span><span class="sxs-lookup"><span data-stu-id="b45d3-180">Replicating data is inefficient.</span></span>  
  
- <span data-ttu-id="b45d3-181">循环引用。</span><span class="sxs-lookup"><span data-stu-id="b45d3-181">Circular references.</span></span> <span data-ttu-id="b45d3-182">如果对象引用自身，甚至通过其他对象引用自身，则通过复制进行序列化会导致无限循环。</span><span class="sxs-lookup"><span data-stu-id="b45d3-182">If objects refer to themselves, even through other objects, serializing by replication results in an infinite loop.</span></span> <span data-ttu-id="b45d3-183">（如果发生这种状况，序列化程序将引发 <xref:System.Runtime.Serialization.SerializationException> 。）</span><span class="sxs-lookup"><span data-stu-id="b45d3-183">(The serializer throws a <xref:System.Runtime.Serialization.SerializationException> if this happens.)</span></span>  
  
- <span data-ttu-id="b45d3-184">语义。</span><span class="sxs-lookup"><span data-stu-id="b45d3-184">Semantics.</span></span> <span data-ttu-id="b45d3-185">有时，一定要记住这一点：两个引用指向的是同一个对象而不是两个相同的对象。</span><span class="sxs-lookup"><span data-stu-id="b45d3-185">Sometimes it is important to preserve the fact that two references are to the same object, and not to two identical objects.</span></span>  
  
 <span data-ttu-id="b45d3-186">有关这些原因，一些 `DataContractSerializer` 构造函数重载具有 `preserveObjectReferences` 参数（默认值为 `false`）。</span><span class="sxs-lookup"><span data-stu-id="b45d3-186">For these reasons, some `DataContractSerializer` constructor overloads have a `preserveObjectReferences` parameter (the default is `false`).</span></span> <span data-ttu-id="b45d3-187">将此参数设置为时 `true` ，将使用一种特殊的编码对象引用方法，只使用 WCF 识别的对象。</span><span class="sxs-lookup"><span data-stu-id="b45d3-187">When this parameter is set to `true`, a special method of encoding object references, which only WCF understands, is used.</span></span> <span data-ttu-id="b45d3-188">当设置为 `true`时，XML 代码示例现在如下所示。</span><span class="sxs-lookup"><span data-stu-id="b45d3-188">When set to `true`, the XML code example now resembles the following.</span></span>  
  
```xml  
<PurchaseOrder ser:id="1">  
  <billTo ser:id="2"><street ser:id="3">123 Main St.</street></billTo>  
  <shipTo ser:ref="2"/>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="b45d3-189">"Ser" 命名空间引用标准序列化命名空间 `http://schemas.microsoft.com/2003/10/Serialization/` 。</span><span class="sxs-lookup"><span data-stu-id="b45d3-189">The "ser" namespace refers to the standard serialization namespace, `http://schemas.microsoft.com/2003/10/Serialization/`.</span></span> <span data-ttu-id="b45d3-190">每一段数据只进行一次序列化并获得一个 ID 号，后续使用会导致引用已序列化的数据。</span><span class="sxs-lookup"><span data-stu-id="b45d3-190">Each piece of data is serialized only once and given an ID number, and subsequent uses result in a reference to the already serialized data.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="b45d3-191">如果“id”和“ref”属性同时存在于数据协定 `XMLElement`中，则接受“ref”属性，而忽略“id”属性。</span><span class="sxs-lookup"><span data-stu-id="b45d3-191">If both "id" and "ref" attributes are present in the data contract `XMLElement`, then the "ref" attribute is honored and the "id" attribute is ignored.</span></span>  
  
 <span data-ttu-id="b45d3-192">了解此模式的限制是很重要的：</span><span class="sxs-lookup"><span data-stu-id="b45d3-192">It is important to understand the limitations of this mode:</span></span>  
  
- <span data-ttu-id="b45d3-193">`DataContractSerializer` 在 `preserveObjectReferences` 设置为 `true` 的情况下生成的 XML 与任何其他技术都无法进行交互，仅可以由另一个其 `DataContractSerializer` 也设置为 `preserveObjectReferences` 的 `true`实例进行访问。</span><span class="sxs-lookup"><span data-stu-id="b45d3-193">The XML the `DataContractSerializer` produces with `preserveObjectReferences` set to `true` is not interoperable with any other technologies, and can be accessed only by another `DataContractSerializer` instance, also with `preserveObjectReferences` set to `true`.</span></span>  
  
- <span data-ttu-id="b45d3-194">元数据（架构）不支持此功能。</span><span class="sxs-lookup"><span data-stu-id="b45d3-194">There is no metadata (schema) support for this feature.</span></span> <span data-ttu-id="b45d3-195">生成的架构仅对 `preserveObjectReferences` 设置为 `false`的情况有效。</span><span class="sxs-lookup"><span data-stu-id="b45d3-195">The schema that is produced is valid only for the case when `preserveObjectReferences` is set to `false`.</span></span>  
  
- <span data-ttu-id="b45d3-196">此功能可能导致序列化和反序列化进程运行速度减慢。</span><span class="sxs-lookup"><span data-stu-id="b45d3-196">This feature may cause the serialization and deserialization process to run slower.</span></span> <span data-ttu-id="b45d3-197">尽管不必复制数据，但是在此模式中必须执行额外的对象比较。</span><span class="sxs-lookup"><span data-stu-id="b45d3-197">Although data does not have to be replicated, extra object comparisons must be performed in this mode.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="b45d3-198">当启用 `preserveObjectReferences` 模式时，需要将 `maxItemsInObjectGraph` 值设置为正确的配额，这一点特别重要。</span><span class="sxs-lookup"><span data-stu-id="b45d3-198">When the `preserveObjectReferences` mode is enabled, it is especially important to set the `maxItemsInObjectGraph` value to the correct quota.</span></span> <span data-ttu-id="b45d3-199">由于在此模式中处理数组的方式方面的原因，攻击者很容易构造一条小的恶意消息来造成内存大量消耗（仅通过 `maxItemsInObjectGraph` 配额来限制）。</span><span class="sxs-lookup"><span data-stu-id="b45d3-199">Due to the way arrays are handled in this mode, it is easy for an attacker to construct a small malicious message that results in large memory consumption limited only by the `maxItemsInObjectGraph` quota.</span></span>  
  
### <a name="specifying-a-data-contract-surrogate"></a><span data-ttu-id="b45d3-200">指定数据协定代理项</span><span class="sxs-lookup"><span data-stu-id="b45d3-200">Specifying a Data Contract Surrogate</span></span>  
 <span data-ttu-id="b45d3-201">一些 `DataContractSerializer` 构造函数重载具有 `dataContractSurrogate` 参数，该参数可以设置为 `null`。</span><span class="sxs-lookup"><span data-stu-id="b45d3-201">Some `DataContractSerializer` constructor overloads have a `dataContractSurrogate` parameter, which may be set to `null`.</span></span> <span data-ttu-id="b45d3-202">此外，可以使用它来指定数据协定代理项 \*\*，数据协定代理项是一种实现 <xref:System.Runtime.Serialization.IDataContractSurrogate> 接口的类型。</span><span class="sxs-lookup"><span data-stu-id="b45d3-202">Otherwise, you can use it to specify a *data contract surrogate*, which is a type that implements the <xref:System.Runtime.Serialization.IDataContractSurrogate> interface.</span></span> <span data-ttu-id="b45d3-203">然后可以使用该接口来自定义序列化和反序列化进程。</span><span class="sxs-lookup"><span data-stu-id="b45d3-203">You can then use the interface to customize the serialization and deserialization process.</span></span> <span data-ttu-id="b45d3-204">有关详细信息，请参阅 [数据协定代理](../extending/data-contract-surrogates.md)项。</span><span class="sxs-lookup"><span data-stu-id="b45d3-204">For more information, see [Data Contract Surrogates](../extending/data-contract-surrogates.md).</span></span>  
  
## <a name="serialization"></a><span data-ttu-id="b45d3-205">序列化</span><span class="sxs-lookup"><span data-stu-id="b45d3-205">Serialization</span></span>  
 <span data-ttu-id="b45d3-206">下面的信息适用于从 <xref:System.Runtime.Serialization.XmlObjectSerializer>继承的任何类，包括 <xref:System.Runtime.Serialization.DataContractSerializer> 和 <xref:System.Runtime.Serialization.NetDataContractSerializer> 类。</span><span class="sxs-lookup"><span data-stu-id="b45d3-206">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
### <a name="simple-serialization"></a><span data-ttu-id="b45d3-207">简单序列化</span><span class="sxs-lookup"><span data-stu-id="b45d3-207">Simple Serialization</span></span>  
 <span data-ttu-id="b45d3-208">对对象进行序列化最基本的方法是将其传递到 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b45d3-208">The most basic way to serialize an object is to pass it to the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method.</span></span> <span data-ttu-id="b45d3-209">该方法有三个重载，每个重载分别用于写入到 <xref:System.IO.Stream>、 <xref:System.Xml.XmlWriter>或 <xref:System.Xml.XmlDictionaryWriter>。</span><span class="sxs-lookup"><span data-stu-id="b45d3-209">There are three overloads, one each for writing to a <xref:System.IO.Stream>, an <xref:System.Xml.XmlWriter>, or an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="b45d3-210">使用 <xref:System.IO.Stream> 重载时，输出是采用 UTF-8 编码的 XML。</span><span class="sxs-lookup"><span data-stu-id="b45d3-210">With the <xref:System.IO.Stream> overload, the output is XML in the UTF-8 encoding.</span></span> <span data-ttu-id="b45d3-211">使用 <xref:System.Xml.XmlDictionaryWriter> 重载时，序列化程序会针对二进制 XML 优化其输出。</span><span class="sxs-lookup"><span data-stu-id="b45d3-211">With the <xref:System.Xml.XmlDictionaryWriter> overload, the serializer optimizes its output for binary XML.</span></span>  
  
 <span data-ttu-id="b45d3-212">使用方法时 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> ，序列化程序使用包装元素的默认名称和命名空间，并将其与内容一起写入 (参阅前面的 "指定默认根名称和命名空间" 部分) 。</span><span class="sxs-lookup"><span data-stu-id="b45d3-212">When using the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method, the serializer uses the default name and namespace for the wrapper element and writes it out along with the contents (see the previous "Specifying the Default Root Name and Namespace" section).</span></span>  
  
 <span data-ttu-id="b45d3-213">下面的示例演示如何使用 <xref:System.Xml.XmlDictionaryWriter>进行写入。</span><span class="sxs-lookup"><span data-stu-id="b45d3-213">The following example demonstrates writing with an <xref:System.Xml.XmlDictionaryWriter>.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#8)]
 [!code-vb[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#8)]  
  
 <span data-ttu-id="b45d3-214">这将生成类似于如下所示的 XML。</span><span class="sxs-lookup"><span data-stu-id="b45d3-214">This produces XML similar to the following.</span></span>  
  
```xml  
<Person>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
### <a name="step-by-step-serialization"></a><span data-ttu-id="b45d3-215">分步引导的序列化</span><span class="sxs-lookup"><span data-stu-id="b45d3-215">Step-By-Step Serialization</span></span>  
 <span data-ttu-id="b45d3-216"><xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>、 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>和 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> 方法可分别用于写入结束元素、写入对象内容以及关闭包装元素。</span><span class="sxs-lookup"><span data-stu-id="b45d3-216">Use the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>, and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> methods to write the end element, write the object contents, and close the wrapper element, respectively.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b45d3-217">这些方法没有 <xref:System.IO.Stream> 重载。</span><span class="sxs-lookup"><span data-stu-id="b45d3-217">There are no <xref:System.IO.Stream> overloads of these methods.</span></span>  
  
 <span data-ttu-id="b45d3-218">此分步引导的序列化具有两个常见用途。</span><span class="sxs-lookup"><span data-stu-id="b45d3-218">This step-by-step serialization has two common uses.</span></span> <span data-ttu-id="b45d3-219">一种用途是在 `WriteStartObject` 和 `WriteObjectContent`之间插入内容（例如属性或注释），如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="b45d3-219">One is to insert contents such as attributes or comments between `WriteStartObject` and `WriteObjectContent`,  as shown in the following example.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#9)]
 [!code-vb[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#9)]  
  
 <span data-ttu-id="b45d3-220">这将生成类似于如下所示的 XML。</span><span class="sxs-lookup"><span data-stu-id="b45d3-220">This produces XML similar to the following.</span></span>  
  
```xml  
<Person serializedBy="myCode">  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
 <span data-ttu-id="b45d3-221">另一种常见用途是完全避免使用 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> 和 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> ，并写入自己的自定义包装元素（或者甚至连同跳过写入包装），如以下代码中所示。</span><span class="sxs-lookup"><span data-stu-id="b45d3-221">Another common use is to avoid using <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> entirely, and to write your own custom wrapper element (or even skip writing a wrapper altogether), as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#10)]
 [!code-vb[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#10)]  
  
 <span data-ttu-id="b45d3-222">这将生成类似于如下所示的 XML。</span><span class="sxs-lookup"><span data-stu-id="b45d3-222">This produces XML similar to the following.</span></span>  
  
```xml  
<MyCustomWrapper>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</MyCustomWrapper>  
```  
  
> [!NOTE]
> <span data-ttu-id="b45d3-223">使用分步引导的序列化可能会导致架构无效的 XML。</span><span class="sxs-lookup"><span data-stu-id="b45d3-223">Using step-by-step serialization may result in schema-invalid XML.</span></span>  
  
## <a name="deserialization"></a><span data-ttu-id="b45d3-224">反序列化</span><span class="sxs-lookup"><span data-stu-id="b45d3-224">Deserialization</span></span>  
 <span data-ttu-id="b45d3-225">下面的信息适用于从 <xref:System.Runtime.Serialization.XmlObjectSerializer>继承的任何类，包括 <xref:System.Runtime.Serialization.DataContractSerializer> 和 <xref:System.Runtime.Serialization.NetDataContractSerializer> 类。</span><span class="sxs-lookup"><span data-stu-id="b45d3-225">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
 <span data-ttu-id="b45d3-226">对对象进行反序列化的最基本的方式是调用 <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> 方法重载之一。</span><span class="sxs-lookup"><span data-stu-id="b45d3-226">The most basic way to deserialize an object is to call one of the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method overloads.</span></span> <span data-ttu-id="b45d3-227">该方法有三个重载，每个重载分别用于读取 <xref:System.Xml.XmlDictionaryReader>、 `XmlReader`或 `Stream`。</span><span class="sxs-lookup"><span data-stu-id="b45d3-227">There are three overloads, one each for reading with a <xref:System.Xml.XmlDictionaryReader>, an `XmlReader`, or a `Stream`.</span></span> <span data-ttu-id="b45d3-228">请注意， `Stream` 重载将创建不受任何配额保护的文本 <xref:System.Xml.XmlDictionaryReader> ，此重载仅应用于读取受信任的数据。</span><span class="sxs-lookup"><span data-stu-id="b45d3-228">Note that the `Stream` overload creates a textual <xref:System.Xml.XmlDictionaryReader> that is not protected by any quotas, and should be used only to read trusted data.</span></span>  
  
 <span data-ttu-id="b45d3-229">还请注意，必须将 `ReadObject` 方法返回的对象强制转换为适当的类型。</span><span class="sxs-lookup"><span data-stu-id="b45d3-229">Also note that the object the `ReadObject` method returns must be cast to the appropriate type.</span></span>  
  
 <span data-ttu-id="b45d3-230">下面的代码构造 <xref:System.Runtime.Serialization.DataContractSerializer> 和 <xref:System.Xml.XmlDictionaryReader>的实例，然后对 `Person` 实例进行反序列化。</span><span class="sxs-lookup"><span data-stu-id="b45d3-230">The following code constructs an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> and an <xref:System.Xml.XmlDictionaryReader>, then deserializes a `Person` instance.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#11)]
 [!code-vb[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#11)]  
  
 <span data-ttu-id="b45d3-231">在调用 <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> 方法之前，将 XML 读取器置于包装元素上或包装元素前面的非内容节点上。</span><span class="sxs-lookup"><span data-stu-id="b45d3-231">Before calling the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method, position the XML reader on the wrapper element or on a non-content node that precedes the wrapper element.</span></span> <span data-ttu-id="b45d3-232">可以通过调用 <xref:System.Xml.XmlReader.Read%2A> 或其派生项的 <xref:System.Xml.XmlReader> 方法并测试 <xref:System.Xml.XmlReader.NodeType%2A>来完成此操作，如以下代码所示。</span><span class="sxs-lookup"><span data-stu-id="b45d3-232">You can do this by calling the <xref:System.Xml.XmlReader.Read%2A> method of the <xref:System.Xml.XmlReader> or its derivation, and testing the <xref:System.Xml.XmlReader.NodeType%2A>, as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#12)]
 [!code-vb[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#12)]  
  
 <span data-ttu-id="b45d3-233">请注意，在将读取器传递给 `ReadObject`之前，可以读取此包装元素上的属性。</span><span class="sxs-lookup"><span data-stu-id="b45d3-233">Note that you can read attributes on this wrapper element before handing the reader to `ReadObject`.</span></span>  
  
 <span data-ttu-id="b45d3-234">使用简单的重载之一时 `ReadObject` ，反序列化程序会在包装元素上查找默认名称和命名空间 (参阅前面的 "指定默认根名称和命名空间" 一节 ) 并在找到未知元素时引发异常。</span><span class="sxs-lookup"><span data-stu-id="b45d3-234">When using one of the simple `ReadObject` overloads, the deserializer looks for the default name and namespace on the wrapper element (see the preceding section, "Specifying the Default Root Name and Namespace") and throws an exception if it finds an unknown element.</span></span> <span data-ttu-id="b45d3-235">在上面的示例中，应有 `<Person>` 包装元素。</span><span class="sxs-lookup"><span data-stu-id="b45d3-235">In the preceding example, the `<Person>` wrapper element is expected.</span></span> <span data-ttu-id="b45d3-236">可调用 <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> 方法来验证是否已将读取器定位在按预期命名的元素上。</span><span class="sxs-lookup"><span data-stu-id="b45d3-236">The <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> method is called to verify that the reader is positioned on an element that is named as expected.</span></span>  
  
 <span data-ttu-id="b45d3-237">有一种方法可以用来禁用此包装元素名称检查；一些 `ReadObject` 方法的重载采用布尔参数 `verifyObjectName`，该参数默认设置为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="b45d3-237">There is a way to disable this wrapper element name check; some overloads of the `ReadObject` method take the Boolean parameter `verifyObjectName`, which is set to `true` by default.</span></span> <span data-ttu-id="b45d3-238">当该参数设置为 `false`时，包装元素的名称和命名空间将被忽略。</span><span class="sxs-lookup"><span data-stu-id="b45d3-238">When set to `false`, the name and namespace of the wrapper element is ignored.</span></span> <span data-ttu-id="b45d3-239">这对于读取使用先前描述的分步引导的序列化机制写入的 XML 是有用的。</span><span class="sxs-lookup"><span data-stu-id="b45d3-239">This is useful for reading XML that was written using the step-by-step serialization mechanism described previously.</span></span>  
  
## <a name="using-the-netdatacontractserializer"></a><span data-ttu-id="b45d3-240">使用 NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="b45d3-240">Using the NetDataContractSerializer</span></span>  
 <span data-ttu-id="b45d3-241">与之间的主要差异在于 `DataContractSerializer` <xref:System.Runtime.Serialization.NetDataContractSerializer> `DataContractSerializer` 使用数据协定名称，而在 `NetDataContractSerializer` 序列化的 XML 中输出完整 .NET Framework 程序集和类型名称。</span><span class="sxs-lookup"><span data-stu-id="b45d3-241">The primary difference between the `DataContractSerializer` and the <xref:System.Runtime.Serialization.NetDataContractSerializer> is that the `DataContractSerializer` uses data contract names, whereas the `NetDataContractSerializer` outputs full .NET Framework assembly and type names in the serialized XML.</span></span> <span data-ttu-id="b45d3-242">这意味着必须在序列化终结点和反序列化终结点之间共享完全相同的类型。</span><span class="sxs-lookup"><span data-stu-id="b45d3-242">This means that the exact same types must be shared between the serialization and deserialization endpoints.</span></span> <span data-ttu-id="b45d3-243">这也同时意味着不需要对 `NetDataContractSerializer` 使用已知类型机制，因为要反序列化的确切类型始终是已知的。</span><span class="sxs-lookup"><span data-stu-id="b45d3-243">This means that the known types mechanism is not required with the `NetDataContractSerializer` because the exact types to be deserialized are always known.</span></span>  
  
 <span data-ttu-id="b45d3-244">但是，会出现以下几个问题：</span><span class="sxs-lookup"><span data-stu-id="b45d3-244">However, several problems can occur:</span></span>  
  
- <span data-ttu-id="b45d3-245">安全性。</span><span class="sxs-lookup"><span data-stu-id="b45d3-245">Security.</span></span> <span data-ttu-id="b45d3-246">在要反序列化的 XML 中找到的任何类型都会加载。</span><span class="sxs-lookup"><span data-stu-id="b45d3-246">Any type found in the XML being deserialized is loaded.</span></span> <span data-ttu-id="b45d3-247">有人可以利用这一点来强制加载恶意类型。</span><span class="sxs-lookup"><span data-stu-id="b45d3-247">This can be exploited to force the loading of malicious types.</span></span> <span data-ttu-id="b45d3-248">仅在使用 `NetDataContractSerializer` 序列化联编程序 *时（使用* 属性或构造函数参数）才应将 <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> 用于不受信任的数据。</span><span class="sxs-lookup"><span data-stu-id="b45d3-248">Using the `NetDataContractSerializer` with untrusted data should be done only if a *Serialization Binder* is used (using the <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> property or constructor parameter).</span></span> <span data-ttu-id="b45d3-249">联编程序仅允许加载安全类型。</span><span class="sxs-lookup"><span data-stu-id="b45d3-249">The binder permits only safe types to be loaded.</span></span> <span data-ttu-id="b45d3-250">联编程序机制与 <xref:System.Runtime.Serialization> 命名空间中的类型使用的机制相同。</span><span class="sxs-lookup"><span data-stu-id="b45d3-250">The Binder mechanism is identical to the one that types in the <xref:System.Runtime.Serialization> namespace use.</span></span>  
  
- <span data-ttu-id="b45d3-251">版本管理。</span><span class="sxs-lookup"><span data-stu-id="b45d3-251">Versioning.</span></span> <span data-ttu-id="b45d3-252">在 XML 中使用完整的类型和程序集名称会严格限制对类型进行版本管理的方式。</span><span class="sxs-lookup"><span data-stu-id="b45d3-252">Using full type and assembly names in the XML severely restricts how types can be versioned.</span></span> <span data-ttu-id="b45d3-253">以下内容不可更改：类型名称、命名空间、程序集名称和程序集版本。</span><span class="sxs-lookup"><span data-stu-id="b45d3-253">The following cannot be changed: type names, namespaces, assembly names, and assembly versions.</span></span> <span data-ttu-id="b45d3-254">通过将 <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> 属性或构造函数参数设置为 <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> （而非 <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> 的默认值），可以允许程序集版本更改，但不允许泛型参数类型更改。</span><span class="sxs-lookup"><span data-stu-id="b45d3-254">Setting the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property or constructor parameter to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> instead of the default value of <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> allows for assembly version changes, but not for generic parameter types.</span></span>  
  
- <span data-ttu-id="b45d3-255">互操作性。</span><span class="sxs-lookup"><span data-stu-id="b45d3-255">Interoperability.</span></span> <span data-ttu-id="b45d3-256">由于 .NET Framework 类型和程序集名称包含在 XML 中，因此 .NET Framework 以外的平台不能访问生成的数据。</span><span class="sxs-lookup"><span data-stu-id="b45d3-256">Because .NET Framework type and assembly names are included in the XML, platforms other than the .NET Framework cannot access the resulting data.</span></span>  
  
- <span data-ttu-id="b45d3-257">性能。</span><span class="sxs-lookup"><span data-stu-id="b45d3-257">Performance.</span></span> <span data-ttu-id="b45d3-258">写出类型和程序集名称会显著增加生成的 XML 的大小。</span><span class="sxs-lookup"><span data-stu-id="b45d3-258">Writing out the type and assembly names significantly increases the size of the resulting XML.</span></span>  
  
 <span data-ttu-id="b45d3-259">此机制类似于 .NET Framework 远程处理 (所使用的二进制或 SOAP 序列化， <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 以及和 <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>) 。</span><span class="sxs-lookup"><span data-stu-id="b45d3-259">This mechanism is similar to binary or SOAP serialization used by .NET Framework remoting (specifically, the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>).</span></span>  
  
 <span data-ttu-id="b45d3-260">使用 `NetDataContractSerializer` 与使用 `DataContractSerializer`类似，但存在以下区别：</span><span class="sxs-lookup"><span data-stu-id="b45d3-260">Using the `NetDataContractSerializer` is similar to using the `DataContractSerializer`, with the following differences:</span></span>  
  
- <span data-ttu-id="b45d3-261">构造函数不要求指定根类型。</span><span class="sxs-lookup"><span data-stu-id="b45d3-261">The constructors do not require you to specify a root type.</span></span> <span data-ttu-id="b45d3-262">可以使用 `NetDataContractSerializer`的相同实例对任何类型进行序列化。</span><span class="sxs-lookup"><span data-stu-id="b45d3-262">You can serialize any type with the same instance of the `NetDataContractSerializer`.</span></span>  
  
- <span data-ttu-id="b45d3-263">构造函数不接受已知类型的列表。</span><span class="sxs-lookup"><span data-stu-id="b45d3-263">The constructors do not accept a list of known types.</span></span> <span data-ttu-id="b45d3-264">如果将类型名称序列化为 XML，则不需要已知类型机制。</span><span class="sxs-lookup"><span data-stu-id="b45d3-264">The known types mechanism is unnecessary if type names are serialized into the XML.</span></span>  
  
- <span data-ttu-id="b45d3-265">构造函数不接受数据协定代理项，</span><span class="sxs-lookup"><span data-stu-id="b45d3-265">The constructors do not accept a data contract surrogate.</span></span> <span data-ttu-id="b45d3-266">而是接受一个名为 <xref:System.Runtime.Serialization.ISurrogateSelector> 的 `surrogateSelector` 参数（映射到 <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> 属性）。</span><span class="sxs-lookup"><span data-stu-id="b45d3-266">Instead, they accept an <xref:System.Runtime.Serialization.ISurrogateSelector> parameter called `surrogateSelector` (which maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> property).</span></span> <span data-ttu-id="b45d3-267">这是旧式代理项机制。</span><span class="sxs-lookup"><span data-stu-id="b45d3-267">This is a legacy surrogate mechanism.</span></span>  
  
- <span data-ttu-id="b45d3-268">构造函数接受 `assemblyFormat` 的一个名为 <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> 的参数，该参数映射到 <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="b45d3-268">The constructors accept a parameter called `assemblyFormat` of the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property.</span></span> <span data-ttu-id="b45d3-269">如前所述，这可以用于增强序列化程序的版本管理功能。</span><span class="sxs-lookup"><span data-stu-id="b45d3-269">As discussed previously, this can be used to enhance the versioning capabilities of the serializer.</span></span> <span data-ttu-id="b45d3-270">这与二进制或 SOAP 序列化中的 <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> 机制相同。</span><span class="sxs-lookup"><span data-stu-id="b45d3-270">This is identical to the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> mechanism in binary or SOAP serialization.</span></span>  
  
- <span data-ttu-id="b45d3-271">构造函数接受一个名为 <xref:System.Runtime.Serialization.StreamingContext> 的 `context` 参数，该参数映射到 <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="b45d3-271">The constructors accept a <xref:System.Runtime.Serialization.StreamingContext> parameter called `context` that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> property.</span></span> <span data-ttu-id="b45d3-272">可以使用该参数将信息传递到要序列化的类型中。</span><span class="sxs-lookup"><span data-stu-id="b45d3-272">You can use this to pass information into types being serialized.</span></span> <span data-ttu-id="b45d3-273">此用法与其他 <xref:System.Runtime.Serialization.StreamingContext> 类中使用的 <xref:System.Runtime.Serialization> 机制的用法相同。</span><span class="sxs-lookup"><span data-stu-id="b45d3-273">This usage is identical to that of the <xref:System.Runtime.Serialization.StreamingContext> mechanism used in other <xref:System.Runtime.Serialization> classes.</span></span>  
  
- <span data-ttu-id="b45d3-274"><xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> 和 <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> 方法是 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> 和 <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> 方法的别名。</span><span class="sxs-lookup"><span data-stu-id="b45d3-274">The <xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> and <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> methods are aliases for the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> methods.</span></span> <span data-ttu-id="b45d3-275">这些别名可以为二进制或 SOAP 序列化提供更为一致的编程模型。</span><span class="sxs-lookup"><span data-stu-id="b45d3-275">These exist to provide a more consistent programming model with binary or SOAP serialization.</span></span>  
  
 <span data-ttu-id="b45d3-276">有关这些功能的详细信息，请参阅 [二进制序列化](../../../standard/serialization/binary-serialization.md)。</span><span class="sxs-lookup"><span data-stu-id="b45d3-276">For more information about these features, see [Binary Serialization](../../../standard/serialization/binary-serialization.md).</span></span>  
  
 <span data-ttu-id="b45d3-277">`NetDataContractSerializer` 和 `DataContractSerializer` 使用的 XML 格式通常是不兼容的。</span><span class="sxs-lookup"><span data-stu-id="b45d3-277">The XML formats that the `NetDataContractSerializer` and the `DataContractSerializer` use are normally not compatible.</span></span> <span data-ttu-id="b45d3-278">也就是说，不支持尝试使用这些序列化程序的一种进行序列化而使用另一种序列化程序进行反序列化的情况。</span><span class="sxs-lookup"><span data-stu-id="b45d3-278">That is, attempting to serialize with one of these serializers and deserialize with the other is not a supported scenario.</span></span>  
  
 <span data-ttu-id="b45d3-279">另请注意，不 `NetDataContractSerializer` 会输出对象图中每个节点的完整 .NET Framework 类型和程序集名称。</span><span class="sxs-lookup"><span data-stu-id="b45d3-279">Also, note that the `NetDataContractSerializer` does not output the full .NET Framework type and assembly name for each node in the object graph.</span></span> <span data-ttu-id="b45d3-280">仅在有歧义的地方才会输出上述信息。</span><span class="sxs-lookup"><span data-stu-id="b45d3-280">It outputs that information only where it is ambiguous.</span></span> <span data-ttu-id="b45d3-281">也就是说，它是在根对象级别进行输出并且是针对任何多态情况。</span><span class="sxs-lookup"><span data-stu-id="b45d3-281">That is, it outputs at the root object level and for any polymorphic cases.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b45d3-282">请参阅</span><span class="sxs-lookup"><span data-stu-id="b45d3-282">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.NetDataContractSerializer>
- <xref:System.Runtime.Serialization.XmlObjectSerializer>
- [<span data-ttu-id="b45d3-283">二进制序列化</span><span class="sxs-lookup"><span data-stu-id="b45d3-283">Binary Serialization</span></span>](../../../standard/serialization/binary-serialization.md)
- [<span data-ttu-id="b45d3-284">数据协定序列化程序支持的类型</span><span class="sxs-lookup"><span data-stu-id="b45d3-284">Types Supported by the Data Contract Serializer</span></span>](types-supported-by-the-data-contract-serializer.md)
