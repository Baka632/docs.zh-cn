---
title: 大型数据和流
description: 了解基于 WCF XML 的通信、编码器和流式处理数据（包括二进制数据传输）的注意事项。
ms.date: 03/30/2017
ms.assetid: ab2851f5-966b-4549-80ab-c94c5c0502d2
ms.openlocfilehash: 09e020801486c09c027883fca3d67a6c2e2fe8d7
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/26/2020
ms.locfileid: "96234695"
---
# <a name="large-data-and-streaming"></a><span data-ttu-id="25ae3-103">大型数据和流</span><span class="sxs-lookup"><span data-stu-id="25ae3-103">Large Data and Streaming</span></span>

<span data-ttu-id="25ae3-104">Windows Communication Foundation (WCF) 是一种基于 XML 的通信基础结构。</span><span class="sxs-lookup"><span data-stu-id="25ae3-104">Windows Communication Foundation (WCF) is an XML-based communications infrastructure.</span></span> <span data-ttu-id="25ae3-105">由于 XML 数据通常采用 [xml 1.0 规范](https://www.w3.org/TR/REC-xml/)中定义的标准文本格式进行编码，因此连接的系统开发人员和架构师通常会担心线路需求量 (或大小) 网络上发送的消息，而基于文本的 XML 编码对于有效传输二进制数据会带来特殊的挑战。</span><span class="sxs-lookup"><span data-stu-id="25ae3-105">Because XML data is commonly encoded in the standard text format defined in the [XML 1.0 specification](https://www.w3.org/TR/REC-xml/), connected systems developers and architects are typically concerned about the wire footprint (or size) of messages sent across the network, and the text-based encoding of XML poses special challenges for the efficient transfer of binary data.</span></span>  
  
## <a name="basic-considerations"></a><span data-ttu-id="25ae3-106">基本考虑事项</span><span class="sxs-lookup"><span data-stu-id="25ae3-106">Basic Considerations</span></span>  

 <span data-ttu-id="25ae3-107">为了提供有关 WCF 的以下信息的背景信息，本部分重点介绍了通常适用于连接的系统基础结构的编码、二进制数据和流式处理的一些一般注意事项和注意事项。</span><span class="sxs-lookup"><span data-stu-id="25ae3-107">To provide background information about the following information for WCF, this section highlights some general concerns and considerations for encodings, binary data, and streaming that generally apply to connected systems infrastructures.</span></span>  
  
### <a name="encoding-data-text-vs-binary"></a><span data-ttu-id="25ae3-108">编码数据：文本和二进制</span><span class="sxs-lookup"><span data-stu-id="25ae3-108">Encoding Data: Text vs. Binary</span></span>  

 <span data-ttu-id="25ae3-109">开发人员最常有的顾虑包括：认为与二进制格式相比 XML 的开销非常可观（因为其开始标记和结束标记的重复性），数值的编码可能要大得多（因为它们是以文本值来表示的），并且无法有效地表示二进制数据（因为它们必须进行特殊的编码才能嵌入到文本格式中）。</span><span class="sxs-lookup"><span data-stu-id="25ae3-109">Commonly expressed developer concerns include the perception that XML has significant overhead when compared to binary formats due to the repetitive nature of start tags and end tags, that the encoding of numerical values is considered to be significantly larger because they are expressed in text values, and that binary data cannot be expressed efficiently because it must be specially encoded for embedding into a text format.</span></span>  
  
 <span data-ttu-id="25ae3-110">尽管上述以及其他许多类似的问题是存在的，但是 XML Web services 环境中的 XML 文本编码消息与旧式的远程过程调用 (RPC) 环境中的二进制编码消息之间的实际差异，通常远远小于最初的考虑中所预想的程度。</span><span class="sxs-lookup"><span data-stu-id="25ae3-110">While many of these and similar concerns are valid, the actual difference between XML-text encoded messages in an XML Web services environment and binary-encoded messages in a legacy remote procedure call (RPC) environment is often much less significant than the initial consideration might suggest.</span></span>  
  
 <span data-ttu-id="25ae3-111">XML 文本编码消息是透明的并且是“易读的”，而比较而言，二进制消息通常相当晦涩，在无工具的情况下很难解码。</span><span class="sxs-lookup"><span data-stu-id="25ae3-111">While XML-text encoded messages are transparent and "human readable", binary messages are often fairly obscure in comparison and difficult to decode without tools.</span></span> <span data-ttu-id="25ae3-112">这种易读性方面的差异会使人忽视这样一点：二进制消息的负载中通常还携带内联元数据，这样会和 XML 文本消息一样增加开销。</span><span class="sxs-lookup"><span data-stu-id="25ae3-112">This difference in legibility leads one to overlook that binary messages also often carry inline metadata in the payload, which adds overhead just as with XML text messages.</span></span> <span data-ttu-id="25ae3-113">对于旨在提供松散耦合和动态调用功能的二进制格式，这种情况尤为突出。</span><span class="sxs-lookup"><span data-stu-id="25ae3-113">This is specifically true for binary formats that aim to provide loose-coupling and dynamic invocation capabilities.</span></span>  
  
 <span data-ttu-id="25ae3-114">不过，二进制格式通常在“头”中携带此类描述性元数据信息，而且头中还声明了后续数据记录的数据布局。</span><span class="sxs-lookup"><span data-stu-id="25ae3-114">However, binary formats commonly carry such descriptive metadata information in a "header," which also declares the data layout for the following data records.</span></span> <span data-ttu-id="25ae3-115">之后负载将遵循这一公共元数据块声明，这样就将进一步的开销控制在最小的程度。</span><span class="sxs-lookup"><span data-stu-id="25ae3-115">The payload then follows this common metadata block declaration with minimal further overhead.</span></span> <span data-ttu-id="25ae3-116">相反，XML 将每个数据项都包括在一个元素或属性中，这样会为每个序列化的负载对象重复包括包含负载对象用的元数据。</span><span class="sxs-lookup"><span data-stu-id="25ae3-116">In contrast, XML encloses each data item in an element or attribute so that the enclosing metadata is repetitively included for each serialized payload object.</span></span> <span data-ttu-id="25ae3-117">因此，将文本表示法与二进制表示法进行比较，会发现单个序列化的负载对象的大小相差不大，因为二者都必须有一些描述性元数据。但由于二进制格式的每个额外传输的负载对象都共享同一元数据描述，因此总体开销较低，也就是说二进制格式更有优势。</span><span class="sxs-lookup"><span data-stu-id="25ae3-117">As a result, the size of a single serialized payload object is similar when comparing text to binary representations as some descriptive metadata must be expressed for both, but the binary format benefits from the shared metadata description with each additional payload object that is transferred due to the lower overall overhead.</span></span>  
  
 <span data-ttu-id="25ae3-118">但是，对于某些数据类型（如数字），使用固定大小的二进制数字表示法（例如，使用 128 位的十进制类型，而不是纯文本）可能是不利的，因为纯文本表示法可能会小若干字节。</span><span class="sxs-lookup"><span data-stu-id="25ae3-118">Still, for certain data types, such as numbers, there might be a disadvantage to using fixed-size, binary numerical representations, such as a 128-bit decimal type instead of plain text, as the plain text representation might be several bytes smaller.</span></span> <span data-ttu-id="25ae3-119">由于文本数据可以选择通常更为灵活的 XML 文本编码选项，因此在大小上也可能具有优势，而一些二进制格式可能默认为 16 位甚至 32 位 Unicode，这不适用于 .NET 二进制 XML 格式。</span><span class="sxs-lookup"><span data-stu-id="25ae3-119">Text data also might have size benefits from the typically more flexible XML text encoding choices, while some binary formats might default to 16-bit or even 32-bit Unicode, which does not apply to the .NET Binary XML Format.</span></span>  
  
 <span data-ttu-id="25ae3-120">因此，要在文本与二进制之间进行选择，不能简单地认为二进制消息总是小于 XML 文本消息。</span><span class="sxs-lookup"><span data-stu-id="25ae3-120">As a result, deciding between text or binary is not quite as easy as assuming that binary messages are always smaller than XML-text messages.</span></span>  
  
 <span data-ttu-id="25ae3-121">XML 文本消息的一个明确优点为：它们是基于标准的消息，并且提供最为广泛的互操作性选项和平台支持。</span><span class="sxs-lookup"><span data-stu-id="25ae3-121">A clear advantage of XML-text messages is that they are standards-based and offer the broadest choice of interoperability options and platform support.</span></span> <span data-ttu-id="25ae3-122">有关详细信息，请参阅本主题后面的 "编码" 一节。</span><span class="sxs-lookup"><span data-stu-id="25ae3-122">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="binary-content"></a><span data-ttu-id="25ae3-123">二进制内容</span><span class="sxs-lookup"><span data-stu-id="25ae3-123">Binary Content</span></span>  

 <span data-ttu-id="25ae3-124">从最终的消息大小这一角度而言，二进制编码优于基于文本编码的一个方面就在于大型二进制数据项，例如，图片、视频、音效剪辑或者必须在服务与其使用者之间交换的任何其他形式的非透明二进制数据。</span><span class="sxs-lookup"><span data-stu-id="25ae3-124">One area where binary encodings are superior to text-based encodings in terms of the resulting message size are large binary data items such as pictures, videos, sound clips, or any other form of opaque, binary data that must be exchanged between services and their consumers.</span></span> <span data-ttu-id="25ae3-125">为了使这些类型的数据也适合 XML 文本，常用的方法就是使用 Base64 编码对其进行编码。</span><span class="sxs-lookup"><span data-stu-id="25ae3-125">To fit these types of data into XML text, the common approach is to encode them using the Base64 encoding.</span></span>  
  
 <span data-ttu-id="25ae3-126">在 Base64 编码字符串中，每个字符都表示原始 8 位数据的 6 位，这导致 Base64 的编码开销比率是 4:3，且未计算额外的格式字符（回车符/换行符），而按惯例这些字符通常是会添加的。</span><span class="sxs-lookup"><span data-stu-id="25ae3-126">In a Base64-encoded string, each character represents 6-bits of the original 8-bit data, which results in a 4:3 encoding-overhead ratio for Base64, not counting extra formatting characters (carriage return/line feed) that are commonly added by convention.</span></span> <span data-ttu-id="25ae3-127">虽然 XML 编码与二进制编码之间的差异显著与否通常视具体情况而定，但当传送 500 MB 负载时大小增加超过 33% 通常是不可接受的。</span><span class="sxs-lookup"><span data-stu-id="25ae3-127">While the significance of the differences between XML and binary encodings typically depends on the scenario, a size gain of more than 33% when transmitting a 500-MB payload is usually not acceptable.</span></span>  
  
 <span data-ttu-id="25ae3-128">为避免这种编码开销，消息传输优化机制 (MTOM) 标准允许将消息中包含的大型数据元素外部化，并将其作为无任何特殊编码的二进制数据随消息一起传送。</span><span class="sxs-lookup"><span data-stu-id="25ae3-128">To avoid this encoding overhead, the Message Transmission Optimization Mechanism (MTOM) standard allows for externalizing large data elements that are contained in a message and carrying them with the message as binary data without any special encoding.</span></span> <span data-ttu-id="25ae3-129">使用 MTOM，消息以类似方式与简单邮件传输协议进行交换 (SMTP) 电子邮件，其中包含附件或嵌入内容 (图片和其他嵌入内容) ;MTOM 消息会打包为多部分/相关 MIME 序列，根部分作为实际的 SOAP 消息。</span><span class="sxs-lookup"><span data-stu-id="25ae3-129">With MTOM, messages are exchanged in a similar fashion to Simple Mail Transfer Protocol (SMTP) email messages with attachments or embedded content (pictures and other embedded content); MTOM messages are packaged as multipart/related MIME sequences with the root part being the actual SOAP message.</span></span>  
  
 <span data-ttu-id="25ae3-130">MTOM SOAP 消息是在其未编码版本的基础上进行修改的，这样引用各自 MIME 部分的特殊元素标记会替代消息中包含二进制数据的原始元素。</span><span class="sxs-lookup"><span data-stu-id="25ae3-130">An MTOM SOAP message is modified from its un-encoded version so that special element tags that refer to the respective MIME parts take the place of the original elements in the message that contained binary data.</span></span> <span data-ttu-id="25ae3-131">因此，SOAP 消息通过指向随其发送的 MIME 部分来引用二进制内容，但除此之外则仅仅携带 XML 文本数据。</span><span class="sxs-lookup"><span data-stu-id="25ae3-131">As a result, the SOAP message refers to binary content by pointing to the MIME parts sent with it, but otherwise just carries XML text data.</span></span> <span data-ttu-id="25ae3-132">因为此模型与完善的 SMTP 模型基本一致，所以在多种平台上编码和解码 MTOM 消息有着广泛的工具支持，这令其成为一个极其具有可互操作性的选择。</span><span class="sxs-lookup"><span data-stu-id="25ae3-132">Because this model is closely aligned with the well-established SMTP model, there is broad tooling support to encode and decode MTOM messages on many platforms, which makes it an extremely interoperable choice.</span></span>  
  
 <span data-ttu-id="25ae3-133">但是，与 Base64 一样，对于 MIME 格式，MTOM 也有一些必要的开销，这样仅在二进制数据元素的大小超过大约 1 KB 时，才能体现出使用 MTOM 的好处。</span><span class="sxs-lookup"><span data-stu-id="25ae3-133">Still, as with Base64, MTOM also comes with some necessary overhead for the MIME format, so that advantages of using MTOM are only seen when the size of a binary data element exceeds about 1 KB.</span></span> <span data-ttu-id="25ae3-134">由于这一开销，如果二进制负载保持在该阈值之下，则 MTOM 编码的消息可能会大于对二进制数据使用 Base64 编码的消息。</span><span class="sxs-lookup"><span data-stu-id="25ae3-134">Due to the overhead, MTOM-encoded messages might be larger than messages that use Base64 encoding for binary data, if the binary payload remains under that threshold.</span></span> <span data-ttu-id="25ae3-135">有关详细信息，请参阅本主题后面的 "编码" 一节。</span><span class="sxs-lookup"><span data-stu-id="25ae3-135">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="large-data-content"></a><span data-ttu-id="25ae3-136">大型数据内容</span><span class="sxs-lookup"><span data-stu-id="25ae3-136">Large Data Content</span></span>  

 <span data-ttu-id="25ae3-137">即使不考虑线路需求量，前面提及的 500 MB 负载也对服务和客户端本身提出了很大的考验。</span><span class="sxs-lookup"><span data-stu-id="25ae3-137">Wire-footprint aside, the previously mentioned 500-MB payload also poses a great local challenge at for the service and the client.</span></span> <span data-ttu-id="25ae3-138">默认情况下，WCF 处理 *缓冲模式下* 的消息。</span><span class="sxs-lookup"><span data-stu-id="25ae3-138">By default, WCF processes messages in *buffered mode*.</span></span> <span data-ttu-id="25ae3-139">这意味着消息的整个内容在发送前或接收后都存在于内存中。</span><span class="sxs-lookup"><span data-stu-id="25ae3-139">This means that the entire content of a message is present in memory before it is sent or after it is received.</span></span> <span data-ttu-id="25ae3-140">尽管对于大多数情形来说这是个很好的策略，并且是消息传递功能（如数字签名）和可靠传递所必需的，但是大型消息可能会耗尽系统资源。</span><span class="sxs-lookup"><span data-stu-id="25ae3-140">While that is a good strategy for most scenarios, and necessary for messaging features such as digital signatures and reliable delivery, large messages could exhaust a system's resources.</span></span>  
  
 <span data-ttu-id="25ae3-141">处理大型负载的策略是流。</span><span class="sxs-lookup"><span data-stu-id="25ae3-141">The strategy to deal with large payloads is streaming.</span></span> <span data-ttu-id="25ae3-142">尽管消息（尤其是以 XML 表示的消息）通常会被认为是相对紧凑的数据包，但消息大小也可能达到 GB 数量级，这样的大小与连续的数据流而不是数据包相仿。</span><span class="sxs-lookup"><span data-stu-id="25ae3-142">While messages, especially those expressed in XML, are commonly thought of as being relatively compact data packages, a message might be multiple gigabytes in size and resemble a continuous data stream more than a data package.</span></span> <span data-ttu-id="25ae3-143">当以流模式而不是缓冲模式传输数据时，发送方会以流的形式将消息正文的内容提供给接收方，并且消息基础结构会不断地将就绪的数据从发送方转发给接收方。</span><span class="sxs-lookup"><span data-stu-id="25ae3-143">When data is transferred in streaming mode instead of buffered mode, the sender makes the contents of the message body available to the recipient in the form of a stream and the message infrastructure continuously forwards the data from sender to receiver as it becomes available.</span></span>  
  
 <span data-ttu-id="25ae3-144">传输此类大型数据内容的最常见情形是传输具有以下特点的二进制数据对象：</span><span class="sxs-lookup"><span data-stu-id="25ae3-144">The most common scenario in which such large data content transfers occur are transfers of binary data objects that:</span></span>  
  
- <span data-ttu-id="25ae3-145">无法方便地分成消息序列。</span><span class="sxs-lookup"><span data-stu-id="25ae3-145">Cannot be easily broken up into a message sequence.</span></span>  
  
- <span data-ttu-id="25ae3-146">必须以及时方式传递。</span><span class="sxs-lookup"><span data-stu-id="25ae3-146">Must be delivered in a timely manner.</span></span>  
  
- <span data-ttu-id="25ae3-147">当开始传输时，还不是已全部就绪。</span><span class="sxs-lookup"><span data-stu-id="25ae3-147">Are not available in their entirety when the transfer is initiated.</span></span>  
  
 <span data-ttu-id="25ae3-148">对于不具有上述限制条件的数据，通常最好在一个会话的范围内发送消息序列，而不是一次性地发送一个大消息。</span><span class="sxs-lookup"><span data-stu-id="25ae3-148">For data that does not have these constraints, it is typically better to send sequences of messages within the scope of a session than one large message.</span></span> <span data-ttu-id="25ae3-149">有关详细信息，请参阅本主题后面的 "流式处理数据" 一节。</span><span class="sxs-lookup"><span data-stu-id="25ae3-149">For more information, see the "Streaming Data" section later in this topic.</span></span>  
  
 <span data-ttu-id="25ae3-150">发送大量数据时，需要设置 `maxAllowedContentLength` iis 设置 (有关详细信息，请参阅 [配置 Iis 请求限制](/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)) 和 `maxReceivedMessageSize` 绑定设置 (例如 [BasicHttpBinding. MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) 或 <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>) 。</span><span class="sxs-lookup"><span data-stu-id="25ae3-150">When sending large amounts of data you will need to set the `maxAllowedContentLength` IIS setting (for more information see [Configuring IIS Request Limits](/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)) and the `maxReceivedMessageSize` binding setting (for example [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) or <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span></span> <span data-ttu-id="25ae3-151">`maxAllowedContentLength`属性默认为 28.6 MB， `maxReceivedMessageSize` 属性默认为64kb。</span><span class="sxs-lookup"><span data-stu-id="25ae3-151">The `maxAllowedContentLength` property defaults to 28.6 MB and the `maxReceivedMessageSize` property defaults to 64KB.</span></span>  
  
## <a name="encodings"></a><span data-ttu-id="25ae3-152">编码</span><span class="sxs-lookup"><span data-stu-id="25ae3-152">Encodings</span></span>  

 <span data-ttu-id="25ae3-153">*编码* 定义有关如何在网络上显示消息的一组规则。</span><span class="sxs-lookup"><span data-stu-id="25ae3-153">An *encoding* defines a set of rules about how to present messages on the wire.</span></span> <span data-ttu-id="25ae3-154">*编码器* 实现此类编码，并负责在发送方，将内存中的内存 <xref:System.ServiceModel.Channels.Message> 转换为可通过网络发送的字节流或字节缓冲区。</span><span class="sxs-lookup"><span data-stu-id="25ae3-154">An *encoder* implements such an encoding and is responsible, on the sender side, for turning an in-memory <xref:System.ServiceModel.Channels.Message> into a byte stream or byte buffer that can be sent across the network.</span></span> <span data-ttu-id="25ae3-155">在接收方，编码器会将一系列字节转变为内存中的消息。</span><span class="sxs-lookup"><span data-stu-id="25ae3-155">On the receiver side, the encoder turns a sequence of bytes into an in-memory message.</span></span>  
  
 <span data-ttu-id="25ae3-156">WCF 包括三个编码器，并允许你编写并插入你自己的编码器（如有必要）。</span><span class="sxs-lookup"><span data-stu-id="25ae3-156">WCF includes three encoders and allows you to write and plug in your own encoders, if necessary.</span></span>  
  
 <span data-ttu-id="25ae3-157">每个标准绑定都包括一个预配置编码器，因此默认情况下带 Net\* 前缀的绑定使用二进制编码器（通过包括 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> 类），而 <xref:System.ServiceModel.BasicHttpBinding> 和 <xref:System.ServiceModel.WSHttpBinding> 类则使用文本消息编码器（通过 <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> 类）。</span><span class="sxs-lookup"><span data-stu-id="25ae3-157">Each of the standard bindings includes a preconfigured encoder, whereby the bindings with the Net\* prefix use the binary encoder (by including the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> class) while the <xref:System.ServiceModel.BasicHttpBinding> and <xref:System.ServiceModel.WSHttpBinding> classes use the text message encoder (by means of the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> class) by default.</span></span>  
  
|<span data-ttu-id="25ae3-158">编码器绑定元素</span><span class="sxs-lookup"><span data-stu-id="25ae3-158">Encoder binding element</span></span>|<span data-ttu-id="25ae3-159">描述</span><span class="sxs-lookup"><span data-stu-id="25ae3-159">Description</span></span>|  
|-----------------------------|-----------------|  
|<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>|<span data-ttu-id="25ae3-160">文本消息编码器是所有基于 HTTP 的绑定的默认编码器，并且是最关注互操作性的所有自定义绑定的正确选择。</span><span class="sxs-lookup"><span data-stu-id="25ae3-160">The text message encoder is the default encoder for all HTTP-based bindings and the appropriate choice for all custom bindings where interoperability is the highest concern.</span></span> <span data-ttu-id="25ae3-161">此编码器读取和编写标准 SOAP 1.1/SOAP 1.2 文本消息，而不会对二进制数据进行任何特殊处理。</span><span class="sxs-lookup"><span data-stu-id="25ae3-161">This encoder reads and writes standard SOAP 1.1/SOAP 1.2 text messages with no special handling for binary data.</span></span> <span data-ttu-id="25ae3-162">如果 <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> 消息的属性设置为 <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType> ，则会从输出中省略 SOAP 信封包装，并且仅序列化消息正文内容。</span><span class="sxs-lookup"><span data-stu-id="25ae3-162">If the <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> property of a message is set to <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>, the SOAP envelope wrapper is omitted from the output and only the message body content is serialized.</span></span>|  
|<xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>|<span data-ttu-id="25ae3-163">MTOM 消息编码器是一个文本编码器，实现对二进制数据的特殊处理，默认情况下在任何标准绑定中都不会使用，因为它是一个严格按具体情况进行优化的实用工具。</span><span class="sxs-lookup"><span data-stu-id="25ae3-163">The MTOM message encoder is a text encoder that implements special handling for binary data and is not used by default in any of the standard bindings because it is strictly a case-by-case optimization utility.</span></span> <span data-ttu-id="25ae3-164">只有当二进制数据的量不超过某个阈值时，MTOM 编码才具有优势，如果消息包含的二进制数据超过了这个阈值，则这些数据会外部化到消息信封之后的 MIME 部分。</span><span class="sxs-lookup"><span data-stu-id="25ae3-164">If the message contains binary data that exceeds a threshold where MTOM encoding yields a benefit, the data is externalized into a MIME part following the message envelope.</span></span> <span data-ttu-id="25ae3-165">请参见本节后面部分中的“启用 MTOM”。</span><span class="sxs-lookup"><span data-stu-id="25ae3-165">See Enabling MTOM later in this section.</span></span>|  
|<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>|<span data-ttu-id="25ae3-166">二进制消息编码器是 Net \* 绑定的默认编码器，只要两个通信方都基于 WCF，就可以选择相应的编码器。</span><span class="sxs-lookup"><span data-stu-id="25ae3-166">The binary message encoder is the default encoder for the Net\* bindings and the appropriate choice whenever both communicating parties are based on WCF.</span></span> <span data-ttu-id="25ae3-167">二进制消息编码器使用 .NET 二进制 XML 格式，该格式是 XML 信息集 (Information Sets, Infosets) 的 Microsoft 特定二进制表示法，与等效的 XML 1.0 表示法相比产生的需求量通常较小，并将二进制数据编码为字节流。</span><span class="sxs-lookup"><span data-stu-id="25ae3-167">The binary message encoder uses the .NET Binary XML Format, a Microsoft-specific binary representation for XML Information Sets (Infosets) that generally yields a smaller footprint than the equivalent XML 1.0 representation and encodes binary data as a byte stream.</span></span>|  
  
 <span data-ttu-id="25ae3-168">通常，文本消息编码是要求互操作性的任意通信途径的最佳选择，而二进制消息编码则是其他任意通信途径的最佳选择。</span><span class="sxs-lookup"><span data-stu-id="25ae3-168">Text message encoding is typically the best choice for any communication path that requires interoperability, while binary message encoding is the best choice for any other communication path.</span></span> <span data-ttu-id="25ae3-169">通常，对于单个消息而言，二进制消息编码生成的消息大小要小于文本编码，并且在通信会话期间消息大小会逐渐变得更小。</span><span class="sxs-lookup"><span data-stu-id="25ae3-169">Binary message encoding typically yields smaller message sizes compared to text for a single message and progressively even smaller message sizes over the duration of a communication session.</span></span> <span data-ttu-id="25ae3-170">与文本编码不同的是，二进制编码不需要对二进制数据使用特殊处理（例如，使用 Base64），但会将字节表示为字节。</span><span class="sxs-lookup"><span data-stu-id="25ae3-170">Unlike text encoding, binary encoding does not have to use special handling for binary data, such as using Base64, but represents bytes as bytes.</span></span>  
  
 <span data-ttu-id="25ae3-171">如果您的解决方案不要求互操作性，但您仍希望使用 HTTP 传输，则可以将 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> 编写为一个使用 <xref:System.ServiceModel.Channels.HttpTransportBindingElement> 类进行传输的自定义绑定。</span><span class="sxs-lookup"><span data-stu-id="25ae3-171">If your solution does not require interoperability, but you still want to use HTTP transport, you can compose the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> into a custom binding that uses the <xref:System.ServiceModel.Channels.HttpTransportBindingElement> class for the transport.</span></span> <span data-ttu-id="25ae3-172">如果您的服务上有许多客户端要求互操作性，则建议您向各个启用的客户端公开其中每一个都具有适当的传输和编码选择的并行终结点。</span><span class="sxs-lookup"><span data-stu-id="25ae3-172">If a number of clients on your service require interoperability, it is recommended that you expose parallel endpoints that each has the appropriate transport and encoding choices for the respective clients enabled.</span></span>  
  
### <a name="enabling-mtom"></a><span data-ttu-id="25ae3-173">启用 MTOM</span><span class="sxs-lookup"><span data-stu-id="25ae3-173">Enabling MTOM</span></span>  

 <span data-ttu-id="25ae3-174">当要求互操作性，并且必须发送大型二进制数据时，MTOM 消息编码是一个备选的编码策略，您可以在标准 <xref:System.ServiceModel.BasicHttpBinding> 或 <xref:System.ServiceModel.WSHttpBinding> 绑定上启用它，方法是：将该绑定的 `MessageEncoding` 属性设置为 <xref:System.ServiceModel.WSMessageEncoding.Mtom>，或者将 <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> 编写为 <xref:System.ServiceModel.Channels.CustomBinding>。</span><span class="sxs-lookup"><span data-stu-id="25ae3-174">When interoperability is a requirement and large binary data must be sent, then MTOM message encoding is the alternative encoding strategy that you can enable on the standard <xref:System.ServiceModel.BasicHttpBinding> or <xref:System.ServiceModel.WSHttpBinding> bindings by setting the respective `MessageEncoding` property to <xref:System.ServiceModel.WSMessageEncoding.Mtom> or by composing the <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> into a <xref:System.ServiceModel.Channels.CustomBinding>.</span></span> <span data-ttu-id="25ae3-175">下面的示例代码（从 [MTOM 编码](../samples/mtom-encoding.md) 示例中提取）演示了如何在配置中启用 MTOM。</span><span class="sxs-lookup"><span data-stu-id="25ae3-175">The following example code, extracted from the [MTOM Encoding](../samples/mtom-encoding.md) sample demonstrates how to enable MTOM in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <wsHttpBinding>  
        <binding name="ExampleBinding" messageEncoding="Mtom"/>  
      </wsHttpBinding>  
    </bindings>  
     …  
</system.serviceModel>  
```  
  
 <span data-ttu-id="25ae3-176">如上所述，是否使用 MTOM 编码取决于您要发送的数据量。</span><span class="sxs-lookup"><span data-stu-id="25ae3-176">As mentioned earlier, the decision to use MTOM encoding depends on the data volume you are sending.</span></span> <span data-ttu-id="25ae3-177">另外，因为 MTOM 是在绑定级别启用的，所以启用 MTOM 会影响给定终结点上的所有操作。</span><span class="sxs-lookup"><span data-stu-id="25ae3-177">Also, because MTOM is enabled at the binding level, enabling MTOM affects all operations on a given endpoint.</span></span>  
  
 <span data-ttu-id="25ae3-178">因为 MTOM 编码器总是会发出 MTOM 编码的 MIME/多部分消息，而与二进制数据是否最终进行外部化无关，所以通常情况下，只有在终结点交换超过 1 KB 二进制数据的消息时，才应对终结点启用 MTOM。</span><span class="sxs-lookup"><span data-stu-id="25ae3-178">Because the MTOM encoder always emits an MTOM-encoded MIME/multi-part message regardless of whether binary data ends up being externalized, you should generally only enable MTOM for endpoints that exchange messages with more than 1 KB of binary data.</span></span> <span data-ttu-id="25ae3-179">另外，在可能的情况下，应限定设计为与启用 MTOM 的终结点一起使用的服务协定仅指定此类数据传输操作。</span><span class="sxs-lookup"><span data-stu-id="25ae3-179">Also, the service contracts designed for use with MTOM-enabled endpoints should, when possible, be constrained to specifying such data transfer operations.</span></span> <span data-ttu-id="25ae3-180">相关的控制功能应当位于一个单独的协定中。</span><span class="sxs-lookup"><span data-stu-id="25ae3-180">Related control functionality should reside on a separate contract.</span></span> <span data-ttu-id="25ae3-181">这一“仅 MTOM”规则仅适用于通过已启用 MTOM 的终结点发送的消息；MTOM 编码器也可以对传入的非 MTOM 消息进行解码和分析。</span><span class="sxs-lookup"><span data-stu-id="25ae3-181">This "MTOM-only" rule applies only to messages sent through an MTOM-enabled endpoint; the MTOM-encoder can decode and parse incoming non-MTOM messages as well.</span></span>  
  
 <span data-ttu-id="25ae3-182">使用 MTOM 编码器符合所有其他 WCF 功能。</span><span class="sxs-lookup"><span data-stu-id="25ae3-182">Using the MTOM encoder conforms with all other WCF features.</span></span> <span data-ttu-id="25ae3-183">请注意，可能不是在所有情况下都能遵守此规则，例如，当需要会话支持时。</span><span class="sxs-lookup"><span data-stu-id="25ae3-183">Note that it may not be possible to observe this rule in all cases, such as when session support is required.</span></span>  
  
### <a name="programming-model"></a><span data-ttu-id="25ae3-184">编程模型</span><span class="sxs-lookup"><span data-stu-id="25ae3-184">Programming Model</span></span>  

 <span data-ttu-id="25ae3-185">不论在应用程序中使用三个内置编码器中的哪一个，您在传输二进制数据方面的编程体验都是相同的。</span><span class="sxs-lookup"><span data-stu-id="25ae3-185">Regardless of which of the three built-in encoders you use in your application, the programming experience is identical with regards to transferring binary data.</span></span> <span data-ttu-id="25ae3-186">不同之处在于 WCF 如何根据数据类型处理数据。</span><span class="sxs-lookup"><span data-stu-id="25ae3-186">The difference is in how WCF handles the data based on their data types.</span></span>  
  
```csharp
[DataContract]  
class MyData  
{  
    [DataMember]  
    byte[] binaryBuffer;  
    [DataMember]  
    string someStringData;  
}
```  
  
 <span data-ttu-id="25ae3-187">当使用 MTOM 时，将根据以下规则序列化上面的数据协定：</span><span class="sxs-lookup"><span data-stu-id="25ae3-187">When using MTOM, the preceding data contract is serialized according to the following rules:</span></span>  
  
- <span data-ttu-id="25ae3-188">如果 `binaryBuffer` 不是 `null`，并且有个别包含足够的数据，使得需要 Base64 编码所没有的 MTOM 外部化开销（MIME 头等等），则这些数据将外部化并作为二进制 MIME 部分随消息一起传送。</span><span class="sxs-lookup"><span data-stu-id="25ae3-188">If `binaryBuffer` is not `null` and individually contains enough data to justify the MTOM externalization overhead (MIME headers, and so on) when compared to Base64 encoding, the data is externalized and carried with the message as a binary MIME part.</span></span> <span data-ttu-id="25ae3-189">如果未超过阈值，则数据会编码为 Base64。</span><span class="sxs-lookup"><span data-stu-id="25ae3-189">If the threshold is not exceeded, the data is encoded as Base64.</span></span>  
  
- <span data-ttu-id="25ae3-190">字符串（和其他所有非二进制的类型）无论多大，始终表示为消息正文内的字符串。</span><span class="sxs-lookup"><span data-stu-id="25ae3-190">The string (and all other types that are not binary) is always represented as a string inside the message body, regardless of size.</span></span>  
  
 <span data-ttu-id="25ae3-191">无论您是否使用显式数据协定（如上面的示例中所示）、操作中是否使用参数列表、是否有嵌套的数据协定或者是否传输集合内的数据协定对象，MTOM 编码的效果都是一样的。</span><span class="sxs-lookup"><span data-stu-id="25ae3-191">The effect on the MTOM encoding is the same whether you use an explicit data contract, as shown in the preceding example, use a parameter list in an operation, have nested data contracts, or transfer a data contract object inside a collection.</span></span> <span data-ttu-id="25ae3-192">字节数组始终是优化的候选项，如果达到优化阈值，将会对字节数组进行优化。</span><span class="sxs-lookup"><span data-stu-id="25ae3-192">Byte arrays are always candidates for optimization and are optimized if the optimization thresholds are being met.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="25ae3-193">您不应在数据协定内使用 <xref:System.IO.Stream?displayProperty=nameWithType> 派生类型。</span><span class="sxs-lookup"><span data-stu-id="25ae3-193">You should not be using <xref:System.IO.Stream?displayProperty=nameWithType> derived types inside of data contracts.</span></span> <span data-ttu-id="25ae3-194">应使用流模型传输流数据，如下面的“数据的流模式”一节所述。</span><span class="sxs-lookup"><span data-stu-id="25ae3-194">Stream data should be communicated using the streaming model, explained in the following "Streaming Data" section.</span></span>  
  
## <a name="streaming-data"></a><span data-ttu-id="25ae3-195">数据的流模式</span><span class="sxs-lookup"><span data-stu-id="25ae3-195">Streaming Data</span></span>  

 <span data-ttu-id="25ae3-196">当有大量数据要传输时，WCF 中的流传输模式是一种可用于在内存中缓冲和处理消息的默认行为的可行替代方法。</span><span class="sxs-lookup"><span data-stu-id="25ae3-196">When you have a large amount of data to transfer, the streaming transfer mode in WCF is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</span></span>  
  
 <span data-ttu-id="25ae3-197">如上所述，只应对数据无法分段、消息必须以及时的方式传递或者当传输启动时数据尚未完全就绪的大型消息（带文本或二进制内容）启用流模式。</span><span class="sxs-lookup"><span data-stu-id="25ae3-197">As mentioned earlier, enable streaming only for large messages (with text or binary content) if the data cannot be segmented, if the message must be delivered in a timely fashion, or if the data is not yet fully available when the transfer is initiated.</span></span>  
  
### <a name="restrictions"></a><span data-ttu-id="25ae3-198">限制</span><span class="sxs-lookup"><span data-stu-id="25ae3-198">Restrictions</span></span>  

 <span data-ttu-id="25ae3-199">启用流式处理时，不能使用大量的 WCF 功能：</span><span class="sxs-lookup"><span data-stu-id="25ae3-199">You cannot use a significant number of WCF features when streaming is enabled:</span></span>  
  
- <span data-ttu-id="25ae3-200">无法执行消息正文的数字签名，因为它们需要对整个消息内容进行哈希运算。</span><span class="sxs-lookup"><span data-stu-id="25ae3-200">Digital signatures for the message body cannot be performed because they require computing a hash over the entire message contents.</span></span> <span data-ttu-id="25ae3-201">采用流模式的情况下，当构造和发送消息头时，内容尚未完全就绪，因此无法计算数字签名。</span><span class="sxs-lookup"><span data-stu-id="25ae3-201">With streaming, the content is not fully available when the message headers are constructed and sent and, therefore, a digital signature cannot be computed.</span></span>  
  
- <span data-ttu-id="25ae3-202">加密依赖于数字签名来验证是否已正确地重新构造数据。</span><span class="sxs-lookup"><span data-stu-id="25ae3-202">Encryption depends on digital signatures to verify that the data has been reconstructed correctly.</span></span>  
  
- <span data-ttu-id="25ae3-203">如果消息在传输过程中丢失，可靠的会话必须在客户端上缓冲已发送的消息以便可以重新传递，并且在将消息传递给服务实现之前必须在服务上保留消息以保存消息顺序，以备在未按顺序接收消息时可以按照正确的顺序重新排列消息。</span><span class="sxs-lookup"><span data-stu-id="25ae3-203">Reliable sessions must buffer sent messages on the client for redelivery if a message gets lost in transfer and must hold messages on the service before handing them to the service implementation to preserve message order in case messages are received out-of-sequence.</span></span>  
  
 <span data-ttu-id="25ae3-204">由于上述功能约束，您只能对流模式使用传输级安全选项，并且无法打开可靠会话。</span><span class="sxs-lookup"><span data-stu-id="25ae3-204">Because of these functional constraints, you can use only transport-level security options for streaming and you cannot turn on reliable sessions.</span></span> <span data-ttu-id="25ae3-205">流处理仅在下列系统定义的绑定中可用：</span><span class="sxs-lookup"><span data-stu-id="25ae3-205">Streaming is only available with the following system-defined bindings:</span></span>  
  
- <xref:System.ServiceModel.BasicHttpBinding>  
  
- <xref:System.ServiceModel.NetTcpBinding>  
  
- <xref:System.ServiceModel.NetNamedPipeBinding>  
  
- <xref:System.ServiceModel.WebHttpBinding>  
  
 <span data-ttu-id="25ae3-206">由于 <xref:System.ServiceModel.NetTcpBinding> 和 <xref:System.ServiceModel.NetNamedPipeBinding> 的基础传输具有内在的可靠传递和基于连接的会话支持，因此与 HTTP 不同，这两个绑定在实践中受上述约束的影响非常小。</span><span class="sxs-lookup"><span data-stu-id="25ae3-206">Because the underlying transports of <xref:System.ServiceModel.NetTcpBinding> and <xref:System.ServiceModel.NetNamedPipeBinding> have inherent reliable delivery and connection-based session support, unlike HTTP, these two bindings are only minimally affected by these constraints, in practice.</span></span>  
  
 <span data-ttu-id="25ae3-207">流模式在消息队列 (MSMQ) 传输中不可用，因此不能与 <xref:System.ServiceModel.NetMsmqBinding> 或 <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> 类一起使用。</span><span class="sxs-lookup"><span data-stu-id="25ae3-207">Streaming is not available with the Message Queuing (MSMQ) transport and so cannot be used with the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class.</span></span> <span data-ttu-id="25ae3-208">消息队列传输仅支持限定消息大小的缓冲数据传输，而大多数情形下其他所有传输都不具有任何实际的消息大小限制。</span><span class="sxs-lookup"><span data-stu-id="25ae3-208">The Message Queuing transport only supports buffered data transfers with a constrained message size, while all other transports do not have any practical message size limit for the vast majority of scenarios.</span></span>  
  
 <span data-ttu-id="25ae3-209">当使用对等通道传输时，流模式也不可用，因此流模式在 <xref:System.ServiceModel.NetPeerTcpBinding> 中不可用。</span><span class="sxs-lookup"><span data-stu-id="25ae3-209">Streaming is also not available when using the Peer Channel transport, so is not available with the <xref:System.ServiceModel.NetPeerTcpBinding>.</span></span>  
  
#### <a name="streaming-and-sessions"></a><span data-ttu-id="25ae3-210">流和会话</span><span class="sxs-lookup"><span data-stu-id="25ae3-210">Streaming and Sessions</span></span>  

 <span data-ttu-id="25ae3-211">在流与基于会话的绑定一起调用时可能会产生意外行为。</span><span class="sxs-lookup"><span data-stu-id="25ae3-211">You may get unexpected behavior when streaming calls with a session-based binding.</span></span> <span data-ttu-id="25ae3-212">可通过单一通道（数据报通道）执行所有流调用，该通道不支持会话，即使将正在使用的绑定配置为使用会话也是如此。</span><span class="sxs-lookup"><span data-stu-id="25ae3-212">All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</span></span> <span data-ttu-id="25ae3-213">如果多个客户端通过基于会话的绑定对同一服务对象进行流调用，并且该服务对象的并发模式设置为“单个”，同时其实例上下文模式设置为 PerSession，则所用调用都必须经过数据报通道，因此一次只处理一个调用。</span><span class="sxs-lookup"><span data-stu-id="25ae3-213">If multiple clients make streaming calls to the same service object over a session-based binding and the service object's concurrency mode is set to single and its instance context mode is set to PerSession, all calls must go through the datagram channel and so only one call is processed at a time.</span></span> <span data-ttu-id="25ae3-214">一个或多个客户端可能会超时。可以通过将服务对象的实例上下文模式设置为 PerCall 或并发性到多个，来解决此问题。</span><span class="sxs-lookup"><span data-stu-id="25ae3-214">One or more clients may then time out. You can work around this issue by either setting the service object's Instance Context Mode to PerCall or Concurrency to Multiple.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="25ae3-215">MaxConcurrentSessions 在此情况下不会产生任何影响，因为只有一个“会话”可用。</span><span class="sxs-lookup"><span data-stu-id="25ae3-215">MaxConcurrentSessions has no effect in this case because there is only one "session" available.</span></span>  
  
### <a name="enabling-streaming"></a><span data-ttu-id="25ae3-216">启用流模式</span><span class="sxs-lookup"><span data-stu-id="25ae3-216">Enabling Streaming</span></span>  

 <span data-ttu-id="25ae3-217">您可以通过以下方式启用流模式：</span><span class="sxs-lookup"><span data-stu-id="25ae3-217">You can enable streaming in the following ways:</span></span>  
  
- <span data-ttu-id="25ae3-218">以流模式发送和接受请求，以缓冲模式接受和返回响应 (<xref:System.ServiceModel.TransferMode.StreamedRequest>)。</span><span class="sxs-lookup"><span data-stu-id="25ae3-218">Send and accept requests in streaming mode, and accept and return responses in buffered mode (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span></span>  
  
- <span data-ttu-id="25ae3-219">以缓冲模式发送和接受请求，以流模式接受和返回响应 (<xref:System.ServiceModel.TransferMode.StreamedResponse>)。</span><span class="sxs-lookup"><span data-stu-id="25ae3-219">Send and accept requests in buffered mode, and accept and return responses in streamed mode (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span></span>  
  
- <span data-ttu-id="25ae3-220">在两个方向均以流模式发送/接收请求/响应</span><span class="sxs-lookup"><span data-stu-id="25ae3-220">Send and receive requests and responses in streamed mode in both directions.</span></span> <span data-ttu-id="25ae3-221">(<xref:System.ServiceModel.TransferMode.Streamed>).</span><span class="sxs-lookup"><span data-stu-id="25ae3-221">(<xref:System.ServiceModel.TransferMode.Streamed>).</span></span>  
  
 <span data-ttu-id="25ae3-222">您可以通过将传输模式设置为 <xref:System.ServiceModel.TransferMode.Buffered> 来禁用流模式，该设置是所有绑定的默认设置。</span><span class="sxs-lookup"><span data-stu-id="25ae3-222">You can disable streaming by setting the transfer mode to <xref:System.ServiceModel.TransferMode.Buffered>, which is the default setting on all bindings.</span></span> <span data-ttu-id="25ae3-223">下面的代码演示如何在配置中设置传输模式。</span><span class="sxs-lookup"><span data-stu-id="25ae3-223">The following code shows how to set the transfer mode in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <basicHttpBinding>  
        <binding name="ExampleBinding" transferMode="Streamed"/>  
      </basicHttpBinding>  
    </bindings>  
     …  
</system.serviceModel>  
```  
  
 <span data-ttu-id="25ae3-224">当通过代码实例化绑定时，必须将该绑定（如果您创建自定义绑定，则为传输绑定元素）的 `TransferMode` 属性设置为上面提到的某个值。</span><span class="sxs-lookup"><span data-stu-id="25ae3-224">When you instantiate your binding in code, you must set the respective `TransferMode` property of the binding (or the transport binding element if you are composing a custom binding) to one of the previously mentioned values.</span></span>  
  
 <span data-ttu-id="25ae3-225">您可以在不影响功能的情况下在通信双方的任何一方独立地对请求和答复或者同时对两个方向启用流模式。</span><span class="sxs-lookup"><span data-stu-id="25ae3-225">You can turn on streaming for requests and replies or for both directions independently at either side of the communicating parties without affecting functionality.</span></span> <span data-ttu-id="25ae3-226">不过，您应始终认为已传输数据的大小非常大，完全需要在通信链路的两个终结点上均启用流模式。</span><span class="sxs-lookup"><span data-stu-id="25ae3-226">However, you should always assume that the transferred data size is so significant that enabling streaming is justified on both endpoints of a communication link.</span></span> <span data-ttu-id="25ae3-227">对于其中一个终结点未使用 WCF 实现的跨平台通信，使用流式处理的能力取决于平台的流式处理功能。</span><span class="sxs-lookup"><span data-stu-id="25ae3-227">For cross-platform communication where one of the endpoints is not implemented with WCF, the ability to use streaming depends on the platform's streaming capabilities.</span></span> <span data-ttu-id="25ae3-228">另一个极少见的例外可能是一种内存消耗驱动情形，在这种情形下，客户端或服务必须尽量减小其工作集，并且只能提供较小的缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="25ae3-228">Another rare exception might be a memory-consumption driven scenario where a client or service must minimize its working set and can only afford small buffer sizes.</span></span>  
  
### <a name="enabling-asynchronous-streaming"></a><span data-ttu-id="25ae3-229">启用异步流处理</span><span class="sxs-lookup"><span data-stu-id="25ae3-229">Enabling Asynchronous Streaming</span></span>  

 <span data-ttu-id="25ae3-230">若要启用异步流，请将 <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> 终结点行为添加到服务主机，并将其 <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> 属性设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="25ae3-230">To enable asynchronous streaming, add the  <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> endpoint behavior to the service host and set its <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> property to `true`.</span></span> <span data-ttu-id="25ae3-231">我们还在发送端添加真正异步流处理的能力。</span><span class="sxs-lookup"><span data-stu-id="25ae3-231">We have also added the capability of true asynchronous streaming on the send side.</span></span> <span data-ttu-id="25ae3-232">在将消息流式处理到多个客户端的方案中，这可提高服务的可扩展性；其中某些客户端的读取速度较慢，这可能由于网络拥塞或根本无法阅读造成的。</span><span class="sxs-lookup"><span data-stu-id="25ae3-232">This improves scalability of the service in scenarios where it is streaming messages to multiple clients some of which are slow in reading possibly due to network congestion or are not reading at all.</span></span> <span data-ttu-id="25ae3-233">在这些方案中，我们现在不针对每个客户端对服务阻止各个线程。</span><span class="sxs-lookup"><span data-stu-id="25ae3-233">In these scenarios we now do not block individual threads on the service per client.</span></span> <span data-ttu-id="25ae3-234">这确保服务能够处理多得多的客户端，进而提高服务的可扩展性。</span><span class="sxs-lookup"><span data-stu-id="25ae3-234">This ensures that the service is able to process many more clients thereby improving the scalability of the service.</span></span>  
  
### <a name="programming-model-for-streamed-transfers"></a><span data-ttu-id="25ae3-235">流式传输的编程模型</span><span class="sxs-lookup"><span data-stu-id="25ae3-235">Programming Model for Streamed Transfers</span></span>  

 <span data-ttu-id="25ae3-236">流式传输的编程模型非常简单。</span><span class="sxs-lookup"><span data-stu-id="25ae3-236">The programming model for streaming is straightforward.</span></span> <span data-ttu-id="25ae3-237">要接收流数据，请指定具有单个 <xref:System.IO.Stream> 类型化输入参数的操作协定。</span><span class="sxs-lookup"><span data-stu-id="25ae3-237">For receiving streamed data, specify an operation contract that has a single <xref:System.IO.Stream> typed input parameter.</span></span> <span data-ttu-id="25ae3-238">为了返回流数据，应返回一个 <xref:System.IO.Stream> 引用。</span><span class="sxs-lookup"><span data-stu-id="25ae3-238">For returning streamed data, return a <xref:System.IO.Stream> reference.</span></span>  
  
```csharp
[ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]  
public interface IStreamedService  
{  
    [OperationContract]  
    Stream Echo(Stream data);  
    [OperationContract]  
    Stream RequestInfo(string query);  
    [OperationContract(OneWay=true)]  
    void ProvideInfo(Stream data);  
}  
```  
  
 <span data-ttu-id="25ae3-239">上面示例中的操作 `Echo` 接收并返回一个流，因此应当用在具有 <xref:System.ServiceModel.TransferMode.Streamed> 的绑定上。</span><span class="sxs-lookup"><span data-stu-id="25ae3-239">The operation `Echo` in the preceding example receives and returns a stream and should therefore be used on a binding with <xref:System.ServiceModel.TransferMode.Streamed>.</span></span> <span data-ttu-id="25ae3-240">对于操作 `RequestInfo`，<xref:System.ServiceModel.TransferMode.StreamedResponse> 最适合，因为它仅仅返回 <xref:System.IO.Stream>。</span><span class="sxs-lookup"><span data-stu-id="25ae3-240">For the operation `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> is best suited, because it only returns a <xref:System.IO.Stream>.</span></span> <span data-ttu-id="25ae3-241">单向操作最适合于 <xref:System.ServiceModel.TransferMode.StreamedRequest>。</span><span class="sxs-lookup"><span data-stu-id="25ae3-241">The one-way operation is best suited for <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span></span>  
  
 <span data-ttu-id="25ae3-242">请注意，向后面的 `Echo` 或 `ProvideInfo` 操作添加第二个参数会导致服务模型回复为缓冲策略，并使用流的运行时序列化表示。</span><span class="sxs-lookup"><span data-stu-id="25ae3-242">Note that adding a second parameter to the following `Echo` or `ProvideInfo` operations causes the service model to revert back to a buffered strategy and use the run-time serialization representation of the stream.</span></span> <span data-ttu-id="25ae3-243">只有具有单个输入流参数的操作才与端对端请求流兼容。</span><span class="sxs-lookup"><span data-stu-id="25ae3-243">Only operations with a single input stream parameter are compatible with end-to-end request streaming.</span></span>  
  
 <span data-ttu-id="25ae3-244">类似地，此规则也适用于消息协定。</span><span class="sxs-lookup"><span data-stu-id="25ae3-244">This rule similarly applies to message contracts.</span></span> <span data-ttu-id="25ae3-245">如下面的消息协定所示，在流模式的消息协定中，只能有一个正文成员。</span><span class="sxs-lookup"><span data-stu-id="25ae3-245">As shown in the following message contract, you can have only a single body member in your message contract that is a stream.</span></span> <span data-ttu-id="25ae3-246">如果希望使用流传送更多信息，必须在消息头中携带这一信息。</span><span class="sxs-lookup"><span data-stu-id="25ae3-246">If you want to communicate additional information with the stream, this information must be a carried in message headers.</span></span> <span data-ttu-id="25ae3-247">消息正文是专为流内容保留的。</span><span class="sxs-lookup"><span data-stu-id="25ae3-247">The message body is exclusively reserved for the stream content.</span></span>  
  
```csharp
[MessageContract]  
public class UploadStreamMessage  
{  
   [MessageHeader]  
   public string appRef;  
   [MessageBodyMember]  
   public Stream data;  
}
```  
  
 <span data-ttu-id="25ae3-248">当流到达文件尾 (EOF) 时，流传输结束，消息关闭。</span><span class="sxs-lookup"><span data-stu-id="25ae3-248">Streamed transfers end and the message is closed when the stream reaches the end of file (EOF).</span></span> <span data-ttu-id="25ae3-249">发送消息 (返回值或) 调用操作时，可以传递 <xref:System.IO.FileStream> ，然后 WCF 基础结构将从该流中提取所有数据，直到流已完全读取并到达 EOF。</span><span class="sxs-lookup"><span data-stu-id="25ae3-249">When sending a message (returning a value or invoking an operation), you can pass a <xref:System.IO.FileStream> and the WCF infrastructure subsequently pulls all the data from that stream until the stream has been completely read and reached EOF.</span></span> <span data-ttu-id="25ae3-250">要为不存在此类预置 <xref:System.IO.Stream> 派生类的源传输流数据，请构造这样一个类，用该类覆盖流源，并将其用作自变量或返回值。</span><span class="sxs-lookup"><span data-stu-id="25ae3-250">To transfer streamed data for the source that no such pre-built <xref:System.IO.Stream> derived class exists, construct such a class, overlay that class over your stream source, and use that as the argument or return value.</span></span>  
  
 <span data-ttu-id="25ae3-251">当接收消息时，WCF 会在 Base64 编码的消息正文内容 (或各自的 MIME 部分中构造流，前提是使用 MTOM) 并且当内容已读取时，流到达 EOF。</span><span class="sxs-lookup"><span data-stu-id="25ae3-251">When receiving a message, WCF constructs a stream over the Base64-encoded message body content (or the respective MIME part if using MTOM) and the stream reaches EOF when the content has been read.</span></span>  
  
 <span data-ttu-id="25ae3-252">传输级流还可以与其他任何消息协定类型（参数列表、数据协定参数和显式消息协定）一起工作，但是由于此类型化消息的序列化和反序列化要求由序列化程序进行缓冲，因此不建议使用此类协定变体。</span><span class="sxs-lookup"><span data-stu-id="25ae3-252">Transport-level streaming also works with any other message contract type (parameter lists, data contract arguments, and explicit message contract), but because the serialization and deserialization of such typed messages requires buffering by the serializer, using such contract variants is not advisable.</span></span>  
  
### <a name="special-security-considerations-for-large-data"></a><span data-ttu-id="25ae3-253">关于大型数据的特殊安全考虑事项</span><span class="sxs-lookup"><span data-stu-id="25ae3-253">Special Security Considerations for Large Data</span></span>  

 <span data-ttu-id="25ae3-254">所有绑定都允许您限制传入消息的大小，以阻止拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="25ae3-254">All bindings allow you to constrain the size of incoming messages to prevent denial-of-service attacks.</span></span> <span data-ttu-id="25ae3-255"><xref:System.ServiceModel.BasicHttpBinding>例如，公开[BasicHttpBinding MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A)属性，该属性限制传入消息的大小，因此也会限制处理消息时所访问的最大内存量。</span><span class="sxs-lookup"><span data-stu-id="25ae3-255">The <xref:System.ServiceModel.BasicHttpBinding>, for example, exposes a [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) property that bounds the size of the incoming message, and so also bounds the maximum amount of memory that is accessed when processing the message.</span></span> <span data-ttu-id="25ae3-256">此单元是以字节为单位设置的，默认值为 65,536 个字节。</span><span class="sxs-lookup"><span data-stu-id="25ae3-256">This unit is set in bytes with a default value of 65,536 bytes.</span></span>  
  
 <span data-ttu-id="25ae3-257">大型数据流情形所特有的安全威胁会在接收方希望数据以流模式发送时导致数据缓冲，从而促使拒绝服务。</span><span class="sxs-lookup"><span data-stu-id="25ae3-257">A security threat that is specific to the large data streaming scenario provokes a denial of service by causing data to be buffered when the receiver expects it to be streamed.</span></span> <span data-ttu-id="25ae3-258">例如，WCF 始终会缓冲消息的 SOAP 标头，因此攻击者可能会构建一个完全由标头组成的大型恶意消息来强制缓冲数据。</span><span class="sxs-lookup"><span data-stu-id="25ae3-258">For example, WCF always buffers the SOAP headers of a message, and so an attacker may construct a large malicious message that consists entirely of headers to force the data to be buffered.</span></span> <span data-ttu-id="25ae3-259">当启用流模式时，`MaxReceivedMessageSize` 可能设置为一个极其大的值，因为接收方绝预料不到会一次性地在内存中缓冲整个消息。</span><span class="sxs-lookup"><span data-stu-id="25ae3-259">When streaming is enabled, the `MaxReceivedMessageSize` may be set to an extremely large value, because the receiver never expects the entire message to be buffered in memory at once.</span></span> <span data-ttu-id="25ae3-260">如果强制 WCF 对消息进行缓冲，则会发生内存溢出。</span><span class="sxs-lookup"><span data-stu-id="25ae3-260">If WCF is forced to buffer the message, a memory overflow occurs.</span></span>  
  
 <span data-ttu-id="25ae3-261">因此，这种情况下仅限制最大传入消息大小是不够的。</span><span class="sxs-lookup"><span data-stu-id="25ae3-261">Therefore, restricting the maximum incoming message size is not enough in this case.</span></span> <span data-ttu-id="25ae3-262">`MaxBufferSize`需要属性来约束 WCF 缓冲区的内存。</span><span class="sxs-lookup"><span data-stu-id="25ae3-262">The `MaxBufferSize` property is required to constrain the memory that WCF buffers.</span></span> <span data-ttu-id="25ae3-263">进行流处理时，将此属性设置为一个安全值（或保留为默认值）很重要。</span><span class="sxs-lookup"><span data-stu-id="25ae3-263">It is important to set this to a safe value (or keep it at the default value) when streaming.</span></span> <span data-ttu-id="25ae3-264">例如，假设您的服务必须接收大至 4 GB 的文件，并将其存储在本地磁盘上。</span><span class="sxs-lookup"><span data-stu-id="25ae3-264">For example, suppose your service must receive files up to 4 GB in size and store them on the local disk.</span></span> <span data-ttu-id="25ae3-265">另外，还假设您的内存存在一些约束，一次只能缓冲 64 KB 的数据。</span><span class="sxs-lookup"><span data-stu-id="25ae3-265">Suppose also that your memory is constrained in such a way that you can only buffer 64 KB of data at a time.</span></span> <span data-ttu-id="25ae3-266">这样，您应该将 `MaxReceivedMessageSize` 设置为 4 GB，将 `MaxBufferSize` 设置为 64 KB。</span><span class="sxs-lookup"><span data-stu-id="25ae3-266">Then you would set the `MaxReceivedMessageSize` to 4 GB and `MaxBufferSize` to 64 KB.</span></span> <span data-ttu-id="25ae3-267">另外，在您的服务实现中，必须确保仅按 64 KB 大小的块从传入流中读取数据，并且在上一块写入到磁盘并从内存中丢弃之前，不读取下一块。</span><span class="sxs-lookup"><span data-stu-id="25ae3-267">Also, in your service implementation, you must ensure that you read only from the incoming stream in 64-KB chunks and do not read the next chunk before the previous one has been written to disk and discarded from memory.</span></span>  
  
 <span data-ttu-id="25ae3-268">还必须了解，此配额仅限制由 WCF 完成的缓冲，而不能防止您在自己的服务或客户端实现中执行任何缓冲。</span><span class="sxs-lookup"><span data-stu-id="25ae3-268">It is also important to understand that this quota only limits the buffering done by WCF and cannot protect you against any buffering that you do in your own service or client implementation.</span></span> <span data-ttu-id="25ae3-269">有关其他安全注意事项的详细信息，请参阅 [数据的安全注意事项](security-considerations-for-data.md)。</span><span class="sxs-lookup"><span data-stu-id="25ae3-269">For more information about additional security considerations, see [Security Considerations for Data](security-considerations-for-data.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="25ae3-270">使用缓冲传输还是流传输是在终结点本地决定的。</span><span class="sxs-lookup"><span data-stu-id="25ae3-270">The decision to use either buffered or streamed transfers is a local decision of the endpoint.</span></span> <span data-ttu-id="25ae3-271">对于 HTTP 传输，传输模式不会通过连接传播，也不会传播到代理服务器和其他中间方。</span><span class="sxs-lookup"><span data-stu-id="25ae3-271">For HTTP transports, the transfer mode does not propagate across a connection or to proxy servers and other intermediaries.</span></span> <span data-ttu-id="25ae3-272">设置传输模式不会反映在服务接口的说明中。</span><span class="sxs-lookup"><span data-stu-id="25ae3-272">Setting the transfer mode is not reflected in the description of the service interface.</span></span> <span data-ttu-id="25ae3-273">将 WCF 客户端生成到服务后，必须编辑要与流式传输一起使用的服务的配置文件，以设置模式。</span><span class="sxs-lookup"><span data-stu-id="25ae3-273">After generating a WCF client to a service, you must edit the configuration file for services intended to be used with streamed transfers to set the mode.</span></span> <span data-ttu-id="25ae3-274">对于 TCP 和命名管道传输协议，该传输模式将作为策略断言传播。</span><span class="sxs-lookup"><span data-stu-id="25ae3-274">For TCP and named pipe transports, the transfer mode is propagated as a policy assertion.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="25ae3-275">另请参阅</span><span class="sxs-lookup"><span data-stu-id="25ae3-275">See also</span></span>

- [<span data-ttu-id="25ae3-276">如何：启用流处理</span><span class="sxs-lookup"><span data-stu-id="25ae3-276">How to: Enable Streaming</span></span>](how-to-enable-streaming.md)
