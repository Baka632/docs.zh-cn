---
title: 实例锁定异常操作
ms.date: 03/30/2017
ms.assetid: 164a5419-315c-4987-ad72-54cbdb88d402
ms.openlocfilehash: 3554975589bb6d55cef3611320d25687d1ee9ba6
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/26/2020
ms.locfileid: "96279852"
---
# <a name="instance-locked-exception-action"></a><span data-ttu-id="f80b1-102">实例锁定异常操作</span><span class="sxs-lookup"><span data-stu-id="f80b1-102">Instance Locked Exception Action</span></span>

<span data-ttu-id="f80b1-103">利用 SQL 工作流实例存储的 <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceLockedExceptionAction%2A> 属性，可以指定当 SQL 持久性提供程序收到 <xref:System.Runtime.DurableInstancing.InstanceLockedException> 时应采取什么操作。</span><span class="sxs-lookup"><span data-stu-id="f80b1-103">The <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore.InstanceLockedExceptionAction%2A> property of the SQL Workflow Instance Store lets you specify what action the SQL persistence provider should take when it receives an <xref:System.Runtime.DurableInstancing.InstanceLockedException>.</span></span> <span data-ttu-id="f80b1-104">当持久性提供程序尝试锁定当前已由另一个服务主机锁定的工作流服务实例时，将收到此异常。</span><span class="sxs-lookup"><span data-stu-id="f80b1-104">The persistence provider receives this exception when it tries to lock a workflow service instance that is currently locked by another service host.</span></span> <span data-ttu-id="f80b1-105">此属性的值有 <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>、<xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> 和 <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>。</span><span class="sxs-lookup"><span data-stu-id="f80b1-105">The values for this property are <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>, <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry>, and <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>.</span></span> <span data-ttu-id="f80b1-106">默认值为 <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>。</span><span class="sxs-lookup"><span data-stu-id="f80b1-106">The default value is <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span></span> <span data-ttu-id="f80b1-107">以下列表对这三个选项进行了说明：</span><span class="sxs-lookup"><span data-stu-id="f80b1-107">The following list describes the three options:</span></span>  
  
- <span data-ttu-id="f80b1-108"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span><span class="sxs-lookup"><span data-stu-id="f80b1-108"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span></span> <span data-ttu-id="f80b1-109">服务主机不会尝试锁定工作流服务实例，并将传递 <xref:System.Runtime.DurableInstancing.InstanceLockedException> 给调用方。</span><span class="sxs-lookup"><span data-stu-id="f80b1-109">The service host does not attempt to lock the workflow service instance and passes the <xref:System.Runtime.DurableInstancing.InstanceLockedException> to the caller.</span></span>  <span data-ttu-id="f80b1-110">如果工作流在内存中保留的时间超过了60秒，请使用 <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry> 作为重试。</span><span class="sxs-lookup"><span data-stu-id="f80b1-110">If your workflow stays in memory for a period exceeding 60 seconds, use <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry> as the retry.</span></span> <span data-ttu-id="f80b1-111">默认值为 <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>。</span><span class="sxs-lookup"><span data-stu-id="f80b1-111">The default value is <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.NoRetry>.</span></span>  
  
- <span data-ttu-id="f80b1-112"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry>.</span><span class="sxs-lookup"><span data-stu-id="f80b1-112"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry>.</span></span> <span data-ttu-id="f80b1-113">服务主机将以线性间隔在重试尝试之间重新尝试锁定工作流服务实例，并在序列结尾将 <xref:System.Runtime.DurableInstancing.InstanceLockedException> 传递给调用方。</span><span class="sxs-lookup"><span data-stu-id="f80b1-113">The service host reattempts to lock the workflow service instance with a linear interval between retry attempts and passes the <xref:System.Runtime.DurableInstancing.InstanceLockedException> to the caller at the end of the sequence.</span></span> <span data-ttu-id="f80b1-114">如果工作流在内存中将停留约 5-60 秒，并且消息分批到达（其中，消息更可能发送给相同主机上的相同实例，以便处理所有消息，然后再卸载工作流），则使用 <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> 可实现最佳延迟并且不会浪费资源。</span><span class="sxs-lookup"><span data-stu-id="f80b1-114">If you workflow stays in memory approximately between 5-60 seconds, and messages arrive in batches where it is more likely for messages being sent to the same instance on the same host to process all messages before unloading the workflow, use <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> to achieve the best latency without wasting resources.</span></span>  
  
- <span data-ttu-id="f80b1-115"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>.</span><span class="sxs-lookup"><span data-stu-id="f80b1-115"><xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>.</span></span> <span data-ttu-id="f80b1-116">服务主机将以指数回退间隔在重试之间重新尝试锁定工作流服务实例，并在序列结尾将异常传递给调用方。</span><span class="sxs-lookup"><span data-stu-id="f80b1-116">The service host reattempts to lock the workflow service instance with an exponential backoff interval between retry attempts, and passes the exception to the caller at the end of the sequence.</span></span> <span data-ttu-id="f80b1-117">如果你的工作流在内存中停留的时间很短（少于 5 秒），或者网络场很大并且另一个消息传递到同一主机的机会不是很高，则使用 <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry> 可实现最佳延迟。</span><span class="sxs-lookup"><span data-stu-id="f80b1-117">If your workflow stays in memory for a very short time (less than 5 seconds), or a Web farm is large and the chance of another message being delivered to the same host is not very high, use <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry> to achieve the best latency.</span></span>  
  
 <span data-ttu-id="f80b1-118">实例锁定异常操作功能支持以下方案。</span><span class="sxs-lookup"><span data-stu-id="f80b1-118">The Instance Locked Exception Action feature supports the following scenarios.</span></span> <span data-ttu-id="f80b1-119">在所有方案中，如果将 SqlWorkflowInstanceStore 的 instanceLockedExceptionAction 属性设置为 <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> 或 <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>，主机会定期透明地重试获取对实例的锁定。</span><span class="sxs-lookup"><span data-stu-id="f80b1-119">In all scenarios, if the instanceLockedExceptionAction property of the SqlWorkflowInstanceStore is set to <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.BasicRetry> or <xref:System.Activities.DurableInstancing.InstanceLockedExceptionAction.AggressiveRetry>, the host transparently retries to acquire the lock on instances periodically.</span></span>  
  
1. <span data-ttu-id="f80b1-120">**支持正常关机和应用程序域的重叠回收。**</span><span class="sxs-lookup"><span data-stu-id="f80b1-120">**Enabling graceful shutdown and overlapped recycling of application domains.**</span></span> <span data-ttu-id="f80b1-121">假设正在回收一个服务主机运行工作流服务实例的 **appdomain** ，并在旧 **appdomain** 正常关闭的情况下，将新的 **appdomain** 置于并行处理新请求。</span><span class="sxs-lookup"><span data-stu-id="f80b1-121">Suppose an **AppDomain** with a service host running workflow service instances is being recycled and a new **AppDomain** is brought up to handle new requests in parallel while the old **AppDomain** is brought down gracefully.</span></span> <span data-ttu-id="f80b1-122">此关闭将等待一段时间，直到工作流服务实例空闲为止，然后将保存并卸载这些实例。</span><span class="sxs-lookup"><span data-stu-id="f80b1-122">The shutdown waits until workflow service instances are idle, and then persists and unloads the instances.</span></span> <span data-ttu-id="f80b1-123">新 **AppDomain** 中的主机用于锁定实例的任何尝试都会导致 <xref:System.Runtime.DurableInstancing.InstanceLockedException> 。</span><span class="sxs-lookup"><span data-stu-id="f80b1-123">Any attempts by hosts in the new **AppDomain** to lock an instance will cause an <xref:System.Runtime.DurableInstancing.InstanceLockedException>.</span></span>  
  
2. <span data-ttu-id="f80b1-124">**在服务器的同一个服务器场中水平缩放持久性工作流。**</span><span class="sxs-lookup"><span data-stu-id="f80b1-124">**Horizontally scaling durable workflows across a homogeneous farm of servers.**</span></span> <span data-ttu-id="f80b1-125">假定服务器场中正在运行工作流实例的某一节点崩溃，并且工作流主机无法移除对其正在运行的实例的锁定。</span><span class="sxs-lookup"><span data-stu-id="f80b1-125">Suppose a node of a server farm on which a workflow instance is running crashes and the workflow host cannot remove locks on the instance it is running.</span></span> <span data-ttu-id="f80b1-126">当场中的另一节点上运行的服务主机接收到有关该工作流实例的消息时，它会尝试获取对这些实例的锁定，并且将接收到 <xref:System.Runtime.DurableInstancing.InstanceLockedException>。</span><span class="sxs-lookup"><span data-stu-id="f80b1-126">When a service host running on another node of the farm receives a message for that workflow instance, it tries to acquire locks on these instances it will receive the <xref:System.Runtime.DurableInstancing.InstanceLockedException>.</span></span> <span data-ttu-id="f80b1-127">该锁定将在一段时间后过期，这是因为原本应续订锁定的主机已不再存在。</span><span class="sxs-lookup"><span data-stu-id="f80b1-127">The locks will expire after some time because the host that was supposed to renew the lock no longer exists.</span></span>  
  
     <span data-ttu-id="f80b1-128">**在服务器的同一个服务器场中水平缩放持久性工作流。**</span><span class="sxs-lookup"><span data-stu-id="f80b1-128">**Horizontally scaling durable workflows across a homogeneous farm of servers.**</span></span>  <span data-ttu-id="f80b1-129">假定您希望使用支持 NLB（网络负载平衡器）的多个主机水平扩展持续性工作流，在场中的一个节点上运行的工作流主机加载了一个工作流实例，并且正在处理一条消息，该实例的下一条消息将路由到在另一节点上运行的主机，其原因在于 NLB 没有相应的路由算法将多条消息传递到已在运行该实例的主机。</span><span class="sxs-lookup"><span data-stu-id="f80b1-129">Suppose you want to horizontally scale a durable workflow using multiple hosts behind a NLB (Network Load Balancer), the workflow host running on one node of the farm loads a workflow instance and is processing a message, and the next message to the instance is routed to the host that is running on another node because the NLB does not have routing algorithm to deliver messages to the host that is already running the instance.</span></span> <span data-ttu-id="f80b1-130">接收到此消息后，第二个主机尝试加载工作流实例，并接收到 <xref:System.Runtime.DurableInstancing.InstanceLockedException>，这是因为第一个主机已锁定该实例。</span><span class="sxs-lookup"><span data-stu-id="f80b1-130">Upon receiving the message, the second host attempts to load the workflow instance and receives the <xref:System.Runtime.DurableInstancing.InstanceLockedException> because the first host has a lock on the instance.</span></span> <span data-ttu-id="f80b1-131">第一个主机在处理完第一条消息后，将解除对该实例的锁定，第二个主机将在下次重试时获取锁定，然后加载该实例，并处理第二条消息。</span><span class="sxs-lookup"><span data-stu-id="f80b1-131">The first host unlocks the instance when it is finished with processing the first message and the second host acquires the lock when it retries the next time, loads the instance, and processes the second message.</span></span>
