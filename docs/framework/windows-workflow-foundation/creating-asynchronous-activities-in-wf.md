---
title: 在 WF 中创建异步活动
description: 了解如何使用 AsyncCodeActivity 创建自定义异步活动，该活动允许派生的活动实现异步执行逻辑。
ms.date: 03/30/2017
ms.assetid: 497e81ed-5eef-460c-ba55-fae73c05824f
ms.openlocfilehash: a03fbde1ff27084cc36dffc3a1912220d9bbca7e
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/26/2020
ms.locfileid: "96242079"
---
# <a name="creating-asynchronous-activities-in-wf"></a><span data-ttu-id="66055-103">在 WF 中创建异步活动</span><span class="sxs-lookup"><span data-stu-id="66055-103">Creating Asynchronous Activities in WF</span></span>

<span data-ttu-id="66055-104"><xref:System.Activities.AsyncCodeActivity> 提供一个可供活动作者使用的基类，该基类允许派生的活动实现异步执行逻辑。</span><span class="sxs-lookup"><span data-stu-id="66055-104"><xref:System.Activities.AsyncCodeActivity> provides activity authors a base class to use that enables derived activities to implement asynchronous execution logic.</span></span> <span data-ttu-id="66055-105">这对如下自定义活动非常有用：必须执行异步工作，而不会保持工作流计划程序线程并阻止可以并行运行的所有活动。</span><span class="sxs-lookup"><span data-stu-id="66055-105">This is useful for custom activities that must perform asynchronous work without holding the workflow scheduler thread and blocking any activities that may be able to run in parallel.</span></span> <span data-ttu-id="66055-106">本主题概述了如何使用 <xref:System.Activities.AsyncCodeActivity> 创建自定义异步活动。</span><span class="sxs-lookup"><span data-stu-id="66055-106">This topic provides an overview of how to create custom asynchronous activities using <xref:System.Activities.AsyncCodeActivity>.</span></span>  
  
## <a name="using-asynccodeactivity"></a><span data-ttu-id="66055-107">使用 AsyncCodeActivity</span><span class="sxs-lookup"><span data-stu-id="66055-107">Using AsyncCodeActivity</span></span>  

 <span data-ttu-id="66055-108"><xref:System.Activities?displayProperty=nameWithType> 为自定义活动作者提供了不同基类，以满足不同的活动创作需求。</span><span class="sxs-lookup"><span data-stu-id="66055-108"><xref:System.Activities?displayProperty=nameWithType> provides custom activity authors with different base classes for different activity authoring requirements.</span></span> <span data-ttu-id="66055-109">每一种基类都采用特定语义，并为工作流作者（和活动运行时）提供相应协定。</span><span class="sxs-lookup"><span data-stu-id="66055-109">Each one carries a particular semantic and provides a workflow author (and the activity runtime) a corresponding contract.</span></span> <span data-ttu-id="66055-110">基于 <xref:System.Activities.AsyncCodeActivity> 的活动是指异步执行工作（相对于计划程序线程）且以托管代码表示其执行逻辑的活动。</span><span class="sxs-lookup"><span data-stu-id="66055-110">An <xref:System.Activities.AsyncCodeActivity> based activity is an activity that performs work asynchronously relative to the scheduler thread and whose execution logic is expressed in managed code.</span></span> <span data-ttu-id="66055-111">由于将异步执行，因此 <xref:System.Activities.AsyncCodeActivity> 可能会在执行时引入一个空闲点。</span><span class="sxs-lookup"><span data-stu-id="66055-111">As a result of going asynchronous, an <xref:System.Activities.AsyncCodeActivity> may induce an idle point during execution.</span></span> <span data-ttu-id="66055-112">鉴于异步工作灵活多变的性质，<xref:System.Activities.AsyncCodeActivity> 始终创建一个非持久性块来持久执行活动。</span><span class="sxs-lookup"><span data-stu-id="66055-112">Due to the volatile nature of asynchronous work, an <xref:System.Activities.AsyncCodeActivity> always creates a no persist block for the duration of the activity’s execution.</span></span> <span data-ttu-id="66055-113">这可以防止工作流运行时在异步工作中持久化工作流实例，还可以防止工作流实例在执行异步代码时进行卸载。</span><span class="sxs-lookup"><span data-stu-id="66055-113">This prevents the workflow runtime from persisting the workflow instance in the middle of the asynchronous work, and also prevents the workflow instance from unloading while the asynchronous code is executing.</span></span>  
  
### <a name="asynccodeactivity-methods"></a><span data-ttu-id="66055-114">AsyncCodeActivity 方法</span><span class="sxs-lookup"><span data-stu-id="66055-114">AsyncCodeActivity Methods</span></span>  

 <span data-ttu-id="66055-115">从 <xref:System.Activities.AsyncCodeActivity> 派生的活动可以通过用自定义代码重写 <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> 和 <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> 方法来创建异步执行逻辑。</span><span class="sxs-lookup"><span data-stu-id="66055-115">Activities that derive from <xref:System.Activities.AsyncCodeActivity> can create asynchronous execution logic by overriding the <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> and <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> methods with custom code.</span></span> <span data-ttu-id="66055-116">当运行时调用这些方法时，会向这些方法传递一个 <xref:System.Activities.AsyncCodeActivityContext>。</span><span class="sxs-lookup"><span data-stu-id="66055-116">When called by the runtime, these methods are passed an <xref:System.Activities.AsyncCodeActivityContext>.</span></span> <span data-ttu-id="66055-117"><xref:System.Activities.AsyncCodeActivityContext>允许活动作者 <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> /  <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> 在上下文的属性中提供共享状态 <xref:System.Activities.AsyncCodeActivityContext.UserState%2A> 。</span><span class="sxs-lookup"><span data-stu-id="66055-117"><xref:System.Activities.AsyncCodeActivityContext> allows the activity author to provide shared state across <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A>/ <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> in the context’s <xref:System.Activities.AsyncCodeActivityContext.UserState%2A> property.</span></span> <span data-ttu-id="66055-118">在下面的示例中，`GenerateRandom` 活动异步生成一个随机数。</span><span class="sxs-lookup"><span data-stu-id="66055-118">In the following example, a `GenerateRandom` activity generates a random number asynchronously.</span></span>  
  
 [!code-csharp[CFX_ActivityExample#8](~/samples/snippets/csharp/VS_Snippets_CFX/CFX_ActivityExample/cs/Program.cs#8)]  
  
 <span data-ttu-id="66055-119">上一个示例活动派生自 <xref:System.Activities.AsyncCodeActivity%601>，且具有一个名为 `OutArgument<int>` 的提升 `Result`。</span><span class="sxs-lookup"><span data-stu-id="66055-119">The previous example activity derives from <xref:System.Activities.AsyncCodeActivity%601>, and has an elevated `OutArgument<int>` named `Result`.</span></span> <span data-ttu-id="66055-120">`GetRandom` 方法返回的值由 <xref:System.Activities.AsyncCodeActivity%601.EndExecute%2A> 重写提取和返回，并将此值设置为 `Result` 值。</span><span class="sxs-lookup"><span data-stu-id="66055-120">The value returned by the `GetRandom` method is extracted and returned by the <xref:System.Activities.AsyncCodeActivity%601.EndExecute%2A> override, and this value is set as the `Result` value.</span></span> <span data-ttu-id="66055-121">未返回结果的异步活动应派生自 <xref:System.Activities.AsyncCodeActivity>。</span><span class="sxs-lookup"><span data-stu-id="66055-121">Asynchronous activities that do not return a result should derive from <xref:System.Activities.AsyncCodeActivity>.</span></span> <span data-ttu-id="66055-122">在下面的示例中，定义了一个派生自 `DisplayRandom` 的 <xref:System.Activities.AsyncCodeActivity> 活动。</span><span class="sxs-lookup"><span data-stu-id="66055-122">In the following example, a `DisplayRandom` activity is defined which derives from <xref:System.Activities.AsyncCodeActivity>.</span></span> <span data-ttu-id="66055-123">此活动与 `GetRandom` 活动类似，只不过它在返回结果时会向控制台显示一条消息。</span><span class="sxs-lookup"><span data-stu-id="66055-123">This activity is like the `GetRandom` activity but instead of returning a result it displays a message to the console.</span></span>  
  
 [!code-csharp[CFX_ActivityExample#11](~/samples/snippets/csharp/VS_Snippets_CFX/CFX_ActivityExample/cs/Program.cs#11)]  
  
 <span data-ttu-id="66055-124">请注意，由于没有返回值，`DisplayRandom` 将使用 <xref:System.Action> 而非 <xref:System.Func%602> 来调用其委托，并且该委托不返回任何值。</span><span class="sxs-lookup"><span data-stu-id="66055-124">Note that because there is no return value, `DisplayRandom` uses an <xref:System.Action> instead of a <xref:System.Func%602> to invoke its delegate, and the delegate returns no value.</span></span>  
  
 <span data-ttu-id="66055-125"><xref:System.Activities.AsyncCodeActivity> 还提供 <xref:System.Activities.AsyncCodeActivity.Cancel%2A> 重写。</span><span class="sxs-lookup"><span data-stu-id="66055-125"><xref:System.Activities.AsyncCodeActivity> also provides a <xref:System.Activities.AsyncCodeActivity.Cancel%2A> override.</span></span> <span data-ttu-id="66055-126"><xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> 和 <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> 是必需重写，而 <xref:System.Activities.AsyncCodeActivity.Cancel%2A> 是可选重写且可被覆盖，因此当取消或中止活动时，该活动可以清除其未处理的异步状态。</span><span class="sxs-lookup"><span data-stu-id="66055-126">While <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> and <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> are required overrides, <xref:System.Activities.AsyncCodeActivity.Cancel%2A> is optional, and can be overridden so the activity can clean up its outstanding asynchronous state when it is being canceled or aborted.</span></span> <span data-ttu-id="66055-127">如果可以清除，并且 `AsyncCodeActivity.ExecutingActivityInstance.IsCancellationRequested` 为 `true`，则活动应调用 <xref:System.Activities.AsyncCodeActivityContext.MarkCanceled%2A>。</span><span class="sxs-lookup"><span data-stu-id="66055-127">If clean up is possible and `AsyncCodeActivity.ExecutingActivityInstance.IsCancellationRequested` is `true`, the activity should call <xref:System.Activities.AsyncCodeActivityContext.MarkCanceled%2A>.</span></span> <span data-ttu-id="66055-128">对于工作流实例而言，该方法引发的任何异常都是致命的。</span><span class="sxs-lookup"><span data-stu-id="66055-128">Any exceptions thrown from this method are fatal to the workflow instance.</span></span>  
  
 [!code-csharp[CFX_ActivityExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/CFX_ActivityExample/cs/Program.cs#10)]  
  
### <a name="invoking-asynchronous-methods-on-a-class"></a><span data-ttu-id="66055-129">对类调用异步方法</span><span class="sxs-lookup"><span data-stu-id="66055-129">Invoking Asynchronous Methods on a Class</span></span>  

 <span data-ttu-id="66055-130">.NET Framework 中的许多类都提供了异步功能，可以使用基于的活动来异步调用此功能 <xref:System.Activities.AsyncCodeActivity> 。</span><span class="sxs-lookup"><span data-stu-id="66055-130">Many of the classes in the .NET Framework provide asynchronous functionality, and this functionality can be asynchronously invoked by using an <xref:System.Activities.AsyncCodeActivity> based activity.</span></span> <span data-ttu-id="66055-131">在下面的示例中，创建了一个活动，该活动使用类异步创建一个文件 <xref:System.IO.FileStream> 。</span><span class="sxs-lookup"><span data-stu-id="66055-131">In the following example, an activity is created that asynchronously creates a file by using the <xref:System.IO.FileStream> class.</span></span>  
  
 [!code-csharp[CFX_ActivityExample#12](~/samples/snippets/csharp/VS_Snippets_CFX/CFX_ActivityExample/cs/Program.cs#12)]  
  
### <a name="sharing-state-between-the-beginexecute-and-endexecute-methods"></a><span data-ttu-id="66055-132">在 BeginExecute 和 EndExecute 方法之间共享状态</span><span class="sxs-lookup"><span data-stu-id="66055-132">Sharing State Between the BeginExecute and EndExecute Methods</span></span>  

 <span data-ttu-id="66055-133">在前面的示例中，在 <xref:System.IO.FileStream> 中访问了在 <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> 中创建的 <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> 对象。</span><span class="sxs-lookup"><span data-stu-id="66055-133">In the previous example, the <xref:System.IO.FileStream> object that was created in <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> was accessed in the <xref:System.Activities.AsyncCodeActivity.EndExecute%2A>.</span></span> <span data-ttu-id="66055-134">这很可能是因为 `file` 变量被传递到 <xref:System.Activities.AsyncCodeActivityContext.UserState%2A?displayProperty=nameWithType> 中的 <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="66055-134">This is possible because the `file` variable was passed in the <xref:System.Activities.AsyncCodeActivityContext.UserState%2A?displayProperty=nameWithType> property in <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A>.</span></span> <span data-ttu-id="66055-135">这是用于在 <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> 和 <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> 之间共享状态的正确方法。</span><span class="sxs-lookup"><span data-stu-id="66055-135">This is the correct method for sharing state between <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> and <xref:System.Activities.AsyncCodeActivity.EndExecute%2A>.</span></span> <span data-ttu-id="66055-136">使用派生类（在这个例子中为 `FileWriter`）中的成员变量在 <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> 和 <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> 之间共享状态是不正确的做法，因为该活动对象可能被多个活动实例所引用。</span><span class="sxs-lookup"><span data-stu-id="66055-136">It is incorrect to use a member variable in the derived class (`FileWriter` in this case) to share state between <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> and <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> because the activity object may be referenced by multiple activity instances.</span></span> <span data-ttu-id="66055-137">如果尝试使用成员变量共享状态，可能导致来自一个 <xref:System.Activities.ActivityInstance> 中的值覆盖或使用来自另一个 <xref:System.Activities.ActivityInstance> 中的值。</span><span class="sxs-lookup"><span data-stu-id="66055-137">Attempting to use a member variable to share state can result in values from one <xref:System.Activities.ActivityInstance> overwriting or consuming values from another <xref:System.Activities.ActivityInstance>.</span></span>  
  
### <a name="accessing-argument-values"></a><span data-ttu-id="66055-138">访问自变量值</span><span class="sxs-lookup"><span data-stu-id="66055-138">Accessing Argument Values</span></span>  

 <span data-ttu-id="66055-139"><xref:System.Activities.AsyncCodeActivity> 的环境由在活动中定义的自变量组成。</span><span class="sxs-lookup"><span data-stu-id="66055-139">The environment of an <xref:System.Activities.AsyncCodeActivity> consists of the arguments defined on the activity.</span></span> <span data-ttu-id="66055-140">可以 <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A> / <xref:System.Activities.AsyncCodeActivity.EndExecute%2A> 使用参数从重写访问这些参数 <xref:System.Activities.AsyncCodeActivityContext> 。</span><span class="sxs-lookup"><span data-stu-id="66055-140">These arguments can be accessed from the <xref:System.Activities.AsyncCodeActivity.BeginExecute%2A>/<xref:System.Activities.AsyncCodeActivity.EndExecute%2A> overrides using the <xref:System.Activities.AsyncCodeActivityContext> parameter.</span></span> <span data-ttu-id="66055-141">无法在委托中访问实参，但是可以使用其形参将实参值或任何其他所需的数据传入到委托。</span><span class="sxs-lookup"><span data-stu-id="66055-141">The arguments cannot be accessed in the delegate, but the argument values or any other desired data can be passed in to the delegate using its parameters.</span></span> <span data-ttu-id="66055-142">下面的示例定义了随机数生成活动，该活动从其 `Max` 参数中获取其上界（随机数可以取该上界值）。</span><span class="sxs-lookup"><span data-stu-id="66055-142">In the following example, a random number-generating activity is defined that obtains the inclusive upper bound from its `Max` argument.</span></span> <span data-ttu-id="66055-143">当调用委托时，会将自变量的值传入到异步代码中。</span><span class="sxs-lookup"><span data-stu-id="66055-143">The value of the argument is passed in to the asynchronous code when the delegate is invoked.</span></span>  
  
 [!code-csharp[CFX_ActivityExample#9](~/samples/snippets/csharp/VS_Snippets_CFX/CFX_ActivityExample/cs/Program.cs#9)]  
  
### <a name="scheduling-actions-or-child-activities-using-asynccodeactivity"></a><span data-ttu-id="66055-144">使用 AsyncCodeActivity 安排操作或子活动</span><span class="sxs-lookup"><span data-stu-id="66055-144">Scheduling Actions or Child Activities Using AsyncCodeActivity</span></span>  

 <span data-ttu-id="66055-145"><xref:System.Activities.AsyncCodeActivity> 派生的自定义活动提供了以异步方式执行与工作流线程相关的工作的方法，但不提供安排子活动或操作的功能。 </span><span class="sxs-lookup"><span data-stu-id="66055-145"><xref:System.Activities.AsyncCodeActivity> derived custom activities  provide a method for performing work asynchronously with regard to the workflow thread, but do not provide the ability to schedule child activities or actions.</span></span> <span data-ttu-id="66055-146">但是，可以通过组合方式将异步行为纳入子活动的安排。</span><span class="sxs-lookup"><span data-stu-id="66055-146">However, asynchronous behavior can be incorporated with scheduling of child activities through composition.</span></span> <span data-ttu-id="66055-147">可以创建一个异步活动，然后将其与 <xref:System.Activities.Activity> 或 <xref:System.Activities.NativeActivity> 派生活动组合在一起，以便提供异步行为以及子活动或操作的安排。</span><span class="sxs-lookup"><span data-stu-id="66055-147">An asynchronous activity can be created, and then composed with an <xref:System.Activities.Activity> or <xref:System.Activities.NativeActivity> derived activity to provide asynchronous behavior and scheduling of child activities or actions.</span></span> <span data-ttu-id="66055-148">例如，可以创建一个活动，该活动派生自 <xref:System.Activities.Activity>，并且作为其实现令 <xref:System.Activities.Statements.Sequence> 包含异步活动以及实现该活动的逻辑的其他活动。</span><span class="sxs-lookup"><span data-stu-id="66055-148">For example, an activity could be created that derives from <xref:System.Activities.Activity>, and has as its implementation a <xref:System.Activities.Statements.Sequence> containing the asynchronous activity as well the other activities that implement the logic of the activity.</span></span> <span data-ttu-id="66055-149">有关使用和编写活动的更多示例 <xref:System.Activities.Activity> <xref:System.Activities.NativeActivity> ，请参阅 [如何：创建活动](how-to-create-an-activity.md) 和 [活动创作选项](activity-authoring-options-in-wf.md)。</span><span class="sxs-lookup"><span data-stu-id="66055-149">For more examples of composing activities using <xref:System.Activities.Activity> and <xref:System.Activities.NativeActivity>, see [How to: Create an Activity](how-to-create-an-activity.md) and [Activity Authoring Options](activity-authoring-options-in-wf.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="66055-150">另请参阅</span><span class="sxs-lookup"><span data-stu-id="66055-150">See also</span></span>

- <xref:System.Action>
- <xref:System.Func%602>
