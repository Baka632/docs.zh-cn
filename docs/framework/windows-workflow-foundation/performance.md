---
title: Windows Workflow Foundation 4 性能
description: 本文介绍 Windows Workflow Foundation 的主要修订版的性能特征，这是 .NET Framework 4 中的一部分。
ms.date: 03/30/2017
ms.assetid: 67d2b3e8-3777-49f8-9084-abbb33b5a766
ms.openlocfilehash: 1ad12d9fd69205bde726fe650a2ec28ba6c750ef
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/15/2020
ms.locfileid: "90558337"
---
# <a name="windows-workflow-foundation-4-performance"></a><span data-ttu-id="9c816-103">Windows Workflow Foundation 4 性能</span><span class="sxs-lookup"><span data-stu-id="9c816-103">Windows Workflow Foundation 4 Performance</span></span>

 <span data-ttu-id="9c816-104">.NET Framework 4 包括 Windows Workflow Foundation 的主要修订版， (WF) ，并具有较高的性能投资。</span><span class="sxs-lookup"><span data-stu-id="9c816-104">.NET Framework 4 includes a major revision of the Windows Workflow Foundation (WF) with heavy investments in performance.</span></span> <span data-ttu-id="9c816-105">这一新的修订版本引入了与 [!INCLUDE[wf1](../../../includes/wf1-md.md)] .NET Framework 3.0 和 .NET Framework 3.5 中随附的早期版本的设计更改。</span><span class="sxs-lookup"><span data-stu-id="9c816-105">This new revision introduces significant design changes from the previous versions of [!INCLUDE[wf1](../../../includes/wf1-md.md)] that shipped as part of .NET Framework 3.0 and .NET Framework 3.5.</span></span> <span data-ttu-id="9c816-106">新版本对编程模型内核、运行时和工具均重新进行了架构设计，从而极大地提升了性能和可用性。</span><span class="sxs-lookup"><span data-stu-id="9c816-106">It has been re-architected from the core of the programming model, runtime, and tooling to greatly improve performance and usability.</span></span> <span data-ttu-id="9c816-107">本主题会展示这些修订版的重要性能特征，并将它们与之前的版本进行比较。</span><span class="sxs-lookup"><span data-stu-id="9c816-107">This topic shows the important performance characteristics of these revisions and compares them against those of the previous version.</span></span>

 <span data-ttu-id="9c816-108">在 WF3 和 WF4 之间，单个工作流组件的性能也都得到了几个数量级的提升。</span><span class="sxs-lookup"><span data-stu-id="9c816-108">Individual workflow component performance has increased by orders of magnitude between WF3 and WF4.</span></span>  <span data-ttu-id="9c816-109">这会使 (WCF) 服务和 WCF 工作流服务之间的手动编码 Windows Communication Foundation 之间的差距非常小。</span><span class="sxs-lookup"><span data-stu-id="9c816-109">This leaves the gap between hand-coded Windows Communication Foundation (WCF) services and WCF workflow services to be quite small.</span></span>  <span data-ttu-id="9c816-110">在 WF4 中，工作流延迟也得到了显著的降低。</span><span class="sxs-lookup"><span data-stu-id="9c816-110">Workflow latency has been significantly reduced in WF4.</span></span>  <span data-ttu-id="9c816-111">暂留性能提高了 2.5 至 3.0 倍。</span><span class="sxs-lookup"><span data-stu-id="9c816-111">Persistence performance has increased by a factor of 2.5 - 3.0.</span></span>  <span data-ttu-id="9c816-112">采用工作流跟踪方式的运行状况监视显著降低了开销。</span><span class="sxs-lookup"><span data-stu-id="9c816-112">Health monitoring by means of workflow tracking has significantly less overhead.</span></span>  <span data-ttu-id="9c816-113">这些就是迁移到或在应用程序中采用 WF4 的令人心动的原因。</span><span class="sxs-lookup"><span data-stu-id="9c816-113">These are compelling reasons to migrate to or adopt WF4 in your applications.</span></span>

## <a name="terminology"></a><span data-ttu-id="9c816-114">术语</span><span class="sxs-lookup"><span data-stu-id="9c816-114">Terminology</span></span>

 <span data-ttu-id="9c816-115">[!INCLUDE[wf1](../../../includes/wf1-md.md)]在本主题的其余部分中，.NET Framework 4 中引入的版本将被称为 WF4。</span><span class="sxs-lookup"><span data-stu-id="9c816-115">The version of [!INCLUDE[wf1](../../../includes/wf1-md.md)] introduced in .NET Framework 4 will be referred to as WF4 for the rest of this topic.</span></span> [!INCLUDE[wf1](../../../includes/wf1-md.md)] <span data-ttu-id="9c816-116">是在 .NET Framework 3.0 中引入的，并且通过 .NET Framework 3.5 SP1 有一些次要修订版。</span><span class="sxs-lookup"><span data-stu-id="9c816-116">was introduced in .NET Framework 3.0 and had a few minor revisions through .NET Framework 3.5 SP1.</span></span> <span data-ttu-id="9c816-117">对于本主题的其余部分，Workflow Foundation 的 .NET Framework 3.5 版本将被称为 WF3。</span><span class="sxs-lookup"><span data-stu-id="9c816-117">The .NET Framework 3.5 version of Workflow Foundation will be referred to as WF3 for the rest of this topic.</span></span> <span data-ttu-id="9c816-118">WF3 随 WF4 一起提供 .NET Framework 4 并行提供。</span><span class="sxs-lookup"><span data-stu-id="9c816-118">WF3 is shipped in .NET Framework 4 side-by-side with WF4.</span></span> <span data-ttu-id="9c816-119">有关将 WF3 项目迁移到 WF4 的详细信息，请参阅： [Windows Workflow Foundation 4 迁移指南](migration-guidance.md)。</span><span class="sxs-lookup"><span data-stu-id="9c816-119">For more information about migrating WF3 artifacts to WF4 see: [Windows Workflow Foundation 4 Migration Guide](migration-guidance.md).</span></span>

 <span data-ttu-id="9c816-120">Windows Communication Foundation (WCF) 是 Microsoft 用于构建面向服务的应用程序的统一编程模型。</span><span class="sxs-lookup"><span data-stu-id="9c816-120">Windows Communication Foundation (WCF) is Microsoft’s unified programming model for building service-oriented applications.</span></span> <span data-ttu-id="9c816-121">它最初是作为 .NET 3.0 的一部分引入的，它是 WF3 的一部分，现在是 .NET Framework 的关键组件之一。</span><span class="sxs-lookup"><span data-stu-id="9c816-121">It was first introduced as part of .NET 3.0 together with WF3 and now is one of the key components of the .NET Framework.</span></span>

 <span data-ttu-id="9c816-122">Windows Server AppFabric 是一组集成技术。你可以利用这些技术更轻松地生成、缩放和管理在 IIS 上运行的 Web 应用程序和复合应用程序。</span><span class="sxs-lookup"><span data-stu-id="9c816-122">Windows Server AppFabric is a set of integrated technologies that make it easier to build, scale and manage Web and composite applications that run on IIS.</span></span> <span data-ttu-id="9c816-123">它提供用于监视和管理服务与工作流的工具。</span><span class="sxs-lookup"><span data-stu-id="9c816-123">It provides tools for monitoring and managing services and workflows.</span></span> <span data-ttu-id="9c816-124">有关详细信息，请参阅 [Windows Server AppFabric 1.0](/previous-versions/appfabric/ff384253(v=azure.10))。</span><span class="sxs-lookup"><span data-stu-id="9c816-124">For more information, see [Windows Server AppFabric 1.0](/previous-versions/appfabric/ff384253(v=azure.10)).</span></span>

## <a name="goals"></a><span data-ttu-id="9c816-125">目标</span><span class="sxs-lookup"><span data-stu-id="9c816-125">Goals</span></span>
 <span data-ttu-id="9c816-126">本主题的目标是使用为不同方案测得的数据显示 WF4 的性能特征。</span><span class="sxs-lookup"><span data-stu-id="9c816-126">The goal of this topic is to show the performance characteristics of WF4 with data measured for different scenarios.</span></span> <span data-ttu-id="9c816-127">本文还提供 WF4 与 WF3 之间的详细比较，从而展示在新修订版中所做的重大改进。</span><span class="sxs-lookup"><span data-stu-id="9c816-127">It also provides detailed comparisons between WF4 and WF3, and thus shows the great improvements that have been made in this new revision.</span></span> <span data-ttu-id="9c816-128">本文所展示的方案和数据量化了 WF4 和 WF3 在不同方面的基础成本。</span><span class="sxs-lookup"><span data-stu-id="9c816-128">The scenarios and data presented in this article quantify the underlying cost of different aspects of WF4 and WF3.</span></span> <span data-ttu-id="9c816-129">这些数据有助于了解 WF4 的性能特征，并有助于规划从 WF3 到 WF4 的迁移或在应用程序开发中使用 WF4。</span><span class="sxs-lookup"><span data-stu-id="9c816-129">This data is useful in understanding the performance characteristics of WF4 and can be helpful in planning migrations from WF3 to WF4 or using WF4 in application development.</span></span> <span data-ttu-id="9c816-130">但是，应当关注根据本文展示的数据所得出的结论。</span><span class="sxs-lookup"><span data-stu-id="9c816-130">However, care should be taken in the conclusions drawn from the data presented in this article.</span></span> <span data-ttu-id="9c816-131">复合工作流应用程序的性能高度依赖于工作流的实现方式和不同组件的集成方式。</span><span class="sxs-lookup"><span data-stu-id="9c816-131">The performance of a composite workflow application is highly dependent on how the workflow is implemented and how different components are integrated.</span></span> <span data-ttu-id="9c816-132">必须测量每个应用程序，才能确定该应用程序的性能特征。</span><span class="sxs-lookup"><span data-stu-id="9c816-132">One must measure each application to determine the performance characteristics of that application.</span></span>

## <a name="overview-of-wf4-performance-enhancements"></a><span data-ttu-id="9c816-133">WF4 性能增强功能的概述</span><span class="sxs-lookup"><span data-stu-id="9c816-133">Overview of WF4 Performance Enhancements</span></span>
 <span data-ttu-id="9c816-134">WF4 经过严谨的设计和实现，具有以下各节中描述的高性能和可伸缩性。</span><span class="sxs-lookup"><span data-stu-id="9c816-134">WF4 was carefully designed and implemented with high performance and scalability which are described in the following sections.</span></span>

### <a name="wf-runtime"></a><span data-ttu-id="9c816-135">WF 运行时</span><span class="sxs-lookup"><span data-stu-id="9c816-135">WF Runtime</span></span>
 <span data-ttu-id="9c816-136">[!INCLUDE[wf1](../../../includes/wf1-md.md)] 运行时的核心是一个异步计划程序，能够驱动工作流中活动的执行。</span><span class="sxs-lookup"><span data-stu-id="9c816-136">At the core of the [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime is an asynchronous scheduler that drives the execution of the activities in a workflow.</span></span> <span data-ttu-id="9c816-137">它为活动提供了可预测的高性能执行环境。</span><span class="sxs-lookup"><span data-stu-id="9c816-137">It provides a performant, predictable execution environment for activities.</span></span> <span data-ttu-id="9c816-138">该环境有一个对执行、延续、完成、取消、异常的完善约定，和一个可预测的线程模型。</span><span class="sxs-lookup"><span data-stu-id="9c816-138">The environment has a well-defined contract for execution, continuation, completion, cancellation, exceptions, and a predictable threading model.</span></span>

 <span data-ttu-id="9c816-139">与 WF3 相比，WF4 运行时具有更有效的计划程序。</span><span class="sxs-lookup"><span data-stu-id="9c816-139">In comparison to WF3, the WF4 runtime has a more efficient scheduler.</span></span> <span data-ttu-id="9c816-140">它利用用于 WCF 的同一个 i/o 线程池，这在执行批处理工作项时非常高效。</span><span class="sxs-lookup"><span data-stu-id="9c816-140">It leverages the same I/O thread pool that is used for WCF, which is very efficient at executing batched work items.</span></span> <span data-ttu-id="9c816-141">内部工作项计划程序队列已针对最常用的使用模式进行了优化。</span><span class="sxs-lookup"><span data-stu-id="9c816-141">The internal work item scheduler queue is optimized for most common usage patterns.</span></span> <span data-ttu-id="9c816-142">WF4 运行时还可以使用最小的同步和事件处理逻辑以非常轻量的方式管理执行状态，而 WF3 则依赖于重负载事件注册和调用来执行状态转换的复杂同步。</span><span class="sxs-lookup"><span data-stu-id="9c816-142">The WF4 runtime also manages the execution states in a very lightweight way with minimal synchronization and event handling logic, while WF3 depends on heavy-weight event registration and invocation to perform complex synchronization for state transitions.</span></span>

### <a name="data-storage-and-flow"></a><span data-ttu-id="9c816-143">数据存储和流动</span><span class="sxs-lookup"><span data-stu-id="9c816-143">Data Storage and Flow</span></span>
 <span data-ttu-id="9c816-144">在 WF3 中，与活动相关的数据通过 <xref:System.Windows.DependencyProperty> 类型实现的依赖属性进行建模。</span><span class="sxs-lookup"><span data-stu-id="9c816-144">In WF3, data associated with an activity is modeled through dependency properties implemented by the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="9c816-145"> (WPF) Windows Presentation Foundation 引入了依赖属性模式。</span><span class="sxs-lookup"><span data-stu-id="9c816-145">The dependency property pattern was introduced in Windows Presentation Foundation (WPF).</span></span> <span data-ttu-id="9c816-146">总体上，这种模式十分灵活，能够支持轻松的数据绑定和其他 UI 功能。</span><span class="sxs-lookup"><span data-stu-id="9c816-146">In general, this pattern is very flexible to support easy data binding and other UI features.</span></span> <span data-ttu-id="9c816-147">但是，这种模式需要将属性定义为工作流定义中的静态字段。</span><span class="sxs-lookup"><span data-stu-id="9c816-147">However, the pattern requires the properties to be defined as static fields in the workflow definition.</span></span> <span data-ttu-id="9c816-148">当 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 运行时设置或获取属性值时，它会涉及重型的查找逻辑。</span><span class="sxs-lookup"><span data-stu-id="9c816-148">Whenever the [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime sets or gets the property values, it involves heavily-weighted look-up logic.</span></span>

 <span data-ttu-id="9c816-149">WF4 使用清晰的数据范围逻辑，显著改进了在工作流中处理数据的方式。</span><span class="sxs-lookup"><span data-stu-id="9c816-149">WF4 uses clear data scoping logic to greatly improve how data is handled in a workflow.</span></span> <span data-ttu-id="9c816-150">它使用下面两种不同的概念将存储在活动中的数据与在活动边界之间流动的数据区分开来：变量和自变量。</span><span class="sxs-lookup"><span data-stu-id="9c816-150">It separates the data stored in an activity from the data that is flowing across the activity boundaries by using two different concepts: variables and arguments.</span></span> <span data-ttu-id="9c816-151">通过对变量和 "In/Out/InOut" 参数使用清晰的分层范围，可以显著降低活动的数据使用复杂性，并自动确定数据生存期的范围。</span><span class="sxs-lookup"><span data-stu-id="9c816-151">By using a clear hierarchical scope for variables and "In/Out/InOut" arguments, the data usage complexity for activities is dramatically reduced and the lifetime of the data is also automatically scoped.</span></span> <span data-ttu-id="9c816-152">活动具有由其自变量描述的定义完善的签名。</span><span class="sxs-lookup"><span data-stu-id="9c816-152">Activities have a well-defined signature described by its arguments.</span></span> <span data-ttu-id="9c816-153">通过简单地检查活动，您可以确定它将会接收的数据，以及它执行后将会产生的数据。</span><span class="sxs-lookup"><span data-stu-id="9c816-153">By simply inspecting an activity you can determine what data it expects to receive and what data will be produced by it as the result of its execution.</span></span>

 <span data-ttu-id="9c816-154">在 WF3 中，创建工作流时即会初始化活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-154">In WF3 activities were initialized when a workflow was created.</span></span> <span data-ttu-id="9c816-155">在 WF 4 中，只有在执行活动时，才会初始化相应的活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-155">In WF 4 activities are initialized only when the corresponding activities are executing.</span></span> <span data-ttu-id="9c816-156">这样，在创建新工作流实例时，因为无需执行初始化/取消初始化操作，活动的生命周期将更为简单，并因此能获得更高的效率</span><span class="sxs-lookup"><span data-stu-id="9c816-156">This allows a simpler activity lifecycle without performing Initialize/Uninitialize operations when a new workflow instance is created, and thus has achieved more efficiency</span></span>

### <a name="control-flow"></a><span data-ttu-id="9c816-157">控制流</span><span class="sxs-lookup"><span data-stu-id="9c816-157">Control Flow</span></span>
 <span data-ttu-id="9c816-158">和所有编程语言一样，[!INCLUDE[wf1](../../../includes/wf1-md.md)] 通过引入了一组用于排序、循环、分支和其他模式的控制流活动，为工作流定义提供了控制流支持。</span><span class="sxs-lookup"><span data-stu-id="9c816-158">Just as in any programming language, [!INCLUDE[wf1](../../../includes/wf1-md.md)] provides support for control flows for workflow definitions by introducing a set of control flow activities for sequencing, looping, branching and other patterns.</span></span> <span data-ttu-id="9c816-159">在 WF3 中，当需要重新执行相同的活动时，会通过基于 <xref:System.Workflow.ComponentModel.ActivityExecutionContext> 的重型序列化和反序列化逻辑创建一个新的 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>，并克隆该活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-159">In WF3, when the same activity needs to be re-executed, a new <xref:System.Workflow.ComponentModel.ActivityExecutionContext> is created and the activity is cloned through a heavy-weight serialization and deserialization logic based on <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>.</span></span> <span data-ttu-id="9c816-160">通常，迭代控制流的性能要比执行一个活动序列慢得多。</span><span class="sxs-lookup"><span data-stu-id="9c816-160">Usually the performance for iterative control flows is much slower than executing a sequence of activities.</span></span>

 <span data-ttu-id="9c816-161">WF4 以完全不同的方式处理这种情况。</span><span class="sxs-lookup"><span data-stu-id="9c816-161">WF4 handles this quite differently.</span></span> <span data-ttu-id="9c816-162">它采用活动模板，创建一个新的 ActivityInstance 对象并将其添加到计划程序队列中。</span><span class="sxs-lookup"><span data-stu-id="9c816-162">It takes the activity template, creates a new ActivityInstance object, and adds it to the scheduler queue.</span></span> <span data-ttu-id="9c816-163">整个过程仅涉及显式对象创建，非常轻量。</span><span class="sxs-lookup"><span data-stu-id="9c816-163">This whole process only involves explicit object creation and is very lightweight.</span></span>

### <a name="asynchronous-programming"></a><span data-ttu-id="9c816-164">异步编程</span><span class="sxs-lookup"><span data-stu-id="9c816-164">Asynchronous Programming</span></span>
 <span data-ttu-id="9c816-165">使用异步编程时，应用程序对长时间运行的阻止操作（如 I/O）或分布式计算操作通常会表现出更佳的性能和可伸缩性。</span><span class="sxs-lookup"><span data-stu-id="9c816-165">Applications usually have better performance and scalability with asynchronous programming for long running blocking operations such as I/O or distributed computing operations.</span></span> <span data-ttu-id="9c816-166">WF4 通过基础活动类型 <xref:System.Activities.AsyncCodeActivity> 和 <xref:System.Activities.AsyncCodeActivity%601> 提供异步支持。</span><span class="sxs-lookup"><span data-stu-id="9c816-166">WF4 provides asynchronous support through base activity types <xref:System.Activities.AsyncCodeActivity>, <xref:System.Activities.AsyncCodeActivity%601>.</span></span> <span data-ttu-id="9c816-167">运行时本身就了解异步活动，因此可以在异步工作未处理时，自动将实例放入非持久性区域中。</span><span class="sxs-lookup"><span data-stu-id="9c816-167">The runtime natively understands asynchronous activities and therefore can automatically put the instance in a no-persist zone while the asynchronous work is outstanding.</span></span> <span data-ttu-id="9c816-168">自定义活动可以从这些类型派生，从而无需保留工作流计划程序线程和阻止能够并行运行的任何活动，即可执行异步工作。</span><span class="sxs-lookup"><span data-stu-id="9c816-168">Custom activities can derive from these types to perform asynchronous work without holding the workflow scheduler thread and blocking any activities that may be able to run in parallel.</span></span>

### <a name="messaging"></a><span data-ttu-id="9c816-169">消息传递</span><span class="sxs-lookup"><span data-stu-id="9c816-169">Messaging</span></span>
 <span data-ttu-id="9c816-170">最初，WF3 通过外部事件或 Web 服务调用提供相当有限的消息传送支持。</span><span class="sxs-lookup"><span data-stu-id="9c816-170">Initially WF3 had very limited messaging support through external events or web services invocations.</span></span> <span data-ttu-id="9c816-171">在 .NET 3.5 中，工作流可以作为 WCF 客户端实现，也可以通过和公开为 WCF 服务 <xref:System.Workflow.Activities.SendActivity> <xref:System.Workflow.Activities.ReceiveActivity> 。</span><span class="sxs-lookup"><span data-stu-id="9c816-171">In .NET 3.5, workflows could be implemented as WCF clients or exposed as WCF services through <xref:System.Workflow.Activities.SendActivity> and <xref:System.Workflow.Activities.ReceiveActivity>.</span></span> <span data-ttu-id="9c816-172">在 WF4 中，基于工作流的消息传递编程的概念通过将 WCF 消息传递逻辑紧密集成到 WF 中，进一步增强了这一概念。</span><span class="sxs-lookup"><span data-stu-id="9c816-172">In WF4, the concept of workflow-based messaging programming has been further strengthened through the tight integration of WCF messaging logic into WF.</span></span>

 <span data-ttu-id="9c816-173">.NET 4 的 WCF 中提供的统一消息处理管道可帮助 WF4 服务获得比 WF3 更好的性能和可伸缩性。</span><span class="sxs-lookup"><span data-stu-id="9c816-173">The unified message processing pipeline provided in WCF in .NET 4 helps WF4 services to have significantly better performance and scalability than WF3.</span></span> <span data-ttu-id="9c816-174">WF4 还提供了更丰富的消息传送编程支持，可以对复杂消息交换模式 (MEP) 进行建模。</span><span class="sxs-lookup"><span data-stu-id="9c816-174">WF4 also provides richer messaging programming support that can model complex Message Exchange Patterns (MEPs).</span></span> <span data-ttu-id="9c816-175">开发人员可以使用类型化的服务协定实现简单的编程，也可以使用非类型化的服务协定获得更好的性能，而无需付出序列化成本。</span><span class="sxs-lookup"><span data-stu-id="9c816-175">Developers can use either typed service contracts to achieve easy programming or un-typed service contracts to achieve better performance without paying serialization costs.</span></span> <span data-ttu-id="9c816-176">WF4 中通过 <xref:System.ServiceModel.Activities.SendMessageChannelCache> 类提供的客户端通道缓存支持可帮助开发人员以最小的工作量构建快速应用程序。</span><span class="sxs-lookup"><span data-stu-id="9c816-176">The client-side channel caching support through the <xref:System.ServiceModel.Activities.SendMessageChannelCache> class in WF4 helps developers build fast applications with minimal effort.</span></span> <span data-ttu-id="9c816-177">有关详细信息，请参阅 [更改发送活动的缓存共享级别](../wcf/feature-details/changing-the-cache-sharing-levels-for-send-activities.md)。</span><span class="sxs-lookup"><span data-stu-id="9c816-177">For more information, see [Changing the Cache Sharing Levels for Send Activities](../wcf/feature-details/changing-the-cache-sharing-levels-for-send-activities.md).</span></span>

### <a name="declarative-programming"></a><span data-ttu-id="9c816-178">声明性编程</span><span class="sxs-lookup"><span data-stu-id="9c816-178">Declarative Programming</span></span>
 <span data-ttu-id="9c816-179">WF4 提供一个清楚、简单的声明性编程框架，用以对业务流程和服务进行建模。</span><span class="sxs-lookup"><span data-stu-id="9c816-179">WF4 provides a clean and simple declarative programming framework to model business processes and services.</span></span> <span data-ttu-id="9c816-180">无需任何其他代码，该编程模型支持完全声明性地编写活动，极大地简化了工作流的创作。</span><span class="sxs-lookup"><span data-stu-id="9c816-180">The programming model supports fully declarative composition of activities, with no code-beside, greatly simplifying workflow authoring.</span></span> <span data-ttu-id="9c816-181">在 .NET Framework 4 中，基于 XAML 的声明性编程框架已统一到单个程序集 System.Xaml.dll 以支持 WPF 和 WF。</span><span class="sxs-lookup"><span data-stu-id="9c816-181">In .NET Framework 4, the XAML-based declarative programming framework has been unified into the single assembly System.Xaml.dll to support both WPF and WF.</span></span>

 <span data-ttu-id="9c816-182">在 WF4 中，在 XAML 提供真正的声明性经验，并允许用 XML 标记定义工作流的整个定义，并引用使用 .NET 构建的活动和类型。</span><span class="sxs-lookup"><span data-stu-id="9c816-182">In WF4, XAML provides a truly declarative experience and allows for the entire definition of the workflow to be defined in XML markup, referencing activities and types built using .NET.</span></span> <span data-ttu-id="9c816-183">这在使用 XOML 的 WF3 中则很难实现，因为这种格式没有自定义的代码隐藏逻辑。</span><span class="sxs-lookup"><span data-stu-id="9c816-183">This was difficult to do in WF3 with XOML format without involving custom code-behind logic.</span></span> <span data-ttu-id="9c816-184">.NET 4 中的新 XAML 堆栈在序列化/反序列化工作流项目时具有更好的性能，并使声明性编程更加引人注目和可靠。</span><span class="sxs-lookup"><span data-stu-id="9c816-184">The new XAML-stack in .NET 4 has much better performance in serializing/deserializing workflow artifacts and makes declarative programming more attractive and solid.</span></span>

### <a name="workflow-designer"></a><span data-ttu-id="9c816-185">工作流设计器</span><span class="sxs-lookup"><span data-stu-id="9c816-185">Workflow Designer</span></span>
 <span data-ttu-id="9c816-186">WF4 的完全声明性编程和支持对于大型工作流的设计时性能明确提出了更高的需求。</span><span class="sxs-lookup"><span data-stu-id="9c816-186">Fully declarative programming support for WF4 explicitly imposes higher requirements for design time performance for large workflows.</span></span> <span data-ttu-id="9c816-187">与 WF3 相比，WF4 中的工作流设计器对于大型工作流来说，具有更佳的可伸缩性。</span><span class="sxs-lookup"><span data-stu-id="9c816-187">The Workflow designer in WF4 has much better scalability for large workflows than that for WF3.</span></span> <span data-ttu-id="9c816-188">有了 UI 虚拟化支持，设计器在几秒钟内就能轻松加载包括 1000 个活动的大型工作流，而在 WF3 设计器中，加载包括数百个活动的工作流几乎都是件不可能完成的任务。</span><span class="sxs-lookup"><span data-stu-id="9c816-188">With UI virtualization support, the designer can easily load a large workflow of 1000 activities in a few seconds, while it is almost impossible to load a workflow of a few hundred activities with the WF3 designer.</span></span>

## <a name="component-level-performance-comparisons"></a><span data-ttu-id="9c816-189">组件级性能比较</span><span class="sxs-lookup"><span data-stu-id="9c816-189">Component-level Performance Comparisons</span></span>
 <span data-ttu-id="9c816-190">本节包括对 WF3 和 WF4 工作流中的单个活动进行直接比较的相关数据。</span><span class="sxs-lookup"><span data-stu-id="9c816-190">This section contains data on direct comparisons between individual activities in WF3 and WF4 workflows.</span></span>  <span data-ttu-id="9c816-191">与单个活动组件相比，暂留这样的关键方面对于性能的影响更加深远。</span><span class="sxs-lookup"><span data-stu-id="9c816-191">Key areas like persistence have a more profound impact on performance than the individual activity components.</span></span>  <span data-ttu-id="9c816-192">但是，因为 WF4 中单个组件目前的速度足以与手工编码的业务流程逻辑相媲美，所以这些组件的性能改进也非常重要。</span><span class="sxs-lookup"><span data-stu-id="9c816-192">The performance improvements in individual components in WF4 are important though because the components are now fast enough to be compared against hand-coded orchestration logic.</span></span>  <span data-ttu-id="9c816-193">下一节中介绍了的一个示例： "服务组合方案"。</span><span class="sxs-lookup"><span data-stu-id="9c816-193">An example of which is covered in the next section: "Service Composition Scenario."</span></span>

### <a name="environment-setup"></a><span data-ttu-id="9c816-194">环境设置</span><span class="sxs-lookup"><span data-stu-id="9c816-194">Environment Setup</span></span>
 ![工作流性能度量的环境设置](./media/performance/performance-test-environment.gif)

 <span data-ttu-id="9c816-196">上图显示了用于组件级性能测量的计算机配置。</span><span class="sxs-lookup"><span data-stu-id="9c816-196">The above figure shows the machine configuration used for component-level performance measurement.</span></span> <span data-ttu-id="9c816-197">一台服务器和五台客户端通过一个 1 Gbps 以太网网络接口连接在一起。</span><span class="sxs-lookup"><span data-stu-id="9c816-197">A single server and five clients connected over one 1-Gbps Ethernet network interface.</span></span> <span data-ttu-id="9c816-198">为了简化测量，服务器配置为使用运行 Windows Server 2008 x86 的双处理器/四核服务器中的一个内核。</span><span class="sxs-lookup"><span data-stu-id="9c816-198">For easy measurements, the server is configured to use a single core of a dual-proc/quad-core server  running Windows Server 2008 x86.</span></span> <span data-ttu-id="9c816-199">系统 CPU 利用率保持在接近 100%。</span><span class="sxs-lookup"><span data-stu-id="9c816-199">The system CPU utilization is maintained at nearly 100%.</span></span>

### <a name="test-details"></a><span data-ttu-id="9c816-200">测试详细信息</span><span class="sxs-lookup"><span data-stu-id="9c816-200">Test Details</span></span>
 <span data-ttu-id="9c816-201">WF3，<xref:System.Workflow.Activities.CodeActivity> 可能是可以在 WF3 工作流中使用的最简单的活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-201">The WF3 <xref:System.Workflow.Activities.CodeActivity> is likely the simplest activity that can be used in a WF3 workflow.</span></span>  <span data-ttu-id="9c816-202">该活动在工作流程序员可以放入自定义代码的代码隐藏文件中调用一个方法。</span><span class="sxs-lookup"><span data-stu-id="9c816-202">The activity calls a method in the code-behind that the workflow programmer can put custom code into.</span></span>  <span data-ttu-id="9c816-203">在 WF4 中，没有与 WF3 <xref:System.Workflow.Activities.CodeActivity> 提供相同功能的类似项目。</span><span class="sxs-lookup"><span data-stu-id="9c816-203">In WF4, there is no direct analog to the WF3 <xref:System.Workflow.Activities.CodeActivity> that provides the same functionality.</span></span>  <span data-ttu-id="9c816-204">注意，WF4 中有一个 <xref:System.Activities.CodeActivity> 基类，但它与 WF3 <xref:System.Workflow.Activities.CodeActivity> 没有关联。</span><span class="sxs-lookup"><span data-stu-id="9c816-204">Note that there is a <xref:System.Activities.CodeActivity> base class in WF4 that is not related to the WF3 <xref:System.Workflow.Activities.CodeActivity>.</span></span>  <span data-ttu-id="9c816-205">建议工作流作者创建自定义活动并构建仅 XAML 的工作流。</span><span class="sxs-lookup"><span data-stu-id="9c816-205">Workflow authors are encouraged to create custom activities and build XAML-only workflows.</span></span>  <span data-ttu-id="9c816-206">在下面的测试中，在 WF4 工作流中使用名为 `Comment` 的活动代替空 <xref:System.Workflow.Activities.CodeActivity>。</span><span class="sxs-lookup"><span data-stu-id="9c816-206">In the tests below, an activity called `Comment` is used in place of an empty <xref:System.Workflow.Activities.CodeActivity> in WF4 workflows.</span></span>  <span data-ttu-id="9c816-207">`Comment` 活动中的代码如下所示：</span><span class="sxs-lookup"><span data-stu-id="9c816-207">The code in the `Comment` activity is as follows:</span></span>

```csharp
[ContentProperty("Body")]
    public sealed class Comment : CodeActivity
    {
        public Comment()
            : base()
        {
        }

        [DefaultValue(null)]
        public Activity Body
        {
            get;
            set;
        }

        protected override void Execute(CodeActivityContext context)
        {
        }
    }
```

### <a name="empty-workflow"></a><span data-ttu-id="9c816-208">空工作流</span><span class="sxs-lookup"><span data-stu-id="9c816-208">Empty Workflow</span></span>
 <span data-ttu-id="9c816-209">此测试使用一个没有子活动的序列工作流。</span><span class="sxs-lookup"><span data-stu-id="9c816-209">This test uses a sequence workflow with no child activities.</span></span>

### <a name="single-activity"></a><span data-ttu-id="9c816-210">单个活动</span><span class="sxs-lookup"><span data-stu-id="9c816-210">Single Activity</span></span>
 <span data-ttu-id="9c816-211">工作流是包含一个子活动的序列工作流。</span><span class="sxs-lookup"><span data-stu-id="9c816-211">The workflow is a sequence workflow containing one child activity.</span></span>  <span data-ttu-id="9c816-212">该活动在 WF3 中是没有代码的 <xref:System.Workflow.Activities.CodeActivity>，而在 WF4 中是 `Comment` 活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-212">The activity is a <xref:System.Workflow.Activities.CodeActivity> with no code in the WF3 case and a `Comment` activity in the WF4 case.</span></span>

### <a name="while-with-1000-iterations"></a><span data-ttu-id="9c816-213">While 搭配 1000 次迭代</span><span class="sxs-lookup"><span data-stu-id="9c816-213">While with 1000 Iterations</span></span>
 <span data-ttu-id="9c816-214">序列工作流包含一个 <xref:System.Activities.Statements.While> 活动，该活动在循环中有一个不执行任何工作的子活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-214">The sequence workflow contains one <xref:System.Activities.Statements.While> activity with one child activity in the loop that does not perform any work.</span></span>

### <a name="replicator-compared-to-parallelforeach"></a><span data-ttu-id="9c816-215">Replicator 与 ParallelForEach 的比较</span><span class="sxs-lookup"><span data-stu-id="9c816-215">Replicator compared to ParallelForEach</span></span>
 <span data-ttu-id="9c816-216">WF3 中的 <xref:System.Workflow.Activities.ReplicatorActivity> 具有顺序和并行两种执行模式。</span><span class="sxs-lookup"><span data-stu-id="9c816-216"><xref:System.Workflow.Activities.ReplicatorActivity> in WF3 has sequential and parallel execution modes.</span></span>  <span data-ttu-id="9c816-217">在顺序模式中，活动的性能与 <xref:System.Workflow.Activities.WhileActivity> 类似。</span><span class="sxs-lookup"><span data-stu-id="9c816-217">In sequential mode, the activity’s performance is similar to the <xref:System.Workflow.Activities.WhileActivity>.</span></span>  <span data-ttu-id="9c816-218"><xref:System.Workflow.Activities.ReplicatorActivity> 最适用于并行执行。</span><span class="sxs-lookup"><span data-stu-id="9c816-218">The <xref:System.Workflow.Activities.ReplicatorActivity> is most useful for parallel execution.</span></span>  <span data-ttu-id="9c816-219">WF4 中与此类似的是 <xref:System.Activities.Statements.ParallelForEach%601> 活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-219">The WF4 analog for this is the <xref:System.Activities.Statements.ParallelForEach%601> activity.</span></span>

 <span data-ttu-id="9c816-220">下图显示了此测试使用的工作流。</span><span class="sxs-lookup"><span data-stu-id="9c816-220">The following diagram shows the workflows used for this test.</span></span> <span data-ttu-id="9c816-221">左侧为 WF3 工作流，右侧为 WF4 工作流。</span><span class="sxs-lookup"><span data-stu-id="9c816-221">The WF3 workflow is on the left and the WF4 workflow is on the right.</span></span>

 ![WF3 ReplicatorActivity 和 WF4 ParallelForEach](./media/performance/replicator-parallel-wf3-wf4.gif)

### <a name="sequential-workflow-with-five-activities"></a><span data-ttu-id="9c816-223">包含五个活动的顺序工作流</span><span class="sxs-lookup"><span data-stu-id="9c816-223">Sequential Workflow with Five Activities</span></span>
 <span data-ttu-id="9c816-224">此测试的目的是为了显示在序列中执行几个活动的效果。</span><span class="sxs-lookup"><span data-stu-id="9c816-224">This test is meant to show the effect of having several activities execute in sequence.</span></span>  <span data-ttu-id="9c816-225">序列中有五个活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-225">There are five activities in the sequence.</span></span>

### <a name="transaction-scope"></a><span data-ttu-id="9c816-226">事务范围</span><span class="sxs-lookup"><span data-stu-id="9c816-226">Transaction Scope</span></span>
 <span data-ttu-id="9c816-227">事务范围测试与其他侧试略有不同，不会为每次迭代创建一个新的工作流实例。</span><span class="sxs-lookup"><span data-stu-id="9c816-227">The transaction scope test differs from the other tests slightly in that a new workflow instance is not created for every iteration.</span></span>  <span data-ttu-id="9c816-228">相反，工作流的结构是一个包含 <xref:System.Activities.Statements.TransactionScope> 活动的 while 循环，而该活动包含一个不执行任何工作的活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-228">Instead, the workflow is structured with a while loop containing a <xref:System.Activities.Statements.TransactionScope> activity containing a single activity that does no work.</span></span>  <span data-ttu-id="9c816-229">每次通过 while 循环运行一批 50 个迭代，计为一个单独的操作。</span><span class="sxs-lookup"><span data-stu-id="9c816-229">Each run of a batch of 50 iterations through the while loop is counted as a single operation.</span></span>

### <a name="compensation"></a><span data-ttu-id="9c816-230">补偿</span><span class="sxs-lookup"><span data-stu-id="9c816-230">Compensation</span></span>
 <span data-ttu-id="9c816-231">WF3 工作流有一个名为 `WorkScope` 的可补偿活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-231">The WF3 workflow has a single compensatable activity named `WorkScope`.</span></span>  <span data-ttu-id="9c816-232">该活动只实现 <xref:System.Workflow.ComponentModel.ICompensatableActivity> 接口：</span><span class="sxs-lookup"><span data-stu-id="9c816-232">The activity simply implements the <xref:System.Workflow.ComponentModel.ICompensatableActivity> interface:</span></span>

```csharp
class WorkScope :
        CompositeActivity, ICompensatableActivity
    {
        public WorkScope() : base() { }

        public WorkScope(string name)
        {
            this.Name = name;
        }

        public ActivityExecutionStatus Compensate(
            ActivityExecutionContext executionContext)
        {
            return ActivityExecutionStatus.Closed;
        }
    }
```

 <span data-ttu-id="9c816-233">错误处理程序以活动为目标 `WorkScope` 。</span><span class="sxs-lookup"><span data-stu-id="9c816-233">The fault handler targets the `WorkScope` activity.</span></span> <span data-ttu-id="9c816-234">WF4 工作流同样简单。</span><span class="sxs-lookup"><span data-stu-id="9c816-234">The WF4 workflow is equally simplistic.</span></span>  <span data-ttu-id="9c816-235"><xref:System.Activities.Statements.CompensableActivity> 有一个 Body 和一个补偿处理程序。</span><span class="sxs-lookup"><span data-stu-id="9c816-235">A <xref:System.Activities.Statements.CompensableActivity> has a body and a compensation handler.</span></span>  <span data-ttu-id="9c816-236">序列中随后是一个显式的补偿。</span><span class="sxs-lookup"><span data-stu-id="9c816-236">An explicit compensate is next in the sequence.</span></span>  <span data-ttu-id="9c816-237">Body 活动和补偿处理程序活动都是空实现：</span><span class="sxs-lookup"><span data-stu-id="9c816-237">The body activity and compensation handler activity are both empty implementations:</span></span>

```csharp
public sealed class CompensableActivityEmptyCompensation : CodeActivity
    {
        public CompensableActivityEmptyCompensation()
            : base() { }

        public Activity Body { get; set; }

        protected override void Execute(CodeActivityContext context) { }
    }
    public sealed class CompensableActivityEmptyBody : CodeActivity
    {
        public CompensableActivityEmptyBody()
            : base() { }

        public Activity Body { get; set; }

        protected override void Execute(CodeActivityContext context) { }
    }
```

<span data-ttu-id="9c816-238">下图显示了基本补偿工作流。</span><span class="sxs-lookup"><span data-stu-id="9c816-238">The following diagram shows the basic compensation workflow.</span></span> <span data-ttu-id="9c816-239">左侧为 WF3 工作流，右侧为 WF4 工作流。</span><span class="sxs-lookup"><span data-stu-id="9c816-239">The WF3 workflow is on the left and the WF4 workflow is on the right.</span></span>

![WF3 和 WF4 基本补偿工作流](./media/performance/basic-compensation-workflows-wf3-wf4.gif)

### <a name="performance-test-results"></a><span data-ttu-id="9c816-241">性能测试结果</span><span class="sxs-lookup"><span data-stu-id="9c816-241">Performance Test Results</span></span>

 ![显示性能测试结果数据的表](./media/performance/performance-test-data.gif)

 ![比较 WF3 和 WF4 性能测试数据的柱形图](./media/performance/performance-test-chart.gif)

 <span data-ttu-id="9c816-244">除事务范围测试外，会以秒为单位在工作流中测量所有测试。</span><span class="sxs-lookup"><span data-stu-id="9c816-244">All tests are measured in workflows per second with the exception of the transaction scope test.</span></span>  <span data-ttu-id="9c816-245">如上文所见，[!INCLUDE[wf1](../../../includes/wf1-md.md)] 运行时性能已得到全面提升，特别是在像 while 循环这样需要多次执行同一活动的方面。</span><span class="sxs-lookup"><span data-stu-id="9c816-245">As can be seen above, the [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime performance has improved across the board, especially in areas that require multiple executions of the same activity like the while loop.</span></span>

## <a name="service-composition-scenario"></a><span data-ttu-id="9c816-246">服务撰写方案</span><span class="sxs-lookup"><span data-stu-id="9c816-246">Service Composition Scenario</span></span>
 <span data-ttu-id="9c816-247">如前面的 "组件级性能比较" 一节中所示，WF3 与 WF4 之间的开销显著降低。</span><span class="sxs-lookup"><span data-stu-id="9c816-247">As is shown in the previous section, "Component-level Performance Comparisons," there has been a significant reduction in overhead between WF3 and WF4.</span></span>  <span data-ttu-id="9c816-248">WCF 工作流服务现在可以与手动编码的 WCF 服务的性能几乎匹配，但仍具有运行时的所有优势 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="9c816-248">WCF workflow services can now almost match the performance of hand-coded WCF services but still have all the benefits of the [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime.</span></span>  <span data-ttu-id="9c816-249">此测试方案将 WCF 服务与 WF4 中的 WCF 工作流服务进行比较。</span><span class="sxs-lookup"><span data-stu-id="9c816-249">This test scenario compares a WCF service against a WCF workflow service in WF4.</span></span>

### <a name="online-store-service"></a><span data-ttu-id="9c816-250">在线商店服务</span><span class="sxs-lookup"><span data-stu-id="9c816-250">Online Store Service</span></span>
 <span data-ttu-id="9c816-251">Windows Workflow Foundation 的优点之一是能够使用多个服务来编写进程。</span><span class="sxs-lookup"><span data-stu-id="9c816-251">One of the strengths of Windows Workflow Foundation is the ability to compose processes using several services.</span></span>  <span data-ttu-id="9c816-252">本例为一个在线商店服务，该服务会协调两个服务调用以采购订单。</span><span class="sxs-lookup"><span data-stu-id="9c816-252">For this example, there is an online store service that orchestrates two service calls to purchase an order.</span></span>  <span data-ttu-id="9c816-253">第一步是使用订单验证服务验证订单。</span><span class="sxs-lookup"><span data-stu-id="9c816-253">The first step is to validate the order using an Order Validating Service.</span></span>  <span data-ttu-id="9c816-254">第二步是使用仓库服务填写订单。</span><span class="sxs-lookup"><span data-stu-id="9c816-254">The second step is to fill the order using a Warehouse Service.</span></span>

 <span data-ttu-id="9c816-255">订单验证服务和仓库服务这两个后端服务在两项测试中保持不变。</span><span class="sxs-lookup"><span data-stu-id="9c816-255">The two backend services, Order Validating Service and Warehouse Service, remain the same for both tests.</span></span>  <span data-ttu-id="9c816-256">发生变化的部分是执行业务流程的在线商店服务。</span><span class="sxs-lookup"><span data-stu-id="9c816-256">The part that changes is the Online Store Service that performs the orchestration.</span></span>  <span data-ttu-id="9c816-257">在一种情况下，服务将手动编码为 WCF 服务。</span><span class="sxs-lookup"><span data-stu-id="9c816-257">In one case, the service is hand-coded as a WCF service.</span></span>  <span data-ttu-id="9c816-258">对于其他情况，该服务在 WF4 中编写为 WCF 工作流服务。</span><span class="sxs-lookup"><span data-stu-id="9c816-258">For the other case, the service is written as a WCF workflow service in WF4.</span></span> <span data-ttu-id="9c816-259">在此项测试中，[!INCLUDE[wf1](../../../includes/wf1-md.md)] 特定的功能（如跟踪和暂留）都会关闭。</span><span class="sxs-lookup"><span data-stu-id="9c816-259">[!INCLUDE[wf1](../../../includes/wf1-md.md)]-specific features like tracking and persistence are turned off for this test.</span></span>

### <a name="environment"></a><span data-ttu-id="9c816-260">环境</span><span class="sxs-lookup"><span data-stu-id="9c816-260">Environment</span></span>
![性能测量的环境设置](./media/performance/performance-test-environment.gif)

 <span data-ttu-id="9c816-262">多个计算机通过 HTTP 对在线商店服务发出客户端请求。</span><span class="sxs-lookup"><span data-stu-id="9c816-262">Client requests are made to the Online Store Service via HTTP from multiple computers.</span></span>  <span data-ttu-id="9c816-263">一台计算机承载了全部三个服务。</span><span class="sxs-lookup"><span data-stu-id="9c816-263">A single computer hosts all three services.</span></span>  <span data-ttu-id="9c816-264">在线商店服务和后台服务之间的传输层是 TCP 或 HTTP。</span><span class="sxs-lookup"><span data-stu-id="9c816-264">The transport layer between the Online Store Service and the backend services is TCP or HTTP.</span></span>  <span data-ttu-id="9c816-265">每秒操作数的测量以对在线商店服务完成的 `PurchaseOrder` 调用数为基础。</span><span class="sxs-lookup"><span data-stu-id="9c816-265">The measurement of operations/second is based on the number of completed `PurchaseOrder` calls made to the Online Store Service.</span></span>  <span data-ttu-id="9c816-266">通道池是 WF4 的一项新功能。</span><span class="sxs-lookup"><span data-stu-id="9c816-266">Channel pooling is a new feature available in WF4.</span></span>  <span data-ttu-id="9c816-267">在此测试通道池的 WCF 部分中，不提供现成的，因此在在线商店服务中使用了简单的池技术的手动编码实现。</span><span class="sxs-lookup"><span data-stu-id="9c816-267">In the WCF portion of this test channel pooling is not provided out of the box so a hand-coded implementation of a simple pooling technique was used in the Online Store Service.</span></span>

### <a name="performance"></a><span data-ttu-id="9c816-268">性能</span><span class="sxs-lookup"><span data-stu-id="9c816-268">Performance</span></span>
![显示在线商店服务性能的柱形图](./media/performance/online-store-performance-graph.gif)

 <span data-ttu-id="9c816-270">如果连接后端 TCP 服务时不使用通道池，则 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 服务对吞吐量有 17.2% 的影响。</span><span class="sxs-lookup"><span data-stu-id="9c816-270">Connecting to backend TCP services without channel pooling, the [!INCLUDE[wf1](../../../includes/wf1-md.md)] service has a 17.2% impact on throughput.</span></span>  <span data-ttu-id="9c816-271">如果使用通道池，则损失大约为 23.8%。</span><span class="sxs-lookup"><span data-stu-id="9c816-271">With channel pooling, the penalty is about 23.8%.</span></span>  <span data-ttu-id="9c816-272">对于 HTTP，影响要少得多：不使用池时为 4.3%，使用池时为 8.1%。</span><span class="sxs-lookup"><span data-stu-id="9c816-272">For HTTP, the impact is much less: 4.3% without pooling and 8.1% with pooling.</span></span>  <span data-ttu-id="9c816-273">另外要特别注意的是，使用 HTTP 时通道池提供的好处比较少。</span><span class="sxs-lookup"><span data-stu-id="9c816-273">It is also important to note that the channel pooling provides very little benefit when using HTTP.</span></span>

 <span data-ttu-id="9c816-274">虽然 WF4 运行时的开销与此测试中的手动编码的 WCF 服务相比，但可能会将其视为最糟糕的情况。</span><span class="sxs-lookup"><span data-stu-id="9c816-274">While there is overhead from the WF4 runtime compared with a hand-coded WCF service in this test, it could be considered a worst-case scenario.</span></span>  <span data-ttu-id="9c816-275">此测试中的两个后端服务执行的工作很少。</span><span class="sxs-lookup"><span data-stu-id="9c816-275">The two backend services in this test do very little work.</span></span>  <span data-ttu-id="9c816-276">在实际的端到端方案中，这些服务将会执行更加昂贵的操作，如数据库调用，使传输层的性能影响显得更加微小。</span><span class="sxs-lookup"><span data-stu-id="9c816-276">In a real end-to-end scenario, these services would perform more expensive operations like database calls, making the performance impact of the transport layer less important.</span></span>  <span data-ttu-id="9c816-277">再加上 WF4 所提供功能的优点，使 Workflow Foundation 成为创建业务流程服务的可行选择。</span><span class="sxs-lookup"><span data-stu-id="9c816-277">This plus the benefits of the features available in WF4 makes Workflow Foundation a viable choice for creating orchestration services.</span></span>

## <a name="key-performance-considerations"></a><span data-ttu-id="9c816-278">关键的性能注意事项</span><span class="sxs-lookup"><span data-stu-id="9c816-278">Key Performance Considerations</span></span>
 <span data-ttu-id="9c816-279">除 Interop 外，本节所述的功能在 WF3 和 WF4 之间已有显著的更改。</span><span class="sxs-lookup"><span data-stu-id="9c816-279">The feature areas in this section, with the exception of interop, have dramatically changed between WF3 and WF4.</span></span>  <span data-ttu-id="9c816-280">这会对工作流应用程序的设计以及性能产生影响。</span><span class="sxs-lookup"><span data-stu-id="9c816-280">This affects the design of workflow applications as well as the performance.</span></span>

#### <a name="workflow-activation-latency"></a><span data-ttu-id="9c816-281">工作流激活延迟</span><span class="sxs-lookup"><span data-stu-id="9c816-281">Workflow Activation Latency</span></span>
 <span data-ttu-id="9c816-282">在 WCF 工作流服务应用程序中，启动新工作流或加载现有工作流的延迟非常重要，因为它可能会被阻止。</span><span class="sxs-lookup"><span data-stu-id="9c816-282">In a WCF workflow service application, the latency for starting a new workflow or loading an existing workflow is important as it can be blocking.</span></span>  <span data-ttu-id="9c816-283">此测试会测量典型方案中的 WF3 XOML 主机与 WF4 XAMLX 主机。</span><span class="sxs-lookup"><span data-stu-id="9c816-283">This test case measures a WF3 XOML host against a WF4 XAMLX host in a typical scenario.</span></span>

##### <a name="environment-setup"></a><span data-ttu-id="9c816-284">环境设置</span><span class="sxs-lookup"><span data-stu-id="9c816-284">Environment Setup</span></span>
 ![延迟和吞吐量测试的环境设置](./media/performance/latency-throughput-environment-setup.gif)

##### <a name="test-setup"></a><span data-ttu-id="9c816-286">测试设置</span><span class="sxs-lookup"><span data-stu-id="9c816-286">Test Setup</span></span>
 <span data-ttu-id="9c816-287">在此方案中，客户端计算机使用基于上下文的关联来联系 WCF 工作流服务。</span><span class="sxs-lookup"><span data-stu-id="9c816-287">In the scenario, a client computer contacts a WCF workflow service using context-based correlation.</span></span>  <span data-ttu-id="9c816-288">上下文相关需要特殊的上下文绑定，并使用上下文标头或 Cookie 将消息与正确的工作流实例相关联。</span><span class="sxs-lookup"><span data-stu-id="9c816-288">Context correlation requires a special context binding and uses a context header or cookie to relate messages to the correct workflow instance.</span></span>  <span data-ttu-id="9c816-289">它具有一定的性能优势，因为关联 ID 位于消息标头中，所以不需要解析消息正文。</span><span class="sxs-lookup"><span data-stu-id="9c816-289">It has a performance benefit in that the correlation Id is located in the message header so the message body does not need to be parsed.</span></span>

 <span data-ttu-id="9c816-290">该服务将根据请求创建新工作流，并发送即时响应，以使测量到的延迟不包括运行工作流所用的时间。</span><span class="sxs-lookup"><span data-stu-id="9c816-290">The service will create a new workflow with the request and send an immediate response so that the measurement of latency does not include the time spent running the workflow.</span></span>  <span data-ttu-id="9c816-291">WF3 工作流是有隐藏代码的 XOML，而 WF4 工作流则是完全的 XAML。</span><span class="sxs-lookup"><span data-stu-id="9c816-291">The WF3 workflow is XOML with a code-behind and the WF4 workflow is entirely XAML.</span></span>  <span data-ttu-id="9c816-292">WF4 工作流如下所示：</span><span class="sxs-lookup"><span data-stu-id="9c816-292">The WF4 workflow looks like this:</span></span>

 ![WF4 关联作用域工作流](./media/performance/wf4-correlationscope-workflow.gif)

 <span data-ttu-id="9c816-294"><xref:System.ServiceModel.Activities.Receive> 活动创建工作流实例。</span><span class="sxs-lookup"><span data-stu-id="9c816-294">The <xref:System.ServiceModel.Activities.Receive> activity creates the workflow instance.</span></span>  <span data-ttu-id="9c816-295">传入收到的消息的值在回复消息中回显。</span><span class="sxs-lookup"><span data-stu-id="9c816-295">A value passed in the received message is echoed in the reply message.</span></span>  <span data-ttu-id="9c816-296">回复之后的序列包含工作流的剩余部分。</span><span class="sxs-lookup"><span data-stu-id="9c816-296">A sequence following the reply contains the rest of the workflow.</span></span>  <span data-ttu-id="9c816-297">在上述情况下，只会显示一个 Comment 活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-297">In the above case, only one comment activity is shown.</span></span>  <span data-ttu-id="9c816-298">Comment 活动的数量会发生变化，以模拟工作流的复杂程度。</span><span class="sxs-lookup"><span data-stu-id="9c816-298">The number of comment activities is changed to simulate workflow complexity.</span></span>  <span data-ttu-id="9c816-299">Comment 活动相当于不执行任何工作的 WF3 <xref:System.Workflow.Activities.CodeActivity>。</span><span class="sxs-lookup"><span data-stu-id="9c816-299">A comment activity is equivalent to a WF3 <xref:System.Workflow.Activities.CodeActivity> that performs no work.</span></span> <span data-ttu-id="9c816-300">有关注释活动的详细信息，请参阅本文前面的 "组件级性能比较" 一节。</span><span class="sxs-lookup"><span data-stu-id="9c816-300">For more information about the comment activity, see the "Component-level Performance Comparison" section earlier in this article.</span></span>

##### <a name="test-results"></a><span data-ttu-id="9c816-301">测试结果</span><span class="sxs-lookup"><span data-stu-id="9c816-301">Test Results</span></span>

 <span data-ttu-id="9c816-302">WCF 工作流服务的冷和预热延迟：</span><span class="sxs-lookup"><span data-stu-id="9c816-302">Cold and warm latency for WCF workflow services:</span></span>

 ![显示 WCF 工作流服务的冷和预热延迟的柱形图，使用 WF3 和 WF4](./media/performance/latency-results-graph.gif)

 <span data-ttu-id="9c816-304">在上图中，"冷" 指的是 <xref:System.ServiceModel.WorkflowServiceHost> 给定工作流没有现有的情况。</span><span class="sxs-lookup"><span data-stu-id="9c816-304">In the previous chart, cold refers to the case where there is not an existing <xref:System.ServiceModel.WorkflowServiceHost> for the given workflow.</span></span>  <span data-ttu-id="9c816-305">换言之，冷延迟是第一次使用工作流和需要编译 XOML 或 XAML 的时间。</span><span class="sxs-lookup"><span data-stu-id="9c816-305">In other words, cold latency is when the workflow is being used for the first time and the XOML or XAML needs to be compiled.</span></span>  <span data-ttu-id="9c816-306">热延迟是当工作流类型已经编译时创建新工作流实例的时间。</span><span class="sxs-lookup"><span data-stu-id="9c816-306">Warm latency is the time to create a new workflow instance when the workflow type has already been compiled.</span></span>  <span data-ttu-id="9c816-307">在 WF4 中，工作流的复杂程度只有细微的变化，但在 WF3 中，则呈现线性发展态势。</span><span class="sxs-lookup"><span data-stu-id="9c816-307">The complexity of the workflow makes very little difference in the WF4 case but has a linear progression in the WF3 case.</span></span>

#### <a name="correlation-throughput"></a><span data-ttu-id="9c816-308">相关吞吐量</span><span class="sxs-lookup"><span data-stu-id="9c816-308">Correlation Throughput</span></span>
 <span data-ttu-id="9c816-309">WF4 采用一种新的基于内容的相关功能。</span><span class="sxs-lookup"><span data-stu-id="9c816-309">WF4 introduces a new content-based correlation feature.</span></span>  <span data-ttu-id="9c816-310">WF3 只提供基于上下文的相关。</span><span class="sxs-lookup"><span data-stu-id="9c816-310">WF3 provided only context-based correlation.</span></span>  <span data-ttu-id="9c816-311">基于上下文的关联只能通过特定的 WCF 通道绑定完成。</span><span class="sxs-lookup"><span data-stu-id="9c816-311">Context-based correlation could only be done over specific WCF channel bindings.</span></span>  <span data-ttu-id="9c816-312">使用这些绑定时，工作流 ID 会插入消息标头。</span><span class="sxs-lookup"><span data-stu-id="9c816-312">The workflow Id is inserted into the message header when using these bindings.</span></span>  <span data-ttu-id="9c816-313">WF3 运行时只能按其 Id 识别工作流。 使用基于内容的相关，工作流作者可以从相关数据片段（如帐号或客户 Id）创建相关键。</span><span class="sxs-lookup"><span data-stu-id="9c816-313">The WF3 runtime could only identify a workflow by its Id.  With content-based correlation, the workflow author can create a correlation key out of a relevant piece of data like an account number or customer Id.</span></span>

 <span data-ttu-id="9c816-314">基于上下文的相关的性能优势在于，相关键位于消息标头中。</span><span class="sxs-lookup"><span data-stu-id="9c816-314">Context-based correlation has a performance advantage in that the correlation key is located in the message header.</span></span>  <span data-ttu-id="9c816-315">无需反序列化或复制消息，就可以从消息中读取键。</span><span class="sxs-lookup"><span data-stu-id="9c816-315">The key can be read from the message without de-serialization/message-copying.</span></span>  <span data-ttu-id="9c816-316">在基于内容的相关中，相关键存储在消息正文中。</span><span class="sxs-lookup"><span data-stu-id="9c816-316">In content-based correlation, the correlation key is stored in the message body.</span></span>  <span data-ttu-id="9c816-317">会使用 XPath 表达式来定位键。</span><span class="sxs-lookup"><span data-stu-id="9c816-317">An XPath expression is used to locate the key.</span></span>  <span data-ttu-id="9c816-318">这一额外处理所需的成本取决于消息的大小、键在正文中的深度和键的数量。</span><span class="sxs-lookup"><span data-stu-id="9c816-318">The cost of this extra processing depends on the size of the message, depth of the key in the body, and the number of keys.</span></span>  <span data-ttu-id="9c816-319">此测试比较基于上下文的相关和基于内容的相关，并显示使用多个键时的性能下降。</span><span class="sxs-lookup"><span data-stu-id="9c816-319">This test compares context- and content-based correlation and also shows the performance degradation when using multiple keys.</span></span>

#### <a name="environment-setup"></a><span data-ttu-id="9c816-320">环境设置</span><span class="sxs-lookup"><span data-stu-id="9c816-320">Environment Setup</span></span>
![工作流性能测试的环境设置](./media/performance/performance-test-environment.gif)

#### <a name="test-setup"></a><span data-ttu-id="9c816-322">测试设置</span><span class="sxs-lookup"><span data-stu-id="9c816-322">Test Setup</span></span>
<span data-ttu-id="9c816-323">![相关吞吐量工作流测试](./media/performance/correlation-throughput-workflow.gif "相关吞吐量工作流测试设置")</span><span class="sxs-lookup"><span data-stu-id="9c816-323">![Correlation Throughput Workflow Test](./media/performance/correlation-throughput-workflow.gif "Correlation throughput workflow test setup")</span></span>

 <span data-ttu-id="9c816-324">上一个工作流与 " [持久性](#persistence) " 部分中使用的工作流相同。</span><span class="sxs-lookup"><span data-stu-id="9c816-324">The previous workflow is the same one used in the [Persistence](#persistence) section.</span></span> <span data-ttu-id="9c816-325">对于没有持久性的相关测试，运行时中没有安装永久性提供程序。</span><span class="sxs-lookup"><span data-stu-id="9c816-325">For the correlation tests without persistence, there is no persistence provider installed in the runtime.</span></span> <span data-ttu-id="9c816-326">相关发生在两个位置：CreateOrder 和 CompleteOrder。</span><span class="sxs-lookup"><span data-stu-id="9c816-326">Correlation occurs in two places: CreateOrder and CompleteOrder.</span></span>

#### <a name="test-results"></a><span data-ttu-id="9c816-327">测试结果</span><span class="sxs-lookup"><span data-stu-id="9c816-327">Test Results</span></span>
<span data-ttu-id="9c816-328">![相关吞吐量](./media/performance/correlation-throughput-graph.gif "相关吞吐量图表")</span><span class="sxs-lookup"><span data-stu-id="9c816-328">![Correlation Throughput](./media/performance/correlation-throughput-graph.gif "Correlation throughput graph")</span></span>

 <span data-ttu-id="9c816-329">此图显示随着基于内容的相关中使用的键数的增加，所发生的性能下降。</span><span class="sxs-lookup"><span data-stu-id="9c816-329">This graph shows a decrease in performance as the number of keys used in content-based correlation increases.</span></span>  <span data-ttu-id="9c816-330">TCP 和 HTTP 之间曲线的相似度表示与这些协议相关的开销。</span><span class="sxs-lookup"><span data-stu-id="9c816-330">The similarity in the curves between TCP and HTTP indicates the overhead associated with these protocols.</span></span>

#### <a name="correlation-with-persistence"></a><span data-ttu-id="9c816-331">使用暂留的关联</span><span class="sxs-lookup"><span data-stu-id="9c816-331">Correlation with Persistence</span></span>
 <span data-ttu-id="9c816-332">对于暂留的工作流，基于内容的相关产生的 CPU 压力从工作流运行时转移到 SQL 数据库。</span><span class="sxs-lookup"><span data-stu-id="9c816-332">With a persisted workflow, the CPU pressure from content-based correlation shifts from the workflow runtime to the SQL database.</span></span>  <span data-ttu-id="9c816-333">SQL 暂留提供程序中的存储过程执行匹配键以找到相应工作流的工作。</span><span class="sxs-lookup"><span data-stu-id="9c816-333">The stored procedures in the SQL persistence provider do the work of matching the keys to locate the appropriate workflow.</span></span>

 ![显示相关性和持久性结果的折线图](./media/performance/correlation-persistence-graph.gif)

 <span data-ttu-id="9c816-335">基于上下文的相关仍比基于内容的相关速度快。</span><span class="sxs-lookup"><span data-stu-id="9c816-335">Context-based correlation is still faster than content-based correlation.</span></span>  <span data-ttu-id="9c816-336">但是，因为暂留比相关对性能的影响大，所以这种差别并不明显。</span><span class="sxs-lookup"><span data-stu-id="9c816-336">However, the difference is less pronounced as persistence has more impact on performance than correlation.</span></span>

### <a name="complex-workflow-throughput"></a><span data-ttu-id="9c816-337">复杂工作流吞吐量</span><span class="sxs-lookup"><span data-stu-id="9c816-337">Complex Workflow Throughput</span></span>
 <span data-ttu-id="9c816-338">工作流的复杂程度不能只通过活动数来衡量。</span><span class="sxs-lookup"><span data-stu-id="9c816-338">The complexity of a workflow is not measured only by the number of activities.</span></span>  <span data-ttu-id="9c816-339">复合活动可以包含多个子活动，这些子活动可能也是复合活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-339">Composite activities can contain many children and those children can also be composite activities.</span></span>  <span data-ttu-id="9c816-340">随着嵌套层数的增加，当前处于执行状态的活动数，以及处于活动状态的变量数也会不断增加。</span><span class="sxs-lookup"><span data-stu-id="9c816-340">As the number of levels of nesting increases, so does the number of activities that can be currently in the executing state and the number of variables that can be in state.</span></span>  <span data-ttu-id="9c816-341">此测试对执行复杂工作流时 WF3 和 WF4 之间的吞吐量进行比较。</span><span class="sxs-lookup"><span data-stu-id="9c816-341">This test compares throughput between WF3 and WF4 when executing complex workflows.</span></span>

### <a name="test-setup"></a><span data-ttu-id="9c816-342">测试设置</span><span class="sxs-lookup"><span data-stu-id="9c816-342">Test Setup</span></span>
 <span data-ttu-id="9c816-343">这些测试都是在运行 Windows Server 2008 x64、具有 4 GB RAM 且采用 Intel Xeon X 5355（速度 2.66GHz）的 4 路计算机上执行的。</span><span class="sxs-lookup"><span data-stu-id="9c816-343">These tests were executed on an Intel Xeon X5355 @ 2.66GHz 4-way computer with 4GB RAM running Windows Server 2008 x64.</span></span>  <span data-ttu-id="9c816-344">测试代码在一个进程中以每个线程一个内核的方式运行，从而实现 100% 的 CPU 利用率。</span><span class="sxs-lookup"><span data-stu-id="9c816-344">The test code runs in a single process with one thread per core to reach 100% CPU utilization.</span></span>

 <span data-ttu-id="9c816-345">为此测试生成的工作流有两个主要的变量：深度和每个序列中的活动数。</span><span class="sxs-lookup"><span data-stu-id="9c816-345">The workflows generated for this test have two main variables: depth and number of activities in each sequence.</span></span>  <span data-ttu-id="9c816-346">每个深度级别都包括并行活动、while 循环、决策、分配和序列。</span><span class="sxs-lookup"><span data-stu-id="9c816-346">Each depth level includes a parallel activity, while loop, decisions, assignments, and sequences.</span></span>  <span data-ttu-id="9c816-347">在下面图示的 WF4 设计器中，描绘的是顶级流程图。</span><span class="sxs-lookup"><span data-stu-id="9c816-347">In the WF4 designer pictured below, the top-level flow chart is pictured.</span></span>  <span data-ttu-id="9c816-348">每个流程图活动都与主流程图类似。</span><span class="sxs-lookup"><span data-stu-id="9c816-348">Each flowchart activity resembles the main flowchart.</span></span>  <span data-ttu-id="9c816-349">您可以将此工作流想像成一个分形，其中的深度受限于测试的参数。</span><span class="sxs-lookup"><span data-stu-id="9c816-349">It may be helpful to think of a fractal when picturing this workflow, where the depth is limited to the parameters of the test.</span></span>

 <span data-ttu-id="9c816-350">给定的测试中的活动数由深度和每个序列的活动数决定。</span><span class="sxs-lookup"><span data-stu-id="9c816-350">The number of activities in a given test is determined by the depth and number of activities per sequence.</span></span>  <span data-ttu-id="9c816-351">以下公式会计算 WF4 测试中的活动数：</span><span class="sxs-lookup"><span data-stu-id="9c816-351">The following equation computes the number of activities in the WF4 test:</span></span>

 ![计算活动数的等式](./media/performance/number-activities-equation.gif)

 <span data-ttu-id="9c816-353">由于有一个额外的序列，所以计算 WF3 测试活动计数的等式可能会稍有不同：</span><span class="sxs-lookup"><span data-stu-id="9c816-353">The WF3 test’s activity count can be computed with a slightly different equation due to an extra sequence:</span></span>

 ![计算 WF3 活动数的公式](./media/performance/wf3-number-activities-equation.gif)

 <span data-ttu-id="9c816-355">其中 d 代表深度，a 代表每个序列的活动数。</span><span class="sxs-lookup"><span data-stu-id="9c816-355">Where d is the depth and a is the number of activities per sequence.</span></span>  <span data-ttu-id="9c816-356">这些公式背后的逻辑在于，第一个常量（会乘以 a）是序列数，而第二个常量是当前级别中的静态活动数。</span><span class="sxs-lookup"><span data-stu-id="9c816-356">The logic behind these equations is that the first constant, multiplied by a, is the number of sequences and the second constant is the static number of activities in the current level.</span></span>  <span data-ttu-id="9c816-357">每个流程图中有三个流程图子活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-357">There are three flowchart child activities in each flowchart.</span></span>  <span data-ttu-id="9c816-358">在底部的深度级别，这些流程图都是空的，但在其他级别，它们是主流程图的副本。</span><span class="sxs-lookup"><span data-stu-id="9c816-358">At the bottom depth level, these flowcharts are empty but at the other levels they are copies of the main flowchart.</span></span>  <span data-ttu-id="9c816-359">每个测试变体的工作流定义中的活动数如下表所示：</span><span class="sxs-lookup"><span data-stu-id="9c816-359">The number of activities in each test variation’s workflow definition is indicated in the following table:</span></span>

 ![显示每个测试中使用的活动数的表](./media/performance/workflow-variation-compare-table.gif)

 <span data-ttu-id="9c816-361">工作流定义中的活动数随着每个深度级别而急剧增加。</span><span class="sxs-lookup"><span data-stu-id="9c816-361">The number of activities in the workflow definition increases sharply with each depth level.</span></span>  <span data-ttu-id="9c816-362">但是，在给定工作流实例中，每个决策点只会执行一条路径，所以只会执行实际活动的一小部分。</span><span class="sxs-lookup"><span data-stu-id="9c816-362">But only one path per decision point is executed in a given workflow instance, so only a small subset of the actual activities are executed.</span></span>

 ![复杂吞吐量工作流的流程图](./media/performance/complex-workflow-throughput-workflow.gif)

 <span data-ttu-id="9c816-364">为 WF3 创建了一个等效的工作流。</span><span class="sxs-lookup"><span data-stu-id="9c816-364">An equivalent workflow was created for WF3.</span></span> <span data-ttu-id="9c816-365">WF3 设计器在设计区域显示整个工作流，而不是显示嵌套结构，因此由于它过大而未在本主题中显示。</span><span class="sxs-lookup"><span data-stu-id="9c816-365">The WF3 designer shows the entire workflow in the design area instead of nesting, therefore it is too big to display in this topic.</span></span> <span data-ttu-id="9c816-366">下面显示了工作流的一个代码段。</span><span class="sxs-lookup"><span data-stu-id="9c816-366">A snippet of the workflow is shown below.</span></span>

 ![WF3 工作流的流程图代码段](./media/performance/wf3-workflow-snippet.gif)

 <span data-ttu-id="9c816-368">为了演练极端情况下的嵌套，此测试包括的另一个工作流使用了 100 个嵌套的序列。</span><span class="sxs-lookup"><span data-stu-id="9c816-368">To exercise nesting in an extreme case, another workflow that is part of this test uses 100 nested sequences.</span></span>  <span data-ttu-id="9c816-369">最内层的序列中是一个 `Comment` 或 <xref:System.Workflow.Activities.CodeActivity>。</span><span class="sxs-lookup"><span data-stu-id="9c816-369">In the innermost sequence is a single `Comment` or <xref:System.Workflow.Activities.CodeActivity>.</span></span>

 ![嵌套序列的流程图](./media/performance/nested-sequence-workflow.gif)

 <span data-ttu-id="9c816-371">此测试中不会使用跟踪和暂留。</span><span class="sxs-lookup"><span data-stu-id="9c816-371">Tracking and persistence are not used as part of this test.</span></span>

### <a name="test-results"></a><span data-ttu-id="9c816-372">测试结果</span><span class="sxs-lookup"><span data-stu-id="9c816-372">Test Results</span></span>
 ![显示吞吐量性能结果的柱形图](./media/performance/throughput-performance-results.gif)

 <span data-ttu-id="9c816-374">即使是具有许多深度和大量活动的复杂工作流，性能结果仍与本文前面显示的吞吐量数字一致。</span><span class="sxs-lookup"><span data-stu-id="9c816-374">Even with complex workflows with lots of depth and a high number of activities, the performance results are consistent with other throughput numbers shown earlier in this article.</span></span>  <span data-ttu-id="9c816-375">WF4 的吞吐量速度呈现几个数量级的增长，必须在对数刻度上进行比较。</span><span class="sxs-lookup"><span data-stu-id="9c816-375">WF4’s throughput is orders of magnitude faster and has to be compared on a logarithmic scale.</span></span>

### <a name="memory"></a><span data-ttu-id="9c816-376">内存</span><span class="sxs-lookup"><span data-stu-id="9c816-376">Memory</span></span>
 <span data-ttu-id="9c816-377">Windows Workflow Foundation 的内存开销从两个主要方面进行测量：工作流复杂程度和工作流定义数。</span><span class="sxs-lookup"><span data-stu-id="9c816-377">The memory overhead of Windows Workflow Foundation is measured in two key areas: workflow complexity and number of workflow definitions.</span></span>  <span data-ttu-id="9c816-378">内存测量是在 Windows 7 64 位工作站上进行的。</span><span class="sxs-lookup"><span data-stu-id="9c816-378">Memory measurements were taken on a Windows 7 64-bit workstation.</span></span>  <span data-ttu-id="9c816-379">可以通过多种方法来获取工作集大小的度量，如监视性能计数器、轮询环境工作集，或使用 VMMap 中提供的工具（例如 [VMMap](/sysinternals/downloads/vmmap)）。</span><span class="sxs-lookup"><span data-stu-id="9c816-379">There are many ways to obtain the measurement of working set size such as monitoring performance counters, polling Environment.WorkingSet, or using a tool like VMMap available from [VMMap](/sysinternals/downloads/vmmap).</span></span> <span data-ttu-id="9c816-380">使用各种方法的组合来获得并验证每个测试的结果。</span><span class="sxs-lookup"><span data-stu-id="9c816-380">A combination of methods was used to obtain and verify the results of each test.</span></span>

### <a name="workflow-complexity-test"></a><span data-ttu-id="9c816-381">工作流复杂程度测试</span><span class="sxs-lookup"><span data-stu-id="9c816-381">Workflow Complexity Test</span></span>
 <span data-ttu-id="9c816-382">工作流复杂程度测试根据工作流的复杂程度测试工作集的差异。</span><span class="sxs-lookup"><span data-stu-id="9c816-382">The workflow complexity test measures the working set difference based on the complexity of the workflow.</span></span>  <span data-ttu-id="9c816-383">除了上一节中使用的复杂工作流外，还添加了新的变种以覆盖两种基本情况：单个活动工作流和包含 1000 个活动的序列。</span><span class="sxs-lookup"><span data-stu-id="9c816-383">In addition to the complex workflows used in the previous section, new variations are added to cover two basic cases: a single activity workflow and a sequence with 1000 activities.</span></span>  <span data-ttu-id="9c816-384">对于这些测试，这些工作流在一分钟的时间里，在单个序列循环中初始化并执行完成。</span><span class="sxs-lookup"><span data-stu-id="9c816-384">For these tests the workflows are initialized and executed to completion in a single serial loop for a period of one minute.</span></span>  <span data-ttu-id="9c816-385">每个测试变体都运行三次，记录的数据是这三次运行的平均值。</span><span class="sxs-lookup"><span data-stu-id="9c816-385">Each test variation is run three times and the data recorded is the average of those three runs.</span></span>

 <span data-ttu-id="9c816-386">两个新的基本测试的工作流与下面显示的工作流类似：</span><span class="sxs-lookup"><span data-stu-id="9c816-386">The two new basic tests have workflows that look like those shown below:</span></span>

 ![WF3 和 WF4 的复杂工作流](./media/performance/complex-workflow-wf3-wf4.gif)

 <span data-ttu-id="9c816-388">在上面显示的 WF3 工作流中，使用了空 <xref:System.Workflow.Activities.CodeActivity> 活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-388">In the WF3 workflow shown above, empty <xref:System.Workflow.Activities.CodeActivity> activities are used.</span></span>  <span data-ttu-id="9c816-389">上面的 WF4 工作流使用 `Comment` 活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-389">The WF4 workflow above uses `Comment` activities.</span></span>  <span data-ttu-id="9c816-390">本文前面的“组件级性能比较”一节对 `Comment` 活动进行了介绍。</span><span class="sxs-lookup"><span data-stu-id="9c816-390">The `Comment` activity was described in the Component-level Performance Comparisons section earlier in this article.</span></span>

 ![显示 WF3 和 WF4 工作流的复杂工作流内存使用情况的柱形图](./media/performance/complex-memory-usage-wf3-wf4.gif)

 <span data-ttu-id="9c816-392">需要注意此图形中一个明显的趋势，即在 WF3 和 WF4 中，嵌套对内存使用量的影响都相对较低。</span><span class="sxs-lookup"><span data-stu-id="9c816-392">One of the clear trends to notice in this graph is that nesting has relatively minimal impact on memory usage in both WF3 and WF4.</span></span>  <span data-ttu-id="9c816-393">最大的内存影响来自给定工作流中的活动数。</span><span class="sxs-lookup"><span data-stu-id="9c816-393">The most significant memory impact comes from the number of activities in a given workflow.</span></span>  <span data-ttu-id="9c816-394">若采用序列 1000 的数据，复杂深度 5、序列 5，复杂深度 7、序列 1 这两个变体，如果活动数达到几千时，则内存使用量会出现明显的增长。</span><span class="sxs-lookup"><span data-stu-id="9c816-394">Given the data from the sequence 1000, complex depth 5 sequence 5, and complex depth 7 sequence 1 variations, it is clear that as the number of activities enters the thousands, the memory usage increase becomes more noticeable.</span></span>  <span data-ttu-id="9c816-395">在有大约 29000 个活动的极端情况下（深度 7、序列 1），WF4 使用的内存几乎要比 WF3 少 79%。</span><span class="sxs-lookup"><span data-stu-id="9c816-395">In the extreme case (depth 7 sequence 1) where there are ~29K activities, WF4 is using almost 79% less memory than WF3.</span></span>

### <a name="multiple-workflow-definitions-test"></a><span data-ttu-id="9c816-396">多个工作流定义测试</span><span class="sxs-lookup"><span data-stu-id="9c816-396">Multiple Workflow Definitions Test</span></span>
 <span data-ttu-id="9c816-397">测量每个工作流定义的内存分为两个不同的测试，原因是 WF3 和 WF4 中可用于承载工作流的选项有所不同。</span><span class="sxs-lookup"><span data-stu-id="9c816-397">Measuring memory per workflow definition is divided into two different tests because of the available options for hosting workflows in WF3 and WF4.</span></span>  <span data-ttu-id="9c816-398">这些测试与工作流复杂程度测试采用不同的运行方式，给定工作流对于每个定义只实例化和执行一次。</span><span class="sxs-lookup"><span data-stu-id="9c816-398">The tests are run in a different manner than the workflow complexity test in that a given workflow is instanced and executed only once per definition.</span></span>  <span data-ttu-id="9c816-399">这是因为工作流定义和它的主机在 AppDomain 的生存期内会保留在内存中。</span><span class="sxs-lookup"><span data-stu-id="9c816-399">This is because the workflow definition and its host remain in memory for the lifetime of the AppDomain.</span></span>  <span data-ttu-id="9c816-400">运行给定的工作流实例使用的内存应当在垃圾回收期间清理。</span><span class="sxs-lookup"><span data-stu-id="9c816-400">The memory used by running a given workflow instance should be cleaned up during garbage collection.</span></span>  <span data-ttu-id="9c816-401">WF4 的迁移指南包含承载选项的更多详细信息。</span><span class="sxs-lookup"><span data-stu-id="9c816-401">The migration guidance for WF4 contains more detailed information on the hosting options.</span></span> <span data-ttu-id="9c816-402">有关详细信息，请参阅 [WF 迁移手册：工作流托管](migration-guidance.md)。</span><span class="sxs-lookup"><span data-stu-id="9c816-402">For more information, see [WF Migration Cookbook: Workflow Hosting](migration-guidance.md).</span></span>

 <span data-ttu-id="9c816-403">为工作流定义测试创建多个工作流定义，可以通过多种方式完成。</span><span class="sxs-lookup"><span data-stu-id="9c816-403">Creating many workflow definitions for a workflow definition test can be done in several ways.</span></span>  <span data-ttu-id="9c816-404">例如，可以使用代码生成创建一组除名称外完全相同的 1000 个工作流，并将这些工作流中的每一个都保存到单独的文件中。</span><span class="sxs-lookup"><span data-stu-id="9c816-404">For instance, one could use code generation to create a set of 1000 workflows that are identical except in name and save each of those workflows into separate files.</span></span>  <span data-ttu-id="9c816-405">对于控制台承载的测试采取了这种方法。</span><span class="sxs-lookup"><span data-stu-id="9c816-405">This approach was taken for the console-hosted test.</span></span>  <span data-ttu-id="9c816-406">在 WF3 中，<xref:System.Workflow.Runtime.WorkflowRuntime>类用于运行工作流定义。</span><span class="sxs-lookup"><span data-stu-id="9c816-406">In WF3, the <xref:System.Workflow.Runtime.WorkflowRuntime> class was used to run the workflow definitions.</span></span>  <span data-ttu-id="9c816-407">WF4 可使用 <xref:System.Activities.WorkflowApplication> 创建单个工作流实例，也可以直接使用 <xref:System.Activities.WorkflowInvoker> 运行活动，如同它是方法调用一样。</span><span class="sxs-lookup"><span data-stu-id="9c816-407">WF4 can either use <xref:System.Activities.WorkflowApplication> to create a single workflow instance or directly use <xref:System.Activities.WorkflowInvoker> to run the activity as if it were a method call.</span></span>  <span data-ttu-id="9c816-408"><xref:System.Activities.WorkflowApplication> 是单个工作流实例的主机，并与 <xref:System.Workflow.Runtime.WorkflowRuntime> 具有相近功能，所以在此测试中进行了使用。</span><span class="sxs-lookup"><span data-stu-id="9c816-408"><xref:System.Activities.WorkflowApplication> is a host of a single workflow instance and has closer feature parity to <xref:System.Workflow.Runtime.WorkflowRuntime> so that was used in this test.</span></span>

 <span data-ttu-id="9c816-409">在 IIS 中承载工作流时，可以使用 <xref:System.Web.Hosting.VirtualPathProvider> 创建新的 <xref:System.ServiceModel.WorkflowServiceHost>，而不是生成所有 XAMLX 或 XOML 文件。</span><span class="sxs-lookup"><span data-stu-id="9c816-409">When hosting workflows in IIS it is possible to use a <xref:System.Web.Hosting.VirtualPathProvider> to create a new <xref:System.ServiceModel.WorkflowServiceHost> instead of generating all of the XAMLX or XOML files.</span></span>  <span data-ttu-id="9c816-410"><xref:System.Web.Hosting.VirtualPathProvider>处理传入的请求并使用可从数据库加载的 "虚拟文件" 进行响应，在这种情况下，会动态生成该文件。</span><span class="sxs-lookup"><span data-stu-id="9c816-410">The <xref:System.Web.Hosting.VirtualPathProvider> handles the incoming request and responds with a "virtual file" that can be loaded from a database or, in this case, generated on the fly.</span></span>  <span data-ttu-id="9c816-411">这样就不必创建 1000 个物理文件了。</span><span class="sxs-lookup"><span data-stu-id="9c816-411">It is therefore unnecessary to create 1000 physical files.</span></span>

 <span data-ttu-id="9c816-412">在控制台测试中使用的工作流定义是具有单个活动的简单顺序工作流。</span><span class="sxs-lookup"><span data-stu-id="9c816-412">The workflow definitions used in the console test were simple sequential workflows with a single activity.</span></span>  <span data-ttu-id="9c816-413">单个活动对于 WF3 是空 <xref:System.Workflow.Activities.CodeActivity>，对于 WF4 是 `Comment` 活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-413">The single activity was an empty <xref:System.Workflow.Activities.CodeActivity> for the WF3 case and a `Comment` activity for the WF4 case.</span></span>  <span data-ttu-id="9c816-414">IIS 承载情况下使用的工作流在接收消息时启动，在发送回复时结束：</span><span class="sxs-lookup"><span data-stu-id="9c816-414">The IIS-hosted case used workflows that start on receiving a message and end on sending a reply:</span></span>

<span data-ttu-id="9c816-415">下图显示了 WF3 工作流，其中包含 ReceiveActivity 和具有请求/响应模式的 WF4 工作流：</span><span class="sxs-lookup"><span data-stu-id="9c816-415">The following image shows a WF3 workflow with ReceiveActivity and a WF4 workflow with request/response pattern:</span></span>

 ![WF3 和 WF4 中的工作流服务](./media/performance/workflow-receive-activity.gif)

 <span data-ttu-id="9c816-417">下表显示了单个工作流定义与1001定义之间工作集中的增量：</span><span class="sxs-lookup"><span data-stu-id="9c816-417">The following table shows the delta in working set between a single workflow definition and 1001 definitions:</span></span>

|<span data-ttu-id="9c816-418">宿主选项</span><span class="sxs-lookup"><span data-stu-id="9c816-418">Hosting Options</span></span>|<span data-ttu-id="9c816-419">WF3 工作集增量</span><span class="sxs-lookup"><span data-stu-id="9c816-419">WF3 Working Set Delta</span></span>|<span data-ttu-id="9c816-420">WF4 工作集增量</span><span class="sxs-lookup"><span data-stu-id="9c816-420">WF4 Working Set Delta</span></span>|
|---------------------|---------------------------|---------------------------|
|<span data-ttu-id="9c816-421">控制台应用程序承载的工作流</span><span class="sxs-lookup"><span data-stu-id="9c816-421">Console Application Hosted Workflows</span></span>|<span data-ttu-id="9c816-422">18 MB</span><span class="sxs-lookup"><span data-stu-id="9c816-422">18 MB</span></span>|<span data-ttu-id="9c816-423">9 MB</span><span class="sxs-lookup"><span data-stu-id="9c816-423">9 MB</span></span>|
|<span data-ttu-id="9c816-424">IIS 承载的工作流服务</span><span class="sxs-lookup"><span data-stu-id="9c816-424">IIS Hosted Workflow Services</span></span>|<span data-ttu-id="9c816-425">446 MB</span><span class="sxs-lookup"><span data-stu-id="9c816-425">446 MB</span></span>|<span data-ttu-id="9c816-426">364 MB</span><span class="sxs-lookup"><span data-stu-id="9c816-426">364 MB</span></span>|

 <span data-ttu-id="9c816-427">由于 <xref:System.ServiceModel.WorkflowServiceHost> 、详细的 WCF 服务项目和与宿主关联的消息处理逻辑，在 IIS 中承载工作流定义会消耗更多内存。</span><span class="sxs-lookup"><span data-stu-id="9c816-427">Hosting workflow definitions in IIS consumes much more memory due to the <xref:System.ServiceModel.WorkflowServiceHost>, detailed WCF service artifacts, and the message processing logic associated with the host.</span></span>

 <span data-ttu-id="9c816-428">对于 WF3 中的控制台承载，工作流在代码中实现，而不是在 XOML 中实现。</span><span class="sxs-lookup"><span data-stu-id="9c816-428">For console hosting in WF3 the workflows were implemented in code instead of XOML.</span></span>  <span data-ttu-id="9c816-429">在 WF4 中，默认为使用 XAML。</span><span class="sxs-lookup"><span data-stu-id="9c816-429">In WF4 the default is to use XAML.</span></span>  <span data-ttu-id="9c816-430">XAML 作为嵌入资源存储在程序集中并在运行时期间编译，以提供工作流的实现。</span><span class="sxs-lookup"><span data-stu-id="9c816-430">The XAML is stored as an embedded resource in the assembly and compiled during runtime to provide the implementation of the workflow.</span></span>  <span data-ttu-id="9c816-431">此过程会有一些相关的开销。</span><span class="sxs-lookup"><span data-stu-id="9c816-431">There is some overhead associated with this process.</span></span>  <span data-ttu-id="9c816-432">为了在 WF3 和 WF4 之间进行公平比较，使用的是编码的工作流，而不是 XAML。</span><span class="sxs-lookup"><span data-stu-id="9c816-432">In order to make a fair comparison between WF3 and WF4, coded workflows were used instead of XAML.</span></span>  <span data-ttu-id="9c816-433">下面显示了一个 WF4 工作流示例：</span><span class="sxs-lookup"><span data-stu-id="9c816-433">An example of one of the WF4 workflows is shown below:</span></span>

```csharp
public class Workflow1 : Activity
{
    protected override Func<Activity> Implementation
    {
        get
        {
            return new Func<Activity>(() =>
            {
                return new Sequence
                {
                    Activities = {
                        new Comment()
                    }
                };
            });
        }
        set
        {
            base.Implementation = value;
        }
    }
}
```

 <span data-ttu-id="9c816-434">还有许多其他因素可以影响内存消耗。</span><span class="sxs-lookup"><span data-stu-id="9c816-434">There are many other factors that can affect memory consumption.</span></span> <span data-ttu-id="9c816-435">相同的建议也适用于所有托管的程序。</span><span class="sxs-lookup"><span data-stu-id="9c816-435">The same advice for all managed programs still applies.</span></span>  <span data-ttu-id="9c816-436">在 IIS 承载的环境中，为工作流定义创建的 <xref:System.ServiceModel.WorkflowServiceHost> 对象保留在内存中，直到应用程序池被回收。</span><span class="sxs-lookup"><span data-stu-id="9c816-436">In IIS-hosted environments, the <xref:System.ServiceModel.WorkflowServiceHost> object created for a workflow definition stays in memory until the application pool is recycled.</span></span>  <span data-ttu-id="9c816-437">编写扩展时应当记住这一点。</span><span class="sxs-lookup"><span data-stu-id="9c816-437">This should be kept in mind when writing extensions.</span></span>  <span data-ttu-id="9c816-438">此外，最好避免将 "global" 变量 () 整个工作流的变量，并尽可能限制变量的范围。</span><span class="sxs-lookup"><span data-stu-id="9c816-438">Also, it is best to avoid "global" variables (variables scoped to the whole workflow) and limit the scope of variables wherever possible.</span></span>

## <a name="workflow-runtime-services"></a><span data-ttu-id="9c816-439">工作流运行时服务</span><span class="sxs-lookup"><span data-stu-id="9c816-439">Workflow Runtime Services</span></span>

### <a name="persistence"></a><span data-ttu-id="9c816-440">持久性</span><span class="sxs-lookup"><span data-stu-id="9c816-440">Persistence</span></span>
 <span data-ttu-id="9c816-441">WF3 和 WF4 都附带 SQL 暂留提供程序。</span><span class="sxs-lookup"><span data-stu-id="9c816-441">WF3 and WF4 both ship with a SQL persistence provider.</span></span>  <span data-ttu-id="9c816-442">WF3 SQL 暂留提供程序是序列化工作流实例并将它存储在 blob 中的简单实现。</span><span class="sxs-lookup"><span data-stu-id="9c816-442">The WF3 SQL persistence provider is a simple implementation that serializes the workflow instance and stores it in a blob.</span></span>  <span data-ttu-id="9c816-443">因此，此提供程序的性能主要取决于工作流实例的大小。</span><span class="sxs-lookup"><span data-stu-id="9c816-443">For this reason, the performance of this provider depends heavily on the size of the workflow instance.</span></span>  <span data-ttu-id="9c816-444">在 WF3 中，如本文前面所述，实例大小可能因为多种原因而增加。</span><span class="sxs-lookup"><span data-stu-id="9c816-444">In WF3, the instance size could increase for many reasons, as is discussed previously in this paper.</span></span>  <span data-ttu-id="9c816-445">许多用户选择不使用默认的 SQL 暂留提供程序，因为在数据库中存储序列化实例会导致无法看见工作流的状态。</span><span class="sxs-lookup"><span data-stu-id="9c816-445">Many customers choose not to use the default SQL persistence provider because storing a serialized instance in a database gives no visibility into the state of the workflow.</span></span>  <span data-ttu-id="9c816-446">为了在不知道工作流 ID 的情况下找到特定工作流，必须反序列化每个暂留的实例，并检查内容。</span><span class="sxs-lookup"><span data-stu-id="9c816-446">In order to find a particular workflow without knowing the workflow id, one would have to deserialize each persisted instance and examine the contents.</span></span>  <span data-ttu-id="9c816-447">许多开发人员喜欢编写自己的暂留提供程序以克服这些障碍。</span><span class="sxs-lookup"><span data-stu-id="9c816-447">Many developers prefer to write their own persistence providers to overcome this obstacle.</span></span>

 <span data-ttu-id="9c816-448">WF4 SQL 暂留提供程序已尝试解决这些困挠。</span><span class="sxs-lookup"><span data-stu-id="9c816-448">The WF4 SQL persistence provider has tried to address some of these concerns.</span></span>  <span data-ttu-id="9c816-449">暂留表公开特定的信息，如活动的书签和可提升的属性。</span><span class="sxs-lookup"><span data-stu-id="9c816-449">The persistence tables expose certain information such as the active bookmarks and promotable properties.</span></span>  <span data-ttu-id="9c816-450">WF4 中的新的基于内容的相关功能在使用 WF3 SQL 暂留方法时可能无法正常执行，因为它为使暂留的工作流实例的组织产生变化。</span><span class="sxs-lookup"><span data-stu-id="9c816-450">The new content-based correlation feature in WF4 would not perform well using the WF3 SQL persistence approach, which has driven some change in the organization of the persisted workflow instance.</span></span>  <span data-ttu-id="9c816-451">这使暂留提供程序的作业更为复杂，并为数据库施加了额外的压力。</span><span class="sxs-lookup"><span data-stu-id="9c816-451">This makes the job of the persistence provider more complex and puts extra stress on the database.</span></span>

### <a name="environment-setup"></a><span data-ttu-id="9c816-452">环境设置</span><span class="sxs-lookup"><span data-stu-id="9c816-452">Environment Setup</span></span>
![工作流性能测试的环境设置](./media/performance/performance-test-environment.gif)

### <a name="test-setup"></a><span data-ttu-id="9c816-454">测试设置</span><span class="sxs-lookup"><span data-stu-id="9c816-454">Test Setup</span></span>
 <span data-ttu-id="9c816-455">因为有了改进的功能集和更好的并行处理，所以 WF4 中的 SQL 暂留提供程序要比 WF3 中的提供程序更快。</span><span class="sxs-lookup"><span data-stu-id="9c816-455">Even with an improved feature set and better concurrency handling, the SQL persistence provider in WF4 is faster than the provider in WF3.</span></span>  <span data-ttu-id="9c816-456">为了展示这一点，下面比较 WF3 和 WF4 中基本执行相同操作的两个工作流。</span><span class="sxs-lookup"><span data-stu-id="9c816-456">To showcase this, two workflows that perform essentially the same operations in WF3 and WF4 are compared below.</span></span>

 ![左侧 WF3 中的暂留工作流，右侧为 WF4](./media/performance/persist-workflow-wf3-wf4.gif)

 <span data-ttu-id="9c816-458">两个工作流均通过收到的消息创建。</span><span class="sxs-lookup"><span data-stu-id="9c816-458">The two workflows are both created by a received message.</span></span>  <span data-ttu-id="9c816-459">在发送初始答复后，会暂留工作流。</span><span class="sxs-lookup"><span data-stu-id="9c816-459">After sending an initial reply, the workflow is persisted.</span></span>  <span data-ttu-id="9c816-460">在 WF3 中，会使用空 <xref:System.Workflow.ComponentModel.TransactionScopeActivity> 来启动暂留。</span><span class="sxs-lookup"><span data-stu-id="9c816-460">In the WF3 case, an empty <xref:System.Workflow.ComponentModel.TransactionScopeActivity> is used to initiate the persistence.</span></span>  <span data-ttu-id="9c816-461">在 WF3 中，可以通过将活动标记为 "关闭时保留" 来实现相同的目的。</span><span class="sxs-lookup"><span data-stu-id="9c816-461">The same could be achieved in WF3 by marking an activity as "persist on close."</span></span>  <span data-ttu-id="9c816-462">另一个关联的消息会完成工作流。</span><span class="sxs-lookup"><span data-stu-id="9c816-462">A second, correlated message completes the workflow.</span></span>  <span data-ttu-id="9c816-463">该工作流暂留下来，但不会卸载。</span><span class="sxs-lookup"><span data-stu-id="9c816-463">The workflows are persisted but not unloaded.</span></span>

### <a name="test-results"></a><span data-ttu-id="9c816-464">测试结果</span><span class="sxs-lookup"><span data-stu-id="9c816-464">Test Results</span></span>
 ![显示吞吐量持久性的柱形图](./media/performance/throughput-persistence-graph.gif)

 <span data-ttu-id="9c816-466">客户端和中间层之间的传输使用 HTTP 时，WF4 中的暂留会出现 2.6 倍的提升。</span><span class="sxs-lookup"><span data-stu-id="9c816-466">When the transport between client and middle tier is HTTP, persistence in WF4 shows an improvement of 2.6 times.</span></span>  <span data-ttu-id="9c816-467">TCP 传输会将提升增加到 3.0 倍。</span><span class="sxs-lookup"><span data-stu-id="9c816-467">The TCP transport increases that factor to 3.0 times.</span></span>  <span data-ttu-id="9c816-468">在所有情况下，中间层上的 CPU 使用率都等于或高于 98%。</span><span class="sxs-lookup"><span data-stu-id="9c816-468">In all cases, CPU utilization on the middle tier is 98% or higher.</span></span>  <span data-ttu-id="9c816-469">WF4 吞吐量更大的原因是由于工作流运行时的速度更快。</span><span class="sxs-lookup"><span data-stu-id="9c816-469">The reason that WF4 throughput is greater is due to the faster workflow runtime.</span></span>  <span data-ttu-id="9c816-470">这两种情况的序列化实例都不大，所以在这种情况下实例大小不是主要的影响元素。</span><span class="sxs-lookup"><span data-stu-id="9c816-470">The size of the serialized instance is low for both cases and is not a major contributing element in this situation.</span></span>

 <span data-ttu-id="9c816-471">此测试中的 WF3 和 WF4 工作流都使用活动显式指出应当发生暂留的时间。</span><span class="sxs-lookup"><span data-stu-id="9c816-471">Both the WF3 and WF4 workflows in this test use an activity to explicitly indicate when persistence should occur.</span></span>  <span data-ttu-id="9c816-472">它的好处是不用卸载工作流，而是暂留它。</span><span class="sxs-lookup"><span data-stu-id="9c816-472">This has the benefit of persisting the workflow without unloading it.</span></span>  <span data-ttu-id="9c816-473">在 WF3 中，还可以使用 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> 功能进行暂留，但这会从内存中卸载工作流实例。</span><span class="sxs-lookup"><span data-stu-id="9c816-473">In WF3, it is also possible to persist using the <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> feature, but this unloads the workflow instance from memory.</span></span>  <span data-ttu-id="9c816-474">如果使用 WF3 的开发人员想要确保在特定时间点暂留工作流，则他们要么必须修改工作流定义，要么必须付出卸载并重新加载工作流实例的成本。</span><span class="sxs-lookup"><span data-stu-id="9c816-474">If a developer using WF3 wants to make sure a workflow persists at certain points, they either have to alter the workflow definition or pay the cost for unloading and re-loading the workflow instance.</span></span>  <span data-ttu-id="9c816-475">WF4 中的一项新功能使无需卸载就进行暂留成为可能： <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToPersist%2A>。</span><span class="sxs-lookup"><span data-stu-id="9c816-475">A new feature in WF4 makes it possible to persist without unloading: <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToPersist%2A>.</span></span>  <span data-ttu-id="9c816-476">此功能允许在工作流实例闲置时将其暂留，但仍将其保存在内存中，直到达到 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> 阈值或恢复执行。</span><span class="sxs-lookup"><span data-stu-id="9c816-476">This feature allows the workflow instance to be persisted on idle but stay in memory until the <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> threshold is met or execution is resumed.</span></span>

 <span data-ttu-id="9c816-477">注意，WF4 SQL 暂留提供程序在数据库层会执行较多的工作。</span><span class="sxs-lookup"><span data-stu-id="9c816-477">Note that the WF4 SQL persistence provider performs more work in the database tier.</span></span>  <span data-ttu-id="9c816-478">由于 SQL 数据库可能成为瓶颈，所以务必要监视该处的 CPU 和磁盘使用情况。</span><span class="sxs-lookup"><span data-stu-id="9c816-478">The SQL database can become a bottleneck so it is important to monitor the CPU and disk usage there.</span></span>  <span data-ttu-id="9c816-479">在对工作流应用程序进行性能测试时，务必包括 SQL 数据库中的下列性能计数器：</span><span class="sxs-lookup"><span data-stu-id="9c816-479">Be sure to include the following performance counters from the SQL database when performance testing workflow applications:</span></span>

- <span data-ttu-id="9c816-480">PhysicalDisk \\ 磁盘读取时间百分比</span><span class="sxs-lookup"><span data-stu-id="9c816-480">PhysicalDisk\\%Disk Read Time</span></span>

- <span data-ttu-id="9c816-481">PhysicalDisk \\ 磁盘时间百分比</span><span class="sxs-lookup"><span data-stu-id="9c816-481">PhysicalDisk\\% Disk Time</span></span>

- <span data-ttu-id="9c816-482">PhysicalDisk \\ 磁盘写入时间百分比</span><span class="sxs-lookup"><span data-stu-id="9c816-482">PhysicalDisk\\% Disk Write Time</span></span>

- <span data-ttu-id="9c816-483">PhysicalDisk \\ % Avg. Disk Queue Length</span><span class="sxs-lookup"><span data-stu-id="9c816-483">PhysicalDisk\\% Avg. Disk Queue Length</span></span>

- <span data-ttu-id="9c816-484">PhysicalDisk\Avg. 磁盘读取队列长度</span><span class="sxs-lookup"><span data-stu-id="9c816-484">PhysicalDisk\Avg. Disk Read Queue Length</span></span>

- <span data-ttu-id="9c816-485">PhysicalDisk\Avg. 磁盘写入队列长度</span><span class="sxs-lookup"><span data-stu-id="9c816-485">PhysicalDisk\Avg. Disk Write Queue Length</span></span>

- <span data-ttu-id="9c816-486">PhysicalDisk\Current Disk Queue Length</span><span class="sxs-lookup"><span data-stu-id="9c816-486">PhysicalDisk\Current Disk Queue Length</span></span>

- <span data-ttu-id="9c816-487">处理器信息 \\ 处理器时间百分比</span><span class="sxs-lookup"><span data-stu-id="9c816-487">Processor Information\\% Processor Time</span></span>

- <span data-ttu-id="9c816-488">SQLServer:Latches\Average Latch Wait Time (ms)</span><span class="sxs-lookup"><span data-stu-id="9c816-488">SQLServer:Latches\Average Latch Wait Time (ms)</span></span>

- <span data-ttu-id="9c816-489">SQLServer:Latches\Latch Waits/sec</span><span class="sxs-lookup"><span data-stu-id="9c816-489">SQLServer:Latches\Latch Waits/sec</span></span>

### <a name="tracking"></a><span data-ttu-id="9c816-490">跟踪</span><span class="sxs-lookup"><span data-stu-id="9c816-490">Tracking</span></span>
 <span data-ttu-id="9c816-491">跟踪工作流可用于跟踪工作流的进度。</span><span class="sxs-lookup"><span data-stu-id="9c816-491">Workflow tracking can be used to track the progress of a workflow.</span></span>  <span data-ttu-id="9c816-492">跟踪事件中所包含的信息由跟踪配置文件决定。</span><span class="sxs-lookup"><span data-stu-id="9c816-492">The information that is included in the tracking events is determined by a tracking profile.</span></span>  <span data-ttu-id="9c816-493">跟踪配置文件越复杂，跟踪的成本就越高。</span><span class="sxs-lookup"><span data-stu-id="9c816-493">The more complex the tracking profile, the more expensive tracking becomes.</span></span>

 <span data-ttu-id="9c816-494">WF3 附带了一个基于 SQL 的跟踪服务。</span><span class="sxs-lookup"><span data-stu-id="9c816-494">WF3 shipped with a SQL-based tracking service.</span></span>  <span data-ttu-id="9c816-495">此服务可以在批处理和非批处理模式下工作。</span><span class="sxs-lookup"><span data-stu-id="9c816-495">This service could work in batched and non-batched modes.</span></span>  <span data-ttu-id="9c816-496">在非批处理模式下，跟踪事件直接写入数据库。</span><span class="sxs-lookup"><span data-stu-id="9c816-496">In non-batched mode, tracking events are written directly to the database.</span></span>  <span data-ttu-id="9c816-497">在批处理模式下，会将跟踪事件与工作流实例状态收集到同一个批次中。</span><span class="sxs-lookup"><span data-stu-id="9c816-497">In batched mode, tracking events are collected into the same batch as the workflow instance state.</span></span>  <span data-ttu-id="9c816-498">批处理模式具有最佳的性能，适合各种工作流设计。</span><span class="sxs-lookup"><span data-stu-id="9c816-498">The batched mode has the best performance for the widest range of workflow designs.</span></span>  <span data-ttu-id="9c816-499">但是，如果工作流运行许多活动但不使用暂留，并且要跟踪这些活动，则批处理可能对性能产生负面影响。</span><span class="sxs-lookup"><span data-stu-id="9c816-499">However, batching can have a negative performance impact if the workflow runs many activities without persisting and those activities are tracked.</span></span>  <span data-ttu-id="9c816-500">这通常会发生在循环中，若要避免这种情况，最好的方法来设计大型循环，以包含暂留点。</span><span class="sxs-lookup"><span data-stu-id="9c816-500">This would commonly happen in loops and the best way to avoid this scenario is to design large loops to contain a persistence point.</span></span>  <span data-ttu-id="9c816-501">在循环中引入暂留点也会对性能产生负面影响，所以必须测量每项的成本并找出平衡。</span><span class="sxs-lookup"><span data-stu-id="9c816-501">Introducing a persistence point into a loop can negatively affect performance as well so it is important to measure the costs of each and come up with a balance.</span></span>

 <span data-ttu-id="9c816-502">WF4 未附带 SQL 跟踪服务。</span><span class="sxs-lookup"><span data-stu-id="9c816-502">WF4 is not shipped with a SQL tracking service.</span></span>  <span data-ttu-id="9c816-503">将跟踪信息记录到 SQL 数据库中可以更好地从应用程序服务器处理，而不是内置于 .NET Framework 中。</span><span class="sxs-lookup"><span data-stu-id="9c816-503">Recording tracking information to a SQL database can be handled better from an application server rather than built into the .NET Framework.</span></span> <span data-ttu-id="9c816-504">因此，SQL 跟踪目前由 AppFabric 处理。</span><span class="sxs-lookup"><span data-stu-id="9c816-504">Therefore SQL tracking is now handled by AppFabric.</span></span>  <span data-ttu-id="9c816-505">WF4 中现成的跟踪提供程序以 Windows 事件跟踪 (ETW) 为基础。</span><span class="sxs-lookup"><span data-stu-id="9c816-505">The out-of-the-box tracking provider in WF4 is based on Event Tracing for Windows (ETW).</span></span>

 <span data-ttu-id="9c816-506">ETW 是 Windows 中内置的内核级低延迟事件系统。</span><span class="sxs-lookup"><span data-stu-id="9c816-506">ETW is a kernel-level, low-latency event system built into Windows.</span></span>  <span data-ttu-id="9c816-507">它使用提供者/使用者模型，使之能在有实际使用者时才使事件跟踪产生负面影响。</span><span class="sxs-lookup"><span data-stu-id="9c816-507">It uses a provider/consumer model that makes it possible to only incur the penalty for event tracing when there is actually a consumer.</span></span>  <span data-ttu-id="9c816-508">除了处理器、磁盘、内存和网络使用情况等内核事件外，许多应用程序也利用 ETW。</span><span class="sxs-lookup"><span data-stu-id="9c816-508">In addition to kernel events such as processor, disk, memory, and network usage, many applications leverage ETW as well.</span></span>  <span data-ttu-id="9c816-509">ETW 事件比性能计数器更强大，因为可以根据应用程序自定义事件。</span><span class="sxs-lookup"><span data-stu-id="9c816-509">ETW events are more powerful than performance counters in that events can be customized to the application.</span></span>  <span data-ttu-id="9c816-510">事件可以包含文本，如工作流 ID 或信息性消息。</span><span class="sxs-lookup"><span data-stu-id="9c816-510">An event can contain text such as a workflow ID or an informational message.</span></span>  <span data-ttu-id="9c816-511">此外，还会用位掩码对事件进行分类，这样，使用特定的事件子集要比捕获所有事件所产生的性能影响更低。</span><span class="sxs-lookup"><span data-stu-id="9c816-511">Also, events are categorized with bitmasks so that consuming a certain subset of events will have less performance impact than capturing all events.</span></span>

 <span data-ttu-id="9c816-512">使用 ETW 跟踪代替 SQL 跟踪的好处包括：</span><span class="sxs-lookup"><span data-stu-id="9c816-512">Benefits to the approach of using ETW for tracking instead of SQL include:</span></span>

- <span data-ttu-id="9c816-513">跟踪事件的收集可以分散到其他进程。</span><span class="sxs-lookup"><span data-stu-id="9c816-513">Collection of tracking events can be separated to another process.</span></span>  <span data-ttu-id="9c816-514">这就为记录事件的方式提供了更大的灵活性。</span><span class="sxs-lookup"><span data-stu-id="9c816-514">This gives greater flexibility in how the events are recorded.</span></span>

- <span data-ttu-id="9c816-515">ETW 跟踪事件与 WCF ETW 事件或其他 ETW 提供程序（如 SQL Server 或内核提供程序）很容易组合在一起。</span><span class="sxs-lookup"><span data-stu-id="9c816-515">ETW tracking events are easily combined with the WCF ETW events or other ETW providers such as a SQL Server or kernel provider.</span></span>

- <span data-ttu-id="9c816-516">工作流作者无需更改工作流，就能很好地使用特定的跟踪实现，如 WF3 SQL 跟踪服务的批处理模式。</span><span class="sxs-lookup"><span data-stu-id="9c816-516">Workflow authors do not need to alter a workflow to work better with a particular tracking implementation, such as the WF3 SQL tracking service’s batch mode.</span></span>

- <span data-ttu-id="9c816-517">管理员无需回收主机进程就可以打开或关闭跟踪。</span><span class="sxs-lookup"><span data-stu-id="9c816-517">An administrator can turn tracking on or off without recycling the host process.</span></span>

 <span data-ttu-id="9c816-518">ETW 跟踪的种种性能优势也带来了一个缺点。</span><span class="sxs-lookup"><span data-stu-id="9c816-518">The performance benefits to ETW tracking come with a drawback.</span></span>  <span data-ttu-id="9c816-519">如果系统受到密集的资源压力，ETW 事件可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="9c816-519">ETW events can be lost if the system is under intense resource pressure.</span></span>  <span data-ttu-id="9c816-520">处理事件的目的不是为了阻止正常的程序执行，因此不能保证所有 ETW 事件都会广播至其订阅者。</span><span class="sxs-lookup"><span data-stu-id="9c816-520">The processing of events is not meant to block normal program execution and therefore it is not guaranteed that all ETW events will be broadcast to their subscribers.</span></span>  <span data-ttu-id="9c816-521">这使 ETW 跟踪非常适合运行状况监视，但不适合审核。</span><span class="sxs-lookup"><span data-stu-id="9c816-521">This makes ETW tracking great for health monitoring but not suitable for auditing.</span></span>

 <span data-ttu-id="9c816-522">虽然 WF4 没有 SQL 跟踪提供程序，但是 AppFabric 有。</span><span class="sxs-lookup"><span data-stu-id="9c816-522">While WF4 does not have a SQL tracking provider, AppFabric does.</span></span>  <span data-ttu-id="9c816-523">AppFabric 的 SQL 跟踪方法是使用 Windows 服务订阅 ETW 事件，该服务将事件分批，并将它们写入专门用于快速插入的 SQL 表中。</span><span class="sxs-lookup"><span data-stu-id="9c816-523">AppFabric’s SQL tracking approach is to subscribe to ETW events with a Windows Service that batches the events and writes them to a SQL table designed for quick inserts.</span></span>  <span data-ttu-id="9c816-524">另一个作业从此表中抽取数据，并将其转换为可以在 AppFabric 仪表板上查看的报表。</span><span class="sxs-lookup"><span data-stu-id="9c816-524">A separate job drains the data from this table and reforms it into reporting tables that can be viewed on the AppFabric dashboard.</span></span>  <span data-ttu-id="9c816-525">这意味着一批跟踪事件会与其来源的工作流分开处理，因此不用等待暂留点就可以进行记录。</span><span class="sxs-lookup"><span data-stu-id="9c816-525">This means that a batch of tracking events is handled independent of the workflow it came from and therefore does not have to wait for a persistence point before being recorded.</span></span>

 <span data-ttu-id="9c816-526">ETW 事件可以使用 logman 或 xperf 之类的工具进行记录。</span><span class="sxs-lookup"><span data-stu-id="9c816-526">ETW events can be recorded with tools such as logman or xperf.</span></span>  <span data-ttu-id="9c816-527">可以使用 xperfview 之类的工具查看压缩的 ETL 文件，也可以使用 tracerpt 将其转换为更容易读取的格式，如 XML。</span><span class="sxs-lookup"><span data-stu-id="9c816-527">The compact ETL file can be viewed with a tool like xperfview or converted to a more readable format, such as XML, with tracerpt.</span></span>  <span data-ttu-id="9c816-528">在 WF3 中，不使用 SQL 数据库而获得跟踪事件的唯一方法是创建自定义跟踪服务。</span><span class="sxs-lookup"><span data-stu-id="9c816-528">In WF3, the only option for getting tracking events without a SQL database is to create a custom tracking service.</span></span> <span data-ttu-id="9c816-529">有关 ETW 的详细信息，请参阅 [适用于 windows 的 WCF 服务和事件跟踪](../wcf/samples/wcf-services-and-event-tracing-for-windows.md) 和 [事件跟踪-windows 应用程序](/windows/desktop/etw/event-tracing-portal)。</span><span class="sxs-lookup"><span data-stu-id="9c816-529">For more information about ETW, see [WCF Services and Event Tracing for Windows](../wcf/samples/wcf-services-and-event-tracing-for-windows.md) and [Event Tracing - Windows applications](/windows/desktop/etw/event-tracing-portal).</span></span>

 <span data-ttu-id="9c816-530">启用工作流跟踪将不同程度地影响性能。</span><span class="sxs-lookup"><span data-stu-id="9c816-530">Enabling workflow tracking will impact performance in varying degrees.</span></span>  <span data-ttu-id="9c816-531">下面的基准测试使用 logman 工具来使用 ETW 跟踪事件并将它们记录到 ETL 文件中。</span><span class="sxs-lookup"><span data-stu-id="9c816-531">The benchmark below uses the logman tool to consume the ETW tracking events and record them to an ETL file.</span></span>  <span data-ttu-id="9c816-532">AppFabric 中 SQL 跟踪的成本不在本文的讨论范围内。</span><span class="sxs-lookup"><span data-stu-id="9c816-532">The cost of the SQL tracking in AppFabric is not in the scope of this article.</span></span>  <span data-ttu-id="9c816-533">基本跟踪配置文件（也会在 AppFabric 中使用）会在此基准测试中显示。</span><span class="sxs-lookup"><span data-stu-id="9c816-533">The basic tracking profile, also used in AppFabric, is shown in this benchmark.</span></span>  <span data-ttu-id="9c816-534">此外，还会包括只跟踪运行状况监视事件的成本。</span><span class="sxs-lookup"><span data-stu-id="9c816-534">Also included is the cost of tracking only health monitoring events.</span></span>  <span data-ttu-id="9c816-535">这些事件有助于解决疑难问题和确定系统的平均吞吐量。</span><span class="sxs-lookup"><span data-stu-id="9c816-535">These events are useful for troubleshooting problems and determining the average throughput of the system.</span></span>

### <a name="environment-setup"></a><span data-ttu-id="9c816-536">环境设置</span><span class="sxs-lookup"><span data-stu-id="9c816-536">Environment Setup</span></span>
 ![工作流性能测试的环境设置](./media/performance/performance-test-environment.gif)

### <a name="test-results"></a><span data-ttu-id="9c816-538">测试结果</span><span class="sxs-lookup"><span data-stu-id="9c816-538">Test Results</span></span>

 ![显示工作流跟踪成本的柱形图](./media/performance/workflow-tracking-costs.gif)

 <span data-ttu-id="9c816-540">运行状况监视对吞吐量大约有 3% 的影响。</span><span class="sxs-lookup"><span data-stu-id="9c816-540">Health monitoring has roughly a 3% impact on throughput.</span></span>  <span data-ttu-id="9c816-541">基本配置文件的成本大约为 8%。</span><span class="sxs-lookup"><span data-stu-id="9c816-541">The basic profile’s cost is around 8%.</span></span>

## <a name="interop"></a><span data-ttu-id="9c816-542">Interop</span><span class="sxs-lookup"><span data-stu-id="9c816-542">Interop</span></span>
 <span data-ttu-id="9c816-543">WF4 几乎是对 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 完全重写，因此 WF3 工作流和活动不能与 WF4 直接兼容。</span><span class="sxs-lookup"><span data-stu-id="9c816-543">WF4 is almost a complete rewrite of [!INCLUDE[wf1](../../../includes/wf1-md.md)] and therefore WF3 workflows and activities are not directly compatible with WF4.</span></span>  <span data-ttu-id="9c816-544">采用 Windows Workflow Foundation 早期采用的许多客户将具有内部或第三方工作流定义和 WF3 的自定义活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-544">Many customers that adopted Windows Workflow Foundation early will have in-house or third-party workflow definitions and custom activities for WF3.</span></span>  <span data-ttu-id="9c816-545">为了简化向 WF4 的迁移，一种方法是使用 Interop 活动，这种活动可以从 WF4 工作流中执行 WF3 活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-545">One way to ease the transition to WF4 is to use the Interop activity, which can execute WF3 activities from within a WF4 workflow.</span></span>  <span data-ttu-id="9c816-546">建议仅在必要时才使用 <xref:System.Activities.Statements.Interop> 活动。</span><span class="sxs-lookup"><span data-stu-id="9c816-546">It is recommended that the <xref:System.Activities.Statements.Interop> activity only be used when necessary.</span></span> <span data-ttu-id="9c816-547">有关迁移到 WF4 的详细信息，请查看 [WF4 迁移指南](migration-guidance.md)。</span><span class="sxs-lookup"><span data-stu-id="9c816-547">For more information about migrating to WF4 check out the [WF4 Migration Guidance](migration-guidance.md).</span></span>

### <a name="environment-setup"></a><span data-ttu-id="9c816-548">环境设置</span><span class="sxs-lookup"><span data-stu-id="9c816-548">Environment Setup</span></span>
 ![工作流性能测试的环境设置](./media/performance/performance-test-environment.gif)

### <a name="test-results"></a><span data-ttu-id="9c816-550">测试结果</span><span class="sxs-lookup"><span data-stu-id="9c816-550">Test Results</span></span>

<span data-ttu-id="9c816-551">下表显示了在不同配置中按顺序运行包含五个活动的工作流的结果。</span><span class="sxs-lookup"><span data-stu-id="9c816-551">The following table shows the results of running a workflow containing five activities in a sequence in various configurations.</span></span>

|<span data-ttu-id="9c816-552">测试</span><span class="sxs-lookup"><span data-stu-id="9c816-552">Test</span></span>|<span data-ttu-id="9c816-553">吞吐量（工作流/秒）</span><span class="sxs-lookup"><span data-stu-id="9c816-553">Throughput (workflows/sec)</span></span>|
|----------|-----------------------------------|
|<span data-ttu-id="9c816-554">WF3 运行时中的 WF3 序列</span><span class="sxs-lookup"><span data-stu-id="9c816-554">WF3 Sequence in WF3 runtime</span></span>|<span data-ttu-id="9c816-555">1,576</span><span class="sxs-lookup"><span data-stu-id="9c816-555">1,576</span></span>|
|<span data-ttu-id="9c816-556">使用 Interop 的 WF4 运行时中的 WF3 序列</span><span class="sxs-lookup"><span data-stu-id="9c816-556">WF3 Sequence in WF4 runtime using Interop</span></span>|<span data-ttu-id="9c816-557">2,745</span><span class="sxs-lookup"><span data-stu-id="9c816-557">2,745</span></span>|
|<span data-ttu-id="9c816-558">WF4 序列</span><span class="sxs-lookup"><span data-stu-id="9c816-558">WF4 Sequence</span></span>|<span data-ttu-id="9c816-559">153,582</span><span class="sxs-lookup"><span data-stu-id="9c816-559">153,582</span></span>|

 <span data-ttu-id="9c816-560">可以注意到，使用 Interop 与直接使用 WF3 相比有显著的性能提升。</span><span class="sxs-lookup"><span data-stu-id="9c816-560">There is a notable performance increase to using Interop over straight WF3.</span></span>  <span data-ttu-id="9c816-561">但是，与 WF4 活动比较后，增加则可以忽略不计。</span><span class="sxs-lookup"><span data-stu-id="9c816-561">However, when compared against WF4 activities, the increase is negligible.</span></span>

## <a name="summary"></a><span data-ttu-id="9c816-562">“摘要”</span><span class="sxs-lookup"><span data-stu-id="9c816-562">Summary</span></span>
 <span data-ttu-id="9c816-563">WF4 对性能的巨大投资在许多重要的方面得到了回报。</span><span class="sxs-lookup"><span data-stu-id="9c816-563">Heavy investments in performance for WF4 have paid off in many crucial areas.</span></span>  <span data-ttu-id="9c816-564">由于更接近 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 运行时，所以 WF4 中单个工作流组件性能在某些情况下能比 WF3 快数百倍。</span><span class="sxs-lookup"><span data-stu-id="9c816-564">Individual workflow component performance is in some cases hundreds of times faster in WF4 compared to WF3 due to a leaner [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime.</span></span>  <span data-ttu-id="9c816-565">延迟数字也得到显著改善。</span><span class="sxs-lookup"><span data-stu-id="9c816-565">Latency numbers are significantly better as well.</span></span>  <span data-ttu-id="9c816-566">这意味着，使用 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 而不是手动编码 WCF 业务流程服务的性能损失非常小，因为这样做的好处在于使用 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="9c816-566">This means the performance penalty for using [!INCLUDE[wf1](../../../includes/wf1-md.md)] as opposed to hand-coding WCF orchestration services is very small considering the added benefits of using [!INCLUDE[wf1](../../../includes/wf1-md.md)].</span></span>  <span data-ttu-id="9c816-567">暂留性能提高了 2.5 至 3.0 倍。</span><span class="sxs-lookup"><span data-stu-id="9c816-567">Persistence performance has increased by a factor of 2.5 - 3.0.</span></span>  <span data-ttu-id="9c816-568">采用工作流跟踪方式的运行状况监视目前的开销非常低。</span><span class="sxs-lookup"><span data-stu-id="9c816-568">Health monitoring by means of workflow tracking now has very little overhead.</span></span>  <span data-ttu-id="9c816-569">我们为那些考虑从 WF3 迁移到 WF4 的用户提供了一套全面的迁集指南。</span><span class="sxs-lookup"><span data-stu-id="9c816-569">A comprehensive set of migration guides are available for those that are considering moving from WF3 to WF4.</span></span>  <span data-ttu-id="9c816-570">所有这些使 WF4 成为您编写复杂应用程序的必备之选。</span><span class="sxs-lookup"><span data-stu-id="9c816-570">All of this should make WF4 an attractive option for writing complex applications.</span></span>
