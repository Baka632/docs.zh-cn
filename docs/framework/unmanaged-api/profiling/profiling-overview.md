---
title: 分析概述
ms.date: 03/30/2017
helpviewer_keywords:
- managed code, profiling API support
- unmanaged code, combining with managed code in profiling
- notification threads [.NET Framework profiling]
- unmanaged code, profiling
- profiling API [.NET Framework], and COM
- profiling API [.NET Framework], unmanaged code profiling
- profilers, writing
- profiling API [.NET Framework], call stacks
- code profilers, writing
- profiling API [.NET Framework], security considerations
- profiling API [.NET Framework], managed code support
- common language runtime, profiling
- profiling API [.NET Framework], notification threads
- call stacks [.NET Framework profiling]
- profiling API [.NET Framework], stack depth
- common language runtime, writing a profiler
- profiling API [.NET Framework], information retrieval interfaces
- shadow stacks [.NET Framework profiling]
- COM, using in the profiling API
- stack snapshots [.NET Framework profiling]
- profiling API [.NET Framework], supported features
- profiling API [.NET Framework], overview
- security, profiling API considerations
- stack depth [.NET Framework profiling]
ms.assetid: 864c2344-71dc-46f9-96b2-ed59fb6427a8
ms.openlocfilehash: cf29260c36437aaf679498f648d0fcac5d65f321
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/15/2020
ms.locfileid: "90558324"
---
# <a name="profiling-overview"></a><span data-ttu-id="f57a6-102">分析概述</span><span class="sxs-lookup"><span data-stu-id="f57a6-102">Profiling Overview</span></span>

<span data-ttu-id="f57a6-103">探查器是一种工具，可监视另一个应用程序的执行情况。</span><span class="sxs-lookup"><span data-stu-id="f57a6-103">A profiler is a tool that monitors the execution of another application.</span></span> <span data-ttu-id="f57a6-104">公共语言运行时 (CLR) 探查器是一个动态链接库 (DLL)，具有使用分析 API 从 CLR 中接收消息以及向 CLR 发送消息的功能。</span><span class="sxs-lookup"><span data-stu-id="f57a6-104">A common language runtime (CLR) profiler is a dynamic link library (DLL) that consists of functions that receive messages from, and send messages to, the CLR by using the profiling API.</span></span> <span data-ttu-id="f57a6-105">CLR 在运行时加载探查器 DLL。</span><span class="sxs-lookup"><span data-stu-id="f57a6-105">The profiler DLL is loaded by the CLR at run time.</span></span>

<span data-ttu-id="f57a6-106">传统的分析工具专注于测量应用程序的执行情况。</span><span class="sxs-lookup"><span data-stu-id="f57a6-106">Traditional profiling tools focus on measuring the execution of the application.</span></span> <span data-ttu-id="f57a6-107">即测量随着时间的推移应用程序使用每个功能或内存所花费的时间。</span><span class="sxs-lookup"><span data-stu-id="f57a6-107">That is, they measure the time that is spent in each function or the memory usage of the application over time.</span></span> <span data-ttu-id="f57a6-108">而分析 API 则针对更广泛的诊断工具，如代码覆盖率实用程序，甚至高级的调试辅助工具。</span><span class="sxs-lookup"><span data-stu-id="f57a6-108">The profiling API targets a broader class of diagnostic tools such as code-coverage utilities and even advanced debugging aids.</span></span> <span data-ttu-id="f57a6-109">实际上，它们全都用于诊断用途。</span><span class="sxs-lookup"><span data-stu-id="f57a6-109">These uses are all diagnostic in nature.</span></span> <span data-ttu-id="f57a6-110">分析 API 不仅测量而且还监视应用程序的执行情况。</span><span class="sxs-lookup"><span data-stu-id="f57a6-110">The profiling API not only measures but also monitors the execution of an application.</span></span> <span data-ttu-id="f57a6-111">基于此原因，应用程序本身始终不应使用分析 API 并且应用程序的执行情况不应依赖于探查器或受探查器影响。</span><span class="sxs-lookup"><span data-stu-id="f57a6-111">For this reason, the profiling API should never be used by the application itself, and the application’s execution should not depend on (or be affected by) the profiler.</span></span>

<span data-ttu-id="f57a6-112">与分析常规编译的机器代码相比，分析 CLR 应用程序需要更多支持。</span><span class="sxs-lookup"><span data-stu-id="f57a6-112">Profiling a CLR application requires more support than profiling conventionally compiled machine code.</span></span> <span data-ttu-id="f57a6-113">这是因为 CLR 引进了诸如应用程序域、垃圾回收、托管异常处理、实时 (JIT) 代码编译（将 Microsoft 中间语言、MSIL 或代码转换为本机代码）以及类似功能的概念。</span><span class="sxs-lookup"><span data-stu-id="f57a6-113">This is because the CLR introduces concepts such as application domains, garbage collection, managed exception handling, just-in-time (JIT) compilation of code (converting Microsoft intermediate language, or MSIL, code into native machine code), and similar features.</span></span> <span data-ttu-id="f57a6-114">常规的分析机制无法识别或提供关于这些功能的有用信息。</span><span class="sxs-lookup"><span data-stu-id="f57a6-114">Conventional profiling mechanisms cannot identify or provide useful information about these features.</span></span> <span data-ttu-id="f57a6-115">分析 API 则有效地提供缺少的信息，并对 CLR 和分析的应用程序的性能产生最小的影响。</span><span class="sxs-lookup"><span data-stu-id="f57a6-115">The profiling API provides this missing information efficiently, with minimal effect on the performance of the CLR and the profiled application.</span></span>

<span data-ttu-id="f57a6-116">运行时的 JIT 编译可以很好地进行分析。</span><span class="sxs-lookup"><span data-stu-id="f57a6-116">JIT compilation at run time provides good opportunities for profiling.</span></span> <span data-ttu-id="f57a6-117">分析 API 允许探查器在对某一例程进行 JIT 编译之前更改该例程的内存中 MSIL 代码流。</span><span class="sxs-lookup"><span data-stu-id="f57a6-117">The profiling API enables a profiler to change the in-memory MSIL code stream for a routine before it is JIT-compiled.</span></span> <span data-ttu-id="f57a6-118">探查器可以利用这种方式向需要深入调查的特定例程动态添加检测代码。</span><span class="sxs-lookup"><span data-stu-id="f57a6-118">In this manner, the profiler can dynamically add instrumentation code to particular routines that need deeper investigation.</span></span> <span data-ttu-id="f57a6-119">尽管此种方法在常规方案中可用，但是通过使用分析 API 可以更轻松地实现 CLR。</span><span class="sxs-lookup"><span data-stu-id="f57a6-119">Although this approach is possible in conventional scenarios, it is much easier to implement for the CLR by using the profiling API.</span></span>

## <a name="the-profiling-api"></a><span data-ttu-id="f57a6-120">分析 API</span><span class="sxs-lookup"><span data-stu-id="f57a6-120">The Profiling API</span></span>

<span data-ttu-id="f57a6-121">通常情况下，分析 API 用于编写 *代码探查器，代码探查器*是一种监视托管应用程序执行情况的程序。</span><span class="sxs-lookup"><span data-stu-id="f57a6-121">Typically, the profiling API is used to write a *code profiler*, which is a program that monitors the execution of a managed application.</span></span>

<span data-ttu-id="f57a6-122">分析 API 由探查器 DLL 使用，加载到与所分析应用程序相同的进程中。</span><span class="sxs-lookup"><span data-stu-id="f57a6-122">The profiling API is used by a profiler DLL, which is loaded into the same process as the application that is being profiled.</span></span> <span data-ttu-id="f57a6-123">探查器 DLL 实现 .NET Framework 版本1.0 和1.1，在版本2.0 和更高版本[) 中 (](icorprofilercallback2-interface.md) [ICorProfilerCallback](icorprofilercallback-interface.md)的回调接口。</span><span class="sxs-lookup"><span data-stu-id="f57a6-123">The profiler DLL implements a callback interface ([ICorProfilerCallback](icorprofilercallback-interface.md) in the .NET Framework version 1.0 and 1.1, [ICorProfilerCallback2](icorprofilercallback2-interface.md) in version 2.0 and later).</span></span> <span data-ttu-id="f57a6-124">CLR 调用该接口的方法，以通知探查器所分析进程中发生的事件。</span><span class="sxs-lookup"><span data-stu-id="f57a6-124">The CLR calls the methods in that interface to notify the profiler of events in the profiled process.</span></span> <span data-ttu-id="f57a6-125">探查器可以通过使用 [ICorProfilerInfo](icorprofilerinfo-interface.md) 和 [ICorProfilerInfo2](icorprofilerinfo2-interface.md) 接口中的方法返回到运行时，以获取有关所分析应用程序状态的信息。</span><span class="sxs-lookup"><span data-stu-id="f57a6-125">The profiler can call back into the runtime by using the methods in the [ICorProfilerInfo](icorprofilerinfo-interface.md) and [ICorProfilerInfo2](icorprofilerinfo2-interface.md) interfaces to obtain information about the state of the profiled application.</span></span>

> [!NOTE]
> <span data-ttu-id="f57a6-126">只有探查器解决方案的数据收集部分才能在与所分析应用程序相同的进程中运行。</span><span class="sxs-lookup"><span data-stu-id="f57a6-126">Only the data-gathering part of the profiler solution should be running in the same process as the profiled application.</span></span> <span data-ttu-id="f57a6-127">所有用户界面和数据分析都应在单独的进程中执行。</span><span class="sxs-lookup"><span data-stu-id="f57a6-127">All user interface and data analysis should be performed in a separate process.</span></span>

<span data-ttu-id="f57a6-128">下图显示探查器 DLL 如何与所分析应用程序和 CLR 交互。</span><span class="sxs-lookup"><span data-stu-id="f57a6-128">The following illustration shows how the profiler DLL interacts with the application that is being profiled and the CLR.</span></span>

![显示分析体系结构的屏幕截图。](./media/profiling-overview/profiling-architecture.png)

### <a name="the-notification-interfaces"></a><span data-ttu-id="f57a6-130">通知接口</span><span class="sxs-lookup"><span data-stu-id="f57a6-130">The Notification Interfaces</span></span>

<span data-ttu-id="f57a6-131">可以将[ICorProfilerCallback](icorprofilercallback-interface.md)和[ICorProfilerCallback2](icorprofilercallback2-interface.md)视为通知接口。</span><span class="sxs-lookup"><span data-stu-id="f57a6-131">[ICorProfilerCallback](icorprofilercallback-interface.md) and [ICorProfilerCallback2](icorprofilercallback2-interface.md) can be considered notification interfaces.</span></span> <span data-ttu-id="f57a6-132">这些接口包括 [ClassLoadStarted](icorprofilercallback-classloadstarted-method.md)、 [ClassLoadFinished](icorprofilercallback-classloadfinished-method.md)和 [JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md)等方法。</span><span class="sxs-lookup"><span data-stu-id="f57a6-132">These interfaces consist of methods such as [ClassLoadStarted](icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](icorprofilercallback-classloadfinished-method.md), and [JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md).</span></span> <span data-ttu-id="f57a6-133">每次 CLR 进行加载或卸载类、编译函数等操作时，都会调用探查器的 `ICorProfilerCallback` 或 `ICorProfilerCallback2` 接口中的相应方法。</span><span class="sxs-lookup"><span data-stu-id="f57a6-133">Each time the CLR loads or unloads a class, compiles a function, and so on, it calls the corresponding method in the profiler's `ICorProfilerCallback` or `ICorProfilerCallback2` interface.</span></span>

<span data-ttu-id="f57a6-134">例如，探查器可以通过两个通知函数（ [FunctionEnter2](functionenter2-function.md) 和 [FunctionLeave2](functionleave2-function.md)）来度量代码性能。</span><span class="sxs-lookup"><span data-stu-id="f57a6-134">For example, a profiler could measure code performance through two notification functions: [FunctionEnter2](functionenter2-function.md) and [FunctionLeave2](functionleave2-function.md).</span></span> <span data-ttu-id="f57a6-135">它会对每个通知添加时间戳、累积结果并输出一个列表指示在应用程序执行期间哪个函数占用的 CPU 最多或消耗的时钟时间最长。</span><span class="sxs-lookup"><span data-stu-id="f57a6-135">It just time-stamps each notification, accumulates results, and outputs a list that indicates which functions consumed the most CPU or wall-clock time during the execution of the application.</span></span>

### <a name="the-information-retrieval-interfaces"></a><span data-ttu-id="f57a6-136">信息检索接口</span><span class="sxs-lookup"><span data-stu-id="f57a6-136">The Information Retrieval Interfaces</span></span>

<span data-ttu-id="f57a6-137">分析中涉及的其他主要界面是 [ICorProfilerInfo](icorprofilerinfo-interface.md) 和 [ICorProfilerInfo2](icorprofilerinfo2-interface.md)。</span><span class="sxs-lookup"><span data-stu-id="f57a6-137">The other main interfaces involved in profiling are [ICorProfilerInfo](icorprofilerinfo-interface.md) and [ICorProfilerInfo2](icorprofilerinfo2-interface.md).</span></span> <span data-ttu-id="f57a6-138">探查器根据需要调用这些接口，以获取更多的信息来帮助进行分析。</span><span class="sxs-lookup"><span data-stu-id="f57a6-138">The profiler calls these interfaces as required to obtain more information to help its analysis.</span></span> <span data-ttu-id="f57a6-139">例如，每当 CLR 调用 [FunctionEnter2](functionenter2-function.md) 函数时，它都会提供函数标识符。</span><span class="sxs-lookup"><span data-stu-id="f57a6-139">For example, whenever the CLR calls the [FunctionEnter2](functionenter2-function.md) function, it supplies a function identifier.</span></span> <span data-ttu-id="f57a6-140">探查器可以通过调用 [ICorProfilerInfo2：： GetFunctionInfo2](icorprofilerinfo2-getfunctioninfo2-method.md) 方法来获取有关该函数的详细信息，以发现该函数的父类、名称，等等。</span><span class="sxs-lookup"><span data-stu-id="f57a6-140">The profiler can get more information about that function by calling the [ICorProfilerInfo2::GetFunctionInfo2](icorprofilerinfo2-getfunctioninfo2-method.md) method to discover the function's parent class, its name, and so on.</span></span>

## <a name="supported-features"></a><span data-ttu-id="f57a6-141">支持的功能</span><span class="sxs-lookup"><span data-stu-id="f57a6-141">Supported Features</span></span>

<span data-ttu-id="f57a6-142">分析 API 提供公共语言运行时中发生的各种事件和操作的相关信息。</span><span class="sxs-lookup"><span data-stu-id="f57a6-142">The profiling API provides information about a variety of events and actions that occur in the common language runtime.</span></span> <span data-ttu-id="f57a6-143">你可以使用此信息来监视进程的内部工作情况，也可分析 .NET Framework 应用程序的性能。</span><span class="sxs-lookup"><span data-stu-id="f57a6-143">You can use this information to monitor the inner workings of processes and to analyze the performance of your .NET Framework application.</span></span>

<span data-ttu-id="f57a6-144">分析 API 检索 CLR 中发生的以下操作和事件的相关信息：</span><span class="sxs-lookup"><span data-stu-id="f57a6-144">The profiling API retrieves information about the following actions and events that occur in the CLR:</span></span>

- <span data-ttu-id="f57a6-145">CLR 启动和关闭事件。</span><span class="sxs-lookup"><span data-stu-id="f57a6-145">CLR startup and shutdown events.</span></span>

- <span data-ttu-id="f57a6-146">应用程序域创建和关闭事件。</span><span class="sxs-lookup"><span data-stu-id="f57a6-146">Application domain creation and shutdown events.</span></span>

- <span data-ttu-id="f57a6-147">程序集加载和卸载事件。</span><span class="sxs-lookup"><span data-stu-id="f57a6-147">Assembly loading and unloading events.</span></span>

- <span data-ttu-id="f57a6-148">模块加载和卸载事件。</span><span class="sxs-lookup"><span data-stu-id="f57a6-148">Module loading and unloading events.</span></span>

- <span data-ttu-id="f57a6-149">COM vtable 创建和析构事件。</span><span class="sxs-lookup"><span data-stu-id="f57a6-149">COM vtable creation and destruction events.</span></span>

- <span data-ttu-id="f57a6-150">实时 (JIT) 编译和代码间距调整事件。</span><span class="sxs-lookup"><span data-stu-id="f57a6-150">Just-in-time (JIT) compilation and code-pitching events.</span></span>

- <span data-ttu-id="f57a6-151">类加载和卸载事件。</span><span class="sxs-lookup"><span data-stu-id="f57a6-151">Class loading and unloading events.</span></span>

- <span data-ttu-id="f57a6-152">线程创建和析构事件。</span><span class="sxs-lookup"><span data-stu-id="f57a6-152">Thread creation and destruction events.</span></span>

- <span data-ttu-id="f57a6-153">函数入口和退出事件。</span><span class="sxs-lookup"><span data-stu-id="f57a6-153">Function entry and exit events.</span></span>

- <span data-ttu-id="f57a6-154">异常。</span><span class="sxs-lookup"><span data-stu-id="f57a6-154">Exceptions.</span></span>

- <span data-ttu-id="f57a6-155">托管和非托管代码执行之间的转换。</span><span class="sxs-lookup"><span data-stu-id="f57a6-155">Transitions between managed and unmanaged code execution.</span></span>

- <span data-ttu-id="f57a6-156">不同运行时上下文之间的转换。</span><span class="sxs-lookup"><span data-stu-id="f57a6-156">Transitions between different runtime contexts.</span></span>

- <span data-ttu-id="f57a6-157">有关运行时挂起的信息。</span><span class="sxs-lookup"><span data-stu-id="f57a6-157">Information about runtime suspensions.</span></span>

- <span data-ttu-id="f57a6-158">有关运行时内存堆和垃圾回收活动的信息。</span><span class="sxs-lookup"><span data-stu-id="f57a6-158">Information about the runtime memory heap and garbage collection activity.</span></span>

<span data-ttu-id="f57a6-159">分析 API 可从任何（非托管）COM 兼容语言调用。</span><span class="sxs-lookup"><span data-stu-id="f57a6-159">The profiling API can be called from any (non-managed) COM-compatible language.</span></span>

<span data-ttu-id="f57a6-160">API 可高效减少 CPU 和内存占用。</span><span class="sxs-lookup"><span data-stu-id="f57a6-160">The API is efficient with regard to CPU and memory consumption.</span></span> <span data-ttu-id="f57a6-161">分析不包括对所分析应用程序进行足以导致误导性结果的更改。</span><span class="sxs-lookup"><span data-stu-id="f57a6-161">Profiling does not involve changes to the profiled application that are significant enough to cause misleading results.</span></span>

<span data-ttu-id="f57a6-162">分析 API 有益于采样和非采样探查器。</span><span class="sxs-lookup"><span data-stu-id="f57a6-162">The profiling API is useful to both sampling and non-sampling profilers.</span></span> <span data-ttu-id="f57a6-163">*采样探查器*定期检查配置文件，如5毫秒。</span><span class="sxs-lookup"><span data-stu-id="f57a6-163">A *sampling profiler* inspects the profile at regular clock ticks, say, at 5 milliseconds apart.</span></span> <span data-ttu-id="f57a6-164">*非采样探查器*与导致事件的线程同步通知事件。</span><span class="sxs-lookup"><span data-stu-id="f57a6-164">A *non-sampling profiler* is informed of an event synchronously with the thread that causes the event.</span></span>

### <a name="unsupported-functionality"></a><span data-ttu-id="f57a6-165">不支持的功能</span><span class="sxs-lookup"><span data-stu-id="f57a6-165">Unsupported Functionality</span></span>

<span data-ttu-id="f57a6-166">分析 API 不支持以下功能：</span><span class="sxs-lookup"><span data-stu-id="f57a6-166">The profiling API does not support the following functionality:</span></span>

- <span data-ttu-id="f57a6-167">非托管代码，此类代码必须使用常规 Win32 方法进行分析。</span><span class="sxs-lookup"><span data-stu-id="f57a6-167">Unmanaged code, which must be profiled using conventional Win32 methods.</span></span> <span data-ttu-id="f57a6-168">然而，CLR 探查器包括过渡事件，以确定托管与非托管代码之间的边界。</span><span class="sxs-lookup"><span data-stu-id="f57a6-168">However, the CLR profiler includes transition events to determine the boundaries between managed and unmanaged code.</span></span>

- <span data-ttu-id="f57a6-169">自修改应用程序，即出于某种目的（如面向方面的编程）修改自己的代码。</span><span class="sxs-lookup"><span data-stu-id="f57a6-169">Self-modifying applications that modify their own code for purposes such as aspect-oriented programming.</span></span>

- <span data-ttu-id="f57a6-170">边界检查，原因是分析 API 不提供此信息。</span><span class="sxs-lookup"><span data-stu-id="f57a6-170">Bounds checking, because the profiling API does not provide this information.</span></span> <span data-ttu-id="f57a6-171">CLR 为所有托管代码的边界检查提供内部支持。</span><span class="sxs-lookup"><span data-stu-id="f57a6-171">The CLR provides intrinsic support for bounds checking of all managed code.</span></span>

- <span data-ttu-id="f57a6-172">远程分析，在以下情况不受支持：</span><span class="sxs-lookup"><span data-stu-id="f57a6-172">Remote profiling, which is not supported for the following reasons:</span></span>

  - <span data-ttu-id="f57a6-173">远程分析延长执行时间。</span><span class="sxs-lookup"><span data-stu-id="f57a6-173">Remote profiling extends execution time.</span></span> <span data-ttu-id="f57a6-174">当使用分析接口时，必须最大限度地缩短执行时间，确保分析结果不会受到不良影响。</span><span class="sxs-lookup"><span data-stu-id="f57a6-174">When you use the profiling interfaces, you must minimize execution time so that profiling results will not be unduly affected.</span></span> <span data-ttu-id="f57a6-175">在执行性能受到监视时尤为如此。</span><span class="sxs-lookup"><span data-stu-id="f57a6-175">This is especially true when execution performance is being monitored.</span></span> <span data-ttu-id="f57a6-176">然而，当分析接口用于监视内存使用情况或用于获取有关堆栈帧、对象等的运行时信息时，远程分析并不是一个限制。</span><span class="sxs-lookup"><span data-stu-id="f57a6-176">However, remote profiling is not a limitation when the profiling interfaces are used to monitor memory usage or to obtain run-time information about stack frames, objects, and so on.</span></span>

  - <span data-ttu-id="f57a6-177">CLR 代码探查器必须向运行所分析应用程序的本地计算机上的运行时注册一个或多个回调接口。</span><span class="sxs-lookup"><span data-stu-id="f57a6-177">The CLR code profiler must register one or more callback interfaces with the runtime on the local computer on which the profiled application is running.</span></span> <span data-ttu-id="f57a6-178">这便限制了创建远程代码探查器的功能。</span><span class="sxs-lookup"><span data-stu-id="f57a6-178">This limits the ability to create a remote code profiler.</span></span>

## <a name="notification-threads"></a><span data-ttu-id="f57a6-179">通知线程</span><span class="sxs-lookup"><span data-stu-id="f57a6-179">Notification Threads</span></span>

<span data-ttu-id="f57a6-180">在大多数情况下，生成事件的线程也会执行通知。</span><span class="sxs-lookup"><span data-stu-id="f57a6-180">In most cases, the thread that generates an event also executes notifications.</span></span> <span data-ttu-id="f57a6-181">此类通知 (例如， [FunctionEnter](functionenter-function.md) 和 [FunctionLeave](functionleave-function.md)) 无需提供显式 `ThreadID` 。</span><span class="sxs-lookup"><span data-stu-id="f57a6-181">Such notifications (for example, [FunctionEnter](functionenter-function.md) and [FunctionLeave](functionleave-function.md)) do not need to supply the explicit `ThreadID`.</span></span> <span data-ttu-id="f57a6-182">此外，探查器还可能决定使用线程本地存储来存储和更新其分析块，而不是基于受影响线程的 `ThreadID` 对全局存储中的分析块建立索引。</span><span class="sxs-lookup"><span data-stu-id="f57a6-182">Also, the profiler might decide to use thread-local storage to store and update its analysis blocks instead of indexing the analysis blocks in global storage, based on the `ThreadID` of the affected thread.</span></span>

<span data-ttu-id="f57a6-183">注意，这些回调未经过序列化。</span><span class="sxs-lookup"><span data-stu-id="f57a6-183">Note that these callbacks are not serialized.</span></span> <span data-ttu-id="f57a6-184">用户必须通过创建线程安全数据结构并在必要时锁定探查器代码以防止从多个线程并行访问的方式保护代码。</span><span class="sxs-lookup"><span data-stu-id="f57a6-184">Users must protect their code by creating thread-safe data structures and by locking the profiler code where necessary to prevent parallel access from multiple threads.</span></span> <span data-ttu-id="f57a6-185">因此，在某些情况下，会收到不正常的回调序列。</span><span class="sxs-lookup"><span data-stu-id="f57a6-185">Therefore, in certain cases you can receive an unusual sequence of callbacks.</span></span> <span data-ttu-id="f57a6-186">例如，假设托管应用程序正在生成执行相同代码的两个线程。</span><span class="sxs-lookup"><span data-stu-id="f57a6-186">For example, assume that a managed application is spawning two threads that are executing identical code.</span></span> <span data-ttu-id="f57a6-187">在这种情况下，在[ICorProfilerCallback::JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md) `FunctionEnter` 接收[ICorProfilerCallback：： JITCompilationFinished](icorprofilercallback-jitcompilationfinished-method.md)回调之前，可以从一个线程接收某个函数的 ICorProfilerCallback：： JITCompilationStarted 事件，并从另一个线程接收回调。</span><span class="sxs-lookup"><span data-stu-id="f57a6-187">In this case, it is possible to receive a [ICorProfilerCallback::JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md) event for some function from one thread and a `FunctionEnter` callback from the other thread before receiving the [ICorProfilerCallback::JITCompilationFinished](icorprofilercallback-jitcompilationfinished-method.md) callback.</span></span> <span data-ttu-id="f57a6-188">在这种情况下，用户将收到可能尚未完全实时 (JIT) 编译的函数的 `FunctionEnter` 回调。</span><span class="sxs-lookup"><span data-stu-id="f57a6-188">In this case, the user will receive a `FunctionEnter` callback for a function that may not have been fully just-in-time (JIT) compiled yet.</span></span>

## <a name="security"></a><span data-ttu-id="f57a6-189">安全性</span><span class="sxs-lookup"><span data-stu-id="f57a6-189">Security</span></span>

<span data-ttu-id="f57a6-190">探查器 DLL 是作为公共语言运行时执行引擎的一部分运行的非托管 DLL。</span><span class="sxs-lookup"><span data-stu-id="f57a6-190">A profiler DLL is an unmanaged DLL that runs as part of the common language runtime execution engine.</span></span> <span data-ttu-id="f57a6-191">因此，探查器 DLL 中的代码并不受到托管代码访问安全性的约束。</span><span class="sxs-lookup"><span data-stu-id="f57a6-191">As a result, the code in the profiler DLL is not subject to the restrictions of managed code access security.</span></span> <span data-ttu-id="f57a6-192">探查器 DLL 的唯一限制是操作系统强加在运行所分析应用程序的用户身上的限制。</span><span class="sxs-lookup"><span data-stu-id="f57a6-192">The only limitations on the profiler DLL are those imposed by the operating system on the user who is running the profiled application.</span></span>

<span data-ttu-id="f57a6-193">探查器作者应采取适当的预防措施以避免安全相关问题。</span><span class="sxs-lookup"><span data-stu-id="f57a6-193">Profiler authors should take appropriate precautions to avoid security-related issues.</span></span> <span data-ttu-id="f57a6-194">例如，在安装期间，应将探查器 DLL 添加到访问控制列表 (ACL)，以确保恶意用户无法对其进行修改。</span><span class="sxs-lookup"><span data-stu-id="f57a6-194">For example, during installation, a profiler DLL should be added to an access control list (ACL) so that a malicious user cannot modify it.</span></span>

## <a name="combining-managed-and-unmanaged-code-in-a-code-profiler"></a><span data-ttu-id="f57a6-195">在代码探查器中组合托管和非托管代码</span><span class="sxs-lookup"><span data-stu-id="f57a6-195">Combining Managed and Unmanaged Code in a Code Profiler</span></span>

<span data-ttu-id="f57a6-196">编写错误的探查器可能会引起自身的循环引用，从而导致不可预知的行为。</span><span class="sxs-lookup"><span data-stu-id="f57a6-196">An incorrectly written profiler can cause circular references to itself, resulting in unpredictable behavior.</span></span>

<span data-ttu-id="f57a6-197">审查 CLR 分析 API 可能会形成这样的印象：可以编写包含托管和非托管组件的探查器，在探查器中这些组件通过 COM 互操作或间接调用相互调用。</span><span class="sxs-lookup"><span data-stu-id="f57a6-197">A review of the CLR profiling API may create the impression that you can write a profiler that contains managed and unmanaged components that call each other through COM interop or indirect calls.</span></span>

<span data-ttu-id="f57a6-198">虽然从设计角度而言这是可行的，但分析 API 并不支持托管组件。</span><span class="sxs-lookup"><span data-stu-id="f57a6-198">Although this is possible from a design perspective, the profiling API does not support managed components.</span></span> <span data-ttu-id="f57a6-199">CLR 探查器必须完全处于非托管状态。</span><span class="sxs-lookup"><span data-stu-id="f57a6-199">A CLR profiler must be completely unmanaged.</span></span> <span data-ttu-id="f57a6-200">尝试在 CLR 探查器中组合托管和非托管代码可能会导致访问冲突、程序故障或死锁。</span><span class="sxs-lookup"><span data-stu-id="f57a6-200">Attempts to combine managed and unmanaged code in a CLR profiler may cause access violations, program failure, or deadlocks.</span></span> <span data-ttu-id="f57a6-201">探查器的托管组件将激发事件返回其非托管组件，随后将再次调用托管组件，从而导致循环引用。</span><span class="sxs-lookup"><span data-stu-id="f57a6-201">The managed components of the profiler will fire events back to their unmanaged components, which would subsequently call the managed components again, resulting in circular references.</span></span>

<span data-ttu-id="f57a6-202">CLR 探查器可以安全调用托管代码的唯一位置是方法的 Microsoft 中间语言 (MSIL) 体。</span><span class="sxs-lookup"><span data-stu-id="f57a6-202">The only location where a CLR profiler can call managed code safely is in the Microsoft intermediate language (MSIL) body of a method.</span></span> <span data-ttu-id="f57a6-203">修改 MSIL 体的建议做法是在 [ICorProfilerCallback4](icorprofilercallback4-interface.md) 接口中使用 JIT 重新编译方法。</span><span class="sxs-lookup"><span data-stu-id="f57a6-203">The recommended practice for modifying the MSIL body is to use the  JIT recompilation methods in the [ICorProfilerCallback4](icorprofilercallback4-interface.md) interface.</span></span>

<span data-ttu-id="f57a6-204">还可以使用较早的检测方法修改 MSIL。</span><span class="sxs-lookup"><span data-stu-id="f57a6-204">It is also possible to use the older instrumentation methods to modify MSIL.</span></span> <span data-ttu-id="f57a6-205">在实时 (JIT) 完成函数的编译之前，探查器可以在方法的 MSIL 体中插入托管调用，然后对其进行 JIT 编译， (参见 [ICorProfilerInfo：： GetILFunctionBody](icorprofilerinfo-getilfunctionbody-method.md) 方法) 。</span><span class="sxs-lookup"><span data-stu-id="f57a6-205">Before the just-in-time (JIT) compilation of a function is completed, the profiler can insert managed calls in the MSIL body of a method and then JIT-compile it (see the [ICorProfilerInfo::GetILFunctionBody](icorprofilerinfo-getilfunctionbody-method.md) method).</span></span> <span data-ttu-id="f57a6-206">这种技术可成功用于托管代码的选择性检测，也可用于收集有关 JIT 的统计信息和性能数据。</span><span class="sxs-lookup"><span data-stu-id="f57a6-206">This technique can successfully be used for selective instrumentation of managed code, or to gather statistics and performance data about the JIT.</span></span>

<span data-ttu-id="f57a6-207">代码探查器也可以在调用到非托管代码的每个托管函数的 MSIL 体中插入本机挂钩。</span><span class="sxs-lookup"><span data-stu-id="f57a6-207">Alternatively, a code profiler can insert native hooks in the MSIL body of every managed function that calls into unmanaged code.</span></span> <span data-ttu-id="f57a6-208">这种技术可用于检测和覆盖。</span><span class="sxs-lookup"><span data-stu-id="f57a6-208">This technique can be used for instrumentation and coverage.</span></span> <span data-ttu-id="f57a6-209">例如，代码探查器可以在每个 MSIL 块后插入检测挂钩，以确保该块已执行。</span><span class="sxs-lookup"><span data-stu-id="f57a6-209">For example, a code profiler could insert instrumentation hooks after every MSIL block to ensure that the block has been executed.</span></span> <span data-ttu-id="f57a6-210">修改方法的 MSIL 体是一项非常细致的操作，因此必须将许多因素考虑在内。</span><span class="sxs-lookup"><span data-stu-id="f57a6-210">The modification of the MSIL body of a method is a very delicate operation, and there are many factors that should be taken into consideration.</span></span>

## <a name="profiling-unmanaged-code"></a><span data-ttu-id="f57a6-211">分析非托管代码</span><span class="sxs-lookup"><span data-stu-id="f57a6-211">Profiling Unmanaged Code</span></span>

<span data-ttu-id="f57a6-212">公共语言运行时 (CLR) 分析 API 为分析非托管代码提供最低支持。</span><span class="sxs-lookup"><span data-stu-id="f57a6-212">The common language runtime (CLR) profiling API provides minimal support for profiling unmanaged code.</span></span> <span data-ttu-id="f57a6-213">它具有以下功能：</span><span class="sxs-lookup"><span data-stu-id="f57a6-213">The following functionality is provided:</span></span>

- <span data-ttu-id="f57a6-214">堆栈链的枚举。</span><span class="sxs-lookup"><span data-stu-id="f57a6-214">Enumeration of stack chains.</span></span> <span data-ttu-id="f57a6-215">借助此功能，代码探查器能够确定托管代码与非托管代码之间的边界。</span><span class="sxs-lookup"><span data-stu-id="f57a6-215">This feature enables a code profiler to determine the boundary between managed code and unmanaged code.</span></span>

- <span data-ttu-id="f57a6-216">确定堆栈链是否与托管代码或本机代码对应。</span><span class="sxs-lookup"><span data-stu-id="f57a6-216">Determination whether a stack chain corresponds to managed code or native code.</span></span>

<span data-ttu-id="f57a6-217">在 .NET Framework 1.0 和 1.1 版中，可通过 CLR 调试 API 的进程内子集使用这些方法。</span><span class="sxs-lookup"><span data-stu-id="f57a6-217">In the .NET Framework versions 1.0 and 1.1, these methods are available through the in-process subset of the CLR debugging API.</span></span> <span data-ttu-id="f57a6-218">它们在 CorDebug.idl 文件中定义。</span><span class="sxs-lookup"><span data-stu-id="f57a6-218">They are defined in the CorDebug.idl file.</span></span>

<span data-ttu-id="f57a6-219">在 .NET Framework 2.0 及更高版本中，可以使用 [ICorProfilerInfo2：:D ostacksnapshot](icorprofilerinfo2-dostacksnapshot-method.md) 方法来实现此功能。</span><span class="sxs-lookup"><span data-stu-id="f57a6-219">In the .NET Framework 2.0 and later, you can use the [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) method for this functionality.</span></span>

## <a name="using-com"></a><span data-ttu-id="f57a6-220">使用 COM</span><span class="sxs-lookup"><span data-stu-id="f57a6-220">Using COM</span></span>

<span data-ttu-id="f57a6-221">尽管将分析接口定义为 COM 接口，但公共语言运行时 (CLR) 并不会实际初始化 COM 以使用这些接口。</span><span class="sxs-lookup"><span data-stu-id="f57a6-221">Although the profiling interfaces are defined as COM interfaces, the common language runtime (CLR) does not actually initialize COM to use these interfaces.</span></span> <span data-ttu-id="f57a6-222">原因是为了避免在托管应用程序有机会指定其所需的线程模型之前，必须使用 [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) 函数设置线程模型。</span><span class="sxs-lookup"><span data-stu-id="f57a6-222">The reason is to avoid having to set the threading model by using the [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) function before the managed application has had a chance to specify its desired threading model.</span></span> <span data-ttu-id="f57a6-223">同样，探查器本身不应调用 `CoInitialize`，因为它可能会选取与所分析应用程序不兼容的线程模型，并可能会导致应用程序失败。</span><span class="sxs-lookup"><span data-stu-id="f57a6-223">Similarly, the profiler itself should not call `CoInitialize`, because it may pick a threading model that is incompatible with the application being profiled and may cause the application to fail.</span></span>

## <a name="call-stacks"></a><span data-ttu-id="f57a6-224">调用堆栈</span><span class="sxs-lookup"><span data-stu-id="f57a6-224">Call Stacks</span></span>

<span data-ttu-id="f57a6-225">分析 API 提供两种方法来获取调用堆栈：堆栈快照方法和阴影堆栈方法，前者以分散方式收集调用堆栈，后者时刻跟踪调用堆栈。</span><span class="sxs-lookup"><span data-stu-id="f57a6-225">The profiling API provides two ways to obtain call stacks: a stack snapshot method, which enables sparse gathering of call stacks, and a shadow stack method, which tracks the call stack at every instant.</span></span>

### <a name="stack-snapshot"></a><span data-ttu-id="f57a6-226">堆栈快照</span><span class="sxs-lookup"><span data-stu-id="f57a6-226">Stack Snapshot</span></span>

<span data-ttu-id="f57a6-227">堆栈快照是线程堆栈在某一时刻的跟踪。</span><span class="sxs-lookup"><span data-stu-id="f57a6-227">A stack snapshot is a trace of the stack of a thread at an instant in time.</span></span> <span data-ttu-id="f57a6-228">分析 API 支持在堆栈上跟踪托管函数，但它会将跟踪非托管函数的工作交给探查器自己的堆栈审核器来完成。</span><span class="sxs-lookup"><span data-stu-id="f57a6-228">The profiling API supports the tracing of managed functions on the stack, but it leaves the tracing of unmanaged functions to the profiler's own stack walker.</span></span>

<span data-ttu-id="f57a6-229">有关如何对探查器进行编程以遍历托管堆栈的详细信息，请参阅本文档集中的 [ICorProfilerInfo2：:D ostacksnapshot](icorprofilerinfo2-dostacksnapshot-method.md) 方法和 [探查器堆栈遍历 .NET Framework 2.0：基础和更](/previous-versions/dotnet/articles/bb264782(v=msdn.10))高版本。</span><span class="sxs-lookup"><span data-stu-id="f57a6-229">For more information about how to program the profiler to walk managed stacks, see the [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) method in this documentation set, and [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span></span>

### <a name="shadow-stack"></a><span data-ttu-id="f57a6-230">阴影堆栈</span><span class="sxs-lookup"><span data-stu-id="f57a6-230">Shadow Stack</span></span>

<span data-ttu-id="f57a6-231">过度频繁使用快照方法很快就会产生性能问题。</span><span class="sxs-lookup"><span data-stu-id="f57a6-231">Using the snapshot method too frequently can quickly create a performance issue.</span></span> <span data-ttu-id="f57a6-232">如果希望频繁地使用堆栈跟踪，探查器应改为通过使用 [FunctionEnter2](functionenter2-function.md)、 [FunctionLeave2](functionleave2-function.md)、 [FunctionTailcall2](functiontailcall2-function.md)和 [ICorProfilerCallback2](icorprofilercallback2-interface.md) 异常回调来生成阴影堆栈。</span><span class="sxs-lookup"><span data-stu-id="f57a6-232">If you want to take stack traces frequently, your profiler should instead build a shadow stack by using the [FunctionEnter2](functionenter2-function.md), [FunctionLeave2](functionleave2-function.md), [FunctionTailcall2](functiontailcall2-function.md), and [ICorProfilerCallback2](icorprofilercallback2-interface.md) exception callbacks.</span></span> <span data-ttu-id="f57a6-233">阴影堆栈始终是最新的，并且在需要堆栈快照时可以快速复制到存储区。</span><span class="sxs-lookup"><span data-stu-id="f57a6-233">The shadow stack is always current and can quickly be copied to storage whenever a stack snapshot is needed.</span></span>

<span data-ttu-id="f57a6-234">阴影堆栈可以获取函数自变量、返回值和有关泛型实例化的信息。</span><span class="sxs-lookup"><span data-stu-id="f57a6-234">A shadow stack may obtain function arguments, return values, and information about generic instantiations.</span></span> <span data-ttu-id="f57a6-235">泛型实例化信息只能通过阴影堆栈获取，并可能在将控件传递到函数时获取。</span><span class="sxs-lookup"><span data-stu-id="f57a6-235">This information is available only through the shadow stack and may be obtained when control is handed to a function.</span></span> <span data-ttu-id="f57a6-236">然而，后续运行此函数时，此信息可能不可用。</span><span class="sxs-lookup"><span data-stu-id="f57a6-236">However, this information may not be available later during the run of the function.</span></span>

## <a name="callbacks-and-stack-depth"></a><span data-ttu-id="f57a6-237">回调和堆栈深度</span><span class="sxs-lookup"><span data-stu-id="f57a6-237">Callbacks and Stack Depth</span></span>

<span data-ttu-id="f57a6-238">在堆栈受到严重限制的情况下，可能会引发探查器回调；并且探查器回调中的堆栈溢出将导致进程立即退出。</span><span class="sxs-lookup"><span data-stu-id="f57a6-238">Profiler callbacks may be issued in very stack-constrained circumstances, and a stack overflow in a profiler callback will lead to an immediate process exit.</span></span> <span data-ttu-id="f57a6-239">探查器应确保尽可能少使用堆栈来响应回调。</span><span class="sxs-lookup"><span data-stu-id="f57a6-239">A profiler should make sure to use as little stack as possible in response to callbacks.</span></span> <span data-ttu-id="f57a6-240">如果希望将探查器用于抑制堆栈溢出的可靠进程中，那么探查器本身也应避免触发堆栈溢出。</span><span class="sxs-lookup"><span data-stu-id="f57a6-240">If the profiler is intended for use against processes that are robust against stack overflow, the profiler itself should also avoid triggering stack overflow.</span></span>

## <a name="related-topics"></a><span data-ttu-id="f57a6-241">相关主题</span><span class="sxs-lookup"><span data-stu-id="f57a6-241">Related Topics</span></span>

|<span data-ttu-id="f57a6-242">Title</span><span class="sxs-lookup"><span data-stu-id="f57a6-242">Title</span></span>|<span data-ttu-id="f57a6-243">说明</span><span class="sxs-lookup"><span data-stu-id="f57a6-243">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="f57a6-244">设置分析环境</span><span class="sxs-lookup"><span data-stu-id="f57a6-244">Setting Up a Profiling Environment</span></span>](setting-up-a-profiling-environment.md)|<span data-ttu-id="f57a6-245">说明如何初始化探查器、设置事件通知和分析 Windows 服务。</span><span class="sxs-lookup"><span data-stu-id="f57a6-245">Explains how to initialize a profiler, set event notifications, and profile a Windows Service.</span></span>|
|[<span data-ttu-id="f57a6-246">分析接口</span><span class="sxs-lookup"><span data-stu-id="f57a6-246">Profiling Interfaces</span></span>](profiling-interfaces.md)|<span data-ttu-id="f57a6-247">描述分析 API 使用的非托管接口。</span><span class="sxs-lookup"><span data-stu-id="f57a6-247">Describes the unmanaged interfaces that the profiling API uses.</span></span>|
|[<span data-ttu-id="f57a6-248">分析全局静态函数</span><span class="sxs-lookup"><span data-stu-id="f57a6-248">Profiling Global Static Functions</span></span>](profiling-global-static-functions.md)|<span data-ttu-id="f57a6-249">描述分析 API 使用的非托管全局静态函数。</span><span class="sxs-lookup"><span data-stu-id="f57a6-249">Describes the unmanaged global static functions that the profiling API uses.</span></span>|
|[<span data-ttu-id="f57a6-250">分析枚举</span><span class="sxs-lookup"><span data-stu-id="f57a6-250">Profiling Enumerations</span></span>](profiling-enumerations.md)|<span data-ttu-id="f57a6-251">描述分析 API 使用的非托管枚举。</span><span class="sxs-lookup"><span data-stu-id="f57a6-251">Describes the unmanaged enumerations that the profiling API uses.</span></span>|
|[<span data-ttu-id="f57a6-252">分析结构</span><span class="sxs-lookup"><span data-stu-id="f57a6-252">Profiling Structures</span></span>](profiling-structures.md)|<span data-ttu-id="f57a6-253">描述分析 API 使用的非托管结构。</span><span class="sxs-lookup"><span data-stu-id="f57a6-253">Describes the unmanaged structures that the profiling API uses.</span></span>|
