---
title: 有关使用 .NET 中字符串的最佳做法
description: 了解如何在 .NET 应用程序中有效地使用字符串。
ms.date: 05/01/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- strings [.NET],searching
- best practices,string comparison and sorting
- strings [.NET],best practices
- strings [.NET],basic string operations
- sorting strings
- strings [.NET],sorting
- string comparison [.NET],best practices
- string sorting
- comparing strings
- strings [.NET],comparing
ms.assetid: b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7
ms.openlocfilehash: ed85d04ffbee0493745c4a5ef63313571b44628b
ms.sourcegitcommit: 4a938327bad8b2e20cabd0f46a9dc50882596f13
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/28/2020
ms.locfileid: "92889096"
---
# <a name="best-practices-for-using-strings-in-net"></a><span data-ttu-id="99149-103">有关使用 .NET 中字符串的最佳做法</span><span class="sxs-lookup"><span data-stu-id="99149-103">Best Practices for Using Strings in .NET</span></span>

<span data-ttu-id="99149-104">.NET 为开发本地化和全球化应用程序提供广泛支持，在执行排序和显示字符串等常见操作时，轻松应用当前区域性或特定区域性的约定。</span><span class="sxs-lookup"><span data-stu-id="99149-104">.NET provides extensive support for developing localized and globalized applications, and makes it easy to apply the conventions of either the current culture or a specific culture when performing common operations such as sorting and displaying strings.</span></span> <span data-ttu-id="99149-105">但排序或比较字符串并不总是区分区域性的操作。</span><span class="sxs-lookup"><span data-stu-id="99149-105">But sorting or comparing strings is not always a culture-sensitive operation.</span></span> <span data-ttu-id="99149-106">例如，对于应用程序内部使用的字符串，通常应该跨所有区域性以相同的方式对其进行处理。</span><span class="sxs-lookup"><span data-stu-id="99149-106">For example, strings that are used internally by an application typically should be handled identically across all cultures.</span></span> <span data-ttu-id="99149-107">如果将 XML 标记、HTML 标记、用户名、文件路径和系统对象名称等与区域性无关的字符串数据解释为区分区域性，则应用程序代码会遭遇细微的错误、不佳的性能，在某些情况下，还会遭遇安全性问题。</span><span class="sxs-lookup"><span data-stu-id="99149-107">When culturally independent string data, such as XML tags, HTML tags, user names, file paths, and the names of system objects, are interpreted as if they were culture-sensitive, application code can be subject to subtle bugs, poor performance, and, in some cases, security issues.</span></span>

<span data-ttu-id="99149-108">本主题介绍了 .NET 中的字符串排序、比较和大小写转换方法，提出了有关如何选择适当的字符串处理方法的建议，以及有关字符串处理方法的其他信息。</span><span class="sxs-lookup"><span data-stu-id="99149-108">This topic examines the string sorting, comparison, and casing methods in .NET, presents recommendations for selecting an appropriate string-handling method, and provides additional information about string-handling methods.</span></span> <span data-ttu-id="99149-109">它还讨论如何处理数据格式（如数字数据以及日期和时间数据）以用于显示和存储。</span><span class="sxs-lookup"><span data-stu-id="99149-109">It also examines how formatted data, such as numeric data and date and time data, is handled for display and for storage.</span></span>

## <a name="recommendations-for-string-usage"></a><span data-ttu-id="99149-110">对字符串用法的建议</span><span class="sxs-lookup"><span data-stu-id="99149-110">Recommendations for string usage</span></span>

<span data-ttu-id="99149-111">使用 .NET 进行开发时，请遵循以下简要建议使用字符串：</span><span class="sxs-lookup"><span data-stu-id="99149-111">When you develop with .NET, follow these simple recommendations when you use strings:</span></span>

- <span data-ttu-id="99149-112">使用为字符串操作显式指定字符串比较规则的重载。</span><span class="sxs-lookup"><span data-stu-id="99149-112">Use overloads that explicitly specify the string comparison rules for string operations.</span></span> <span data-ttu-id="99149-113">通常情况下，这涉及调用具有 <xref:System.StringComparison>类型的参数的方法重载。</span><span class="sxs-lookup"><span data-stu-id="99149-113">Typically, this involves calling a method overload that has a parameter of type <xref:System.StringComparison>.</span></span>
- <span data-ttu-id="99149-114">使用 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 或 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 进行比较，并以此作为匹配区域性不明确的字符串的安全默认设置。</span><span class="sxs-lookup"><span data-stu-id="99149-114">Use <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for comparisons as your safe default for culture-agnostic string matching.</span></span>
- <span data-ttu-id="99149-115">将比较与 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 或 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 配合使用，以获得更好的性能。</span><span class="sxs-lookup"><span data-stu-id="99149-115">Use comparisons with <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for better performance.</span></span>
- <span data-ttu-id="99149-116">向用户显示输出时，使用基于 <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> 的字符串操作。</span><span class="sxs-lookup"><span data-stu-id="99149-116">Use string operations that are based on <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> when you display output to the user.</span></span>
- <span data-ttu-id="99149-117">当进行与语言（例如，符号）无关的比较时，使用非语言的 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 或 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 值，而不使用基于 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 的字符串操作。</span><span class="sxs-lookup"><span data-stu-id="99149-117">Use the non-linguistic <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> values instead of string operations based on <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> when the comparison is linguistically irrelevant (symbolic, for example).</span></span>
- <span data-ttu-id="99149-118">在规范化要比较的字符串时，使用 <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> 方法而非 <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="99149-118">Use the <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> method instead of the <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> method when you normalize strings for comparison.</span></span>
- <span data-ttu-id="99149-119">使用 <xref:System.String.Equals%2A?displayProperty=nameWithType> 方法的重载来测试两个字符串是否相等。</span><span class="sxs-lookup"><span data-stu-id="99149-119">Use an overload of the <xref:System.String.Equals%2A?displayProperty=nameWithType> method to test whether two strings are equal.</span></span>
- <span data-ttu-id="99149-120">使用 <xref:System.String.Compare%2A?displayProperty=nameWithType> 和 <xref:System.String.CompareTo%2A?displayProperty=nameWithType> 方法可对字符串进行排序，而不是检查字符串是否相等。</span><span class="sxs-lookup"><span data-stu-id="99149-120">Use the <xref:System.String.Compare%2A?displayProperty=nameWithType> and <xref:System.String.CompareTo%2A?displayProperty=nameWithType> methods to sort strings, not to check for equality.</span></span>
- <span data-ttu-id="99149-121">在用户界面，使用区分区域性的格式显示非字符串数据，如数字和日期。</span><span class="sxs-lookup"><span data-stu-id="99149-121">Use culture-sensitive formatting to display non-string data, such as numbers and dates, in a user interface.</span></span> <span data-ttu-id="99149-122">使用格式以[固定区域性](xref:System.Globalization.CultureInfo.InvariantCulture)使非字符串数据显示为字符串形式。</span><span class="sxs-lookup"><span data-stu-id="99149-122">Use formatting with the [invariant culture](xref:System.Globalization.CultureInfo.InvariantCulture) to persist non-string data in string form.</span></span>

<span data-ttu-id="99149-123">使用字符串时，请避免采用以下做法：</span><span class="sxs-lookup"><span data-stu-id="99149-123">Avoid the following practices when you use strings:</span></span>

- <span data-ttu-id="99149-124">不要使用未显式或隐式为字符串操作指定字符串比较规则的重载。</span><span class="sxs-lookup"><span data-stu-id="99149-124">Do not use overloads that do not explicitly or implicitly specify the string comparison rules for string operations.</span></span>
- <span data-ttu-id="99149-125">在大多数情况下，不要使用基于 <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> 的字符串操作。</span><span class="sxs-lookup"><span data-stu-id="99149-125">Do not use string operations based on <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> in most cases.</span></span> <span data-ttu-id="99149-126">其中的一个少数例外情况是，保存在语言上有意义但区域性不明确的数据。</span><span class="sxs-lookup"><span data-stu-id="99149-126">One of the few exceptions is when you are persisting linguistically meaningful but culturally agnostic data.</span></span>
- <span data-ttu-id="99149-127">不要使用 <xref:System.String.Compare%2A?displayProperty=nameWithType> 或 <xref:System.String.CompareTo%2A> 方法的重载和用于确定两个字符串是否相等的返回值为 0 的测试。</span><span class="sxs-lookup"><span data-stu-id="99149-127">Do not use an overload of the <xref:System.String.Compare%2A?displayProperty=nameWithType> or <xref:System.String.CompareTo%2A> method and test for a return value of zero to determine whether two strings are equal.</span></span>
- <span data-ttu-id="99149-128">不要使用区分区域性格式以字符串形式来保存数值数据或日期和时间数据。</span><span class="sxs-lookup"><span data-stu-id="99149-128">Do not use culture-sensitive formatting to persist numeric data or date and time data in string form.</span></span>

## <a name="specifying-string-comparisons-explicitly"></a><span data-ttu-id="99149-129">显式指定字符串比较</span><span class="sxs-lookup"><span data-stu-id="99149-129">Specifying string comparisons explicitly</span></span>

<span data-ttu-id="99149-130">重载 .NET 中大部分字符串操作方法。</span><span class="sxs-lookup"><span data-stu-id="99149-130">Most of the string manipulation methods in .NET are overloaded.</span></span> <span data-ttu-id="99149-131">通常，一个或多个重载会接受默认设置，然而其他重载则不接受默认设置，而是定义比较或操作字符串的精确方式。</span><span class="sxs-lookup"><span data-stu-id="99149-131">Typically, one or more overloads accept default settings, whereas others accept no defaults and instead define the precise way in which strings are to be compared or manipulated.</span></span> <span data-ttu-id="99149-132">大多数不依赖于默认设置的方法都包括 <xref:System.StringComparison>类型的参数，该参数是按区域性和大小写为字符串比较显式指定规则的枚举。</span><span class="sxs-lookup"><span data-stu-id="99149-132">Most of the methods that do not rely on defaults include a parameter of type <xref:System.StringComparison>, which is an enumeration that explicitly specifies rules for string comparison by culture and case.</span></span> <span data-ttu-id="99149-133">下表描述 <xref:System.StringComparison> 枚举成员。</span><span class="sxs-lookup"><span data-stu-id="99149-133">The following table describes the <xref:System.StringComparison> enumeration members.</span></span>

|<span data-ttu-id="99149-134">StringComparison 成员</span><span class="sxs-lookup"><span data-stu-id="99149-134">StringComparison member</span></span>|<span data-ttu-id="99149-135">描述</span><span class="sxs-lookup"><span data-stu-id="99149-135">Description</span></span>|
|-----------------------------|-----------------|
|<xref:System.StringComparison.CurrentCulture>|<span data-ttu-id="99149-136">使用当前区域性执行区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="99149-136">Performs a case-sensitive comparison using the current culture.</span></span>|
|<xref:System.StringComparison.CurrentCultureIgnoreCase>|<span data-ttu-id="99149-137">使用当前区域性执行不区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="99149-137">Performs a case-insensitive comparison using the current culture.</span></span>|
|<xref:System.StringComparison.InvariantCulture>|<span data-ttu-id="99149-138">使用固定区域性执行区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="99149-138">Performs a case-sensitive comparison using the invariant culture.</span></span>|
|<xref:System.StringComparison.InvariantCultureIgnoreCase>|<span data-ttu-id="99149-139">使用固定区域性执行不区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="99149-139">Performs a case-insensitive comparison using the invariant culture.</span></span>|
|<xref:System.StringComparison.Ordinal>|<span data-ttu-id="99149-140">执行序号比较。</span><span class="sxs-lookup"><span data-stu-id="99149-140">Performs an ordinal comparison.</span></span>|
|<xref:System.StringComparison.OrdinalIgnoreCase>|<span data-ttu-id="99149-141">执行不区分大小写的序号比较。</span><span class="sxs-lookup"><span data-stu-id="99149-141">Performs a case-insensitive ordinal comparison.</span></span>|

<span data-ttu-id="99149-142">例如， <xref:System.String.IndexOf%2A> 方法（它返回 <xref:System.String> 对象中与某字符或字符串匹配的子字符串的索引）具有九种重载：</span><span class="sxs-lookup"><span data-stu-id="99149-142">For example, the <xref:System.String.IndexOf%2A> method, which returns the index of a substring in a <xref:System.String> object that matches either a character or a string, has nine overloads:</span></span>

- <span data-ttu-id="99149-143">默认情况下，<xref:System.String.IndexOf%28System.Char%29>, <xref:System.String.IndexOf%28System.Char%2CSystem.Int32%29>和 <xref:System.String.IndexOf%28System.Char%2CSystem.Int32%2CSystem.Int32%29>对字符串中的字符执行序号（区分大小写但不区分区域性的）搜索。</span><span class="sxs-lookup"><span data-stu-id="99149-143"><xref:System.String.IndexOf%28System.Char%29>, <xref:System.String.IndexOf%28System.Char%2CSystem.Int32%29>, and <xref:System.String.IndexOf%28System.Char%2CSystem.Int32%2CSystem.Int32%29>, which by default perform an ordinal (case-sensitive and culture-insensitive) search for a character in the string.</span></span>
- <span data-ttu-id="99149-144">默认情况下，<xref:System.String.IndexOf%28System.String%29>, <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>和 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>对字符串中的子字符串执行区分大小写且区分区域性的搜索。</span><span class="sxs-lookup"><span data-stu-id="99149-144"><xref:System.String.IndexOf%28System.String%29>, <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>, and <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>, which by default perform a case-sensitive and culture-sensitive search for a substring in the string.</span></span>
- <span data-ttu-id="99149-145"><xref:System.String.IndexOf%28System.String%2CSystem.StringComparison%29>、 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.StringComparison%29>和 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>，其中包括 <xref:System.StringComparison> 类型的参数，该类型允许指定比较形式。</span><span class="sxs-lookup"><span data-stu-id="99149-145"><xref:System.String.IndexOf%28System.String%2CSystem.StringComparison%29>, <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.StringComparison%29>, and <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>, which include a parameter of type <xref:System.StringComparison> that allows the form of the comparison to be specified.</span></span>

<span data-ttu-id="99149-146">我们建议选择不使用默认值的重载，原因如下：</span><span class="sxs-lookup"><span data-stu-id="99149-146">We recommend that you select an overload that does not use default values, for the following reasons:</span></span>

- <span data-ttu-id="99149-147">具有默认参数的一些重载（在字符串实例中搜索 <xref:System.Char> 的重载）执行序号比较，而其他重载（在字符串实例中搜索字符串的重载）执行的是区分区域性的比较。</span><span class="sxs-lookup"><span data-stu-id="99149-147">Some overloads with default parameters (those that search for a <xref:System.Char> in the string instance) perform an ordinal comparison, whereas others (those that search for a string in the string instance) are culture-sensitive.</span></span> <span data-ttu-id="99149-148">要记住哪种方法使用哪个默认值并非易事，并很容易混淆重载。</span><span class="sxs-lookup"><span data-stu-id="99149-148">It is difficult to remember which method uses which default value, and easy to confuse the overloads.</span></span>
- <span data-ttu-id="99149-149">依赖于方法调用默认值的代码的意图并不清楚。</span><span class="sxs-lookup"><span data-stu-id="99149-149">The intent of the code that relies on default values for method calls is not clear.</span></span> <span data-ttu-id="99149-150">在下面依赖于默认值的示例中，很难了解开发人员对两个字符串的实际意图是执行序号比较还是语言比较，或者 `protocol` 和“http”之间存在的大小写差异是否会导致相等性测试返回 `false`类型的参数的方法重载。</span><span class="sxs-lookup"><span data-stu-id="99149-150">In the following example, which relies on defaults, it is difficult to know whether the developer actually intended an ordinal or a linguistic comparison of two strings, or whether a case difference between `protocol` and "http" might cause the test for equality to return `false`.</span></span>

     [!code-csharp[Conceptual.Strings.BestPractices#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/explicitargs1.cs#1)]
     [!code-vb[Conceptual.Strings.BestPractices#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/explicitargs1.vb#1)]

<span data-ttu-id="99149-151">一般情况下，我们建议调用不依赖于默认设置的方法，因为这会明确代码的意图。</span><span class="sxs-lookup"><span data-stu-id="99149-151">In general, we recommend that you call a method that does not rely on defaults, because it makes the intent of the code unambiguous.</span></span> <span data-ttu-id="99149-152">这进而使代码更具可读性且更易于调试和维护。</span><span class="sxs-lookup"><span data-stu-id="99149-152">This, in turn, makes the code more readable and easier to debug and maintain.</span></span> <span data-ttu-id="99149-153">下面的示例解决了前面示例中提出的问题。</span><span class="sxs-lookup"><span data-stu-id="99149-153">The following example addresses the questions raised about the previous example.</span></span> <span data-ttu-id="99149-154">使用序号比较并且忽略大小写差异。</span><span class="sxs-lookup"><span data-stu-id="99149-154">It makes it clear that ordinal comparison is used and that differences in case are ignored.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/explicitargs1.cs#2)]
[!code-vb[Conceptual.Strings.BestPractices#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/explicitargs1.vb#2)]

## <a name="the-details-of-string-comparison"></a><span data-ttu-id="99149-155">字符串比较的详细信息</span><span class="sxs-lookup"><span data-stu-id="99149-155">The details of string comparison</span></span>

<span data-ttu-id="99149-156">字符串比较是许多字符串相关操作的核心，特别是排序和相等性测试操作。</span><span class="sxs-lookup"><span data-stu-id="99149-156">String comparison is the heart of many string-related operations, particularly sorting and testing for equality.</span></span> <span data-ttu-id="99149-157">字符串以确定的顺序进行排序：如果在排序的字符串列表中，“my”出现在“string”之前，则“my”必定小于或等于“string”。</span><span class="sxs-lookup"><span data-stu-id="99149-157">Strings sort in a determined order: If "my" appears before "string" in a sorted list of strings, "my" must compare less than or equal to "string".</span></span> <span data-ttu-id="99149-158">此外，比较可隐式确定相等性。</span><span class="sxs-lookup"><span data-stu-id="99149-158">Additionally, comparison implicitly defines equality.</span></span> <span data-ttu-id="99149-159">对于认为是相等的字符串，比较操作将返回零。</span><span class="sxs-lookup"><span data-stu-id="99149-159">The comparison operation returns zero for strings it deems equal.</span></span> <span data-ttu-id="99149-160">对此很好的解释是两个字符串都不小于对方。</span><span class="sxs-lookup"><span data-stu-id="99149-160">A good interpretation is that neither string is less than the other.</span></span> <span data-ttu-id="99149-161">涉及到字符串的最有意义的操作包括这些步骤中的一个或两个步骤：与另一个字符串进行比较和执行明确的排序操作。</span><span class="sxs-lookup"><span data-stu-id="99149-161">Most meaningful operations involving strings include one or both of these procedures: comparing with another string, and executing a well-defined sort operation.</span></span>

> [!NOTE]
> <span data-ttu-id="99149-162">可以下载[排序权重表](https://www.microsoft.com/download/details.aspx?id=10921)，这是一组文本文件，其中包含有关 Windows 操作系统排序和比较操作中所使用的字符权重的信息，也可以下载[默认 Unicode 排序元素表](https://www.unicode.org/Public/UCA/latest/allkeys.txt)，这是适用于 Linux 和 macOS 的最新版排序权重表。</span><span class="sxs-lookup"><span data-stu-id="99149-162">You can download the [Sorting Weight Tables](https://www.microsoft.com/download/details.aspx?id=10921), a set of text files that contain information on the character weights used in sorting and comparison operations for Windows operating systems, and the [Default Unicode Collation Element Table](https://www.unicode.org/Public/UCA/latest/allkeys.txt), the latest version of the sort weight table for Linux and macOS.</span></span> <span data-ttu-id="99149-163">Linux 和 macOS 上的特定排序权重表版本取决于系统上安装的 [International Components for Unicode](http://site.icu-project.org/) 库的版本。</span><span class="sxs-lookup"><span data-stu-id="99149-163">The specific version of the sort weight table on Linux and macOS depends on the version of the [International Components for Unicode](http://site.icu-project.org/) libraries installed on the system.</span></span> <span data-ttu-id="99149-164">有关 ICU 版本及它们所实现的 Unicode 版本的信息，请参阅[下载 ICU](http://site.icu-project.org/download)。</span><span class="sxs-lookup"><span data-stu-id="99149-164">For information on ICU versions and the Unicode versions that they implement, see [Downloading ICU](http://site.icu-project.org/download).</span></span>

<span data-ttu-id="99149-165">但是，评估两个字符串的相等性或排序顺序不会生成一个正确的结果；其结果取决于用于比较这两个字符串的条件。</span><span class="sxs-lookup"><span data-stu-id="99149-165">However, evaluating two strings for equality or sort order does not yield a single, correct result; the outcome depends on the criteria used to compare the strings.</span></span> <span data-ttu-id="99149-166">特别是，序号或基于当前区域性或[固定区域性](xref:System.Globalization.CultureInfo.InvariantCulture)（基于英语语言的区域设置不明确的区域性）的大小写和排序约定的字符串比较可能会产生不同的结果。</span><span class="sxs-lookup"><span data-stu-id="99149-166">In particular, string comparisons that are ordinal or that are based on the casing and sorting conventions of the current culture or the [invariant culture](xref:System.Globalization.CultureInfo.InvariantCulture) (a locale-agnostic culture based on the English language) may produce different results.</span></span>

<span data-ttu-id="99149-167">此外，使用不同 .NET 版本或在不同操作系统或不同的操作系统版本上使用 .NET 进行字符串比较时，返回的结果可能不同。</span><span class="sxs-lookup"><span data-stu-id="99149-167">In addition, string comparisons using different versions of .NET or using .NET on different operating systems or operating system versions may return different results.</span></span> <span data-ttu-id="99149-168">有关详细信息，请参阅[字符串和 Unicode 标准](xref:System.String#Unicode)。</span><span class="sxs-lookup"><span data-stu-id="99149-168">For more information, see [Strings and the Unicode Standard](xref:System.String#Unicode).</span></span>

### <a name="string-comparisons-that-use-the-current-culture"></a><span data-ttu-id="99149-169">使用当前区域性的字符串比较</span><span class="sxs-lookup"><span data-stu-id="99149-169">String comparisons that use the current culture</span></span>

<span data-ttu-id="99149-170">一个条件涉及在比较字符串时使用当前区域性的约定。</span><span class="sxs-lookup"><span data-stu-id="99149-170">One criterion involves using the conventions of the current culture when comparing strings.</span></span> <span data-ttu-id="99149-171">基于当前区域性的比较使用线程的当前区域性或区域设置。</span><span class="sxs-lookup"><span data-stu-id="99149-171">Comparisons that are based on the current culture use the thread's current culture or locale.</span></span> <span data-ttu-id="99149-172">如果用户未设置该区域性，则默认为“控制面板”中“区域选项”  窗口中的设置。</span><span class="sxs-lookup"><span data-stu-id="99149-172">If the culture is not set by the user, it defaults to the setting in the **Regional Options** window in Control Panel.</span></span> <span data-ttu-id="99149-173">当数据与语言相关并反映区分区域性的用户交互时，应始终使用基于当前区域性的比较。</span><span class="sxs-lookup"><span data-stu-id="99149-173">You should always use comparisons that are based on the current culture when data is linguistically relevant, and when it reflects culture-sensitive user interaction.</span></span>

<span data-ttu-id="99149-174">但是，当区域性发生更改时，.NET 中的比较和大小写行为也发生更改。</span><span class="sxs-lookup"><span data-stu-id="99149-174">However, comparison and casing behavior in .NET changes when the culture changes.</span></span> <span data-ttu-id="99149-175">如果执行应用程序的计算机与用于开发该应用程序的计算机具有不同的区域性，或者执行线程改变它的区域性，则会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="99149-175">This happens when an application executes on a computer that has a different culture than the computer on which the application was developed, or when the executing thread changes its culture.</span></span> <span data-ttu-id="99149-176">此行为是有意而为之的，但许多开发人员不易察觉此行为。</span><span class="sxs-lookup"><span data-stu-id="99149-176">This behavior is intentional, but it remains non-obvious to many developers.</span></span> <span data-ttu-id="99149-177">下面的示例说明了美国英语（“en-US”）与瑞典语（“sv-SE”）区域性在排序顺序中的差异。</span><span class="sxs-lookup"><span data-stu-id="99149-177">The following example illustrates differences in sort order between the U.S. English ("en-US") and Swedish ("sv-SE") cultures.</span></span> <span data-ttu-id="99149-178">请注意，单词“ångström”、“Windows”和“Visual Studio”将出现在已排序的字符串数组的不同位置。</span><span class="sxs-lookup"><span data-stu-id="99149-178">Note that the words "ångström", "Windows", and "Visual Studio" appear in different positions in the sorted string arrays.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/comparison1.cs#3)]
[!code-vb[Conceptual.Strings.BestPractices#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/comparison1.vb#3)]

<span data-ttu-id="99149-179">使用当前区域性的不区分大小写比较和区分区域性的比较是相同的，只不过前者忽略由线程的当前区域性指示的大小写。</span><span class="sxs-lookup"><span data-stu-id="99149-179">Case-insensitive comparisons that use the current culture are the same as culture-sensitive comparisons, except that they ignore case as dictated by the thread's current culture.</span></span> <span data-ttu-id="99149-180">这种情况也可表明它的排序顺序。</span><span class="sxs-lookup"><span data-stu-id="99149-180">This behavior may manifest itself in sort orders as well.</span></span>

<span data-ttu-id="99149-181">以下方法默认利用使用当前区域性语义的比较：</span><span class="sxs-lookup"><span data-stu-id="99149-181">Comparisons that use current culture semantics are the default for the following methods:</span></span>

- <span data-ttu-id="99149-182">不包括<xref:System.String.Compare%2A?displayProperty=nameWithType> 参数的 <xref:System.StringComparison> 重载。</span><span class="sxs-lookup"><span data-stu-id="99149-182"><xref:System.String.Compare%2A?displayProperty=nameWithType> overloads that do not include a <xref:System.StringComparison> parameter.</span></span>
- <span data-ttu-id="99149-183"><xref:System.String.CompareTo%2A?displayProperty=nameWithType> 重载。</span><span class="sxs-lookup"><span data-stu-id="99149-183"><xref:System.String.CompareTo%2A?displayProperty=nameWithType> overloads.</span></span>
- <span data-ttu-id="99149-184">默认 <xref:System.String.StartsWith%28System.String%29?displayProperty=nameWithType> 方法和具有 <xref:System.String.StartsWith%28System.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> null `null`<xref:System.Globalization.CultureInfo> 重载。</span><span class="sxs-lookup"><span data-stu-id="99149-184">The default <xref:System.String.StartsWith%28System.String%29?displayProperty=nameWithType> method, and the <xref:System.String.StartsWith%28System.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> method with a `null`<xref:System.Globalization.CultureInfo> parameter.</span></span>
- <span data-ttu-id="99149-185">默认 <xref:System.String.EndsWith%28System.String%29?displayProperty=nameWithType> 方法和需要使用 `null`<xref:System.Globalization.CultureInfo> 参数的 <xref:System.String.EndsWith%28System.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="99149-185">The default <xref:System.String.EndsWith%28System.String%29?displayProperty=nameWithType> method, and the <xref:System.String.EndsWith%28System.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> method with a `null`<xref:System.Globalization.CultureInfo> parameter.</span></span>
- <span data-ttu-id="99149-186">接受<xref:System.String.IndexOf%2A?displayProperty=nameWithType> 作为搜索参数且不包含 <xref:System.String> 参数的 <xref:System.StringComparison> 重载。</span><span class="sxs-lookup"><span data-stu-id="99149-186"><xref:System.String.IndexOf%2A?displayProperty=nameWithType> overloads that accept a <xref:System.String> as a search parameter and that do not have a <xref:System.StringComparison> parameter.</span></span>
- <span data-ttu-id="99149-187">接受<xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> 作为搜索参数且不包含 <xref:System.String> 参数的 <xref:System.StringComparison> 重载。</span><span class="sxs-lookup"><span data-stu-id="99149-187"><xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> overloads that accept a <xref:System.String> as a search parameter and that do not have a <xref:System.StringComparison> parameter.</span></span>

<span data-ttu-id="99149-188">总之，我们建议调用具有 <xref:System.StringComparison> 参数的重载，以便明确方法调用的意图。</span><span class="sxs-lookup"><span data-stu-id="99149-188">In any case, we recommend that you call an overload that has a <xref:System.StringComparison> parameter to make the intent of the method call clear.</span></span>

<span data-ttu-id="99149-189">当从语言角度解释非语言的字符串数据，或利用其他区域性的约定解释某个特定区域性中的字符串时，则会发生或大或小的错误。</span><span class="sxs-lookup"><span data-stu-id="99149-189">Subtle and not so subtle bugs can emerge when non-linguistic string data is interpreted linguistically, or when string data from a particular culture is interpreted using the conventions of another culture.</span></span> <span data-ttu-id="99149-190">土耳其语 I 问题便是一个规范示例。</span><span class="sxs-lookup"><span data-stu-id="99149-190">The canonical example is the Turkish-I problem.</span></span>

<span data-ttu-id="99149-191">对于几乎所有拉丁字母来讲（包括美国英语），字符“i”(\u0069) 是字符“I”(\u0049) 的小写形式。</span><span class="sxs-lookup"><span data-stu-id="99149-191">For nearly all Latin alphabets, including U.S. English, the character "i" (\u0069) is the lowercase version of the character "I" (\u0049).</span></span> <span data-ttu-id="99149-192">此大小写规则快速成为在此类区域性中编程的人员的默认设置。</span><span class="sxs-lookup"><span data-stu-id="99149-192">This casing rule quickly becomes the default for someone programming in such a culture.</span></span> <span data-ttu-id="99149-193">但是，土耳其语（“tr-TR”）字母表中包含一个“带有点的 I”的字符“İ”(\u0130)，该字符是“i”的大写形式。</span><span class="sxs-lookup"><span data-stu-id="99149-193">However, the Turkish ("tr-TR") alphabet includes an "I with a dot" character "İ" (\u0130), which is the capital version of "i".</span></span> <span data-ttu-id="99149-194">土耳其语还包括一个小写“不带点的 i”字符，即为“ı”(\u0131)，该字符的大写形式为“I”。</span><span class="sxs-lookup"><span data-stu-id="99149-194">Turkish also includes a lowercase "i without a dot" character, "ı" (\u0131), which capitalizes to "I".</span></span> <span data-ttu-id="99149-195">阿塞拜疆语（“az”）区域也会出现这种情况。</span><span class="sxs-lookup"><span data-stu-id="99149-195">This behavior occurs in the Azerbaijani ("az") culture as well.</span></span>

<span data-ttu-id="99149-196">因此，关于将“i”变为大写或将“I”变为小写的假设并非在所有区域性中都是有效的。</span><span class="sxs-lookup"><span data-stu-id="99149-196">Therefore, assumptions made about capitalizing "i" or lowercasing "I" are not valid among all cultures.</span></span> <span data-ttu-id="99149-197">如果为字符串比较例程使用默认重载，则它们可能会因区域性不同而异。</span><span class="sxs-lookup"><span data-stu-id="99149-197">If you use the default overloads for string comparison routines, they will be subject to variance between cultures.</span></span> <span data-ttu-id="99149-198">如果对非语言的数据进行比较，使用默认重载会产生不良后果，如以下对字符串“file”和“FILE”执行不区分大小写的比较尝试所示。</span><span class="sxs-lookup"><span data-stu-id="99149-198">If the data to be compared is non-linguistic, using the default overloads can produce undesirable results, as the following attempt to perform a case-insensitive comparison of the strings "file" and "FILE" illustrates.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#11](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/turkish1.cs#11)]
[!code-vb[Conceptual.Strings.BestPractices#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/turkish1.vb#11)]

<span data-ttu-id="99149-199">如果无意中在安全敏感设置中使用了区域性，则此比较会导致发生重大问题，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="99149-199">This comparison could cause significant problems if the culture is inadvertently used in security-sensitive settings, as in the following example.</span></span> <span data-ttu-id="99149-200">如果当前区域性为美国英语，则 `IsFileURI("file:")` 等方法调用将返回 `true`；但如果当前区域性为土耳其语，则将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="99149-200">A method call such as `IsFileURI("file:")` returns `true` if the current culture is U.S. English, but `false` if the current culture is Turkish.</span></span> <span data-ttu-id="99149-201">因此，在土耳其语系统中，有人可能会避开阻止访问以“FILE:”开头的不区分大小写的安全措施。</span><span class="sxs-lookup"><span data-stu-id="99149-201">Thus, on Turkish systems, someone could circumvent security measures that block access to case-insensitive URIs that begin with "FILE:".</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#12](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/turkish1.cs#12)]
[!code-vb[Conceptual.Strings.BestPractices#12](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/turkish1.vb#12)]

<span data-ttu-id="99149-202">在这种情况下，由于“file:”会被解释为非语言的、不区分区域性的标识符，因此，应按照下面的示例所示编写代码：</span><span class="sxs-lookup"><span data-stu-id="99149-202">In this case, because "file:" is meant to be interpreted as a non-linguistic, culture-insensitive identifier, the code should instead be written as shown in the following example:</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#13](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/turkish1.cs#13)]
[!code-vb[Conceptual.Strings.BestPractices#13](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/turkish1.vb#13)]

### <a name="ordinal-string-operations"></a><span data-ttu-id="99149-203">序号字符串操作</span><span class="sxs-lookup"><span data-stu-id="99149-203">Ordinal string operations</span></span>

<span data-ttu-id="99149-204">在方法调用中指定 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 或 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 值表示非语言比较，这种比较忽略了自然语言的特性。</span><span class="sxs-lookup"><span data-stu-id="99149-204">Specifying the <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> value in a method call signifies a non-linguistic comparison in which the features of natural languages are ignored.</span></span> <span data-ttu-id="99149-205">利用 <xref:System.StringComparison> 值调用的方法将字符串操作决策建立在简单的字节比较的基础之上，而不是按区域性参数化的大小写或相等表。</span><span class="sxs-lookup"><span data-stu-id="99149-205">Methods that are invoked with these <xref:System.StringComparison> values base string operation decisions on simple byte comparisons instead of casing or equivalence tables that are parameterized by culture.</span></span> <span data-ttu-id="99149-206">在大多数情况下，这种方法最符合字符串的预期解释，并使代码更快更可靠。</span><span class="sxs-lookup"><span data-stu-id="99149-206">In most cases, this approach best fits the intended interpretation of strings while making code faster and more reliable.</span></span>

<span data-ttu-id="99149-207">序号比较就是字符串比较，在这种比较中，将比较每个字符串中的每个字节且不进行语言解释；例如，“windows”不匹配“Windows”。</span><span class="sxs-lookup"><span data-stu-id="99149-207">Ordinal comparisons are string comparisons in which each byte of each string is compared without linguistic interpretation; for example, "windows" does not match "Windows".</span></span> <span data-ttu-id="99149-208">实质上，这是对 C 运行时 `strcmp` 函数的调用。</span><span class="sxs-lookup"><span data-stu-id="99149-208">This is essentially a call to the C runtime `strcmp` function.</span></span> <span data-ttu-id="99149-209">当上下文指示应完全匹配字符串或要求保守匹配策略时，请使用这种比较。</span><span class="sxs-lookup"><span data-stu-id="99149-209">Use this comparison when the context dictates that strings should be matched exactly or demands conservative matching policy.</span></span> <span data-ttu-id="99149-210">此外，序号比较是最快的比较操作，因为它在确定结果时不应用任何语言规则。</span><span class="sxs-lookup"><span data-stu-id="99149-210">Additionally, ordinal comparison is the fastest comparison operation because it applies no linguistic rules when determining a result.</span></span>

<span data-ttu-id="99149-211">.NET 中的字符串可以包括嵌入的空字符。</span><span class="sxs-lookup"><span data-stu-id="99149-211">Strings in .NET can contain embedded null characters.</span></span> <span data-ttu-id="99149-212">序号比较与区分区域性的比较（包括使用固定区域性的比较）之间最明显的区别之一是对字符串中嵌入的空字符的处理方式。</span><span class="sxs-lookup"><span data-stu-id="99149-212">One of the clearest differences between ordinal and culture-sensitive comparison (including comparisons that use the invariant culture) concerns the handling of embedded null characters in a string.</span></span> <span data-ttu-id="99149-213">当使用 <xref:System.String.Compare%2A?displayProperty=nameWithType> 和 <xref:System.String.Equals%2A?displayProperty=nameWithType> 方法执行区分区域性的比较（包括使用固定区域性的比较）时，将忽略这些字符。</span><span class="sxs-lookup"><span data-stu-id="99149-213">These characters are ignored when you use the <xref:System.String.Compare%2A?displayProperty=nameWithType> and <xref:System.String.Equals%2A?displayProperty=nameWithType> methods to perform culture-sensitive comparisons (including comparisons that use the invariant culture).</span></span> <span data-ttu-id="99149-214">因此，在区分区域性的比较中，包含嵌入的空字符的字符串可视为等于不包含空字符的字符串。</span><span class="sxs-lookup"><span data-stu-id="99149-214">As a result, in culture-sensitive comparisons, strings that contain embedded null characters can be considered equal to strings that do not.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="99149-215">尽管字符串比较方法忽略嵌入的空字符，但是 <xref:System.String.Contains%2A?displayProperty=nameWithType>、 <xref:System.String.EndsWith%2A?displayProperty=nameWithType>、 <xref:System.String.IndexOf%2A?displayProperty=nameWithType>、 <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>和 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> 等字符串搜索方法并不会忽略这些字符。</span><span class="sxs-lookup"><span data-stu-id="99149-215">Although string comparison methods disregard embedded null characters, string search methods such as <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, and <xref:System.String.StartsWith%2A?displayProperty=nameWithType> do not.</span></span>

<span data-ttu-id="99149-216">下面的示例对字符串“Aa”与在“A”和“a”之间嵌入了多个空字符的相似字符串进行区分区域性的比较，并显示如何将这两个字符串视为相等的字符串：</span><span class="sxs-lookup"><span data-stu-id="99149-216">The following example performs a culture-sensitive comparison of the string "Aa" with a similar string that contains several embedded null characters between "A" and "a", and shows how the two strings are considered equal:</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#19](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/embeddednulls1.cs#19)]
 [!code-vb[Conceptual.Strings.BestPractices#19](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/embeddednulls1.vb#19)]

<span data-ttu-id="99149-217">但是，当使用序号比较时，这两个字符串不会视为相等，如下面的示例所示：</span><span class="sxs-lookup"><span data-stu-id="99149-217">However, the strings are not considered equal when you use ordinal comparison, as the following example shows:</span></span>
  
[!code-csharp[Conceptual.Strings.BestPractices#20](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/embeddednulls2.cs#20)]
[!code-vb[Conceptual.Strings.BestPractices#20](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/embeddednulls2.vb#20)]

<span data-ttu-id="99149-218">不区分大小写的序号比较是第二种最保守的方法。</span><span class="sxs-lookup"><span data-stu-id="99149-218">Case-insensitive ordinal comparisons are the next most conservative approach.</span></span> <span data-ttu-id="99149-219">这些比较会忽略大多数的大小写；例如，“windows”会匹配“Windows”。</span><span class="sxs-lookup"><span data-stu-id="99149-219">These comparisons ignore most casing; for example, "windows" matches "Windows".</span></span> <span data-ttu-id="99149-220">在处理 ASCII 字符时，此策略等同于 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>，只不过它会忽略常用的 ASCII 大小写。</span><span class="sxs-lookup"><span data-stu-id="99149-220">When dealing with ASCII characters, this policy is equivalent to <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, except that it ignores the usual ASCII casing.</span></span> <span data-ttu-id="99149-221">因此，[A, Z] (\u0041-\u005A) 中的任何字符都会匹配 [a,z] (\u0061-\007A) 中的相应字符。</span><span class="sxs-lookup"><span data-stu-id="99149-221">Therefore, any character in [A, Z] (\u0041-\u005A) matches the corresponding character in [a,z] (\u0061-\007A).</span></span> <span data-ttu-id="99149-222">超出 ASCII 范围的大小写使用固定区域性的表。</span><span class="sxs-lookup"><span data-stu-id="99149-222">Casing outside the ASCII range uses the invariant culture's tables.</span></span> <span data-ttu-id="99149-223">因此，下面的比较：</span><span class="sxs-lookup"><span data-stu-id="99149-223">Therefore, the following comparison:</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#4](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/comparison2.cs#4)]
[!code-vb[Conceptual.Strings.BestPractices#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/comparison2.vb#4)]

<span data-ttu-id="99149-224">等效于（但会更快）这种比较：</span><span class="sxs-lookup"><span data-stu-id="99149-224">is equivalent to (but faster than) this comparison:</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#5](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/comparison2.cs#5)]
[!code-vb[Conceptual.Strings.BestPractices#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/comparison2.vb#5)]

<span data-ttu-id="99149-225">这些比较仍非常快。</span><span class="sxs-lookup"><span data-stu-id="99149-225">These comparisons are still very fast.</span></span>

> [!NOTE]
> <span data-ttu-id="99149-226">文件系统、注册表项和值以及环境变量的字符串行为可由 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>很好地表现出来。</span><span class="sxs-lookup"><span data-stu-id="99149-226">The string behavior of the file system, registry keys and values, and environment variables is best represented by <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="99149-227"><xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 和 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 均直接使用二进制值并最适合匹配。</span><span class="sxs-lookup"><span data-stu-id="99149-227">Both <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> and <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> use the binary values directly, and are best suited for matching.</span></span> <span data-ttu-id="99149-228">当不确定比较设置时，请使用这两个值中的其中一个。</span><span class="sxs-lookup"><span data-stu-id="99149-228">When you are not sure about your comparison settings, use one of these two values.</span></span> <span data-ttu-id="99149-229">不过，由于它们执行逐字节比较，因此不会按照语言排序顺序（如英语词典）进行排序，而是按照二进制排序顺序。</span><span class="sxs-lookup"><span data-stu-id="99149-229">However, because they perform a byte-by-byte comparison, they do not sort by a linguistic sort order (like an English dictionary) but by a binary sort order.</span></span> <span data-ttu-id="99149-230">如果向用户显示结果，则在大多数上下文中结果都看上去不正常。</span><span class="sxs-lookup"><span data-stu-id="99149-230">The results may look odd in most contexts if displayed to users.</span></span>

<span data-ttu-id="99149-231">序号语义是不包括 <xref:System.String.Equals%2A?displayProperty=nameWithType> 参数（包括相等运算符）的 <xref:System.StringComparison> 重载的默认项。</span><span class="sxs-lookup"><span data-stu-id="99149-231">Ordinal semantics are the default for <xref:System.String.Equals%2A?displayProperty=nameWithType> overloads that do not include a <xref:System.StringComparison> argument (including the equality operator).</span></span> <span data-ttu-id="99149-232">总之，我们建议调用具有 <xref:System.StringComparison> 参数的重载。</span><span class="sxs-lookup"><span data-stu-id="99149-232">In any case, we recommend that you call an overload that has a <xref:System.StringComparison> parameter.</span></span>

### <a name="string-operations-that-use-the-invariant-culture"></a><span data-ttu-id="99149-233">使用固定区域性的字符串操作</span><span class="sxs-lookup"><span data-stu-id="99149-233">string operations that use the invariant culture</span></span>

<span data-ttu-id="99149-234">具有固定区域性的比较使用由静态 <xref:System.Globalization.CultureInfo.CompareInfo%2A> 属性返回的 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="99149-234">Comparisons with the invariant culture use the <xref:System.Globalization.CultureInfo.CompareInfo%2A> property returned by the static <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="99149-235">此行为在所有系统中都相同；它会将其范围外的任何字符转换为其认为等效的固定字符。</span><span class="sxs-lookup"><span data-stu-id="99149-235">This behavior is the same on all systems; it translates any characters outside its range into what it believes are equivalent invariant characters.</span></span> <span data-ttu-id="99149-236">此策略对于在各个区域性中维护一组字符串行为很有用，但经常产生意外的结果。</span><span class="sxs-lookup"><span data-stu-id="99149-236">This policy can be useful for maintaining one set of string behavior across cultures, but it often provides unexpected results.</span></span>

<span data-ttu-id="99149-237">具有固定区域性的不区分大小写的比较也使用由静态 <xref:System.Globalization.CultureInfo.CompareInfo%2A> 属性返回的静态 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 属性以获取比较信息。</span><span class="sxs-lookup"><span data-stu-id="99149-237">Case-insensitive comparisons with the invariant culture use the static <xref:System.Globalization.CultureInfo.CompareInfo%2A> property returned by the static <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property for comparison information as well.</span></span> <span data-ttu-id="99149-238">所转换字符中的任何大小写差异都将被忽略。</span><span class="sxs-lookup"><span data-stu-id="99149-238">Any case differences among these translated characters are ignored.</span></span>

<span data-ttu-id="99149-239">使用 <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> 和 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 的比较对 ASCII 字符串产生相同的作用。</span><span class="sxs-lookup"><span data-stu-id="99149-239">Comparisons that use <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> and <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> work identically on ASCII strings.</span></span> <span data-ttu-id="99149-240">但是， <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> 会做出可能不适用于解释为一组字节的字符串的语言性决策。</span><span class="sxs-lookup"><span data-stu-id="99149-240">However, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> makes linguistic decisions that might not be appropriate for strings that have to be interpreted as a set of bytes.</span></span> <span data-ttu-id="99149-241">还可以使用 `CultureInfo.InvariantCulture.CompareInfo` 对象使 <xref:System.String.Compare%2A> 方法将一组特定的字符解释为等效字符。</span><span class="sxs-lookup"><span data-stu-id="99149-241">The `CultureInfo.InvariantCulture.CompareInfo` object makes the <xref:System.String.Compare%2A> method interpret certain sets of characters as equivalent.</span></span> <span data-ttu-id="99149-242">例如，下面的等效字符在固定区域性中是有效的：</span><span class="sxs-lookup"><span data-stu-id="99149-242">For example, the following equivalence is valid under the invariant culture:</span></span>

<span data-ttu-id="99149-243">InvariantCulture: a + ̊ = å</span><span class="sxs-lookup"><span data-stu-id="99149-243">InvariantCulture: a + ̊ = å</span></span>

<span data-ttu-id="99149-244">如果 A 字符的小写拉丁字母“a”(\u0061) 旁边有上方组合圆圈字符“+ " ̊”(\u030a)，A 字符就会被解释为，上方带有圆圈的小写拉丁字母“å”(\u00e5)。</span><span class="sxs-lookup"><span data-stu-id="99149-244">The LATIN SMALL LETTER A character "a"  (\u0061), when it is next to the COMBINING RING ABOVE character "+ " ̊" (\u030a), is interpreted as the LATIN SMALL LETTER A WITH RING ABOVE character "å" (\u00e5).</span></span> <span data-ttu-id="99149-245">如下面的示例所示，此行为不同于序号比较。</span><span class="sxs-lookup"><span data-stu-id="99149-245">As the following example shows, this behavior differs from ordinal comparison.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#15](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/comparison3.cs#15)]
[!code-vb[Conceptual.Strings.BestPractices#15](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/comparison3.vb#15)]

<span data-ttu-id="99149-246">当解释其中出现如“å”组合的文件名称、cookie 或其他内容时，序号比较仍会提供最透明和最合适的行为。</span><span class="sxs-lookup"><span data-stu-id="99149-246">When interpreting file names, cookies, or anything else where a combination such as "å" can appear, ordinal comparisons still offer the most transparent and fitting behavior.</span></span>

<span data-ttu-id="99149-247">总的来说，固定区域性具有极少的对比较有用的属性。</span><span class="sxs-lookup"><span data-stu-id="99149-247">On balance, the invariant culture has very few properties that make it useful for comparison.</span></span> <span data-ttu-id="99149-248">它会以与语言相关的方式执行比较，使其无法保证完整的符号等效性，但它并不是任何区域性中显示的选择。</span><span class="sxs-lookup"><span data-stu-id="99149-248">It does comparison in a linguistically relevant manner, which prevents it from guaranteeing full symbolic equivalence, but it is not the choice for display in any culture.</span></span> <span data-ttu-id="99149-249">使用 <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> 进行比较的其中一个原因是为多个区域性相同的显示保留已排序的数据。</span><span class="sxs-lookup"><span data-stu-id="99149-249">One of the few reasons to use <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> for comparison is to persist ordered data for a cross-culturally identical display.</span></span> <span data-ttu-id="99149-250">例如，如果应用程序附带包含用于显示的已排序标识符列表的大型数据文件，则添加到此列表将需要使用固定条件样式排序插入。</span><span class="sxs-lookup"><span data-stu-id="99149-250">For example, if a large data file that contains a list of sorted identifiers for display accompanies an application, adding to this list would require an insertion with invariant-style sorting.</span></span>

## <a name="choosing-a-stringcomparison-member-for-your-method-call"></a><span data-ttu-id="99149-251">为方法调用选择 StringComparison 成员</span><span class="sxs-lookup"><span data-stu-id="99149-251">Choosing a StringComparison member for your method call</span></span>

<span data-ttu-id="99149-252">下表概述了从语义字符串上下文到 <xref:System.StringComparison> 枚举成员的映射：</span><span class="sxs-lookup"><span data-stu-id="99149-252">The following table outlines the mapping from semantic string context to a <xref:System.StringComparison> enumeration member:</span></span>

|<span data-ttu-id="99149-253">数据</span><span class="sxs-lookup"><span data-stu-id="99149-253">Data</span></span>|<span data-ttu-id="99149-254">行为</span><span class="sxs-lookup"><span data-stu-id="99149-254">Behavior</span></span>|<span data-ttu-id="99149-255">相应 System.StringComparison</span><span class="sxs-lookup"><span data-stu-id="99149-255">Corresponding System.StringComparison</span></span><br /><br /> <span data-ttu-id="99149-256">value</span><span class="sxs-lookup"><span data-stu-id="99149-256">value</span></span>|
|----------|--------------|-----------------------------------------------------|
|<span data-ttu-id="99149-257">区分大小写的内部标识符。</span><span class="sxs-lookup"><span data-stu-id="99149-257">Case-sensitive internal identifiers.</span></span><br /><br /> <span data-ttu-id="99149-258">区分大小写的标准标识符（例如 XML 和 HTTP）。</span><span class="sxs-lookup"><span data-stu-id="99149-258">Case-sensitive identifiers in standards such as XML and HTTP.</span></span><br /><br /> <span data-ttu-id="99149-259">区分大小写的安全相关设置。</span><span class="sxs-lookup"><span data-stu-id="99149-259">Case-sensitive security-related settings.</span></span>|<span data-ttu-id="99149-260">字节完全匹配的非语言标识符。</span><span class="sxs-lookup"><span data-stu-id="99149-260">A non-linguistic identifier, where bytes match exactly.</span></span>|<xref:System.StringComparison.Ordinal>|
|<span data-ttu-id="99149-261">不区分大小写的内部标识符。</span><span class="sxs-lookup"><span data-stu-id="99149-261">Case-insensitive internal identifiers.</span></span><br /><br /> <span data-ttu-id="99149-262">不区分大小写的标准标识符（例如 XML 和 HTTP）。</span><span class="sxs-lookup"><span data-stu-id="99149-262">Case-insensitive identifiers in standards such as XML and HTTP.</span></span><br /><br /> <span data-ttu-id="99149-263">文件路径。</span><span class="sxs-lookup"><span data-stu-id="99149-263">File paths.</span></span><br /><br /> <span data-ttu-id="99149-264">注册表项和值。</span><span class="sxs-lookup"><span data-stu-id="99149-264">Registry keys and values.</span></span><br /><br /> <span data-ttu-id="99149-265">环境变量。</span><span class="sxs-lookup"><span data-stu-id="99149-265">Environment variables.</span></span><br /><br /> <span data-ttu-id="99149-266">资源标识符（例如，句柄名称）。</span><span class="sxs-lookup"><span data-stu-id="99149-266">Resource identifiers (for example, handle names).</span></span><br /><br /> <span data-ttu-id="99149-267">不区分大小写的安全相关设置。</span><span class="sxs-lookup"><span data-stu-id="99149-267">Case-insensitive security-related settings.</span></span>|<span data-ttu-id="99149-268">无关大小写的非语言标识符；尤其是存储在大多数 Windows 系统服务中的数据。</span><span class="sxs-lookup"><span data-stu-id="99149-268">A non-linguistic identifier, where case is irrelevant; especially data stored in most Windows system services.</span></span>|<xref:System.StringComparison.OrdinalIgnoreCase>|
|<span data-ttu-id="99149-269">某些保留的、与语言相关的数据。</span><span class="sxs-lookup"><span data-stu-id="99149-269">Some persisted, linguistically relevant data.</span></span><br /><br /> <span data-ttu-id="99149-270">需要固定排序顺序的语言数据的显示。</span><span class="sxs-lookup"><span data-stu-id="99149-270">Display of linguistic data that requires a fixed sort order.</span></span>|<span data-ttu-id="99149-271">仍与语言相关的区域性不明确数据。</span><span class="sxs-lookup"><span data-stu-id="99149-271">Culturally agnostic data that still is linguistically relevant.</span></span>|<xref:System.StringComparison.InvariantCulture><br /><br /> <span data-ttu-id="99149-272">\- 或 -</span><span class="sxs-lookup"><span data-stu-id="99149-272">-or-</span></span><br /><br /> <xref:System.StringComparison.InvariantCultureIgnoreCase>|
|<span data-ttu-id="99149-273">向用户显示的数据。</span><span class="sxs-lookup"><span data-stu-id="99149-273">Data displayed to the user.</span></span><br /><br /> <span data-ttu-id="99149-274">大多数用户输入。</span><span class="sxs-lookup"><span data-stu-id="99149-274">Most user input.</span></span>|<span data-ttu-id="99149-275">需要本地语言自定义的数据。</span><span class="sxs-lookup"><span data-stu-id="99149-275">Data that requires local linguistic customs.</span></span>|<xref:System.StringComparison.CurrentCulture><br /><br /> <span data-ttu-id="99149-276">\- 或 -</span><span class="sxs-lookup"><span data-stu-id="99149-276">-or-</span></span><br /><br /> <xref:System.StringComparison.CurrentCultureIgnoreCase>|

## <a name="common-string-comparison-methods-in-net"></a><span data-ttu-id="99149-277">.NET 中的常见字符串比较方法</span><span class="sxs-lookup"><span data-stu-id="99149-277">Common string comparison methods in .NET</span></span>

<span data-ttu-id="99149-278">以下各节介绍最常用于执行字符串比较的方法。</span><span class="sxs-lookup"><span data-stu-id="99149-278">The following sections describe the methods that are most commonly used for string comparison.</span></span>

### <a name="stringcompare"></a><span data-ttu-id="99149-279">String.Compare</span><span class="sxs-lookup"><span data-stu-id="99149-279">String.Compare</span></span>

<span data-ttu-id="99149-280">默认解释： <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="99149-280">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="99149-281">作为字符串解释最核心的操作，应根据当前区域性检查这些方法调用的所有实例来确定是否应该从区域性（符号）解释或分离字符串。</span><span class="sxs-lookup"><span data-stu-id="99149-281">As the operation most central to string interpretation, all instances of these method calls should be examined to determine whether strings should be interpreted according to the current culture, or dissociated from the culture (symbolically).</span></span> <span data-ttu-id="99149-282">通常情况下，采用后者，并且应改用 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 比较。</span><span class="sxs-lookup"><span data-stu-id="99149-282">Typically, it is the latter, and a <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> comparison should be used instead.</span></span>

<span data-ttu-id="99149-283"><xref:System.Globalization.CompareInfo?displayProperty=nameWithType> 属性返回的 <xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> 类也包括利用 <xref:System.Globalization.CompareInfo.Compare%2A> 标记枚举的方式提供大量匹配选项（序号、忽略空白、忽略假名类型等）的 <xref:System.Globalization.CompareOptions> 方法。</span><span class="sxs-lookup"><span data-stu-id="99149-283">The <xref:System.Globalization.CompareInfo?displayProperty=nameWithType> class, which is returned by the <xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> property, also includes a <xref:System.Globalization.CompareInfo.Compare%2A> method that provides a large number of matching options (ordinal, ignoring white space, ignoring kana type, and so on) by means of the <xref:System.Globalization.CompareOptions> flag enumeration.</span></span>

### <a name="stringcompareto"></a><span data-ttu-id="99149-284">String.CompareTo</span><span class="sxs-lookup"><span data-stu-id="99149-284">String.CompareTo</span></span>

<span data-ttu-id="99149-285">默认解释： <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="99149-285">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="99149-286">此方法当前不提供指定 <xref:System.StringComparison> 类型的重载。</span><span class="sxs-lookup"><span data-stu-id="99149-286">This method does not currently offer an overload that specifies a <xref:System.StringComparison> type.</span></span> <span data-ttu-id="99149-287">通常可以将此方法转换为建议的 <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> 形式。</span><span class="sxs-lookup"><span data-stu-id="99149-287">It is usually possible to convert this method to the recommended <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> form.</span></span>

<span data-ttu-id="99149-288">实现 <xref:System.IComparable> 和 <xref:System.IComparable%601> 接口的类型实现此方法。</span><span class="sxs-lookup"><span data-stu-id="99149-288">Types that implement the <xref:System.IComparable> and <xref:System.IComparable%601> interfaces implement this method.</span></span> <span data-ttu-id="99149-289">由于它不提供 <xref:System.StringComparison> 参数选项，因此实现类型经常使用户在其构造函数中指定 <xref:System.StringComparer>。</span><span class="sxs-lookup"><span data-stu-id="99149-289">Because it does not offer the option of a <xref:System.StringComparison> parameter, implementing types often let the user specify a <xref:System.StringComparer> in their constructor.</span></span> <span data-ttu-id="99149-290">下面的示例定义 `FileName` 类，其类构造函数包括 <xref:System.StringComparer> 参数。</span><span class="sxs-lookup"><span data-stu-id="99149-290">The following example defines a `FileName` class whose class constructor includes a <xref:System.StringComparer> parameter.</span></span> <span data-ttu-id="99149-291">然后此 <xref:System.StringComparer> 对象将用于 `FileName.CompareTo` 方法。</span><span class="sxs-lookup"><span data-stu-id="99149-291">This <xref:System.StringComparer> object is then used in the `FileName.CompareTo` method.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#6](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/api1.cs#6)]
[!code-vb[Conceptual.Strings.BestPractices#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/api1.vb#6)]

### <a name="stringequals"></a><span data-ttu-id="99149-292">String.Equals</span><span class="sxs-lookup"><span data-stu-id="99149-292">String.Equals</span></span>

<span data-ttu-id="99149-293">默认解释： <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="99149-293">Default interpretation: <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="99149-294"><xref:System.String> 类可通过调用静态或实例 <xref:System.String.Equals%2A> 方法重载或使用静态相等运算符，测试是否相等。</span><span class="sxs-lookup"><span data-stu-id="99149-294">The <xref:System.String> class lets you test for equality by calling either the static or instance <xref:System.String.Equals%2A> method overloads, or by using the static equality operator.</span></span> <span data-ttu-id="99149-295">默认情况下，重载和运算符使用序号比较。</span><span class="sxs-lookup"><span data-stu-id="99149-295">The overloads and operator use ordinal comparison by default.</span></span> <span data-ttu-id="99149-296">但是，我们仍然建议调用显式指定 <xref:System.StringComparison> 类型的重载，即使想要执行序号比较；这将更轻松地搜索特定字符串解释的代码。</span><span class="sxs-lookup"><span data-stu-id="99149-296">However, we still recommend that you call an overload that explicitly specifies the <xref:System.StringComparison> type even if you want to perform an ordinal comparison; this makes it easier to search code for a certain string interpretation.</span></span>

### <a name="stringtoupper-and-stringtolower"></a><span data-ttu-id="99149-297">String.ToUpper 和 String.ToLower</span><span class="sxs-lookup"><span data-stu-id="99149-297">String.ToUpper and String.ToLower</span></span>

<span data-ttu-id="99149-298">默认解释： <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="99149-298">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="99149-299">应谨慎使用这些方法，因为将字符串强制为大写或小写经常用作在不考虑大小写的情况下比较字符串的较小规范化。</span><span class="sxs-lookup"><span data-stu-id="99149-299">You should be careful when you use these methods, because forcing a string to a uppercase or lowercase is often used as a small normalization for comparing strings regardless of case.</span></span> <span data-ttu-id="99149-300">如果是这样，请考虑使用不区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="99149-300">If so, consider using a case-insensitive comparison.</span></span>

<span data-ttu-id="99149-301">还可以使用 <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> 和 <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="99149-301">The <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> and <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> methods are also available.</span></span> <span data-ttu-id="99149-302"><xref:System.String.ToUpperInvariant%2A> 是规范化大小写的标准方式。</span><span class="sxs-lookup"><span data-stu-id="99149-302"><xref:System.String.ToUpperInvariant%2A> is the standard way to normalize case.</span></span> <span data-ttu-id="99149-303">使用 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 进行的比较在行为上是两个调用的组合：对两个字符串参数调用 <xref:System.String.ToUpperInvariant%2A> ，并使用 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>执行比较。</span><span class="sxs-lookup"><span data-stu-id="99149-303">Comparisons made using <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> are behaviorally the composition of two calls: calling <xref:System.String.ToUpperInvariant%2A> on both string arguments, and doing a comparison using <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="99149-304">通过向方法传递表示区域性的 <xref:System.Globalization.CultureInfo> 对象，重载也已可用于转换该特性区域性中的大写和小写字母。</span><span class="sxs-lookup"><span data-stu-id="99149-304">Overloads are also available for converting to uppercase and lowercase in a specific culture, by passing a <xref:System.Globalization.CultureInfo> object that represents that culture to the method.</span></span>

### <a name="chartoupper-and-chartolower"></a><span data-ttu-id="99149-305">Char.ToUpper 和 Char.ToLower</span><span class="sxs-lookup"><span data-stu-id="99149-305">Char.ToUpper and Char.ToLower</span></span>

<span data-ttu-id="99149-306">默认解释： <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="99149-306">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="99149-307">这些方法的工作原理类似于上一节中所述的 <xref:System.String.ToUpper%2A?displayProperty=nameWithType> 和 <xref:System.String.ToLower%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="99149-307">These methods work similarly to the <xref:System.String.ToUpper%2A?displayProperty=nameWithType> and <xref:System.String.ToLower%2A?displayProperty=nameWithType> methods described in the previous section.</span></span>

### <a name="stringstartswith-and-stringendswith"></a><span data-ttu-id="99149-308">String.StartsWith 和 String.EndsWith</span><span class="sxs-lookup"><span data-stu-id="99149-308">String.StartsWith and String.EndsWith</span></span>

<span data-ttu-id="99149-309">默认解释： <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="99149-309">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="99149-310">默认情况下，这两种方法执行区分区域性的比较。</span><span class="sxs-lookup"><span data-stu-id="99149-310">By default, both of these methods perform a culture-sensitive comparison.</span></span>

### <a name="stringindexof-and-stringlastindexof"></a><span data-ttu-id="99149-311">String.IndexOf 和 String.LastIndexOf</span><span class="sxs-lookup"><span data-stu-id="99149-311">String.IndexOf and String.LastIndexOf</span></span>

<span data-ttu-id="99149-312">默认解释： <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="99149-312">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="99149-313">这些方法的默认重载如何执行比较方面缺乏一致性。</span><span class="sxs-lookup"><span data-stu-id="99149-313">There is a lack of consistency in how the default overloads of these methods perform comparisons.</span></span> <span data-ttu-id="99149-314">包含 <xref:System.String.IndexOf%2A?displayProperty=nameWithType> 参数的所有 <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> 和 <xref:System.Char> 方法都执行序号比较，但是包含 <xref:System.String.IndexOf%2A?displayProperty=nameWithType> 参数的默认 <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> 和 <xref:System.String> 方法都执行区分区域性的比较。</span><span class="sxs-lookup"><span data-stu-id="99149-314">All <xref:System.String.IndexOf%2A?displayProperty=nameWithType> and <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> methods that include a <xref:System.Char> parameter perform an ordinal comparison, but the default <xref:System.String.IndexOf%2A?displayProperty=nameWithType> and <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> methods that include a <xref:System.String> parameter perform a culture-sensitive comparison.</span></span>

<span data-ttu-id="99149-315">如果调用 <xref:System.String.IndexOf%28System.String%29?displayProperty=nameWithType> 或 <xref:System.String.LastIndexOf%28System.String%29?displayProperty=nameWithType> 方法并向其传递一个字符串以在当前实例中查找，那么我们建议调用显式指定 <xref:System.StringComparison> 类型的重载。</span><span class="sxs-lookup"><span data-stu-id="99149-315">If you call the <xref:System.String.IndexOf%28System.String%29?displayProperty=nameWithType> or <xref:System.String.LastIndexOf%28System.String%29?displayProperty=nameWithType> method and pass it a string to locate in the current instance, we recommend that you call an overload that explicitly specifies the <xref:System.StringComparison> type.</span></span> <span data-ttu-id="99149-316">包括 <xref:System.Char> 参数的重载不允许指定 <xref:System.StringComparison> 类型。</span><span class="sxs-lookup"><span data-stu-id="99149-316">The overloads that include a <xref:System.Char> argument do not allow you to specify a <xref:System.StringComparison> type.</span></span>

## <a name="methods-that-perform-string-comparison-indirectly"></a><span data-ttu-id="99149-317">间接执行字符串比较的方法</span><span class="sxs-lookup"><span data-stu-id="99149-317">Methods that perform string comparison indirectly</span></span>

<span data-ttu-id="99149-318">将字符串比较作为核心操作的一些非字符串方法使用 <xref:System.StringComparer> 类型。</span><span class="sxs-lookup"><span data-stu-id="99149-318">Some non-string methods that have string comparison as a central operation use the <xref:System.StringComparer> type.</span></span> <span data-ttu-id="99149-319"><xref:System.StringComparer> 类型包含六个返回 <xref:System.StringComparer> 实例的静态属性，这些实例的 <xref:System.StringComparer.Compare%2A?displayProperty=nameWithType> 方法可执行以下类型的字符串比较：</span><span class="sxs-lookup"><span data-stu-id="99149-319">The <xref:System.StringComparer> class includes six static properties that return <xref:System.StringComparer> instances whose <xref:System.StringComparer.Compare%2A?displayProperty=nameWithType> methods perform the following types of string comparisons:</span></span>

- <span data-ttu-id="99149-320">使用当前区域性的区分区域性的字符串比较。</span><span class="sxs-lookup"><span data-stu-id="99149-320">Culture-sensitive string comparisons using the current culture.</span></span> <span data-ttu-id="99149-321">此 <xref:System.StringComparer> 对象由 <xref:System.StringComparer.CurrentCulture%2A?displayProperty=nameWithType> 属性返回。</span><span class="sxs-lookup"><span data-stu-id="99149-321">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.CurrentCulture%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="99149-322">使用当前区域性的不区分区域性的比较。</span><span class="sxs-lookup"><span data-stu-id="99149-322">Case-insensitive comparisons using the current culture.</span></span> <span data-ttu-id="99149-323">此 <xref:System.StringComparer> 对象由 <xref:System.StringComparer.CurrentCultureIgnoreCase%2A?displayProperty=nameWithType> 属性返回。</span><span class="sxs-lookup"><span data-stu-id="99149-323">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.CurrentCultureIgnoreCase%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="99149-324">使用固定区域性的单词比较规则的不区分区域性的比较。</span><span class="sxs-lookup"><span data-stu-id="99149-324">Culture-insensitive comparisons using the word comparison rules of the invariant culture.</span></span> <span data-ttu-id="99149-325">此 <xref:System.StringComparer> 对象由 <xref:System.StringComparer.InvariantCulture%2A?displayProperty=nameWithType> 属性返回。</span><span class="sxs-lookup"><span data-stu-id="99149-325">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="99149-326">使用固定区域性的单词比较规则的不区分大小写和不区分区域性的比较。</span><span class="sxs-lookup"><span data-stu-id="99149-326">Case-insensitive and culture-insensitive comparisons using the word comparison rules of the invariant culture.</span></span> <span data-ttu-id="99149-327">此 <xref:System.StringComparer> 对象由 <xref:System.StringComparer.InvariantCultureIgnoreCase%2A?displayProperty=nameWithType> 属性返回。</span><span class="sxs-lookup"><span data-stu-id="99149-327">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.InvariantCultureIgnoreCase%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="99149-328">序号比较。</span><span class="sxs-lookup"><span data-stu-id="99149-328">Ordinal comparison.</span></span> <span data-ttu-id="99149-329">此 <xref:System.StringComparer> 对象由 <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> 属性返回。</span><span class="sxs-lookup"><span data-stu-id="99149-329">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="99149-330">不区分大小写的序号比较。</span><span class="sxs-lookup"><span data-stu-id="99149-330">Case-insensitive ordinal comparison.</span></span> <span data-ttu-id="99149-331">此 <xref:System.StringComparer> 对象由 <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> 属性返回。</span><span class="sxs-lookup"><span data-stu-id="99149-331">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> property.</span></span>

### <a name="arraysort-and-arraybinarysearch"></a><span data-ttu-id="99149-332">Array.Sort 和 Array.BinarySearch</span><span class="sxs-lookup"><span data-stu-id="99149-332">Array.Sort and Array.BinarySearch</span></span>

<span data-ttu-id="99149-333">默认解释： <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="99149-333">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="99149-334">当在集合中存储任何数据，或将持久数据从文件或数据库中读取到集合中时，切换当前区域性可能会使集合中的固定条件无效。</span><span class="sxs-lookup"><span data-stu-id="99149-334">When you store any data in a collection, or read persisted data from a file or database into a collection, switching the current culture can invalidate the invariants in the collection.</span></span> <span data-ttu-id="99149-335"><xref:System.Array.BinarySearch%2A?displayProperty=nameWithType> 方法假定已对数组中要搜索的元素排序。</span><span class="sxs-lookup"><span data-stu-id="99149-335">The <xref:System.Array.BinarySearch%2A?displayProperty=nameWithType> method assumes that the elements in the array to be searched are already sorted.</span></span> <span data-ttu-id="99149-336">若要对数组中的任何字符串元素进行排序， <xref:System.Array.Sort%2A?displayProperty=nameWithType> 方法会调用 <xref:System.String.Compare%2A?displayProperty=nameWithType> 方法以对各个元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="99149-336">To sort any string element in the array, the <xref:System.Array.Sort%2A?displayProperty=nameWithType> method calls the <xref:System.String.Compare%2A?displayProperty=nameWithType> method to order individual elements.</span></span> <span data-ttu-id="99149-337">如果对数组进行排序和搜索其内容的时间范围内区域性发生变化，那么使用区分区域性的比较器会很危险。</span><span class="sxs-lookup"><span data-stu-id="99149-337">Using a culture-sensitive comparer can be dangerous if the culture changes between the time that the array is sorted and its contents are searched.</span></span> <span data-ttu-id="99149-338">例如在下面的代码中，是在由 `Thread.CurrentThread.CurrentCulture` 属性。</span><span class="sxs-lookup"><span data-stu-id="99149-338">For example, in the following code, storage and retrieval operate on the comparer that is provided implicitly by the `Thread.CurrentThread.CurrentCulture` property.</span></span> <span data-ttu-id="99149-339">如果在调用 `StoreNames` 和 `DoesNameExist`之间更改了区域性（尤其是数组内容保存在两个方法调用之间的某个位置），那么二进制搜索可能会失败。</span><span class="sxs-lookup"><span data-stu-id="99149-339">If the culture can change between the calls to `StoreNames` and `DoesNameExist`, and especially if the array contents are persisted somewhere between the two method calls, the binary search may fail.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#7](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/indirect1.cs#7)]
 [!code-vb[Conceptual.Strings.BestPractices#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/indirect1.vb#7)]

<span data-ttu-id="99149-340">建议的变体将显示在下面使用相同序号（不区分区域性）比较方法进行排序并搜索数组的示例中。</span><span class="sxs-lookup"><span data-stu-id="99149-340">A recommended variation appears in the following example, which uses the same ordinal (culture-insensitive) comparison method both to sort and to search the array.</span></span> <span data-ttu-id="99149-341">在这两个示例中，更改代码会反映在标记 `Line A` 和 `Line B` 的代码行中。</span><span class="sxs-lookup"><span data-stu-id="99149-341">The change code is reflected in the lines labeled `Line A` and `Line B` in the two examples.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#8](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/indirect1.cs#8)]
[!code-vb[Conceptual.Strings.BestPractices#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/indirect1.vb#8)]

<span data-ttu-id="99149-342">如果此数据永久保留并跨区域性移动，并且使用排序来向用户显示此数据，则可以考虑使用 <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>，其语言操作可获得更好的用户输出且不受区域性更改的影响。</span><span class="sxs-lookup"><span data-stu-id="99149-342">If this data is persisted and moved across cultures, and sorting is used to present this data to the user, you might consider using <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, which operates linguistically for better user output but is unaffected by changes in culture.</span></span> <span data-ttu-id="99149-343">下面的示例修改了前面两个示例，使用固定区域性对数组进行排序和搜索。</span><span class="sxs-lookup"><span data-stu-id="99149-343">The following example modifies the two previous examples to use the invariant culture for sorting and searching the array.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#9](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/indirect1.cs#9)]
[!code-vb[Conceptual.Strings.BestPractices#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/indirect1.vb#9)]

### <a name="collections-example-hashtable-constructor"></a><span data-ttu-id="99149-344">集合示例：哈希表构造函数</span><span class="sxs-lookup"><span data-stu-id="99149-344">Collections example: Hashtable constructor</span></span>

<span data-ttu-id="99149-345">哈希字符串提供了第二个运算示例，该运算受比较字符串的方式影响。</span><span class="sxs-lookup"><span data-stu-id="99149-345">Hashing strings provides a second example of an operation that is affected by the way in which strings are compared.</span></span>

<span data-ttu-id="99149-346">下面的示例实例化 <xref:System.Collections.Hashtable> 对象，方法是向其传递由 <xref:System.StringComparer> 属性返回的 <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> 对象。</span><span class="sxs-lookup"><span data-stu-id="99149-346">The following example instantiates a <xref:System.Collections.Hashtable> object by passing it the <xref:System.StringComparer> object that is returned by the <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="99149-347">由于派生自 <xref:System.StringComparer> 的类 <xref:System.StringComparer> 实现 <xref:System.Collections.IEqualityComparer> 接口，其 <xref:System.Collections.IEqualityComparer.GetHashCode%2A> 方法用于计算哈希表中的字符串的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="99149-347">Because a class <xref:System.StringComparer> that is derived from <xref:System.StringComparer> implements the <xref:System.Collections.IEqualityComparer> interface, its <xref:System.Collections.IEqualityComparer.GetHashCode%2A> method is used to compute the hash code of strings in the hash table.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#10](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/indirect2.cs#10)]
[!code-vb[Conceptual.Strings.BestPractices#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/indirect2.vb#10)]

## <a name="displaying-and-persisting-formatted-data"></a><span data-ttu-id="99149-348">显示和保存有格式的数据</span><span class="sxs-lookup"><span data-stu-id="99149-348">Displaying and persisting formatted data</span></span>

<span data-ttu-id="99149-349">当给用户显示非字符串数据（如数字、日期和时间）时，使用用户的区域性设置来格式化他们。</span><span class="sxs-lookup"><span data-stu-id="99149-349">When you display non-string data such as numbers and dates and times to users, format them by using the user's cultural settings.</span></span> <span data-ttu-id="99149-350">默认情况下，以下所有内容都在格式设置操作中使用当前线程区域性：</span><span class="sxs-lookup"><span data-stu-id="99149-350">By default, the following all use the current thread culture in formatting operations:</span></span>

- <span data-ttu-id="99149-351">[C#](../../csharp/language-reference/tokens/interpolated.md) 和 [Visual Basic](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md) 编译器支持的内插字符串。</span><span class="sxs-lookup"><span data-stu-id="99149-351">Interpolated strings supported by the [C#](../../csharp/language-reference/tokens/interpolated.md) and [Visual Basic](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md) compilers.</span></span>
- <span data-ttu-id="99149-352">字符串串联操作，它使用 [C#](../../csharp/language-reference/operators/addition-operator.md#string-concatenation) 或 [Visual Basic](../../visual-basic/programming-guide/language-features/operators-and-expressions/concatenation-operators.md) 串联运算符或直接调用 <xref:System.String.Concat%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="99149-352">String concatenation operations that use the [C#](../../csharp/language-reference/operators/addition-operator.md#string-concatenation) or [Visual Basic](../../visual-basic/programming-guide/language-features/operators-and-expressions/concatenation-operators.md) concatenation operators or that call the <xref:System.String.Concat%2A?displayProperty=nameWithType> method directly.</span></span>
- <span data-ttu-id="99149-353"><xref:System.String.Format%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="99149-353">The <xref:System.String.Format%2A?displayProperty=nameWithType> method.</span></span>
- <span data-ttu-id="99149-354">数值类型的 `ToString` 方法以及日期和时间类型。</span><span class="sxs-lookup"><span data-stu-id="99149-354">The `ToString` methods of the numeric types and the date and time types.</span></span>

<span data-ttu-id="99149-355">若要显式指定应使用指定区域性约定或[固定区域性](xref:System.Globalization.CultureInfo.InvariantCulture)设置字符串的格式，可以执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="99149-355">To explicitly specify that a string should be formatted by using the conventions of a designated culture or the [invariant culture](xref:System.Globalization.CultureInfo.InvariantCulture), you can do the following:</span></span>

- <span data-ttu-id="99149-356">当使用 <xref:System.String.Format%2A?displayProperty=nameWithType> 和 `ToString` 方法时，调用具有 `provider` 参数（如 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> 或 <xref:System.DateTime.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>）的重载，并将 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 属性（表示所需区域性的 <xref:System.Globalization.CultureInfo> 实例）或 <xref:System.Globalization.CultureInfo.InvariantCulture?displayProperty=nameWithType> 属性传递给它。</span><span class="sxs-lookup"><span data-stu-id="99149-356">When using the <xref:System.String.Format%2A?displayProperty=nameWithType> and `ToString` methods, call an overload that has a `provider` parameter, such as <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> or <xref:System.DateTime.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, and pass it the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property, a <xref:System.Globalization.CultureInfo> instance that represents the desired culture, or the <xref:System.Globalization.CultureInfo.InvariantCulture?displayProperty=nameWithType> property.</span></span>

- <span data-ttu-id="99149-357">对于字符串串联，不允许编译器执行任何隐式转换。</span><span class="sxs-lookup"><span data-stu-id="99149-357">For string concatenation, do not allow the compiler to perform any implicit conversions.</span></span> <span data-ttu-id="99149-358">可通过调用具有 `provider` 参数的 `ToString` 重载来执行显式转换。</span><span class="sxs-lookup"><span data-stu-id="99149-358">Instead, perform an explicit conversion by calling a `ToString` overload that has a `provider` parameter.</span></span> <span data-ttu-id="99149-359">例如，在将 <xref:System.Double> 值转换为以下代码中的字符串时，编译器隐式使用当前区域性：</span><span class="sxs-lookup"><span data-stu-id="99149-359">For example, the compiler implicitly uses the current culture when converting a <xref:System.Double> value to a string in the following code:</span></span>

  [!code-csharp[Implicit String Conversion](./snippets/best-practices-strings/csharp/tostring/Program.cs#1)]
  [!code-vb[Implicit String Conversion](./snippets/best-practices-strings/vb/tostring/Program.vb#1)]

  <span data-ttu-id="99149-360">可以通过调用 <xref:System.Double.ToString(System.IFormatProvider)?displayProperty=nameWithType> 方法显式指定在转换中使用格式约定的区域性，如下面的代码所示：</span><span class="sxs-lookup"><span data-stu-id="99149-360">Instead, you can explicitly specify the culture whose formatting conventions are used in the conversion by calling the <xref:System.Double.ToString(System.IFormatProvider)?displayProperty=nameWithType> method, as the following code does:</span></span>

  [!code-csharp[Explicit String Conversion](./snippets/best-practices-strings/csharp/tostring/Program.cs#2)]
  [!code-vb[Implicit String Conversion](./snippets/best-practices-strings/vb/tostring/Program.vb#2)]

- <span data-ttu-id="99149-361">对于字符串内插，不是将内插字符串分配给 <xref:System.String> 实例，而是将其分配给 <xref:System.FormattableString>。</span><span class="sxs-lookup"><span data-stu-id="99149-361">For string interpolation, rather than assigning an interpolated string to a <xref:System.String> instance, assign it to a <xref:System.FormattableString>.</span></span> <span data-ttu-id="99149-362">然后，可以调用其 <xref:System.FormattableString.ToString?displayProperty=nameWithType> 方法生成反映当前区域性约定的结果字符串，也可以调用 <xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType> 方法生成反映指定区域性约定的结果字符串。</span><span class="sxs-lookup"><span data-stu-id="99149-362">You can then call its <xref:System.FormattableString.ToString?displayProperty=nameWithType> method produce a result string that reflects the conventions of the current culture, or you can call the <xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType> method to produce a result string that reflects the conventions of a specified culture.</span></span> <span data-ttu-id="99149-363">还可以将可格式化字符串传递给静态 <xref:System.FormattableString.Invariant%2A?displayProperty=nameWithType> 方法，以生成反映固定区域性约定的结果字符串。</span><span class="sxs-lookup"><span data-stu-id="99149-363">You can also pass the formattable string to the static <xref:System.FormattableString.Invariant%2A?displayProperty=nameWithType> method to produce a result string that reflects the conventions of the invariant culture.</span></span> <span data-ttu-id="99149-364">下面的示例阐释了这种方法。</span><span class="sxs-lookup"><span data-stu-id="99149-364">The following example illustrates this approach.</span></span> <span data-ttu-id="99149-365">（该示例的输出反映了当前的 zh-CN 区域性。）</span><span class="sxs-lookup"><span data-stu-id="99149-365">(The output from the example reflects a current culture of en-US.)</span></span>

  [!code-csharp[String interpolation](./snippets/best-practices-strings/csharp/formattable/Program.cs)]
  [!code-vb[String interpolation](./snippets/best-practices-strings/vb/formattable/Program.vb)]

<span data-ttu-id="99149-366">您可以保留非字符串数据作为二进制数据或作为格式化数据。</span><span class="sxs-lookup"><span data-stu-id="99149-366">You can persist non-string data either as binary data or as formatted data.</span></span> <span data-ttu-id="99149-367">如果您选择将其保存为格式化数据，您应调用包括 `provider` 参数的格式设置方法重载，并向其传递 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="99149-367">If you choose to save it as formatted data, you should call a formatting method overload that includes a `provider` parameter and pass it the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="99149-368">固定区域性为独立于区域性和计算机的格式化数据提供一致的格式。</span><span class="sxs-lookup"><span data-stu-id="99149-368">The invariant culture provides a consistent format for formatted data that is independent of culture and machine.</span></span> <span data-ttu-id="99149-369">相反，使用区域性而非固定区域性进行格式化的持久性数据具有许多限制：</span><span class="sxs-lookup"><span data-stu-id="99149-369">In contrast, persisting data that is formatted by using cultures other than the invariant culture has a number of limitations:</span></span>

- <span data-ttu-id="99149-370">如果在具有不同区域性的系统上检索数据，或者如果当前系统用户更改当前区域性或者尝试检索数据时，该数据可能不可用。</span><span class="sxs-lookup"><span data-stu-id="99149-370">The data is likely to be unusable if it is retrieved on a system that has a different culture, or if the user of the current system changes the current culture and tries to retrieve the data.</span></span>
- <span data-ttu-id="99149-371">特定计算机上的区域性属性可能与标准值不同。</span><span class="sxs-lookup"><span data-stu-id="99149-371">The properties of a culture on a specific computer can differ from standard values.</span></span> <span data-ttu-id="99149-372">任何时候，用户都可以自定义区分区域性的显示设置。</span><span class="sxs-lookup"><span data-stu-id="99149-372">At any time, a user can customize culture-sensitive display settings.</span></span> <span data-ttu-id="99149-373">因此，在系统保存的格式化数据在用户自定义区域性设置之后可能无法读取。</span><span class="sxs-lookup"><span data-stu-id="99149-373">Because of this, formatted data that is saved on a system may not be readable after the user customizes cultural settings.</span></span> <span data-ttu-id="99149-374">格式化数据在计算机之间移植可能会受到更多的限制。</span><span class="sxs-lookup"><span data-stu-id="99149-374">The portability of formatted data across computers is likely to be even more limited.</span></span>
- <span data-ttu-id="99149-375">管理数值或日期时间格式的国际、区域或国家标准会随着时间发生更改，这些更改会合并到 Windows 操作系统更新中。</span><span class="sxs-lookup"><span data-stu-id="99149-375">International, regional, or national standards that govern the formatting of numbers or dates and times change over time, and these changes are incorporated into Windows operating system updates.</span></span> <span data-ttu-id="99149-376">在格式设置约定更改时，将无法读取使用以前的约定格式化的数据。</span><span class="sxs-lookup"><span data-stu-id="99149-376">When formatting conventions change, data that was formatted by using the previous conventions may become unreadable.</span></span>

<span data-ttu-id="99149-377">下面的示例演示了使用区分区域性格式设置进行持久化数据导致的有限可移植性。</span><span class="sxs-lookup"><span data-stu-id="99149-377">The following example illustrates the limited portability that results from using culture-sensitive formatting to persist data.</span></span> <span data-ttu-id="99149-378">该示例将日期和时间数组值保存到文件中。</span><span class="sxs-lookup"><span data-stu-id="99149-378">The example saves an array of date and time values to a file.</span></span> <span data-ttu-id="99149-379">这些数据通过使用英语（美国）区域性约定进行格式化。</span><span class="sxs-lookup"><span data-stu-id="99149-379">These are formatted by using the conventions of the English (United States) culture.</span></span> <span data-ttu-id="99149-380">在应用程序将当前线程区域性更改为法语（瑞士）后，它尝试使用当前区域性的格式设置约定来读取保存的值。</span><span class="sxs-lookup"><span data-stu-id="99149-380">After the application changes the current thread culture to French (Switzerland), it tries to read the saved values by using the formatting conventions of the current culture.</span></span> <span data-ttu-id="99149-381">尝试读取两个数据条目时引发 <xref:System.FormatException> 异常，现在日期数组包含相当于 <xref:System.DateTime.MinValue>的两个错误元素。</span><span class="sxs-lookup"><span data-stu-id="99149-381">The attempt to read two of the data items throws a <xref:System.FormatException> exception, and the array of dates now contains two incorrect elements that are equal to <xref:System.DateTime.MinValue>.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#21](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/persistence.cs#21)]
[!code-vb[Conceptual.Strings.BestPractices#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/persistence.vb#21)]

<span data-ttu-id="99149-382">然而，如果你在对 <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 和 <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 的调用中将 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 属性替换为 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>，则会成功还原持久的日期和时间数据，如以下输出所示：</span><span class="sxs-lookup"><span data-stu-id="99149-382">However, if you replace the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property with <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> in the calls to <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> and <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>,   the persisted date and time data is successfully restored, as the following output shows:</span></span>

```console
06.05.1758 21:26
05.05.1818 07:19
22.04.1870 23:54
08.09.1890 06:47
18.02.1905 15:12
```
