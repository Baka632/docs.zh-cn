---
title: 托管执行过程
ms.date: 03/30/2017
helpviewer_keywords:
- source code language
- code, managed execution process
- runtime, managed execution process
- compiling source code, managed execution process
- managed execution process
- common language runtime, managed execution process
ms.assetid: 476b03dc-2b12-49a7-b067-41caeaa2f533
ms.openlocfilehash: 17494c3b5620ac649aeb3e6ef73085097517d1f5
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/18/2020
ms.locfileid: "94830670"
---
# <a name="managed-execution-process"></a><span data-ttu-id="af5dc-102">托管执行过程</span><span class="sxs-lookup"><span data-stu-id="af5dc-102">Managed Execution Process</span></span>
<a name="introduction"></a> <span data-ttu-id="af5dc-103">托管的执行过程包括以下步骤，在本主题后面将对此进行详细讨论：</span><span class="sxs-lookup"><span data-stu-id="af5dc-103">The managed execution process includes the following steps, which are discussed in detail later in this topic:</span></span>

1. <span data-ttu-id="af5dc-104">[选择编译器](#choosing_a_compiler)。</span><span class="sxs-lookup"><span data-stu-id="af5dc-104">[Choosing a compiler](#choosing_a_compiler).</span></span>

     <span data-ttu-id="af5dc-105">若要获取公共语言运行时提供的好处，必须使用一个或多个面向运行时的语言编译器。</span><span class="sxs-lookup"><span data-stu-id="af5dc-105">To obtain the benefits provided by the common language runtime, you must use one or more language compilers that target the runtime.</span></span>

2. <span data-ttu-id="af5dc-106">[将代码编译为 MSIL](#compiling_to_msil)。</span><span class="sxs-lookup"><span data-stu-id="af5dc-106">[Compiling your code to MSIL](#compiling_to_msil).</span></span>

     <span data-ttu-id="af5dc-107">编译将你的源代码转换为 Microsoft 中间语言 (MSIL) 并生成必需的元数据。</span><span class="sxs-lookup"><span data-stu-id="af5dc-107">Compiling translates your source code into Microsoft intermediate language (MSIL) and generates the required metadata.</span></span>

3. <span data-ttu-id="af5dc-108">[将 MSIL 编译为本机代码](#compiling_msil_to_native_code)。</span><span class="sxs-lookup"><span data-stu-id="af5dc-108">[Compiling MSIL to native code](#compiling_msil_to_native_code).</span></span>

     <span data-ttu-id="af5dc-109">在执行时，实时 (JIT) 编译器将 MSIL 转换为本机代码。</span><span class="sxs-lookup"><span data-stu-id="af5dc-109">At execution time, a just-in-time (JIT) compiler translates the MSIL into native code.</span></span> <span data-ttu-id="af5dc-110">在此编译期间，代码必须通过检查 MSIL 和元数据的验证过程以查明是否可以将代码确定为类型安全。</span><span class="sxs-lookup"><span data-stu-id="af5dc-110">During this compilation, code must pass a verification process that examines the MSIL and metadata to find out whether the code can be determined to be type safe.</span></span>

4. <span data-ttu-id="af5dc-111">[运行代码](#running_code)。</span><span class="sxs-lookup"><span data-stu-id="af5dc-111">[Running code](#running_code).</span></span>

     <span data-ttu-id="af5dc-112">公共语言运行时提供启用要发生的执行的基础结构以及执行期间可使用的服务。</span><span class="sxs-lookup"><span data-stu-id="af5dc-112">The common language runtime provides the infrastructure that enables execution to take place and services that can be used during execution.</span></span>

<a name="choosing_a_compiler"></a>
## <a name="choosing-a-compiler"></a><span data-ttu-id="af5dc-113">选择编译器</span><span class="sxs-lookup"><span data-stu-id="af5dc-113">Choosing a Compiler</span></span>
 <span data-ttu-id="af5dc-114">若要获取公共语言运行时 (CLR) 提供的好处，必须使用一个或多个面向运行时的语言编译器，如 Visual Basic、C#、Visual C++、F# 或众多第三方编译器之一，如 Eiffel、Perl 或 COBOL 编译器。</span><span class="sxs-lookup"><span data-stu-id="af5dc-114">To obtain the benefits provided by the common language runtime (CLR), you must use one or more language compilers that target the runtime, such as Visual Basic, C#, Visual C++, F#, or one of many third-party compilers such as an Eiffel, Perl, or COBOL compiler.</span></span>

 <span data-ttu-id="af5dc-115">因为它是一个多语言的执行环境，运行时支持各种各样的数据类型和语言功能。</span><span class="sxs-lookup"><span data-stu-id="af5dc-115">Because it is a multilanguage execution environment, the runtime supports a wide variety of data types and language features.</span></span> <span data-ttu-id="af5dc-116">你使用的语言编译器确定哪些运行时功能是可用的，并且可以使用这些功能设计你的代码。</span><span class="sxs-lookup"><span data-stu-id="af5dc-116">The language compiler you use determines which runtime features are available, and you design your code using those features.</span></span> <span data-ttu-id="af5dc-117">编译器（而非运行时）设定代码必须使用的语法。</span><span class="sxs-lookup"><span data-stu-id="af5dc-117">Your compiler, not the runtime, establishes the syntax your code must use.</span></span> <span data-ttu-id="af5dc-118">如果组件必须完全可供以其他语言编写的组件使用，则组件的导出类型必须仅公开 [Language Independence and Language-Independent Components](language-independence-and-language-independent-components.md) (CLS) 中包含的语言功能。</span><span class="sxs-lookup"><span data-stu-id="af5dc-118">If your component must be completely usable by components written in other languages, your component's exported types must expose only language features that are included in the [Language Independence and Language-Independent Components](language-independence-and-language-independent-components.md) (CLS).</span></span> <span data-ttu-id="af5dc-119">可以使用 <xref:System.CLSCompliantAttribute> 属性来确保你的代码符合 CLS。</span><span class="sxs-lookup"><span data-stu-id="af5dc-119">You can use the <xref:System.CLSCompliantAttribute> attribute to ensure that your code is CLS-compliant.</span></span> <span data-ttu-id="af5dc-120">有关详细信息，请参阅 “[语言独立性和与语言无关的组件](language-independence-and-language-independent-components.md)”。</span><span class="sxs-lookup"><span data-stu-id="af5dc-120">For more information, see [Language Independence and Language-Independent Components](language-independence-and-language-independent-components.md).</span></span>

 [<span data-ttu-id="af5dc-121">返回页首</span><span class="sxs-lookup"><span data-stu-id="af5dc-121">Back to top</span></span>](#introduction)

<a name="compiling_to_msil"></a>
## <a name="compiling-to-msil"></a><span data-ttu-id="af5dc-122">编译为 MSIL</span><span class="sxs-lookup"><span data-stu-id="af5dc-122">Compiling to MSIL</span></span>
 <span data-ttu-id="af5dc-123">编译为托管代码时，编译器将源代码转换为 Microsoft 中间语言 (MSIL)，这是一组独立于 CPU 且可以有效地转换为本机代码的说明。</span><span class="sxs-lookup"><span data-stu-id="af5dc-123">When compiling to managed code, the compiler translates your source code into Microsoft intermediate language (MSIL), which is a CPU-independent set of instructions that can be efficiently converted to native code.</span></span> <span data-ttu-id="af5dc-124">MSIL 包括有关加载、存储、初始化和调用对象方法的说明，以及有关算术和逻辑运算、控制流、直接内存访问、异常处理和其他操作的说明。</span><span class="sxs-lookup"><span data-stu-id="af5dc-124">MSIL includes instructions for loading, storing, initializing, and calling methods on objects, as well as instructions for arithmetic and logical operations, control flow, direct memory access, exception handling, and other operations.</span></span> <span data-ttu-id="af5dc-125">代码可以运行之前，必须将 MSIL 转换为特定于 CPU 的代码，通常通过 [实时 (JIT) 编译器](#compiling_msil_to_native_code)实现。</span><span class="sxs-lookup"><span data-stu-id="af5dc-125">Before code can be run, MSIL must be converted to CPU-specific code, usually by a [just-in-time (JIT) compiler](#compiling_msil_to_native_code).</span></span> <span data-ttu-id="af5dc-126">由于公共语言运行时为其支持的每个计算机基础结构提供一个或多个 JIT 编译器，同一组的 MSIL 可以在任何受支持的基础结构上进行 JIT 编译和运行。</span><span class="sxs-lookup"><span data-stu-id="af5dc-126">Because the common language runtime supplies one or more JIT compilers for each computer architecture it supports, the same set of MSIL can be JIT-compiled and run on any supported architecture.</span></span>

 <span data-ttu-id="af5dc-127">当编译器生成 MSIL 时，它还生成元数据。</span><span class="sxs-lookup"><span data-stu-id="af5dc-127">When a compiler produces MSIL, it also produces metadata.</span></span> <span data-ttu-id="af5dc-128">元数据描述代码中的类型，包括每种类型的定义、每种类型的成员的签名、代码引用的成员以及运行时在执行时间使用的其他数据。</span><span class="sxs-lookup"><span data-stu-id="af5dc-128">Metadata describes the types in your code, including the definition of each type, the signatures of each type's members, the members that your code references, and other data that the runtime uses at execution time.</span></span> <span data-ttu-id="af5dc-129">MSIL 和元数据包含在一个可移植的可执行 (PE) 文件中，该文件基于且扩展已发布的 Microsoft PE 和历来用于可执行内容的通用对象文件格式 (COFF)。</span><span class="sxs-lookup"><span data-stu-id="af5dc-129">The MSIL and metadata are contained in a portable executable (PE) file that is based on and that extends the published Microsoft PE and common object file format (COFF) used historically for executable content.</span></span> <span data-ttu-id="af5dc-130">容纳 MSIL 或本机代码以及元数据的这种文件格式使操作系统能够识别公共语言运行时映像。</span><span class="sxs-lookup"><span data-stu-id="af5dc-130">This file format, which accommodates MSIL or native code as well as metadata, enables the operating system to recognize common language runtime images.</span></span> <span data-ttu-id="af5dc-131">文件中元数据的存在以及 MSIL 使代码能够描述自身，这意味着将不需要类型库或接口定义语言 (IDL)。</span><span class="sxs-lookup"><span data-stu-id="af5dc-131">The presence of metadata in the file together with MSIL enables your code to describe itself, which means that there is no need for type libraries or Interface Definition Language (IDL).</span></span> <span data-ttu-id="af5dc-132">运行时在执行期间会根据需要从文件中查找并提取元数据。</span><span class="sxs-lookup"><span data-stu-id="af5dc-132">The runtime locates and extracts the metadata from the file as needed during execution.</span></span>

 [<span data-ttu-id="af5dc-133">返回页首</span><span class="sxs-lookup"><span data-stu-id="af5dc-133">Back to top</span></span>](#introduction)

<a name="compiling_msil_to_native_code"></a>
## <a name="compiling-msil-to-native-code"></a><span data-ttu-id="af5dc-134">将 MSIL 编译为本机代码</span><span class="sxs-lookup"><span data-stu-id="af5dc-134">Compiling MSIL to Native Code</span></span>
 <span data-ttu-id="af5dc-135">运行 Microsoft 中间语言 (MSIL) 前，必须根据公共语言运行时将其编译为目标计算机基础结构的本机代码。</span><span class="sxs-lookup"><span data-stu-id="af5dc-135">Before you can run Microsoft intermediate language (MSIL), it must be compiled against the common language runtime to native code for the target machine architecture.</span></span> <span data-ttu-id="af5dc-136">.NET 提供两种方法来执行此转换：</span><span class="sxs-lookup"><span data-stu-id="af5dc-136">.NET provides two ways to perform this conversion:</span></span>

- <span data-ttu-id="af5dc-137">.NET 实时 (JIT) 编译器。</span><span class="sxs-lookup"><span data-stu-id="af5dc-137">A .NET just-in-time (JIT) compiler.</span></span>

- <span data-ttu-id="af5dc-138">[Ngen.exe（本机映像生成器）](../framework/tools/ngen-exe-native-image-generator.md)。</span><span class="sxs-lookup"><span data-stu-id="af5dc-138">[Ngen.exe (Native Image Generator)](../framework/tools/ngen-exe-native-image-generator.md).</span></span>

### <a name="compilation-by-the-jit-compiler"></a><span data-ttu-id="af5dc-139">由 JIT 编译器编译</span><span class="sxs-lookup"><span data-stu-id="af5dc-139">Compilation by the JIT Compiler</span></span>
 <span data-ttu-id="af5dc-140">在加载和执行程序集的内容时，JIT 编译在应用程序运行时按需将 MSIL 转换为本机代码。</span><span class="sxs-lookup"><span data-stu-id="af5dc-140">JIT compilation converts MSIL to native code on demand at application run time, when the contents of an assembly are loaded and executed.</span></span> <span data-ttu-id="af5dc-141">由于公共语言运行时为每个受支持的 CPU 基础结构提供 JIT 编译器，开发人员可以构建一组 MSIL 程序集，这些程序集可以进行 JIT 编译并可在具有不同计算机基础结构的不同计算机上运行。</span><span class="sxs-lookup"><span data-stu-id="af5dc-141">Because the common language runtime supplies a JIT compiler for each supported CPU architecture, developers can build a set of MSIL assemblies that can be JIT-compiled and run on different computers with different machine architectures.</span></span> <span data-ttu-id="af5dc-142">但是，如果你的托管代码调用特定于平台的本机 API 或特定于平台的类库，它将仅在该操作系统上运行。</span><span class="sxs-lookup"><span data-stu-id="af5dc-142">However, if your managed code calls platform-specific native APIs or a platform-specific class library, it will run only on that operating system.</span></span>

 <span data-ttu-id="af5dc-143">JIT 编译将执行期间可能永远不会调用的某些代码的可能性考虑在内。</span><span class="sxs-lookup"><span data-stu-id="af5dc-143">JIT compilation takes into account the possibility that some code might never be called during execution.</span></span> <span data-ttu-id="af5dc-144">它根据需要在执行期间转换 MSIL，而不是使用时间和内存来将 PE 文件中所有 MSIL 转换为本机代码，并在内存中存储生成的本机代码，以便该进程上下文中的后续调用可以对其进行访问。</span><span class="sxs-lookup"><span data-stu-id="af5dc-144">Instead of using time and memory to convert all the MSIL in a PE file to native code, it converts the MSIL as needed during execution and stores the resulting native code in memory so that it is accessible for subsequent calls in the context of that process.</span></span> <span data-ttu-id="af5dc-145">加载类型并将其初始化时，加载程序创建并将存根附加到类型中的每个方法。</span><span class="sxs-lookup"><span data-stu-id="af5dc-145">The loader creates and attaches a stub to each method in a type when the type is loaded and initialized.</span></span> <span data-ttu-id="af5dc-146">第一次调用某个方法时，存根将控件传递给 JIT 编译器，后者将该方法的 MSIL 转换为本机代码，并将存根修改为直接指向生成的本机代码。</span><span class="sxs-lookup"><span data-stu-id="af5dc-146">When a method is called for the first time, the stub passes control to the JIT compiler, which converts the MSIL for that method into native code and modifies the stub to point directly to the generated native code.</span></span> <span data-ttu-id="af5dc-147">因此，对 JIT 编译的方法的后续调用会直接转到本机代码。</span><span class="sxs-lookup"><span data-stu-id="af5dc-147">Therefore, subsequent calls to the JIT-compiled method go directly to the native code.</span></span>

### <a name="install-time-code-generation-using-ngenexe"></a><span data-ttu-id="af5dc-148">使用 NGen.exe 的安装时代码生成</span><span class="sxs-lookup"><span data-stu-id="af5dc-148">Install-Time Code Generation Using NGen.exe</span></span>
 <span data-ttu-id="af5dc-149">由于在调用该程序集中定义的各个方法时，JIT 编译器将程序集的 MSIL 转换为本机代码，因此它在运行时中对性能产生负面影响。</span><span class="sxs-lookup"><span data-stu-id="af5dc-149">Because the JIT compiler converts an assembly's MSIL to native code when individual methods defined in that assembly are called, it affects performance adversely at run time.</span></span> <span data-ttu-id="af5dc-150">在大多数情况下，这种性能降低的程度是可以接受的。</span><span class="sxs-lookup"><span data-stu-id="af5dc-150">In most cases, that diminished performance is acceptable.</span></span> <span data-ttu-id="af5dc-151">更为重要的是，由 JIT 编译器生成的代码会绑定到触发编译的进程上。</span><span class="sxs-lookup"><span data-stu-id="af5dc-151">More importantly, the code generated by the JIT compiler is bound to the process that triggered the compilation.</span></span> <span data-ttu-id="af5dc-152">它无法在多个进程之间进行共享。</span><span class="sxs-lookup"><span data-stu-id="af5dc-152">It cannot be shared across multiple processes.</span></span> <span data-ttu-id="af5dc-153">若要允许生成的代码跨应用程序的多个调用或跨共享一组程序集的多个进程进行共享，则公共语言运行时支持预编译模式。</span><span class="sxs-lookup"><span data-stu-id="af5dc-153">To allow the generated code to be shared across multiple invocations of an application or across multiple processes that share a set of assemblies, the common language runtime supports an ahead-of-time compilation mode.</span></span> <span data-ttu-id="af5dc-154">这种预编译模式使用 [Ngen.exe（本机映像生成器）](../framework/tools/ngen-exe-native-image-generator.md)将 MSIL 程序集转换为本机代码，非常类似 JIT 编译器执行的操作。</span><span class="sxs-lookup"><span data-stu-id="af5dc-154">This ahead-of-time compilation mode uses the [Ngen.exe (Native Image Generator)](../framework/tools/ngen-exe-native-image-generator.md) to convert MSIL assemblies to native code much like the JIT compiler does.</span></span> <span data-ttu-id="af5dc-155">但是，Ngen.exe 的操作在三个方面不同于 JIT 编译器的操作：</span><span class="sxs-lookup"><span data-stu-id="af5dc-155">However, the operation of Ngen.exe differs from that of the JIT compiler in three ways:</span></span>

- <span data-ttu-id="af5dc-156">它在运行应用程序之前而非运行该应用程序时，将 MSIL 转换为本机代码。</span><span class="sxs-lookup"><span data-stu-id="af5dc-156">It performs the conversion from MSIL to native code before running the application instead of while the application is running.</span></span>

- <span data-ttu-id="af5dc-157">它一次编译整个程序集，而不是一次编译一种方法。</span><span class="sxs-lookup"><span data-stu-id="af5dc-157">It compiles an entire assembly at a time, instead of one method at a time.</span></span>

- <span data-ttu-id="af5dc-158">它将本机映像缓存中生成的代码作为磁盘上的文件保存。</span><span class="sxs-lookup"><span data-stu-id="af5dc-158">It persists the generated code in the Native Image Cache as a file on disk.</span></span>

### <a name="code-verification"></a><span data-ttu-id="af5dc-159">代码验证</span><span class="sxs-lookup"><span data-stu-id="af5dc-159">Code Verification</span></span>
 <span data-ttu-id="af5dc-160">作为其编译为本机代码的一部分，MSIL 代码必须通过验证过程，除非管理员已经设定允许代码忽略验证的安全策略。</span><span class="sxs-lookup"><span data-stu-id="af5dc-160">As part of its compilation to native code, the MSIL code must pass a verification process unless an administrator has established a security policy that allows the code to bypass verification.</span></span> <span data-ttu-id="af5dc-161">验证过程检查 MSIL 和元数据，以找出代码是否为类型安全，这意味着它仅访问其有权访问的内存位置。</span><span class="sxs-lookup"><span data-stu-id="af5dc-161">Verification examines MSIL and metadata to find out whether the code is type safe, which means that it accesses only the memory locations it is authorized to access.</span></span> <span data-ttu-id="af5dc-162">类型安全有助于将对象相互隔离，并帮助保护它们免受无意或恶意损坏。</span><span class="sxs-lookup"><span data-stu-id="af5dc-162">Type safety helps isolate objects from each other and helps protect them from inadvertent or malicious corruption.</span></span> <span data-ttu-id="af5dc-163">它还保障可以可靠地对代码强制执行安全限制。</span><span class="sxs-lookup"><span data-stu-id="af5dc-163">It also provides assurance that security restrictions on code can be reliably enforced.</span></span>

 <span data-ttu-id="af5dc-164">运行时基于以下语句对于可验证类型安全代码为 true 这一事实：</span><span class="sxs-lookup"><span data-stu-id="af5dc-164">The runtime relies on the fact that the following statements are true for code that is verifiably type safe:</span></span>

- <span data-ttu-id="af5dc-165">对类型的引用严格符合所引用的类型。</span><span class="sxs-lookup"><span data-stu-id="af5dc-165">A reference to a type is strictly compatible with the type being referenced.</span></span>

- <span data-ttu-id="af5dc-166">在对象上只调用正确定义的操作。</span><span class="sxs-lookup"><span data-stu-id="af5dc-166">Only appropriately defined operations are invoked on an object.</span></span>

- <span data-ttu-id="af5dc-167">标识与声称的要求一致。</span><span class="sxs-lookup"><span data-stu-id="af5dc-167">Identities are what they claim to be.</span></span>

 <span data-ttu-id="af5dc-168">在验证过程中，检查 MSIL 代码以试图确认代码可以访问内存位置，并仅通过正确定义的类型调用方法。</span><span class="sxs-lookup"><span data-stu-id="af5dc-168">During the verification process, MSIL code is examined in an attempt to confirm that the code can access memory locations and call methods only through properly defined types.</span></span> <span data-ttu-id="af5dc-169">例如，代码不允许以允许内存位置溢出的方式访问对象的字段。</span><span class="sxs-lookup"><span data-stu-id="af5dc-169">For example, code cannot allow an object's fields to be accessed in a manner that allows memory locations to be overrun.</span></span> <span data-ttu-id="af5dc-170">此外，验证检查代码以确定是否已正确生成 MSIL，因为错误的 MSIL 可能会导致违反类型安全规则。</span><span class="sxs-lookup"><span data-stu-id="af5dc-170">Additionally, verification inspects code to determine whether the MSIL has been correctly generated, because incorrect MSIL can lead to a violation of the type safety rules.</span></span> <span data-ttu-id="af5dc-171">验证过程传递一组定义完善的类型安全代码，并且仅传递类型安全的代码。</span><span class="sxs-lookup"><span data-stu-id="af5dc-171">The verification process passes a well-defined set of type-safe code, and it passes only code that is type safe.</span></span> <span data-ttu-id="af5dc-172">但是，由于验证过程的一些限制，并且按照设计，某些语言不生成可验证的类型安全代码，某些类型安全代码可能无法通过验证。</span><span class="sxs-lookup"><span data-stu-id="af5dc-172">However, some type-safe code might not pass verification because of some limitations of the verification process, and some languages, by design, do not produce verifiably type-safe code.</span></span> <span data-ttu-id="af5dc-173">如果安全策略要求提供类型安全代码，而该代码不能通过验证，则在运行该代码时将引发异常。</span><span class="sxs-lookup"><span data-stu-id="af5dc-173">If type-safe code is required by the security policy but the code does not pass verification, an exception is thrown when the code is run.</span></span>

 [<span data-ttu-id="af5dc-174">返回页首</span><span class="sxs-lookup"><span data-stu-id="af5dc-174">Back to top</span></span>](#introduction)

<a name="running_code"></a>
## <a name="running-code"></a><span data-ttu-id="af5dc-175">运行代码</span><span class="sxs-lookup"><span data-stu-id="af5dc-175">Running Code</span></span>
 <span data-ttu-id="af5dc-176">公共语言运行时提供启用要发生的托管执行的基础结构以及执行期间可使用的服务。</span><span class="sxs-lookup"><span data-stu-id="af5dc-176">The common language runtime provides the infrastructure that enables managed execution to take place and services that can be used during execution.</span></span> <span data-ttu-id="af5dc-177">方法可以运行之前，必须编译为特定于处理器的代码。</span><span class="sxs-lookup"><span data-stu-id="af5dc-177">Before a method can be run, it must be compiled to processor-specific code.</span></span> <span data-ttu-id="af5dc-178">当第一次调用，然后运行时，为其生成 MSIL 的每种方法都是 JIT 编译的。</span><span class="sxs-lookup"><span data-stu-id="af5dc-178">Each method for which MSIL has been generated is JIT-compiled when it is called for the first time, and then run.</span></span> <span data-ttu-id="af5dc-179">下次运行该方法时，将运行现有的 JIT 编译的本机代码。</span><span class="sxs-lookup"><span data-stu-id="af5dc-179">The next time the method is run, the existing JIT-compiled native code is run.</span></span> <span data-ttu-id="af5dc-180">重复 JIT 编译，然后运行代码的过程，直到执行完毕。</span><span class="sxs-lookup"><span data-stu-id="af5dc-180">The process of JIT-compiling and then running the code is repeated until execution is complete.</span></span>

 <span data-ttu-id="af5dc-181">在执行期间，托管代码接收服务，如垃圾收集、安全性、与非托管代码的互操作性、跨语言调试支持以及增强的部署和版本控制支持。</span><span class="sxs-lookup"><span data-stu-id="af5dc-181">During execution, managed code receives services such as garbage collection, security, interoperability with unmanaged code, cross-language debugging support, and enhanced deployment and versioning support.</span></span>

 <span data-ttu-id="af5dc-182">在 Microsoft Windows Vista 中，操作系统加载程序通过检查 COFF 标头中的一个位检查托管模块。</span><span class="sxs-lookup"><span data-stu-id="af5dc-182">In Microsoft Windows Vista, the operating system loader checks for managed modules by examining a bit in the COFF header.</span></span> <span data-ttu-id="af5dc-183">所设置的位表示托管模块。</span><span class="sxs-lookup"><span data-stu-id="af5dc-183">The bit being set denotes a managed module.</span></span> <span data-ttu-id="af5dc-184">如果加载程序检测到托管模块，它将加载 mscoree.dll， `_CorValidateImage` 并且 `_CorImageUnloading` 在加载和卸载托管模块映像时通知加载程序。</span><span class="sxs-lookup"><span data-stu-id="af5dc-184">If the loader detects managed modules, it loads mscoree.dll, and `_CorValidateImage` and `_CorImageUnloading` notify the loader when the managed module images are loaded and unloaded.</span></span> <span data-ttu-id="af5dc-185">`_CorValidateImage` 执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="af5dc-185">`_CorValidateImage` performs the following actions:</span></span>

1. <span data-ttu-id="af5dc-186">确保代码是有效的托管代码。</span><span class="sxs-lookup"><span data-stu-id="af5dc-186">Ensures that the code is valid managed code.</span></span>

2. <span data-ttu-id="af5dc-187">将映像中的入口点更改为运行时中的入口点。</span><span class="sxs-lookup"><span data-stu-id="af5dc-187">Changes the entry point in the image to an entry point in the runtime.</span></span>

 <span data-ttu-id="af5dc-188">在 64 位 Windows 上， `_CorValidateImage` 通过将其从 PE32 转换为 PE32+ 格式修改内存中的映像。</span><span class="sxs-lookup"><span data-stu-id="af5dc-188">On 64-bit Windows, `_CorValidateImage` modifies the image that is in memory by transforming it from PE32 to PE32+ format.</span></span>

 [<span data-ttu-id="af5dc-189">返回页首</span><span class="sxs-lookup"><span data-stu-id="af5dc-189">Back to top</span></span>](#introduction)

## <a name="see-also"></a><span data-ttu-id="af5dc-190">另请参阅</span><span class="sxs-lookup"><span data-stu-id="af5dc-190">See also</span></span>

- [<span data-ttu-id="af5dc-191">概述</span><span class="sxs-lookup"><span data-stu-id="af5dc-191">Overview</span></span>](../framework/get-started/overview.md)
- [<span data-ttu-id="af5dc-192">语言独立性和与语言无关的组件</span><span class="sxs-lookup"><span data-stu-id="af5dc-192">Language Independence and Language-Independent Components</span></span>](language-independence-and-language-independent-components.md)
- [<span data-ttu-id="af5dc-193">元数据和自描述组件</span><span class="sxs-lookup"><span data-stu-id="af5dc-193">Metadata and Self-Describing Components</span></span>](metadata-and-self-describing-components.md)
- [<span data-ttu-id="af5dc-194">Ilasm.exe（IL 汇编程序）</span><span class="sxs-lookup"><span data-stu-id="af5dc-194">Ilasm.exe (IL Assembler)</span></span>](../framework/tools/ilasm-exe-il-assembler.md)
- [<span data-ttu-id="af5dc-195">安全性</span><span class="sxs-lookup"><span data-stu-id="af5dc-195">Security</span></span>](security/index.md)
- [<span data-ttu-id="af5dc-196">与非托管代码交互操作</span><span class="sxs-lookup"><span data-stu-id="af5dc-196">Interoperating with Unmanaged Code</span></span>](../framework/interop/index.md)
- [<span data-ttu-id="af5dc-197">部署</span><span class="sxs-lookup"><span data-stu-id="af5dc-197">Deployment</span></span>](../framework/deployment/net-framework-applications.md)
- [<span data-ttu-id="af5dc-198">.NET 中的程序集</span><span class="sxs-lookup"><span data-stu-id="af5dc-198">Assemblies in .NET</span></span>](assembly/index.md)
- [<span data-ttu-id="af5dc-199">应用程序域</span><span class="sxs-lookup"><span data-stu-id="af5dc-199">Application Domains</span></span>](../framework/app-domains/application-domains.md)
