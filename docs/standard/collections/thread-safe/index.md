---
title: 线程安全集合
description: 通过 .NET 中的 System.Collections.Concurrent 命名空间（其中包含线程安全且可缩放的集合类）开始使用线程安全集合。
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, overview
ms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd
ms.openlocfilehash: 27b0e887d7dcff6a6c792cf2dfab6a449f59646f
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/15/2020
ms.locfileid: "90547683"
---
# <a name="thread-safe-collections"></a><span data-ttu-id="b2004-103">线程安全集合</span><span class="sxs-lookup"><span data-stu-id="b2004-103">Thread-Safe Collections</span></span>
<span data-ttu-id="b2004-104">.NET Framework 4 引入了 <xref:System.Collections.Concurrent?displayProperty=nameWithType> 命名空间，其中包含多个线程安全且可缩放的集合类。</span><span class="sxs-lookup"><span data-stu-id="b2004-104">The .NET Framework 4 introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable.</span></span> <span data-ttu-id="b2004-105">多个线程可以安全高效地从这些集合添加或删除项，而无需在用户代码中进行其他同步。</span><span class="sxs-lookup"><span data-stu-id="b2004-105">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</span></span> <span data-ttu-id="b2004-106">编写新代码时，只要将多个线程同时写入到集合时，就使用并发集合类。</span><span class="sxs-lookup"><span data-stu-id="b2004-106">When you write new code, use the concurrent collection classes whenever multiple threads will write to the collection concurrently.</span></span> <span data-ttu-id="b2004-107">如果仅从共享集合进行读取，则可使用 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中的类。</span><span class="sxs-lookup"><span data-stu-id="b2004-107">If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="b2004-108">建议不要使用 1.0 集合类，除非需要定位 .NET Framework 1.1 或更低版本运行时。</span><span class="sxs-lookup"><span data-stu-id="b2004-108">We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</span></span>  
  
## <a name="thread-synchronization-in-the-net-framework-10-and-20-collections"></a><span data-ttu-id="b2004-109">.NET Framework 1.0 和 2.0 集合中的线程同步</span><span class="sxs-lookup"><span data-stu-id="b2004-109">Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections</span></span>  
 <span data-ttu-id="b2004-110">.NET Framework 1.0 中引入的集合位于 <xref:System.Collections?displayProperty=nameWithType> 命名空间中。</span><span class="sxs-lookup"><span data-stu-id="b2004-110">The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="b2004-111">这些集合（包括常用的 <xref:System.Collections.ArrayList> 和 <xref:System.Collections.Hashtable>）通过 `Synchronized` 属性（此属性围绕集合返回线程安全的包装器）提供一些线程安全性。</span><span class="sxs-lookup"><span data-stu-id="b2004-111">These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection.</span></span> <span data-ttu-id="b2004-112">该包装器通过对每个添加或删除操作锁定整个集合进行工作。</span><span class="sxs-lookup"><span data-stu-id="b2004-112">The wrapper works by locking the entire collection on every add or remove operation.</span></span> <span data-ttu-id="b2004-113">因此，每个尝试访问集合的线程必须等待，直到轮到它获取锁定。</span><span class="sxs-lookup"><span data-stu-id="b2004-113">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</span></span> <span data-ttu-id="b2004-114">这不可缩放，并且可能导致大型集合的性能显著下降。</span><span class="sxs-lookup"><span data-stu-id="b2004-114">This is not scalable and can cause significant performance degradation for large collections.</span></span> <span data-ttu-id="b2004-115">此外，这一设计并不能完全防止争用情况的出现。</span><span class="sxs-lookup"><span data-stu-id="b2004-115">Also, the design is not completely protected from race conditions.</span></span> <span data-ttu-id="b2004-116">有关详细信息，请参阅[泛型集合中的同步](/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer)。</span><span class="sxs-lookup"><span data-stu-id="b2004-116">For more information, see [Synchronization in Generic Collections](/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span></span>  
  
 <span data-ttu-id="b2004-117">.NET Framework 2.0 中引入的集合类位于 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中。</span><span class="sxs-lookup"><span data-stu-id="b2004-117">The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="b2004-118">它们包括 <xref:System.Collections.Generic.List%601>、<xref:System.Collections.Generic.Dictionary%602> 等。</span><span class="sxs-lookup"><span data-stu-id="b2004-118">These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on.</span></span> <span data-ttu-id="b2004-119">与 .NET Framework 1.0 类相比，这些类提升了类型安全性和性能。</span><span class="sxs-lookup"><span data-stu-id="b2004-119">These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.</span></span> <span data-ttu-id="b2004-120">不过，.NET Framework 2.0 集合类不提供任何线程同步；多线程同时添加或删除项时，用户代码必须提供所有同步。</span><span class="sxs-lookup"><span data-stu-id="b2004-120">However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</span></span>  
  
 <span data-ttu-id="b2004-121">建议使用 .NET Framework 4 中的并发集合类，因为它们不仅能够提供 .NET Framework 2.0 集合类的类型安全性，而且能够比 .NET Framework 1.0 集合更高效完整地提供线程安全性。</span><span class="sxs-lookup"><span data-stu-id="b2004-121">We recommend the concurrent collections classes in the .NET Framework 4 because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the .NET Framework 1.0 collections provide.</span></span>  
  
## <a name="fine-grained-locking-and-lock-free-mechanisms"></a><span data-ttu-id="b2004-122">细粒度锁定和无锁机制</span><span class="sxs-lookup"><span data-stu-id="b2004-122">Fine-Grained Locking and Lock-Free Mechanisms</span></span>  
 <span data-ttu-id="b2004-123">某些并发集合类型使用轻量同步机制，如 <xref:System.Threading.SpinLock>、<xref:System.Threading.SpinWait>、<xref:System.Threading.SemaphoreSlim> 和 <xref:System.Threading.CountdownEvent>，这些机制是 .NET Framework 4 中的新增功能。</span><span class="sxs-lookup"><span data-stu-id="b2004-123">Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the .NET Framework 4.</span></span> <span data-ttu-id="b2004-124">这些同步类型通常在将线程真正置于等待状态之前，会在短时间内使用*忙旋转*。</span><span class="sxs-lookup"><span data-stu-id="b2004-124">These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state.</span></span> <span data-ttu-id="b2004-125">预计等待时间非常短时，旋转比等待所消耗的计算资源少得多，因为后者涉及资源消耗量大的内核转换。</span><span class="sxs-lookup"><span data-stu-id="b2004-125">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</span></span> <span data-ttu-id="b2004-126">对于使用旋转的集合类，这种效率意味着多个线程能够以非常快的速率添加和删除项。</span><span class="sxs-lookup"><span data-stu-id="b2004-126">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</span></span> <span data-ttu-id="b2004-127">有关旋转与锁定的详细信息，请参阅 [SpinLock](../../threading/spinlock.md) 和 [SpinWait](../../threading/spinwait.md)。</span><span class="sxs-lookup"><span data-stu-id="b2004-127">For more information about spinning vs. blocking, see [SpinLock](../../threading/spinlock.md) and [SpinWait](../../threading/spinwait.md).</span></span>  
  
 <span data-ttu-id="b2004-128"><xref:System.Collections.Concurrent.ConcurrentQueue%601> 和 <xref:System.Collections.Concurrent.ConcurrentStack%601> 类完全不使用锁定。</span><span class="sxs-lookup"><span data-stu-id="b2004-128">The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all.</span></span> <span data-ttu-id="b2004-129">相反，它们依赖于 <xref:System.Threading.Interlocked> 操作来实现线程安全性。</span><span class="sxs-lookup"><span data-stu-id="b2004-129">Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b2004-130">由于并发集合类支持 <xref:System.Collections.ICollection>，因此该类可提供针对 <xref:System.Collections.ICollection.IsSynchronized%2A> 和 <xref:System.Collections.ICollection.SyncRoot%2A> 属性的实现，即使这些属性不相关。</span><span class="sxs-lookup"><span data-stu-id="b2004-130">Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant.</span></span> <span data-ttu-id="b2004-131">`IsSynchronized` 始终返回 `false`，而 `SyncRoot` 始终为 `null`（在 Visual Basic 中是 `Nothing`）。</span><span class="sxs-lookup"><span data-stu-id="b2004-131">`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).</span></span>  
  
 <span data-ttu-id="b2004-132">下表列出了 <xref:System.Collections.Concurrent?displayProperty=nameWithType> 命名空间中的集合类型。</span><span class="sxs-lookup"><span data-stu-id="b2004-132">The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace.</span></span>  
  
|<span data-ttu-id="b2004-133">类型</span><span class="sxs-lookup"><span data-stu-id="b2004-133">Type</span></span>|<span data-ttu-id="b2004-134">描述</span><span class="sxs-lookup"><span data-stu-id="b2004-134">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601>|<span data-ttu-id="b2004-135">为实现 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> 的所有类型提供限制和阻止功能。</span><span class="sxs-lookup"><span data-stu-id="b2004-135">Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span></span> <span data-ttu-id="b2004-136">有关详细信息，请参阅 [BlockingCollection 概述](blockingcollection-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="b2004-136">For more information, see [BlockingCollection Overview](blockingcollection-overview.md).</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|<span data-ttu-id="b2004-137">键值对字典的线程安全实现。</span><span class="sxs-lookup"><span data-stu-id="b2004-137">Thread-safe implementation of a dictionary of key-value pairs.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|<span data-ttu-id="b2004-138">FIFO（先进先出）队列的线程安全实现。</span><span class="sxs-lookup"><span data-stu-id="b2004-138">Thread-safe implementation of a FIFO (first-in, first-out) queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601>|<span data-ttu-id="b2004-139">LIFO（后进先出）堆栈的线程安全实现。</span><span class="sxs-lookup"><span data-stu-id="b2004-139">Thread-safe implementation of a LIFO (last-in, first-out) stack.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601>|<span data-ttu-id="b2004-140">无序元素集合的线程安全实现。</span><span class="sxs-lookup"><span data-stu-id="b2004-140">Thread-safe implementation of an unordered collection of elements.</span></span>|  
|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|<span data-ttu-id="b2004-141">类型必须实现以在 `BlockingCollection` 中使用的接口。</span><span class="sxs-lookup"><span data-stu-id="b2004-141">The interface that a type must implement to be used in a `BlockingCollection`.</span></span>|  
  
## <a name="related-topics"></a><span data-ttu-id="b2004-142">相关主题</span><span class="sxs-lookup"><span data-stu-id="b2004-142">Related Topics</span></span>  
  
|<span data-ttu-id="b2004-143">Title</span><span class="sxs-lookup"><span data-stu-id="b2004-143">Title</span></span>|<span data-ttu-id="b2004-144">描述</span><span class="sxs-lookup"><span data-stu-id="b2004-144">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="b2004-145">BlockingCollection 概述</span><span class="sxs-lookup"><span data-stu-id="b2004-145">BlockingCollection Overview</span></span>](blockingcollection-overview.md)|<span data-ttu-id="b2004-146">描述 <xref:System.Collections.Concurrent.BlockingCollection%601> 类型提供的功能。</span><span class="sxs-lookup"><span data-stu-id="b2004-146">Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type.</span></span>|  
|[<span data-ttu-id="b2004-147">如何：在 ConcurrentDictionary 中添加和移除项</span><span class="sxs-lookup"><span data-stu-id="b2004-147">How to: Add and Remove Items from a ConcurrentDictionary</span></span>](how-to-add-and-remove-items.md)|<span data-ttu-id="b2004-148">描述如何从 <xref:System.Collections.Concurrent.ConcurrentDictionary%602> 添加和删除元素</span><span class="sxs-lookup"><span data-stu-id="b2004-148">Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span></span>|  
|[<span data-ttu-id="b2004-149">如何：在 BlockingCollection 中逐个添加和取出项</span><span class="sxs-lookup"><span data-stu-id="b2004-149">How to: Add and Take Items Individually from a BlockingCollection</span></span>](how-to-add-and-take-items.md)|<span data-ttu-id="b2004-150">描述如何在不使用只读枚举器的情况下，从阻止的集合添加和检索项。</span><span class="sxs-lookup"><span data-stu-id="b2004-150">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</span></span>|  
|[<span data-ttu-id="b2004-151">如何：向集合添加限制和阻塞功能</span><span class="sxs-lookup"><span data-stu-id="b2004-151">How to: Add Bounding and Blocking Functionality to a Collection</span></span>](how-to-add-bounding-and-blocking.md)|<span data-ttu-id="b2004-152">描述如何将任一集合类用作 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> 集合的基础存储机制。</span><span class="sxs-lookup"><span data-stu-id="b2004-152">Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.</span></span>|  
|[<span data-ttu-id="b2004-153">如何：使用 ForEach 移除 BlockingCollection 中的项</span><span class="sxs-lookup"><span data-stu-id="b2004-153">How to: Use ForEach to Remove Items in a BlockingCollection</span></span>](how-to-use-foreach-to-remove.md)|<span data-ttu-id="b2004-154">介绍了如何使用 `foreach`（在 Visual Basic 中是 `For Each`）在锁定集合中删除所有项。</span><span class="sxs-lookup"><span data-stu-id="b2004-154">Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.</span></span>|  
|[<span data-ttu-id="b2004-155">如何：在管道中使用阻塞集合的数组</span><span class="sxs-lookup"><span data-stu-id="b2004-155">How to: Use Arrays of Blocking Collections in a Pipeline</span></span>](how-to-use-arrays-of-blockingcollections.md)|<span data-ttu-id="b2004-156">描述如何同时使用多个阻塞集合来实现一个管道。</span><span class="sxs-lookup"><span data-stu-id="b2004-156">Describes how to use multiple blocking collections at the same time to implement a pipeline.</span></span>|  
|[<span data-ttu-id="b2004-157">如何：使用 ConcurrentBag 创建目标池</span><span class="sxs-lookup"><span data-stu-id="b2004-157">How to: Create an Object Pool by Using a ConcurrentBag</span></span>](how-to-create-an-object-pool.md)|<span data-ttu-id="b2004-158">演示如何使用并发包在可重用对象（而不是继续创建新对象）的情况下改进性能。</span><span class="sxs-lookup"><span data-stu-id="b2004-158">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="b2004-159">参考</span><span class="sxs-lookup"><span data-stu-id="b2004-159">Reference</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>
