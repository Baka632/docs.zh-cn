---
title: BlockingCollection 概述
description: 阅读有关 .NET 中线程安全集合类 BlockingCollection<T> 的信息。 此类提供一些功能，例如并发添加项或从多个线程中获取项。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- BlockingCollection, overview
ms.assetid: 987ea3d7-0ad5-4238-8b64-331ce4eb3f0b
ms.openlocfilehash: 0378d038d6081c7ad04fc233ac151ab2bb223fa5
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/18/2020
ms.locfileid: "94818656"
---
# <a name="blockingcollection-overview"></a><span data-ttu-id="a0786-104">BlockingCollection 概述</span><span class="sxs-lookup"><span data-stu-id="a0786-104">BlockingCollection Overview</span></span>
<span data-ttu-id="a0786-105"><xref:System.Collections.Concurrent.BlockingCollection%601> 是一个线程安全集合类，可提供以下功能：</span><span class="sxs-lookup"><span data-stu-id="a0786-105"><xref:System.Collections.Concurrent.BlockingCollection%601> is a thread-safe collection class that provides the following features:</span></span>  
  
- <span data-ttu-id="a0786-106">实现制造者-使用者模式。</span><span class="sxs-lookup"><span data-stu-id="a0786-106">An implementation of the Producer-Consumer pattern.</span></span>  
  
- <span data-ttu-id="a0786-107">通过多线程并发添加和获取项。</span><span class="sxs-lookup"><span data-stu-id="a0786-107">Concurrent adding and taking of items from multiple threads.</span></span>  
  
- <span data-ttu-id="a0786-108">可选最大容量。</span><span class="sxs-lookup"><span data-stu-id="a0786-108">Optional maximum capacity.</span></span>  
  
- <span data-ttu-id="a0786-109">集合为空或已满时通过插入和移除操作进行阻塞。</span><span class="sxs-lookup"><span data-stu-id="a0786-109">Insertion and removal operations that block when collection is empty or full.</span></span>  
  
- <span data-ttu-id="a0786-110">插入和移除“尝试”操作不发生阻塞，或在指定时间段内发生阻塞。</span><span class="sxs-lookup"><span data-stu-id="a0786-110">Insertion and removal "try" operations that do not block or that block up to a specified period of time.</span></span>  
  
- <span data-ttu-id="a0786-111">封装实现 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> 的任何集合类型</span><span class="sxs-lookup"><span data-stu-id="a0786-111">Encapsulates any collection type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601></span></span>  
  
- <span data-ttu-id="a0786-112">使用取消标记执行取消操作。</span><span class="sxs-lookup"><span data-stu-id="a0786-112">Cancellation with cancellation tokens.</span></span>  
  
- <span data-ttu-id="a0786-113">支持使用 `foreach`（在 Visual Basic 中，使用 `For Each`）的两种枚举：</span><span class="sxs-lookup"><span data-stu-id="a0786-113">Two kinds of enumeration with `foreach` (`For Each` in Visual Basic):</span></span>  
  
    1. <span data-ttu-id="a0786-114">只读枚举。</span><span class="sxs-lookup"><span data-stu-id="a0786-114">Read-only enumeration.</span></span>  
  
    2. <span data-ttu-id="a0786-115">在枚举项时将项移除的枚举。</span><span class="sxs-lookup"><span data-stu-id="a0786-115">Enumeration that removes items as they are enumerated.</span></span>  
  
## <a name="bounding-and-blocking-support"></a><span data-ttu-id="a0786-116">限制和阻塞支持</span><span class="sxs-lookup"><span data-stu-id="a0786-116">Bounding and Blocking Support</span></span>  
 <span data-ttu-id="a0786-117"><xref:System.Collections.Concurrent.BlockingCollection%601> 支持限制和阻塞。</span><span class="sxs-lookup"><span data-stu-id="a0786-117"><xref:System.Collections.Concurrent.BlockingCollection%601> supports bounding and blocking.</span></span> <span data-ttu-id="a0786-118">限制意味着可以设置集合的最大容量。</span><span class="sxs-lookup"><span data-stu-id="a0786-118">Bounding means you can set the maximum capacity of the collection.</span></span> <span data-ttu-id="a0786-119">限制在某些情况中很重要，因为它使你能够控制内存中的集合的最大大小，并可阻止制造线程移动到离使用线程前方太远的位置。</span><span class="sxs-lookup"><span data-stu-id="a0786-119">Bounding is important in certain scenarios because it enables you to control the maximum size of the collection in memory, and it prevents the producing threads from moving too far ahead of the consuming threads.</span></span>  
  
 <span data-ttu-id="a0786-120">多个线程或任务可同时向集合添加项，如果集合达到其指定最大容量，则制造线程将发生阻塞，直到移除集合中的某个项。</span><span class="sxs-lookup"><span data-stu-id="a0786-120">Multiple threads or tasks can add items to the collection concurrently, and if the collection reaches its specified maximum capacity, the producing threads will block until an item is removed.</span></span> <span data-ttu-id="a0786-121">多个使用者可以同时移除项，如果集合变空，则使用线程将发生阻塞，直到制造者添加某个项。</span><span class="sxs-lookup"><span data-stu-id="a0786-121">Multiple consumers can remove items concurrently, and if the collection becomes empty, the consuming threads will block until a producer adds an item.</span></span> <span data-ttu-id="a0786-122">制造线程可调用 <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A> 来指示不再添加项。</span><span class="sxs-lookup"><span data-stu-id="a0786-122">A producing thread can call <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A> to indicate that no more items will be added.</span></span> <span data-ttu-id="a0786-123">使用者将监视 <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> 属性以了解集合何时为空且不再添加项。</span><span class="sxs-lookup"><span data-stu-id="a0786-123">Consumers monitor the <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> property to know when the collection is empty and no more items will be added.</span></span> <span data-ttu-id="a0786-124">下面的示例展示了容量上限为 100 的简单 BlockingCollection。</span><span class="sxs-lookup"><span data-stu-id="a0786-124">The following example shows a simple BlockingCollection with a bounded capacity of 100.</span></span> <span data-ttu-id="a0786-125">只要满足某些外部条件为 true，制造者任务就会向集合添加项，然后调用 <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A>。</span><span class="sxs-lookup"><span data-stu-id="a0786-125">A producer task adds items to the collection as long as some external condition is true, and then calls <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A>.</span></span> <span data-ttu-id="a0786-126">使用者任务获取项，直到 <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> 属性为 true。</span><span class="sxs-lookup"><span data-stu-id="a0786-126">The consumer task takes items until the <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> property is true.</span></span>  
  
 [!code-csharp[CDS_BlockingCollection#04](../../../../samples/snippets/csharp/VS_Snippets_Misc/cds_blockingcollection/cs/blockingcollection.cs#04)]
 [!code-vb[CDS_BlockingCollection#04](../../../../samples/snippets/visualbasic/VS_Snippets_Misc/cds_blockingcollection/vb/introsnippetsbc.vb#04)]  
  
 <span data-ttu-id="a0786-127">有关完整的示例，请参阅 [如何：在 BlockingCollection 中逐个添加和取出项](how-to-add-and-take-items.md)。</span><span class="sxs-lookup"><span data-stu-id="a0786-127">For a complete example, see [How to: Add and Take Items Individually from a BlockingCollection](how-to-add-and-take-items.md).</span></span>  
  
## <a name="timed-blocking-operations"></a><span data-ttu-id="a0786-128">计时阻塞操作</span><span class="sxs-lookup"><span data-stu-id="a0786-128">Timed Blocking Operations</span></span>  
 <span data-ttu-id="a0786-129">在针对有限集合的计时阻塞 <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> 和 <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> 操作中，此方法将尝试添加或取出某个项。</span><span class="sxs-lookup"><span data-stu-id="a0786-129">In timed blocking <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> and <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> operations on bounded collections, the method tries to add or take an item.</span></span> <span data-ttu-id="a0786-130">如果项可用，项会被置于通过引用传入的变量中，然后方法返回 true。</span><span class="sxs-lookup"><span data-stu-id="a0786-130">If an item is available it is placed into the variable that was passed in by reference, and the method returns true.</span></span> <span data-ttu-id="a0786-131">如果在指定的超时期限过后未检索到任何项，方法返回 false。</span><span class="sxs-lookup"><span data-stu-id="a0786-131">If no item is retrieved after a specified time-out period the method returns false.</span></span> <span data-ttu-id="a0786-132">相应线程可以任意执行一些其他有用的工作，然后再重新尝试访问该集合。</span><span class="sxs-lookup"><span data-stu-id="a0786-132">The thread is then free to do some other useful work before trying again to access the collection.</span></span> <span data-ttu-id="a0786-133">有关计时阻塞访问的示例，请参阅[如何：在 BlockingCollection 中逐个添加和取出项](how-to-add-and-take-items.md)中的第二个示例。</span><span class="sxs-lookup"><span data-stu-id="a0786-133">For an example of timed blocking access, see the second example in [How to: Add and Take Items Individually from a BlockingCollection](how-to-add-and-take-items.md).</span></span>  
  
## <a name="cancelling-add-and-take-operations"></a><span data-ttu-id="a0786-134">取消添加和取出操作</span><span class="sxs-lookup"><span data-stu-id="a0786-134">Cancelling Add and Take Operations</span></span>  
 <span data-ttu-id="a0786-135">添加和取出操作通常会在一个循环内执行。</span><span class="sxs-lookup"><span data-stu-id="a0786-135">Add and Take operations are typically performed in a loop.</span></span> <span data-ttu-id="a0786-136">可以通过以下方法来取消循环：向 <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> 或 <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> 方法传入 <xref:System.Threading.CancellationToken>，然后在每次迭代时检查该标记的 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> 属性的值。</span><span class="sxs-lookup"><span data-stu-id="a0786-136">You can cancel a loop by passing in a <xref:System.Threading.CancellationToken> to the <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> or <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> method, and then checking the value of the token's <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property on each iteration.</span></span> <span data-ttu-id="a0786-137">如果值为 true，由你自行决定是否通过清理所有资源并退出循环来响应取消请求。</span><span class="sxs-lookup"><span data-stu-id="a0786-137">If the value is true, then it is up to you to respond the cancellation request by cleaning up any resources and exiting the loop.</span></span> <span data-ttu-id="a0786-138">下面的示例演示获取取消标记和使用该标记的代码的 <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> 重载：</span><span class="sxs-lookup"><span data-stu-id="a0786-138">The following example shows an overload of <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> that takes a cancellation token, and the code that uses it:</span></span>  
  
 [!code-csharp[CDS_BlockingCollection#05](../../../../samples/snippets/csharp/VS_Snippets_Misc/cds_blockingcollection/cs/blockingcollection.cs#05)]
 [!code-vb[CDS_BlockingCollection#05](../../../../samples/snippets/visualbasic/VS_Snippets_Misc/cds_blockingcollection/vb/introsnippetsbc.vb#05)]  
  
 <span data-ttu-id="a0786-139">有关如何添加取消支持的示例，请参阅[如何：在 BlockingCollection 中逐个添加和取出项](how-to-add-and-take-items.md)中的第二个示例。</span><span class="sxs-lookup"><span data-stu-id="a0786-139">For an example of how to add cancellation support, see the second example in [How to: Add and Take Items Individually from a BlockingCollection](how-to-add-and-take-items.md).</span></span>  
  
## <a name="specifying-the-collection-type"></a><span data-ttu-id="a0786-140">指定集合类型</span><span class="sxs-lookup"><span data-stu-id="a0786-140">Specifying the Collection Type</span></span>  
 <span data-ttu-id="a0786-141">创建 <xref:System.Collections.Concurrent.BlockingCollection%601> 时，不仅可以指定上限容量，而且可以指定要使用的集合类型。</span><span class="sxs-lookup"><span data-stu-id="a0786-141">When you create a <xref:System.Collections.Concurrent.BlockingCollection%601>, you can specify not only the bounded capacity but also the type of collection to use.</span></span> <span data-ttu-id="a0786-142">例如，可为先进先出 (FIFO) 行为指定 <xref:System.Collections.Concurrent.ConcurrentQueue%601>，也可为后进先出 (LIFO) 行为指定 <xref:System.Collections.Concurrent.ConcurrentStack%601>。</span><span class="sxs-lookup"><span data-stu-id="a0786-142">For example, you could specify a <xref:System.Collections.Concurrent.ConcurrentQueue%601> for first in-first out (FIFO) behavior, or a <xref:System.Collections.Concurrent.ConcurrentStack%601> for last in-first out (LIFO) behavior.</span></span> <span data-ttu-id="a0786-143">可使用实现 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> 接口的任何集合类。</span><span class="sxs-lookup"><span data-stu-id="a0786-143">You can use any collection class that implements the <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> interface.</span></span> <span data-ttu-id="a0786-144"><xref:System.Collections.Concurrent.BlockingCollection%601> 的默认集合类型为 <xref:System.Collections.Concurrent.ConcurrentQueue%601>。</span><span class="sxs-lookup"><span data-stu-id="a0786-144">The default collection type for <xref:System.Collections.Concurrent.BlockingCollection%601> is <xref:System.Collections.Concurrent.ConcurrentQueue%601>.</span></span> <span data-ttu-id="a0786-145">下面的代码示例演示如何创建字符串的 <xref:System.Collections.Concurrent.BlockingCollection%601>，其容量为 1000 并使用 <xref:System.Collections.Concurrent.ConcurrentBag%601>：</span><span class="sxs-lookup"><span data-stu-id="a0786-145">The following code example shows how to create a <xref:System.Collections.Concurrent.BlockingCollection%601> of strings that has a capacity of 1000 and uses a <xref:System.Collections.Concurrent.ConcurrentBag%601>:</span></span>  
  
```vb  
Dim bc = New BlockingCollection(Of String)(New ConcurrentBag(Of String()), 1000)  
```  
  
```csharp  
BlockingCollection<string> bc = new BlockingCollection<string>(new ConcurrentBag<string>(), 1000 );  
```  
  
 <span data-ttu-id="a0786-146">有关详细信息，请参阅[如何：向集合添加限制和阻塞功能](how-to-add-bounding-and-blocking.md)。</span><span class="sxs-lookup"><span data-stu-id="a0786-146">For more information, see [How to: Add Bounding and Blocking Functionality to a Collection](how-to-add-bounding-and-blocking.md).</span></span>  
  
## <a name="ienumerable-support"></a><span data-ttu-id="a0786-147">IEnumerable 支持</span><span class="sxs-lookup"><span data-stu-id="a0786-147">IEnumerable Support</span></span>  
 <span data-ttu-id="a0786-148"><xref:System.Collections.Concurrent.BlockingCollection%601> 提供 <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A> 方法，该方法允许使用者使用 `foreach`（在 Visual Basic 中为 `For Each`）删除项直到完成集合，也就是说，集合为空且不再添加项。</span><span class="sxs-lookup"><span data-stu-id="a0786-148"><xref:System.Collections.Concurrent.BlockingCollection%601> provides a <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A> method that enables consumers to use `foreach` (`For Each` in Visual Basic) to remove items until the collection is completed, which means it is empty and no more items will be added.</span></span> <span data-ttu-id="a0786-149">有关详细信息，请参阅[如何：使用 ForEach 移除 BlockingCollection 中的项](how-to-use-foreach-to-remove.md)。</span><span class="sxs-lookup"><span data-stu-id="a0786-149">For more information, see [How to: Use ForEach to Remove Items in a BlockingCollection](how-to-use-foreach-to-remove.md).</span></span>  
  
## <a name="using-many-blockingcollections-as-one"></a><span data-ttu-id="a0786-150">将多个 BlockingCollection 作为整体使用</span><span class="sxs-lookup"><span data-stu-id="a0786-150">Using Many BlockingCollections As One</span></span>  
 <span data-ttu-id="a0786-151">在使用者需要同时取出多个集合中的项的情况下，可以创建 <xref:System.Collections.Concurrent.BlockingCollection%601> 的数组并使用静态方法，如 <xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A> 和 <xref:System.Collections.Concurrent.BlockingCollection%601.AddToAny%2A> 方法，这两个方法可以在该数组的任意集合中添加或取出项。</span><span class="sxs-lookup"><span data-stu-id="a0786-151">For scenarios in which a consumer needs to take items from multiple collections simultaneously, you can create arrays of <xref:System.Collections.Concurrent.BlockingCollection%601> and use the static methods such as <xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A> and <xref:System.Collections.Concurrent.BlockingCollection%601.AddToAny%2A> that will add to or take from any of the collections in the array.</span></span> <span data-ttu-id="a0786-152">如果一个集合发生阻塞，此方法会立即尝试其他集合，直到找到能够执行该操作的集合。</span><span class="sxs-lookup"><span data-stu-id="a0786-152">If one collection is blocking, the method immediately tries another until it finds one that can perform the operation.</span></span> <span data-ttu-id="a0786-153">有关详细信息，请参阅[如何：在管道中使用阻塞集合的数组](how-to-use-arrays-of-blockingcollections.md)。</span><span class="sxs-lookup"><span data-stu-id="a0786-153">For more information, see [How to: Use Arrays of Blocking Collections in a Pipeline](how-to-use-arrays-of-blockingcollections.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a0786-154">请参阅</span><span class="sxs-lookup"><span data-stu-id="a0786-154">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="a0786-155">集合和数据结构</span><span class="sxs-lookup"><span data-stu-id="a0786-155">Collections and Data Structures</span></span>](../index.md)
- [<span data-ttu-id="a0786-156">线程安全集合</span><span class="sxs-lookup"><span data-stu-id="a0786-156">Thread-Safe Collections</span></span>](index.md)
