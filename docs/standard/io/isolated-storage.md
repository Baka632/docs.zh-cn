---
title: 独立存储
description: 了解独立存储（一种数据存储机制），它在代码与保存的数据之间定义了标准化的关联方式，从而提供隔离性和安全性。
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- data storage using isolated storage
- stores
- storing data using isolated storage
- isolated storage
- location of isolated storage in file system
- standardizing storage systems
- storing data using isolated storage, when not to use
- code, isolated storage
- isolated storage, options
- data storage using isolated storage, when not to use
- storing data using isolated storage, options
- isolated storage, when not to use
- data storage using isolated storage, options
- isolation
ms.assetid: aff939d7-9e49-46f2-a8cd-938d3020e94e
ms.openlocfilehash: 4ad7779b9810954d110af576dd834daf61888d59
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/15/2020
ms.locfileid: "90555915"
---
# <a name="isolated-storage"></a><span data-ttu-id="3038a-103">独立存储</span><span class="sxs-lookup"><span data-stu-id="3038a-103">Isolated storage</span></span>

<span data-ttu-id="3038a-104">对于桌面应用，独立存储是一种数据存储机制，它定义了将代码与保存的数据关联的标准化方式，从而提供隔离性和安全性。</span><span class="sxs-lookup"><span data-stu-id="3038a-104">For desktop apps, isolated storage is a data storage mechanism that provides isolation and safety by defining standardized ways of associating code with saved data.</span></span> <span data-ttu-id="3038a-105">同时，标准化也提供了其他好处。</span><span class="sxs-lookup"><span data-stu-id="3038a-105">Standardization provides other benefits as well.</span></span> <span data-ttu-id="3038a-106">管理员可以使用旨在操作独立存储的工具来配置文件存储空间、设置安全策略及删除未使用的数据。</span><span class="sxs-lookup"><span data-stu-id="3038a-106">Administrators can use tools designed to manipulate isolated storage to configure file storage space, set security policies, and delete unused data.</span></span> <span data-ttu-id="3038a-107">通过独立存储，代码不再需要使用唯一的路径来指定文件系统中的安全位置，同时可以保护数据免遭只具有独立存储访问权限的其他应用程序的损坏。</span><span class="sxs-lookup"><span data-stu-id="3038a-107">With isolated storage, your code no longer needs unique paths to specify safe locations in the file system, and data is protected from other applications that only have isolated storage access.</span></span> <span data-ttu-id="3038a-108">不再需要指示应用程序的存储区域位置的硬编码信息。</span><span class="sxs-lookup"><span data-stu-id="3038a-108">Hard-coded information that indicates where an application's storage area is located is unnecessary.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="3038a-109">独立存储不适用于 Windows 8.x 应用商店应用。</span><span class="sxs-lookup"><span data-stu-id="3038a-109">Isolated storage is not available for Windows 8.x Store apps.</span></span> <span data-ttu-id="3038a-110">请改用 Windows 运行时 API 包含的 `Windows.Storage` 命名空间中的应用程序数据类来存储本地数据和文件。</span><span class="sxs-lookup"><span data-stu-id="3038a-110">Instead, use the application data classes in the `Windows.Storage` namespaces included in the Windows Runtime API to store local data and files.</span></span> <span data-ttu-id="3038a-111">有关详细信息，请参阅 Windows 开发人员中心的 [应用程序数据](/previous-versions/windows/apps/hh464917(v=win.10)) 。</span><span class="sxs-lookup"><span data-stu-id="3038a-111">For more information, see [Application data](/previous-versions/windows/apps/hh464917(v=win.10)) in the Windows Dev Center.</span></span>

<a name="data_compartments_and_stores"></a>

## <a name="data-compartments-and-stores"></a><span data-ttu-id="3038a-112">数据隔离舱和存储区</span><span class="sxs-lookup"><span data-stu-id="3038a-112">Data Compartments and Stores</span></span>

<span data-ttu-id="3038a-113">当应用程序在文件中存储数据时，必须仔细选择文件名和存储位置，最大程度地减小其他应用程序知道该存储位置的可能性，从而使数据不易受到损坏。</span><span class="sxs-lookup"><span data-stu-id="3038a-113">When an application stores data in a file, the file name and storage location must be carefully chosen to minimize the possibility that the storage location will be known to another application and, therefore, will be vulnerable to corruption.</span></span> <span data-ttu-id="3038a-114">如果没有标准系统来管理这些问题，想开发出最大程度地减少存储冲突的特别技术可能并非易事，而且开发出来的技术也不见得可靠。</span><span class="sxs-lookup"><span data-stu-id="3038a-114">Without a standard system in place to manage these problems, developing ad hoc techniques that minimize storage conflicts can be complex, and the results can be unreliable.</span></span>

<span data-ttu-id="3038a-115">通过使用独立存储，数据将始终按用户和程序集进行隔离。</span><span class="sxs-lookup"><span data-stu-id="3038a-115">With isolated storage, data is always isolated by user and by assembly.</span></span> <span data-ttu-id="3038a-116">程序集的源或强名称等凭据确定程序集的身份。</span><span class="sxs-lookup"><span data-stu-id="3038a-116">Credentials such as the origin or the strong name of the assembly determine assembly identity.</span></span> <span data-ttu-id="3038a-117">通过使用类似的凭据，数据还可以按应用程序域进行隔离。</span><span class="sxs-lookup"><span data-stu-id="3038a-117">Data can also be isolated by application domain, using similar credentials.</span></span>

<span data-ttu-id="3038a-118">当使用独立存储时，应用程序将数据保存到与代码标识的某些方面（例如，其发行者或签名）关联的独特数据隔离舱。</span><span class="sxs-lookup"><span data-stu-id="3038a-118">When you use isolated storage, your application saves data to a unique data compartment that is associated with some aspect of the code's identity, such as its publisher or signature.</span></span> <span data-ttu-id="3038a-119">数据隔离舱是一个抽象的存储位置，而不是具体的存储位置，它由一个或多个独立的存储文件（叫做存储区）组成，这些独立的存储文件包含存储数据的实际目录位置。</span><span class="sxs-lookup"><span data-stu-id="3038a-119">The data compartment is an abstraction, not a specific storage location; it consists of one or more isolated storage files, called stores, which contain the actual directory locations where data is stored.</span></span> <span data-ttu-id="3038a-120">例如，应用程序可能有一个与其关联的数据隔离舱，文件系统中的某个目录将实现实际保留应用程序数据的存储区。</span><span class="sxs-lookup"><span data-stu-id="3038a-120">For example, an application might have a data compartment associated with it, and a directory in the file system would implement the store that actually preserves the data for that application.</span></span> <span data-ttu-id="3038a-121">保存在存储区中的数据可以是任意类型的数据，无论是用户首选项信息还是应用程序状态都可以。</span><span class="sxs-lookup"><span data-stu-id="3038a-121">The data saved in the store can be any kind of data, from user preference information to application state.</span></span> <span data-ttu-id="3038a-122">对于开发人员来说，数据隔离舱的位置是透明的。</span><span class="sxs-lookup"><span data-stu-id="3038a-122">For the developer, the location of the data compartment is transparent.</span></span> <span data-ttu-id="3038a-123">应用商店通常位于客户端，但是，服务器应用程序可以使用独立存储通过模拟该服务的用户存储信息。</span><span class="sxs-lookup"><span data-stu-id="3038a-123">Stores usually reside on the client, but a server application could use isolated stores to store information by impersonating the user on whose behalf it is functioning.</span></span> <span data-ttu-id="3038a-124">独立存储还可以将信息和用户漫游配置文件一起存储在服务器上，这样，漫游用户就可以随时使用该信息。</span><span class="sxs-lookup"><span data-stu-id="3038a-124">Isolated storage can also store information on a server with a user's roaming profile so that the information will travel with the roaming user.</span></span>

<a name="quotas"></a>

## <a name="quotas-for-isolated-storage"></a><span data-ttu-id="3038a-125">独立存储的配额</span><span class="sxs-lookup"><span data-stu-id="3038a-125">Quotas for Isolated Storage</span></span>

<span data-ttu-id="3038a-126">配额是对可使用的独立存储数量的限制。</span><span class="sxs-lookup"><span data-stu-id="3038a-126">A quota is a limit on the amount of isolated storage that can be used.</span></span> <span data-ttu-id="3038a-127">配额包括文件空间的字节及与存储区中目录和其他信息关联的系统开销。</span><span class="sxs-lookup"><span data-stu-id="3038a-127">The quota includes bytes of file space as well as the overhead associated with the directory and other information in the store.</span></span> <span data-ttu-id="3038a-128">独立存储使用权限配额，这些配额是使用 <xref:System.Security.Permissions.IsolatedStoragePermission> 对象设置的存储限制。</span><span class="sxs-lookup"><span data-stu-id="3038a-128">Isolated storage uses permission quotas, which are storage limits that are set by using <xref:System.Security.Permissions.IsolatedStoragePermission> objects.</span></span> <span data-ttu-id="3038a-129">如果尝试写入的数据超出配额，则会引发 <xref:System.IO.IsolatedStorage.IsolatedStorageException> 异常。</span><span class="sxs-lookup"><span data-stu-id="3038a-129">If you try to write data that exceeds the quota, an <xref:System.IO.IsolatedStorage.IsolatedStorageException> exception is thrown.</span></span>  <span data-ttu-id="3038a-130">安全策略确定向代码授予的权限，它可以使用 .NET Framework 配置工具 (Mscorcfg.msc) 来修改。</span><span class="sxs-lookup"><span data-stu-id="3038a-130">Security policy, which can be modified using the .NET Framework Configuration Tool (Mscorcfg.msc), determines which permissions are granted to code.</span></span> <span data-ttu-id="3038a-131">已授予 <xref:System.Security.Permissions.IsolatedStoragePermission> 的代码所使用的存储范围不能超过 <xref:System.Security.Permissions.IsolatedStoragePermission.UserQuota%2A> 属性的限制。</span><span class="sxs-lookup"><span data-stu-id="3038a-131">Code that has been granted <xref:System.Security.Permissions.IsolatedStoragePermission> is restricted to using no more storage than the <xref:System.Security.Permissions.IsolatedStoragePermission.UserQuota%2A> property allows.</span></span> <span data-ttu-id="3038a-132">但是，由于代码可以通过表示不同的用户标识绕过权限配额，所以权限配额用作指导代码如何工作的指南，而不是对代码行为的硬性限制。</span><span class="sxs-lookup"><span data-stu-id="3038a-132">However, because code can bypass permission quotas by presenting different user identities, permission quotas serve as guidelines for how code should behave rather than as a firm limit on code behavior.</span></span>

<span data-ttu-id="3038a-133">不对漫游存储区强制执行配额。</span><span class="sxs-lookup"><span data-stu-id="3038a-133">Quotas are not enforced on roaming stores.</span></span> <span data-ttu-id="3038a-134">因此，对使用它们的代码要求稍高级别的权限。</span><span class="sxs-lookup"><span data-stu-id="3038a-134">Because of this, a slightly higher level of permission is required for code to use them.</span></span> <span data-ttu-id="3038a-135">枚举值 <xref:System.Security.Permissions.IsolatedStorageContainment.AssemblyIsolationByRoamingUser> 和 <xref:System.Security.Permissions.IsolatedStorageContainment.DomainIsolationByRoamingUser> 为漫游用户指定使用独立存储的权限。</span><span class="sxs-lookup"><span data-stu-id="3038a-135">The enumeration values <xref:System.Security.Permissions.IsolatedStorageContainment.AssemblyIsolationByRoamingUser> and <xref:System.Security.Permissions.IsolatedStorageContainment.DomainIsolationByRoamingUser> specify a permission to use isolated storage for a roaming user.</span></span>

<a name="secure_access"></a>

## <a name="secure-access"></a><span data-ttu-id="3038a-136">安全访问</span><span class="sxs-lookup"><span data-stu-id="3038a-136">Secure Access</span></span>

<span data-ttu-id="3038a-137">通过使用独立存储，可以使部分受信任的应用程序以由计算机安全策略控制的方式存储数据。</span><span class="sxs-lookup"><span data-stu-id="3038a-137">Using isolated storage enables partially trusted applications to store data in a manner that is controlled by the computer's security policy.</span></span> <span data-ttu-id="3038a-138">对于用户需慎重运行的下载的组件来说，这尤为有用。</span><span class="sxs-lookup"><span data-stu-id="3038a-138">This is especially useful for downloaded components that a user might want to run cautiously.</span></span> <span data-ttu-id="3038a-139">在使用标准 I/O 机制访问文件系统时，安全策略很少向这种代码授予权限。</span><span class="sxs-lookup"><span data-stu-id="3038a-139">Security policy rarely grants this kind of code permission when you access the file system by using standard I/O mechanisms.</span></span> <span data-ttu-id="3038a-140">但是默认情况下，会对在本地计算机、本地网络或 Internet 中运行的代码授予使用独立存储的权限。</span><span class="sxs-lookup"><span data-stu-id="3038a-140">However, by default, code running from the local computer, a local network, or the Internet is granted the right to use isolated storage.</span></span>

<span data-ttu-id="3038a-141">管理员可以根据适当的信任级别限制应用程序或用户可以使用多少独立存储。</span><span class="sxs-lookup"><span data-stu-id="3038a-141">Administrators can limit how much isolated storage an application or a user has available, based on an appropriate trust level.</span></span> <span data-ttu-id="3038a-142">另外，管理员可以完全移除用户的持久性数据。</span><span class="sxs-lookup"><span data-stu-id="3038a-142">In addition, administrators can remove a user's persisted data completely.</span></span> <span data-ttu-id="3038a-143">若要创建或访问独立存储，则必须授予代码相应的 <xref:System.Security.Permissions.IsolatedStorageFilePermission> 权限。</span><span class="sxs-lookup"><span data-stu-id="3038a-143">To create or access isolated storage, code must be granted the appropriate <xref:System.Security.Permissions.IsolatedStorageFilePermission> permission.</span></span>

<span data-ttu-id="3038a-144">要访问独立存储，代码必须具有所有必要的本机平台操作系统权限。</span><span class="sxs-lookup"><span data-stu-id="3038a-144">To access isolated storage, code must have all necessary native platform operating system rights.</span></span> <span data-ttu-id="3038a-145">必须满足用来控制哪些用户有权使用文件系统的访问控制列表 (ACL)。</span><span class="sxs-lookup"><span data-stu-id="3038a-145">The access control lists (ACLs) that control which users have the rights to use the file system must be satisfied.</span></span> <span data-ttu-id="3038a-146">除非执行（特定于平台的）模拟，否则 .NET Framework 应用程序已经具有访问独立存储的操作系统权限。</span><span class="sxs-lookup"><span data-stu-id="3038a-146">.NET Framework applications already have operating system rights to access isolated storage unless they perform (platform-specific) impersonation.</span></span> <span data-ttu-id="3038a-147">在这种情况下，应用程序负责确保被模拟的用户标识具有访问独立存储的适当操作系统权限。</span><span class="sxs-lookup"><span data-stu-id="3038a-147">In this case, the application is responsible for ensuring that the impersonated user identity has the proper operating system rights to access isolated storage.</span></span> <span data-ttu-id="3038a-148">对于在 Web 上运行或从 Web 下载的代码而言，这种访问为之提供了一种对与特定用户相关的存储区域进行读写操作的简便方法。</span><span class="sxs-lookup"><span data-stu-id="3038a-148">This access provides a convenient way for code that is run or downloaded from the web to read and write to a storage area related to a particular user.</span></span>

<span data-ttu-id="3038a-149">为了控制对独立存储的访问，公共语言运行时使用 <xref:System.Security.Permissions.IsolatedStorageFilePermission> 对象。</span><span class="sxs-lookup"><span data-stu-id="3038a-149">To control access to isolated storage, the common language runtime uses <xref:System.Security.Permissions.IsolatedStorageFilePermission> objects.</span></span> <span data-ttu-id="3038a-150">每个对象都具有指定以下值的属性：</span><span class="sxs-lookup"><span data-stu-id="3038a-150">Each object has properties that specify the following values:</span></span>

- <span data-ttu-id="3038a-151">允许的用法，这指出了所允许的访问类型。</span><span class="sxs-lookup"><span data-stu-id="3038a-151">Allowed usage, which indicates the type of access that is allowed.</span></span> <span data-ttu-id="3038a-152">这些值是 <xref:System.Security.Permissions.IsolatedStorageContainment> 枚举的成员。</span><span class="sxs-lookup"><span data-stu-id="3038a-152">The values are members of the <xref:System.Security.Permissions.IsolatedStorageContainment> enumeration.</span></span> <span data-ttu-id="3038a-153">有关这些值的更多信息，请参见下一节中的表。</span><span class="sxs-lookup"><span data-stu-id="3038a-153">For more information about these values, see the table in the next section.</span></span>

- <span data-ttu-id="3038a-154">存储配额（如上一节所述）。</span><span class="sxs-lookup"><span data-stu-id="3038a-154">Storage quota, as discussed in the preceding section.</span></span>

<span data-ttu-id="3038a-155">当代码第一次尝试打开存储时，运行时要求 <xref:System.Security.Permissions.IsolatedStorageFilePermission> 权限。</span><span class="sxs-lookup"><span data-stu-id="3038a-155">The runtime demands <xref:System.Security.Permissions.IsolatedStorageFilePermission> permission when code first attempts to open a store.</span></span> <span data-ttu-id="3038a-156">它根据代码的受信任程度决定是否授予此权限。</span><span class="sxs-lookup"><span data-stu-id="3038a-156">It decides whether to grant this permission, based on how much the code is trusted.</span></span> <span data-ttu-id="3038a-157">如果授予此权限，则允许的用法和存储配额值由安全策略和代码对 <xref:System.Security.Permissions.IsolatedStorageFilePermission>的请求决定。</span><span class="sxs-lookup"><span data-stu-id="3038a-157">If the permission is granted, the allowed usage and storage quota values are determined by security policy and by the code's request for <xref:System.Security.Permissions.IsolatedStorageFilePermission>.</span></span> <span data-ttu-id="3038a-158">安全策略使用 .NET Framework 配置工具 (Mscorcfg.msc) 来进行设置。</span><span class="sxs-lookup"><span data-stu-id="3038a-158">Security policy is set by using the .NET Framework Configuration Tool (Mscorcfg.msc).</span></span> <span data-ttu-id="3038a-159">检查调用堆栈中的所有调用方以确保每个调用方至少具有适当的允许的用法。</span><span class="sxs-lookup"><span data-stu-id="3038a-159">All callers in the call stack are checked to ensure that each caller has at least the appropriate allowed usage.</span></span> <span data-ttu-id="3038a-160">运行时还检查强加于代码的配额，该代码打开或创建将在其中保存文件的存储区。</span><span class="sxs-lookup"><span data-stu-id="3038a-160">The runtime also checks the quota imposed on the code that opened or created the store in which the file is to be saved.</span></span> <span data-ttu-id="3038a-161">如果满足这些条件，就授予权限。</span><span class="sxs-lookup"><span data-stu-id="3038a-161">If these conditions are satisfied, permission is granted.</span></span> <span data-ttu-id="3038a-162">每次文件写入存储区时，都将再次检查配额。</span><span class="sxs-lookup"><span data-stu-id="3038a-162">The quota is checked again every time a file is written to the store.</span></span>

<span data-ttu-id="3038a-163">因为公共语言运行时将根据安全策略授予任何适当的 <xref:System.Security.Permissions.IsolatedStorageFilePermission> ，所以请求权限不需要应用程序代码。</span><span class="sxs-lookup"><span data-stu-id="3038a-163">Application code is not required to request permission because the common language runtime will grant whatever <xref:System.Security.Permissions.IsolatedStorageFilePermission> is appropriate based on security policy.</span></span> <span data-ttu-id="3038a-164">然而，有很好的理由来请求应用程序需要的特定权限，包括 <xref:System.Security.Permissions.IsolatedStorageFilePermission>。</span><span class="sxs-lookup"><span data-stu-id="3038a-164">However, there are good reasons to request specific permissions that your application needs, including <xref:System.Security.Permissions.IsolatedStorageFilePermission>.</span></span>

<a name="allowed_usage"></a>

## <a name="allowed-usage-and-security-risks"></a><span data-ttu-id="3038a-165">允许的用法和安全风险</span><span class="sxs-lookup"><span data-stu-id="3038a-165">Allowed Usage and Security Risks</span></span>

<span data-ttu-id="3038a-166"><xref:System.Security.Permissions.IsolatedStorageFilePermission> 指定的允许的用法确定允许代码创建和使用独立存储的程度。</span><span class="sxs-lookup"><span data-stu-id="3038a-166">The allowed usage specified by <xref:System.Security.Permissions.IsolatedStorageFilePermission> determines the degree to which code will be allowed to create and use isolated storage.</span></span> <span data-ttu-id="3038a-167">下表显示了权限中指定的允许的用法如何与隔离的类型对应，并总结了与每种允许的用法关联的安全风险。</span><span class="sxs-lookup"><span data-stu-id="3038a-167">The following table shows how the allowed usage specified in the permission corresponds to types of isolation and summarizes the security risks associated with each allowed usage.</span></span>

|<span data-ttu-id="3038a-168">允许的用法</span><span class="sxs-lookup"><span data-stu-id="3038a-168">Allowed usage</span></span>|<span data-ttu-id="3038a-169">隔离类型</span><span class="sxs-lookup"><span data-stu-id="3038a-169">Isolation types</span></span>|<span data-ttu-id="3038a-170">安全影响</span><span class="sxs-lookup"><span data-stu-id="3038a-170">Security impact</span></span>|
|-------------------|---------------------|---------------------|
|<xref:System.Security.Permissions.IsolatedStorageContainment.None>|<span data-ttu-id="3038a-171">不允许使用任何独立存储。</span><span class="sxs-lookup"><span data-stu-id="3038a-171">No isolated storage use is allowed.</span></span>|<span data-ttu-id="3038a-172">没有安全影响。</span><span class="sxs-lookup"><span data-stu-id="3038a-172">There is no security impact.</span></span>|
|<xref:System.Security.Permissions.IsolatedStorageContainment.DomainIsolationByUser>|<span data-ttu-id="3038a-173">按用户、域和程序集隔离。</span><span class="sxs-lookup"><span data-stu-id="3038a-173">Isolation by user, domain, and assembly.</span></span> <span data-ttu-id="3038a-174">每个程序集在域中都有单独的子存储区。</span><span class="sxs-lookup"><span data-stu-id="3038a-174">Each assembly has a separate substore within the domain.</span></span> <span data-ttu-id="3038a-175">使用此权限的存储也由计算机隐式隔离。</span><span class="sxs-lookup"><span data-stu-id="3038a-175">Stores that use this permission are also implicitly isolated by computer.</span></span>|<span data-ttu-id="3038a-176">此权限级别无法阻止他人未经授权滥用资源，尽管强制的配额对此做法增添了一些难度。</span><span class="sxs-lookup"><span data-stu-id="3038a-176">This permission level leaves resources open to unauthorized overuse, although enforced quotas make it more difficult.</span></span> <span data-ttu-id="3038a-177">这叫做拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="3038a-177">This is called a denial of service attack.</span></span>|
|<xref:System.Security.Permissions.IsolatedStorageContainment.DomainIsolationByRoamingUser>|<span data-ttu-id="3038a-178">与 `DomainIsolationByUser`相同，但如果启用漫游用户配置文件且不强制配额，则存储将保存到将漫游的位置。</span><span class="sxs-lookup"><span data-stu-id="3038a-178">Same as `DomainIsolationByUser`, but store is saved to a location that will roam if roaming user profiles are enabled and quotas are not enforced.</span></span>|<span data-ttu-id="3038a-179">因为必须禁用配额，所以存储资源更易受到拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="3038a-179">Because quotas must be disabled, storage resources are more vulnerable to a denial of service attack.</span></span>|
|<xref:System.Security.Permissions.IsolatedStorageContainment.AssemblyIsolationByUser>|<span data-ttu-id="3038a-180">按用户和程序集隔离。</span><span class="sxs-lookup"><span data-stu-id="3038a-180">Isolation by user and assembly.</span></span> <span data-ttu-id="3038a-181">使用此权限的存储也由计算机隐式隔离。</span><span class="sxs-lookup"><span data-stu-id="3038a-181">Stores that use this permission are also implicitly isolated by computer.</span></span>|<span data-ttu-id="3038a-182">在此级别强制实施配额以帮助防止拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="3038a-182">Quotas are enforced at this level to help prevent a denial of service attack.</span></span> <span data-ttu-id="3038a-183">由于另一个域中相同的程序集可以访问该存储区，这就使信息可能在应用程序间泄露。</span><span class="sxs-lookup"><span data-stu-id="3038a-183">The same assembly in another domain can access this store, opening the possibility that information could be leaked between applications.</span></span>|
|<xref:System.Security.Permissions.IsolatedStorageContainment.AssemblyIsolationByRoamingUser>|<span data-ttu-id="3038a-184">与 `AssemblyIsolationByUser`相同，但如果启用漫游用户配置文件且不强制配额，则存储将保存到将漫游的位置。</span><span class="sxs-lookup"><span data-stu-id="3038a-184">Same as `AssemblyIsolationByUser`, but store is saved to a location that will roam if roaming user profiles are enabled and quotas are not enforced.</span></span>|<span data-ttu-id="3038a-185">与 `AssemblyIsolationByUser`中相同，但没有配额，增加了拒绝服务攻击的风险。</span><span class="sxs-lookup"><span data-stu-id="3038a-185">Same as in `AssemblyIsolationByUser`, but without quotas, the risk of a denial of service attack increases.</span></span>|
|<xref:System.Security.Permissions.IsolatedStorageContainment.AdministerIsolatedStorageByUser>|<span data-ttu-id="3038a-186">按用户隔离。</span><span class="sxs-lookup"><span data-stu-id="3038a-186">Isolation by user.</span></span> <span data-ttu-id="3038a-187">通常，只有管理或调试工具才使用此级别的权限。</span><span class="sxs-lookup"><span data-stu-id="3038a-187">Typically, only administrative or debugging tools use this level of permission.</span></span>|<span data-ttu-id="3038a-188">使用该权限访问允许代码查看或删除任何的用户独立存储文件或目录（而不论程序集是否隔离）。</span><span class="sxs-lookup"><span data-stu-id="3038a-188">Access with this permission allows code to view or delete any of a user's isolated storage files or directories (regardless of assembly isolation).</span></span> <span data-ttu-id="3038a-189">存在的风险包括（但不限于）泄露信息和数据丢失。</span><span class="sxs-lookup"><span data-stu-id="3038a-189">Risks include, but are not limited to, leaking information and data loss.</span></span>|
|<xref:System.Security.Permissions.IsolatedStorageContainment.UnrestrictedIsolatedStorage>|<span data-ttu-id="3038a-190">按所有用户、域和程序集隔离。</span><span class="sxs-lookup"><span data-stu-id="3038a-190">Isolation by all users, domains, and assemblies.</span></span> <span data-ttu-id="3038a-191">通常，只有管理或调试工具才使用此级别的权限。</span><span class="sxs-lookup"><span data-stu-id="3038a-191">Typically, only administrative or debugging tools use this level of permission.</span></span>|<span data-ttu-id="3038a-192">此权限有可能会整个危害所有用户的所有独立存储区。</span><span class="sxs-lookup"><span data-stu-id="3038a-192">This permission creates the potential for a total compromise of all isolated stores for all users.</span></span>|

## <a name="safety-of-isolated-storage-components-with-regard-to-untrusted-data"></a><span data-ttu-id="3038a-193">与不受信任的数据相关的独立存储组件的安全性</span><span class="sxs-lookup"><span data-stu-id="3038a-193">Safety of isolated storage components with regard to untrusted data</span></span>

<span data-ttu-id="3038a-194">__本节适用于以下框架：__</span><span class="sxs-lookup"><span data-stu-id="3038a-194">__This section applies to the following frameworks:__</span></span>

- <span data-ttu-id="3038a-195">.NET Framework（所有版本）</span><span class="sxs-lookup"><span data-stu-id="3038a-195">.NET Framework (all versions)</span></span>
- <span data-ttu-id="3038a-196">.NET Core 2.1+</span><span class="sxs-lookup"><span data-stu-id="3038a-196">.NET Core 2.1+</span></span>
- <span data-ttu-id="3038a-197">.NET 5.0+</span><span class="sxs-lookup"><span data-stu-id="3038a-197">.NET 5.0+</span></span>

<span data-ttu-id="3038a-198">.NET Framework 和 .NET Core 提供独立存储作为一种为用户、应用程序或组件保留数据的机制。</span><span class="sxs-lookup"><span data-stu-id="3038a-198">.NET Framework and .NET Core offer isolated storage as a mechanism to persist data for a user, an application, or a component.</span></span> <span data-ttu-id="3038a-199">这是一个旧组件，主要用于现已弃用的代码访问安全性方案。</span><span class="sxs-lookup"><span data-stu-id="3038a-199">This is a legacy component primarily designed for now-deprecated Code Access Security scenarios.</span></span>

<span data-ttu-id="3038a-200">各种独立存储 API 和工具可用于跨信任边界读取数据。</span><span class="sxs-lookup"><span data-stu-id="3038a-200">Various isolated storage APIs and tools can be used to read data across trust boundaries.</span></span> <span data-ttu-id="3038a-201">例如，从计算机范围的作用域中读取数据会从计算机上其他可能不太受信任的用户帐户聚合数据。</span><span class="sxs-lookup"><span data-stu-id="3038a-201">For example, reading data from a machine-wide scope can aggregate data from other, possibly less-trusted user accounts on the machine.</span></span> <span data-ttu-id="3038a-202">从计算机范围的独立存储作用域读取的组件或应用程序应了解读取此数据的后果。</span><span class="sxs-lookup"><span data-stu-id="3038a-202">Components or applications which read from machine-wide isolated storage scopes should be aware of the consequences of reading this data.</span></span>

### <a name="security-sensitive-apis-that-can-read-from-the-machine-wide-scope"></a><span data-ttu-id="3038a-203">可从计算机范围作用域读取的安全敏感 API</span><span class="sxs-lookup"><span data-stu-id="3038a-203">Security-sensitive APIs that can read from the machine-wide scope</span></span>

<span data-ttu-id="3038a-204">调用以下任意 API 的组件或应用程序从计算机范围的作用域中读取：</span><span class="sxs-lookup"><span data-stu-id="3038a-204">Components or applications that call any of the following APIs read from the machine-wide scope:</span></span>

* <span data-ttu-id="3038a-205">[IsolatedStorageFile.GetEnumerator](/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getenumerator)，传递包含 IsolatedStorageScope.Machine 标志的作用域</span><span class="sxs-lookup"><span data-stu-id="3038a-205">[IsolatedStorageFile.GetEnumerator](/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getenumerator), passing a scope that includes the IsolatedStorageScope.Machine flag</span></span>
* [<span data-ttu-id="3038a-206">IsolatedStorageFile.GetMachineStoreForApplication</span><span class="sxs-lookup"><span data-stu-id="3038a-206">IsolatedStorageFile.GetMachineStoreForApplication</span></span>](/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getmachinestoreforapplication)
* [<span data-ttu-id="3038a-207">IsolatedStorageFile.GetMachineStoreForAssembly</span><span class="sxs-lookup"><span data-stu-id="3038a-207">IsolatedStorageFile.GetMachineStoreForAssembly</span></span>](/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getmachinestoreforassembly)
* [<span data-ttu-id="3038a-208">IsolatedStorageFile.GetMachineStoreForDomain</span><span class="sxs-lookup"><span data-stu-id="3038a-208">IsolatedStorageFile.GetMachineStoreForDomain</span></span>](/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getmachinestorefordomain)
* <span data-ttu-id="3038a-209">[IsolatedStorageFile.GetStore](/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getstore)，传递包含 IsolatedStorageScope.Machine 标志的作用域</span><span class="sxs-lookup"><span data-stu-id="3038a-209">[IsolatedStorageFile.GetStore](/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getstore), passing a scope that includes the IsolatedStorageScope.Machine flag</span></span>
* <span data-ttu-id="3038a-210">[IsolatedStorageFile.Remove](/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.remove)，传递包含 `IsolatedStorageScope.Machine` 标志的作用域</span><span class="sxs-lookup"><span data-stu-id="3038a-210">[IsolatedStorageFile.Remove](/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.remove), passing a scope that includes the `IsolatedStorageScope.Machine` flag</span></span>

<span data-ttu-id="3038a-211">如果通过 `/machine` 开关调用，则会影响[独立存储工具](../../framework/tools/storeadm-exe-isolated-storage-tool.md) `storeadm.exe`，如以下代码所示：</span><span class="sxs-lookup"><span data-stu-id="3038a-211">The [isolated storage tool](../../framework/tools/storeadm-exe-isolated-storage-tool.md) `storeadm.exe` is impacted if called with the `/machine` switch, as shown in the following code:</span></span>

```txt
storeadm.exe /machine [any-other-switches]
```

<span data-ttu-id="3038a-212">Visual Studio 和 .NET Framework SDK 包含独立存储工具。</span><span class="sxs-lookup"><span data-stu-id="3038a-212">The isolated storage tool is provided as part of Visual Studio and the .NET Framework SDK.</span></span>

<span data-ttu-id="3038a-213">如果应用程序不涉及调用上述 API，或者工作流不涉及以这种方式调用 `storeadm.exe`，则不会应用此文档。</span><span class="sxs-lookup"><span data-stu-id="3038a-213">If the application doesn't involve calls to the preceding APIs, or if the workflow doesn't involve calling `storeadm.exe` in this manner, this document doesn't apply.</span></span>

### <a name="impact-in-multi-user-environments"></a><span data-ttu-id="3038a-214">多用户环境中的影响</span><span class="sxs-lookup"><span data-stu-id="3038a-214">Impact in multi-user environments</span></span>

<span data-ttu-id="3038a-215">如前所述，从一个信任环境写入的数据产生的这些 API 安全影响可从不同的信任环境中读取。</span><span class="sxs-lookup"><span data-stu-id="3038a-215">As mentioned previously, the security impact from these APIs results from data written from one trust environment is read from a different trust environment.</span></span> <span data-ttu-id="3038a-216">独立存储通常使用三个位置中的一个来读取和写入数据：</span><span class="sxs-lookup"><span data-stu-id="3038a-216">Isolated storage generally uses one of three locations to read and write data:</span></span>

1. <span data-ttu-id="3038a-217">`%LOCALAPPDATA%\IsolatedStorage\`：例如，`User` 范围的 `C:\Users\<username>\AppData\Local\IsolatedStorage\`。</span><span class="sxs-lookup"><span data-stu-id="3038a-217">`%LOCALAPPDATA%\IsolatedStorage\`: For example, `C:\Users\<username>\AppData\Local\IsolatedStorage\`, for `User` scope.</span></span>
2. <span data-ttu-id="3038a-218">`%APPDATA%\IsolatedStorage\`：例如，`User|Roaming` 范围的 `C:\Users\<username>\AppData\Roaming\IsolatedStorage\`。</span><span class="sxs-lookup"><span data-stu-id="3038a-218">`%APPDATA%\IsolatedStorage\`: For example, `C:\Users\<username>\AppData\Roaming\IsolatedStorage\`, for `User|Roaming` scope.</span></span>
3. <span data-ttu-id="3038a-219">`%PROGRAMDATA%\IsolatedStorage\`：例如，`Machine` 范围的 `C:\ProgramData\IsolatedStorage\`。</span><span class="sxs-lookup"><span data-stu-id="3038a-219">`%PROGRAMDATA%\IsolatedStorage\`: For example, `C:\ProgramData\IsolatedStorage\`, for `Machine` scope.</span></span>

<span data-ttu-id="3038a-220">每个用户的前两个位置都是独立的。</span><span class="sxs-lookup"><span data-stu-id="3038a-220">The first two locations are isolated per-user.</span></span> <span data-ttu-id="3038a-221">Windows 可确保同一计算机上的不同用户帐户无法访问彼此的用户配置文件文件夹。</span><span class="sxs-lookup"><span data-stu-id="3038a-221">Windows ensures that different user accounts on the same machine cannot access each other's user profile folders.</span></span> <span data-ttu-id="3038a-222">使用 `User` 或 `User|Roaming` 存储区的两个不同用户帐户不会看到彼此的数据，并且不会干扰彼此的数据。</span><span class="sxs-lookup"><span data-stu-id="3038a-222">Two different user accounts who use the `User` or `User|Roaming` stores will not see each other's data and cannot interfere with each other's data.</span></span>

<span data-ttu-id="3038a-223">第三个位置在计算机上的所有用户帐户之间共享。</span><span class="sxs-lookup"><span data-stu-id="3038a-223">The third location is shared across all user accounts on the machine.</span></span> <span data-ttu-id="3038a-224">不同的帐户可以从此位置读取数据以及将数据写入此位置，并且可以查看彼此的数据。</span><span class="sxs-lookup"><span data-stu-id="3038a-224">Different accounts can read from and write to this location, and they're able to see each other's data.</span></span>

<span data-ttu-id="3038a-225">上述路径可能因使用的 Windows 版本而异。</span><span class="sxs-lookup"><span data-stu-id="3038a-225">The preceding paths may differ based on the version of Windows in use.</span></span>

<span data-ttu-id="3038a-226">现在，假设有一个多用户系统，其中有两个注册用户 Mallory 和 Bob 。</span><span class="sxs-lookup"><span data-stu-id="3038a-226">Now consider a multi-user system with two registered users _Mallory_ and _Bob_.</span></span> <span data-ttu-id="3038a-227">Mallory 能够访问用户配置文件目录 `C:\Users\Mallory\`，并且可以访问共享计算机范围的存储位置 `C:\ProgramData\IsolatedStorage\`。</span><span class="sxs-lookup"><span data-stu-id="3038a-227">Mallory has the ability to access her user profile directory `C:\Users\Mallory\`, and she can access the shared machine-wide storage location `C:\ProgramData\IsolatedStorage\`.</span></span> <span data-ttu-id="3038a-228">她无法访问 Bob 的用户配置文件目录 `C:\Users\Bob\`。</span><span class="sxs-lookup"><span data-stu-id="3038a-228">She cannot access Bob's user profile directory `C:\Users\Bob\`.</span></span>

<span data-ttu-id="3038a-229">如果 Mallory 要攻击 Bob，她可以将数据写入到计算机范围的存储位置，然后尝试影响 Bob 从计算机范围的存储中读取数据。</span><span class="sxs-lookup"><span data-stu-id="3038a-229">If Mallory wishes to attack Bob, she might write data to the machine-wide storage location, then attempt to influence Bob into reading from the machine-wide store.</span></span> <span data-ttu-id="3038a-230">当 Bob 运行从该存储区读取的应用时，该应用将对 Mallory 放置在此处的数据进行操作，但从 Bob 的用户帐户的上下文中运行。</span><span class="sxs-lookup"><span data-stu-id="3038a-230">When Bob runs an app that reads from this store, that app will operate on the data Mallory placed there, but from within the context of Bob's user account.</span></span> <span data-ttu-id="3038a-231">本文档的其余部分介绍了各种攻击途径和应用可执行的步骤，以最大程度地降低这些攻击的风险。</span><span class="sxs-lookup"><span data-stu-id="3038a-231">The remainder of this document contemplates various attack vectors and what steps apps can do to minimize their risk to these attacks.</span></span>

<span data-ttu-id="3038a-232">__注意：__ 为了进行这种攻击，Mallory 需要：</span><span class="sxs-lookup"><span data-stu-id="3038a-232">__Note:__ In order for such an attack to take place, Mallory requires:</span></span>

* <span data-ttu-id="3038a-233">计算机上的用户帐户。</span><span class="sxs-lookup"><span data-stu-id="3038a-233">A user account on the machine.</span></span>
* <span data-ttu-id="3038a-234">能够将文件放在文件系统上的已知位置。</span><span class="sxs-lookup"><span data-stu-id="3038a-234">The ability to place a file into a known location on the file system.</span></span>
* <span data-ttu-id="3038a-235">了解 Bob 将在某个时间点运行尝试读取此数据的应用。</span><span class="sxs-lookup"><span data-stu-id="3038a-235">Knowledge that Bob will at some point run an app which attempts to read this data.</span></span>

<span data-ttu-id="3038a-236">这些不是适用于标准单用户桌面环境（例如家庭电脑或单员工企业工作站）的威胁途径。</span><span class="sxs-lookup"><span data-stu-id="3038a-236">These are not threat vectors which apply to standard single-user desktop environments like home PCs or single-employee enterprise workstations.</span></span>

#### <a name="elevation-of-privilege"></a><span data-ttu-id="3038a-237">特权提升</span><span class="sxs-lookup"><span data-stu-id="3038a-237">Elevation of privilege</span></span>

<span data-ttu-id="3038a-238">当 Bob 的应用读取 Mallory 的文件并根据该负载的内容自动尝试执行某些操作时，会出现特权提升攻击。</span><span class="sxs-lookup"><span data-stu-id="3038a-238">An __elevation of privilege__ attack occurs when Bob's app reads Mallory's file and automatically tries to take some action based on the contents of that payload.</span></span> <span data-ttu-id="3038a-239">假设某个应用从计算机范围的存储读取启动脚本的内容，并将这些内容传递到 `Process.Start`。</span><span class="sxs-lookup"><span data-stu-id="3038a-239">Consider an app that reads the contents of a startup script from the machine-wide store and passes those contents to `Process.Start`.</span></span> <span data-ttu-id="3038a-240">如果 Mallory 可以在计算机范围的存储中放置恶意脚本，则在 Bob 启动其应用时：</span><span class="sxs-lookup"><span data-stu-id="3038a-240">If Mallory can place a malicious script inside the machine-wide store, when Bob launches his app:</span></span>

* <span data-ttu-id="3038a-241">Bob 的应用会在其用户配置文件的上下文中分析和启动 Mallory 的恶意脚本。</span><span class="sxs-lookup"><span data-stu-id="3038a-241">His app parses and launches Mallory's malicious script _under the context of Bob's user profile_.</span></span>
* <span data-ttu-id="3038a-242">Mallory 会在本地计算机上获取对 Bob 帐户的访问权限。</span><span class="sxs-lookup"><span data-stu-id="3038a-242">Mallory gaines access to Bob's account on the local machine.</span></span>

#### <a name="denial-of-service"></a><span data-ttu-id="3038a-243">拒绝服务</span><span class="sxs-lookup"><span data-stu-id="3038a-243">Denial of service</span></span>

<span data-ttu-id="3038a-244">当 Bob 的应用读取 Mallory 的文件后崩溃或正常停止运行时，就会出现拒绝服务攻击。</span><span class="sxs-lookup"><span data-stu-id="3038a-244">A __denial of service__ attack occurs when Bob's app reads Mallory's file and crashes or otherwise stops functioning correctly.</span></span> <span data-ttu-id="3038a-245">再次假设前面提到的应用，它尝试从计算机范围的存储分析启动脚本。</span><span class="sxs-lookup"><span data-stu-id="3038a-245">Consider again the app mentioned previously, which attempts to parse a startup script from the machine-wide store.</span></span> <span data-ttu-id="3038a-246">如果 Mallory 可以将格式不正确的文件放在计算机范围的存储中，那么她可以：</span><span class="sxs-lookup"><span data-stu-id="3038a-246">If Mallory can place a file with malformed contents inside the machine-wide store, she might:</span></span>

* <span data-ttu-id="3038a-247">使 Bob 的应用在启动路径初期引发异常。</span><span class="sxs-lookup"><span data-stu-id="3038a-247">Cause Bob's app to throw an exception early in the startup path.</span></span>
* <span data-ttu-id="3038a-248">出于异常原因，阻止应用成功启动。</span><span class="sxs-lookup"><span data-stu-id="3038a-248">Prevent the app from launching successfully because of the exception.</span></span>

<span data-ttu-id="3038a-249">然后，她拒绝 Bob 在他自己的用户帐户下启动该应用。</span><span class="sxs-lookup"><span data-stu-id="3038a-249">She has then denied Bob the ability to launch the app under his own user account.</span></span>

#### <a name="information-disclosure"></a><span data-ttu-id="3038a-250">信息泄露</span><span class="sxs-lookup"><span data-stu-id="3038a-250">Information disclosure</span></span>

<span data-ttu-id="3038a-251">当 Mallory 可以诱使 Bob 泄露 Mallory 通常不能访问的文件内容时，会出现信息泄露。</span><span class="sxs-lookup"><span data-stu-id="3038a-251">An __information disclosure__ attack occurs when Mallory can trick Bob into disclosing the contents of a file that Mallory does not normally have access to.</span></span> <span data-ttu-id="3038a-252">假设 Bob 有一个机密文件 C:\Users\Bob\secret.txt，Mallory 想要读取该文件。</span><span class="sxs-lookup"><span data-stu-id="3038a-252">Consider that Bob has a secret file *C:\Users\Bob\secret.txt* that Mallory wants to read.</span></span> <span data-ttu-id="3038a-253">她知道该文件的路径，但无法读取，因为 Windows 禁止她获取对 Bob 用户配置文件目录的访问权限。</span><span class="sxs-lookup"><span data-stu-id="3038a-253">She knows the path to this file, but she cannot read it because Windows forbids her from gaining access to Bob's user profile directory.</span></span>

<span data-ttu-id="3038a-254">相反，Mallory 会将硬链接放置在计算机范围的存储中。</span><span class="sxs-lookup"><span data-stu-id="3038a-254">Instead, Mallory places a hard link into the machine-wide store.</span></span> <span data-ttu-id="3038a-255">这是一种特殊类型的文件，它本身不包含任何内容，而是指向磁盘上的另一个文件。</span><span class="sxs-lookup"><span data-stu-id="3038a-255">This is a special kind of file that itself does not contain any contents, rather, it points to another file on disk.</span></span> <span data-ttu-id="3038a-256">尝试读取硬链接文件将改为读取链接所指向文件的内容。</span><span class="sxs-lookup"><span data-stu-id="3038a-256">Attempting to read the hard link file will instead read the contents of the file targeted by the link.</span></span> <span data-ttu-id="3038a-257">创建硬链接后，Mallory 仍无法读取文件内容，因为她无权访问链接的目标 (`C:\Users\Bob\secret.txt`)。</span><span class="sxs-lookup"><span data-stu-id="3038a-257">After creating the hard link, Mallory still cannot read the file contents because she does not have access to the target (`C:\Users\Bob\secret.txt`) of the link.</span></span> <span data-ttu-id="3038a-258">不过，Bob 有权访问此文件。</span><span class="sxs-lookup"><span data-stu-id="3038a-258">However, Bob _does_ have access to this file.</span></span>

<span data-ttu-id="3038a-259">当 Bob 的应用现在从计算机范围的存储中读取内容时，会无意中读取他的 `secret.txt` 文件的内容，就像文件本身已存在于计算机范围的存储中一样。</span><span class="sxs-lookup"><span data-stu-id="3038a-259">When Bob's app reads from the machine-wide store, it now inadvertently reads the contents of his `secret.txt` file, just as if the file itself had been present in the machine-wide store.</span></span> <span data-ttu-id="3038a-260">当 Bob 的应用退出时，如果该应用尝试将文件重新保存到计算机范围的存储中，则最终会在 \*C:\ProgramData\IsolatedStorage\* 目录中放置该文件的实际副本。</span><span class="sxs-lookup"><span data-stu-id="3038a-260">When Bob's app exits, if it attempts to resave the file to the machine-wide store, it will end up placing an actual copy of the file in the \*C:\ProgramData\IsolatedStorage\* directory.</span></span> <span data-ttu-id="3038a-261">由于此目录可由计算机上的任何用户读取，Mallory 现在可以读取该文件的内容。</span><span class="sxs-lookup"><span data-stu-id="3038a-261">Since this directory is readable by any user on the machine, Mallory can now read the contents of the file.</span></span>

### <a name="best-practices-to-defend-against-these-attacks"></a><span data-ttu-id="3038a-262">防范这些攻击的最佳做法</span><span class="sxs-lookup"><span data-stu-id="3038a-262">Best practices to defend against these attacks</span></span>

<span data-ttu-id="3038a-263">__重要提示：__ 如果你的环境具有多个相互不受信任的用户，请不要调用 API `IsolatedStorageFile.GetEnumerator(IsolatedStorageScope.Machine)` 或调用工具 `storeadm.exe /machine /list`。</span><span class="sxs-lookup"><span data-stu-id="3038a-263">__Important:__ If your environment has multiple mutually untrusted users, __do not__ call the API `IsolatedStorageFile.GetEnumerator(IsolatedStorageScope.Machine)` or invoke the tool `storeadm.exe /machine /list`.</span></span> <span data-ttu-id="3038a-264">这两种情况都假设它们正在对受信任的数据进行操作。</span><span class="sxs-lookup"><span data-stu-id="3038a-264">Both of these assume that they're operating on trusted data.</span></span> <span data-ttu-id="3038a-265">如果攻击者可以在计算机范围的存储中放置恶意的有效负载，则该有效负载会在运行这些命令的用户的上下文中导致特权提升攻击。</span><span class="sxs-lookup"><span data-stu-id="3038a-265">If an attacker can seed a malicious payload in the machine-wide store, that payload can lead to an elevation of privilege attack under the context of the user who runs these commands.</span></span>

<span data-ttu-id="3038a-266">如果在多用户环境中操作，请重新考虑使用针对计算机范围的独立存储功能。</span><span class="sxs-lookup"><span data-stu-id="3038a-266">If operating in a multi-user environment, reconsider use of isolated storage features which target the _Machine_ scope.</span></span> <span data-ttu-id="3038a-267">如果应用必须从计算机范围的位置中读取数据，则最好从仅由管理员帐户写入的位置读取数据。</span><span class="sxs-lookup"><span data-stu-id="3038a-267">If an app must read data from a machine-wide location, prefer to read the data from a location that are writable only by admin accounts.</span></span> <span data-ttu-id="3038a-268">`%PROGRAMFILES%` 目录和 `HKLM` 注册表配置单元是仅由管理员写入并可由所有人读取的位置的示例。</span><span class="sxs-lookup"><span data-stu-id="3038a-268">The `%PROGRAMFILES%` directory and the `HKLM` registry hive are examples of locations which are writable by only administrators and readable by everyone.</span></span> <span data-ttu-id="3038a-269">因此从这些位置读取的数据为可信数据。</span><span class="sxs-lookup"><span data-stu-id="3038a-269">Data read from those locations is therefore considered trustworthy.</span></span>

<span data-ttu-id="3038a-270">如果应用必须在多用户环境中使用计算机范围，请验证从计算机范围的存储中读取的任何文件内容。</span><span class="sxs-lookup"><span data-stu-id="3038a-270">If an app must use the _Machine_ scope in a multi-user environment, validate the contents of any file that you read from the machine-wide store.</span></span> <span data-ttu-id="3038a-271">如果应用反序列化这些文件中的对象图，请考虑使用更安全的序列化程序，如 `XmlSerializer`，而不是 `BinaryFormatter` 或 `NetDataContractSerializer` 等危险序列化程序。</span><span class="sxs-lookup"><span data-stu-id="3038a-271">If the app deserializing object graphs from these files, consider using safer serializers like `XmlSerializer` instead of dangerous serializers like `BinaryFormatter` or `NetDataContractSerializer`.</span></span> <span data-ttu-id="3038a-272">使用深度嵌套的对象图或根据文件内容执行资源分配的对象图。</span><span class="sxs-lookup"><span data-stu-id="3038a-272">Use caution with deeply nested object graphs or object graphs which perform resource allocation based on the file contents.</span></span>

<a name="isolated_storage_locations"></a>

## <a name="isolated-storage-locations"></a><span data-ttu-id="3038a-273">独立存储位置</span><span class="sxs-lookup"><span data-stu-id="3038a-273">Isolated Storage Locations</span></span>

<span data-ttu-id="3038a-274">有时候，使用操作系统的文件系统来验证对独立存储进行的更改会非常有帮助。</span><span class="sxs-lookup"><span data-stu-id="3038a-274">Sometimes it is helpful to verify a change to isolated storage by using the file system of the operating system.</span></span> <span data-ttu-id="3038a-275">你可能还需要了解独立存储文件的位置。</span><span class="sxs-lookup"><span data-stu-id="3038a-275">You might also want to know the location of isolated storage files.</span></span> <span data-ttu-id="3038a-276">该位置随操作系统的不同而不同。</span><span class="sxs-lookup"><span data-stu-id="3038a-276">This location is different depending on the operating system.</span></span> <span data-ttu-id="3038a-277">下表显示了在几个常见操作系统上创建独立存储的根位置。</span><span class="sxs-lookup"><span data-stu-id="3038a-277">The following table shows the root locations where isolated storage is created on a few common operating systems.</span></span> <span data-ttu-id="3038a-278">在此根位置下查找 Microsoft\IsolatedStorage 目录。</span><span class="sxs-lookup"><span data-stu-id="3038a-278">Look for Microsoft\IsolatedStorage directories under this root location.</span></span> <span data-ttu-id="3038a-279">您必须更改文件夹设置以显示隐藏文件和文件夹，才能查看到文件系统中的独立存储。</span><span class="sxs-lookup"><span data-stu-id="3038a-279">You must change folder settings to show hidden files and folders in order to see isolated storage in the file system.</span></span>

|<span data-ttu-id="3038a-280">操作系统</span><span class="sxs-lookup"><span data-stu-id="3038a-280">Operating system</span></span>|<span data-ttu-id="3038a-281">在文件系统中的位置</span><span class="sxs-lookup"><span data-stu-id="3038a-281">Location in file system</span></span>|
|----------------------|-----------------------------|
|<span data-ttu-id="3038a-282">Windows 2000、Windows XP、Windows Server 2003（从 Windows NT 4.0 升级）</span><span class="sxs-lookup"><span data-stu-id="3038a-282">Windows 2000, Windows XP, Windows Server 2003  (upgrade from Windows NT 4.0)</span></span>|<span data-ttu-id="3038a-283">支持漫游的存储区 =</span><span class="sxs-lookup"><span data-stu-id="3038a-283">Roaming-enabled stores =</span></span><br /><br /> <span data-ttu-id="3038a-284">\<SYSTEMROOT>\Profiles\\<user\>\Application Data</span><span class="sxs-lookup"><span data-stu-id="3038a-284">\<SYSTEMROOT>\Profiles\\<user\>\Application Data</span></span><br /><br /> <span data-ttu-id="3038a-285">非漫游存储区 =</span><span class="sxs-lookup"><span data-stu-id="3038a-285">Nonroaming stores =</span></span><br /><br /> <span data-ttu-id="3038a-286">\<SYSTEMROOT>\Profiles\\<user\>\Local Settings\Application Data</span><span class="sxs-lookup"><span data-stu-id="3038a-286">\<SYSTEMROOT>\Profiles\\<user\>\Local Settings\Application Data</span></span>|
|<span data-ttu-id="3038a-287">Windows 2000 - 全新安装（和从 Windows 98 及 Windows NT 3.51 升级）</span><span class="sxs-lookup"><span data-stu-id="3038a-287">Windows 2000  - clean installation (and upgrades from Windows 98 and Windows NT 3.51)</span></span>|<span data-ttu-id="3038a-288">支持漫游的存储区 =</span><span class="sxs-lookup"><span data-stu-id="3038a-288">Roaming-enabled stores =</span></span><br /><br /> <span data-ttu-id="3038a-289">\<SYSTEMDRIVE>\Documents and Settings\\<user\>\Application Data</span><span class="sxs-lookup"><span data-stu-id="3038a-289">\<SYSTEMDRIVE>\Documents and Settings\\<user\>\Application Data</span></span><br /><br /> <span data-ttu-id="3038a-290">非漫游存储区 =</span><span class="sxs-lookup"><span data-stu-id="3038a-290">Nonroaming stores =</span></span><br /><br /> <span data-ttu-id="3038a-291">\<SYSTEMDRIVE>\Documents and Settings\\<user\>\Local Settings\Application Data</span><span class="sxs-lookup"><span data-stu-id="3038a-291">\<SYSTEMDRIVE>\Documents and Settings\\<user\>\Local Settings\Application Data</span></span>|
|<span data-ttu-id="3038a-292">Windows XP、Windows Server 2003 - 全新安装（和从 Windows 2000 及 Windows 98 升级）</span><span class="sxs-lookup"><span data-stu-id="3038a-292">Windows XP, Windows Server 2003 - clean installation (and upgrades from Windows 2000 and Windows 98)</span></span>|<span data-ttu-id="3038a-293">支持漫游的存储区 =</span><span class="sxs-lookup"><span data-stu-id="3038a-293">Roaming-enabled stores =</span></span><br /><br /> <span data-ttu-id="3038a-294">\<SYSTEMDRIVE>\Documents and Settings\\<user\>\Application Data</span><span class="sxs-lookup"><span data-stu-id="3038a-294">\<SYSTEMDRIVE>\Documents and Settings\\<user\>\Application Data</span></span><br /><br /> <span data-ttu-id="3038a-295">非漫游存储区 =</span><span class="sxs-lookup"><span data-stu-id="3038a-295">Nonroaming stores =</span></span><br /><br /> <span data-ttu-id="3038a-296">\<SYSTEMDRIVE>\Documents and Settings\\<user\>\Local Settings\Application Data</span><span class="sxs-lookup"><span data-stu-id="3038a-296">\<SYSTEMDRIVE>\Documents and Settings\\<user\>\Local Settings\Application Data</span></span>|
|<span data-ttu-id="3038a-297">Windows 8、Windows 7、Windows Server 2008、Windows Vista</span><span class="sxs-lookup"><span data-stu-id="3038a-297">Windows 8, Windows 7, Windows Server 2008, Windows Vista</span></span>|<span data-ttu-id="3038a-298">支持漫游的存储区 =</span><span class="sxs-lookup"><span data-stu-id="3038a-298">Roaming-enabled stores =</span></span><br /><br /> <span data-ttu-id="3038a-299">\<SYSTEMDRIVE>\Users\\<user\>\AppData\Roaming</span><span class="sxs-lookup"><span data-stu-id="3038a-299">\<SYSTEMDRIVE>\Users\\<user\>\AppData\Roaming</span></span><br /><br /> <span data-ttu-id="3038a-300">非漫游存储区 =</span><span class="sxs-lookup"><span data-stu-id="3038a-300">Nonroaming stores =</span></span><br /><br /> <span data-ttu-id="3038a-301">\<SYSTEMDRIVE>\Users\\<user\>\AppData\Local</span><span class="sxs-lookup"><span data-stu-id="3038a-301">\<SYSTEMDRIVE>\Users\\<user\>\AppData\Local</span></span>|

<a name="isolated_storage_tasks"></a>

## <a name="creating-enumerating-and-deleting-isolated-storage"></a><span data-ttu-id="3038a-302">创建、枚举和删除独立存储</span><span class="sxs-lookup"><span data-stu-id="3038a-302">Creating, Enumerating, and Deleting Isolated Storage</span></span>

<span data-ttu-id="3038a-303">.NET Framework 在 <xref:System.IO.IsolatedStorage> 命名空间中提供了三个类来帮助你执行涉及独立存储的任务：</span><span class="sxs-lookup"><span data-stu-id="3038a-303">The .NET Framework provides three classes in the <xref:System.IO.IsolatedStorage> namespace to help you perform tasks that involve isolated storage:</span></span>

- <span data-ttu-id="3038a-304"><xref:System.IO.IsolatedStorage.IsolatedStorageFile>派生自 <xref:System.IO.IsolatedStorage.IsolatedStorage?displayProperty=nameWithType> ，它提供对存储的程序集和应用程序文件的基本管理。</span><span class="sxs-lookup"><span data-stu-id="3038a-304"><xref:System.IO.IsolatedStorage.IsolatedStorageFile>, derives from <xref:System.IO.IsolatedStorage.IsolatedStorage?displayProperty=nameWithType> and provides basic management of stored assembly and application files.</span></span> <span data-ttu-id="3038a-305"><xref:System.IO.IsolatedStorage.IsolatedStorageFile> 类的实例表示位于文件系统中的单个存储区。</span><span class="sxs-lookup"><span data-stu-id="3038a-305">An instance of the <xref:System.IO.IsolatedStorage.IsolatedStorageFile> class represents a single store located in the file system.</span></span>

- <span data-ttu-id="3038a-306"><xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 派生自 <xref:System.IO.FileStream?displayProperty=nameWithType> ，它提供对存储中的文件的访问。</span><span class="sxs-lookup"><span data-stu-id="3038a-306"><xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> derives from <xref:System.IO.FileStream?displayProperty=nameWithType> and provides access to the files in a store.</span></span>

- <span data-ttu-id="3038a-307"><xref:System.IO.IsolatedStorage.IsolatedStorageScope> 是一个枚举，使您可以创建并选择具有适当隔离类型的存储区。</span><span class="sxs-lookup"><span data-stu-id="3038a-307"><xref:System.IO.IsolatedStorage.IsolatedStorageScope> is an enumeration that enables you to create and select a store with the appropriate isolation type.</span></span>

<span data-ttu-id="3038a-308">独立存储类使您可以创建、枚举并删除独立存储。</span><span class="sxs-lookup"><span data-stu-id="3038a-308">The isolated storage classes enable you to create, enumerate, and delete isolated storage.</span></span> <span data-ttu-id="3038a-309">通过 <xref:System.IO.IsolatedStorage.IsolatedStorageFile> 对象可以使用执行这些任务的方法。</span><span class="sxs-lookup"><span data-stu-id="3038a-309">The methods for performing these tasks are available through the <xref:System.IO.IsolatedStorage.IsolatedStorageFile> object.</span></span> <span data-ttu-id="3038a-310">某些操作要求你具有 <xref:System.Security.Permissions.IsolatedStorageFilePermission> 权限（表示管理独立存储的权限）；你可能还需要具有访问文件或目录的操作系统权限。</span><span class="sxs-lookup"><span data-stu-id="3038a-310">Some operations require you to have the <xref:System.Security.Permissions.IsolatedStorageFilePermission> permission that represents the right to administer isolated storage; you might also need to have operating system rights to access the file or directory.</span></span>

<span data-ttu-id="3038a-311">有关演示常见的独立存储任务的一系列示例，请参见 [相关主题](#related_topics)中列出的帮助主题。</span><span class="sxs-lookup"><span data-stu-id="3038a-311">For a series of examples that demonstrate common isolated storage tasks, see the how-to topics listed in [Related Topics](#related_topics).</span></span>

<a name="scenarios_for_isolated_storage"></a>

## <a name="scenarios-for-isolated-storage"></a><span data-ttu-id="3038a-312">独立存储的情况</span><span class="sxs-lookup"><span data-stu-id="3038a-312">Scenarios for Isolated Storage</span></span>

<span data-ttu-id="3038a-313">在许多情况下，独立存储非常有用，包括这四种场景：</span><span class="sxs-lookup"><span data-stu-id="3038a-313">Isolated storage is useful in many situations, including these four scenarios:</span></span>

- <span data-ttu-id="3038a-314">下载的控件。</span><span class="sxs-lookup"><span data-stu-id="3038a-314">Downloaded controls.</span></span> <span data-ttu-id="3038a-315">不允许从 Internet 下载的托管代码控件通过正常的 I/O 类写入硬盘，但它们可以使用独立存储来持久保存用户设置和应用程序状态。</span><span class="sxs-lookup"><span data-stu-id="3038a-315">Managed code controls downloaded from the Internet are not allowed to write to the hard drive through normal I/O classes, but they can use isolated storage to persist users' settings and application states.</span></span>

- <span data-ttu-id="3038a-316">共享组件存储。</span><span class="sxs-lookup"><span data-stu-id="3038a-316">Shared component storage.</span></span> <span data-ttu-id="3038a-317">应用程序间共享的组件可以使用独立存储来提供对数据存储区的有控制的访问。</span><span class="sxs-lookup"><span data-stu-id="3038a-317">Components that are shared between applications can use isolated storage to provide controlled access to data stores.</span></span>

- <span data-ttu-id="3038a-318">服务器存储。</span><span class="sxs-lookup"><span data-stu-id="3038a-318">Server storage.</span></span> <span data-ttu-id="3038a-319">服务器应用程序可以使用独立存储为请求应用程序的大量用户提供单独的存储区。</span><span class="sxs-lookup"><span data-stu-id="3038a-319">Server applications can use isolated storage to provide individual stores for a large number of users making requests to the application.</span></span> <span data-ttu-id="3038a-320">因为独立存储始终按用户进行隔离，所以服务器必须模拟发出请求的用户。</span><span class="sxs-lookup"><span data-stu-id="3038a-320">Because isolated storage is always segregated by user, the server must impersonate the user making the request.</span></span> <span data-ttu-id="3038a-321">在这种情况下，根据主体的标识隔离数据，该标识与应用程序用来区分其用户的标识是同一个标识。</span><span class="sxs-lookup"><span data-stu-id="3038a-321">In this case, data is isolated based on the identity of the principal, which is the same identity the application uses to distinguish between its users.</span></span>

- <span data-ttu-id="3038a-322">漫游。</span><span class="sxs-lookup"><span data-stu-id="3038a-322">Roaming.</span></span> <span data-ttu-id="3038a-323">应用程序还可以将独立存储和漫游用户配置文件一起使用。</span><span class="sxs-lookup"><span data-stu-id="3038a-323">Applications can also use isolated storage with roaming user profiles.</span></span> <span data-ttu-id="3038a-324">这允许用户的独立存储区和配置文件一起漫游。</span><span class="sxs-lookup"><span data-stu-id="3038a-324">This allows a user's isolated stores to roam with the profile.</span></span>

<span data-ttu-id="3038a-325">不应该在以下情况下使用独立存储：</span><span class="sxs-lookup"><span data-stu-id="3038a-325">You should not use isolated storage in the following situations:</span></span>

- <span data-ttu-id="3038a-326">用来存储重要机密，例如不加密的密钥或密码，因为独立存储对高度受信任的代码、非托管代码或计算机的受信任用户不设防。</span><span class="sxs-lookup"><span data-stu-id="3038a-326">To store high-value secrets, such as unencrypted keys or passwords, because isolated storage is not protected from highly trusted code, from unmanaged code, or from trusted users of the computer.</span></span>

- <span data-ttu-id="3038a-327">用来存储代码。</span><span class="sxs-lookup"><span data-stu-id="3038a-327">To store code.</span></span>

- <span data-ttu-id="3038a-328">用来存储管理员控制的配置和部署设置。</span><span class="sxs-lookup"><span data-stu-id="3038a-328">To store configuration and deployment settings, which administrators control.</span></span> <span data-ttu-id="3038a-329">（因为管理员不控制用户首选项，所以用户首选项不被认为是配置设置。）</span><span class="sxs-lookup"><span data-stu-id="3038a-329">(User preferences are not considered to be configuration settings because administrators do not control them.)</span></span>

<span data-ttu-id="3038a-330">许多应用程序都使用数据库来存储和隔离数据，在这种情况下，数据库中的一个或多个行可能代表某个特定用户的存储。</span><span class="sxs-lookup"><span data-stu-id="3038a-330">Many applications use a database to store and isolate data, in which case one or more rows in a database might represent storage for a specific user.</span></span> <span data-ttu-id="3038a-331">当用户数较少时、当使用数据库的系统开销非常大时或当不存在数据库功能时，您可以选择使用独立存储而不使用数据库。</span><span class="sxs-lookup"><span data-stu-id="3038a-331">You might choose to use isolated storage instead of a database when the number of users is small, when the overhead of using a database is significant, or when no database facility exists.</span></span> <span data-ttu-id="3038a-332">另外，当应用程序要求比数据库的行所提供的存储更加灵活和复杂的存储时，独立存储也可以提供一个可行的替代方案。</span><span class="sxs-lookup"><span data-stu-id="3038a-332">Also, when the application requires storage that is more flexible and complex than what a row in a database provides, isolated storage can provide a viable alternative.</span></span>

<a name="related_topics"></a>

## <a name="related-articles"></a><span data-ttu-id="3038a-333">相关文章</span><span class="sxs-lookup"><span data-stu-id="3038a-333">Related articles</span></span>

|<span data-ttu-id="3038a-334">Title</span><span class="sxs-lookup"><span data-stu-id="3038a-334">Title</span></span>|<span data-ttu-id="3038a-335">描述</span><span class="sxs-lookup"><span data-stu-id="3038a-335">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="3038a-336">隔离的类型</span><span class="sxs-lookup"><span data-stu-id="3038a-336">Types of Isolation</span></span>](types-of-isolation.md)|<span data-ttu-id="3038a-337">描述不同类型的隔离。</span><span class="sxs-lookup"><span data-stu-id="3038a-337">Describes the different types of isolation.</span></span>|
|[<span data-ttu-id="3038a-338">如何：获取独立存储的存储区</span><span class="sxs-lookup"><span data-stu-id="3038a-338">How to: Obtain Stores for Isolated Storage</span></span>](how-to-obtain-stores-for-isolated-storage.md)|<span data-ttu-id="3038a-339">提供使用 <xref:System.IO.IsolatedStorage.IsolatedStorageFile> 类获取按用户和程序集隔离的存储区的示例。</span><span class="sxs-lookup"><span data-stu-id="3038a-339">Provides an example of using the <xref:System.IO.IsolatedStorage.IsolatedStorageFile> class to obtain a store isolated by user and assembly.</span></span>|
|[<span data-ttu-id="3038a-340">如何：枚举独立存储的存储区</span><span class="sxs-lookup"><span data-stu-id="3038a-340">How to: Enumerate Stores for Isolated Storage</span></span>](how-to-enumerate-stores-for-isolated-storage.md)|<span data-ttu-id="3038a-341">演示如何使用 <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetEnumerator%2A?displayProperty=nameWithType> 方法计算用户的所有独立存储的大小。</span><span class="sxs-lookup"><span data-stu-id="3038a-341">Shows how to use the <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetEnumerator%2A?displayProperty=nameWithType> method to calculate the size of all isolated storage for the user.</span></span>|
|[<span data-ttu-id="3038a-342">如何：删除独立存储中的存储区</span><span class="sxs-lookup"><span data-stu-id="3038a-342">How to: Delete Stores in Isolated Storage</span></span>](how-to-delete-stores-in-isolated-storage.md)|<span data-ttu-id="3038a-343">演示如何使用 <xref:System.IO.IsolatedStorage.IsolatedStorageFile.Remove%2A?displayProperty=nameWithType> 方法以两种不同方式删除独立存储区。</span><span class="sxs-lookup"><span data-stu-id="3038a-343">Shows how to use the <xref:System.IO.IsolatedStorage.IsolatedStorageFile.Remove%2A?displayProperty=nameWithType> method in two different ways to delete isolated stores.</span></span>|
|[<span data-ttu-id="3038a-344">如何：预见独立存储中的空间不足条件</span><span class="sxs-lookup"><span data-stu-id="3038a-344">How to: Anticipate Out-of-Space Conditions with Isolated Storage</span></span>](how-to-anticipate-out-of-space-conditions-with-isolated-storage.md)|<span data-ttu-id="3038a-345">说明如何测量独立存储区中剩余的空间。</span><span class="sxs-lookup"><span data-stu-id="3038a-345">Shows how to measure the remaining space in an isolated store.</span></span>|
|[<span data-ttu-id="3038a-346">如何：在独立存储中创建文件和目录</span><span class="sxs-lookup"><span data-stu-id="3038a-346">How to: Create Files and Directories in Isolated Storage</span></span>](how-to-create-files-and-directories-in-isolated-storage.md)|<span data-ttu-id="3038a-347">提供一些在独立存储区中创建文件和目录的示例。</span><span class="sxs-lookup"><span data-stu-id="3038a-347">Provides some examples of creating files and directories in an isolated store.</span></span>|
|[<span data-ttu-id="3038a-348">如何：在独立存储中查找现有文件和目录</span><span class="sxs-lookup"><span data-stu-id="3038a-348">How to: Find Existing Files and Directories in Isolated Storage</span></span>](how-to-find-existing-files-and-directories-in-isolated-storage.md)|<span data-ttu-id="3038a-349">演示如何读取独立存储区中的目录结构和文件。</span><span class="sxs-lookup"><span data-stu-id="3038a-349">Demonstrates how to read the directory structure and files in isolated storage.</span></span>|
|[<span data-ttu-id="3038a-350">如何：在独立存储中读取和写入文件</span><span class="sxs-lookup"><span data-stu-id="3038a-350">How to: Read and Write to Files in Isolated Storage</span></span>](how-to-read-and-write-to-files-in-isolated-storage.md)|<span data-ttu-id="3038a-351">提供一个向独立存储文件写入字符串并将其读取回的示例。</span><span class="sxs-lookup"><span data-stu-id="3038a-351">Provides an example of writing a string to an isolated storage file and reading it back.</span></span>|
|[<span data-ttu-id="3038a-352">如何：在独立存储中删除文件和目录</span><span class="sxs-lookup"><span data-stu-id="3038a-352">How to: Delete Files and Directories in Isolated Storage</span></span>](how-to-delete-files-and-directories-in-isolated-storage.md)|<span data-ttu-id="3038a-353">演示如何删除独立存储文件和目录。</span><span class="sxs-lookup"><span data-stu-id="3038a-353">Demonstrates how to delete isolated storage files and directories.</span></span>|
|[<span data-ttu-id="3038a-354">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="3038a-354">File and Stream I/O</span></span>](index.md)|<span data-ttu-id="3038a-355">解释如何执行同步和异步文件和数据流访问。</span><span class="sxs-lookup"><span data-stu-id="3038a-355">Explains how you can perform synchronous and asynchronous file and data stream access.</span></span>|

<a name="reference"></a>

## <a name="reference"></a><span data-ttu-id="3038a-356">参考</span><span class="sxs-lookup"><span data-stu-id="3038a-356">Reference</span></span>

- <xref:System.IO.IsolatedStorage.IsolatedStorage?displayProperty=nameWithType>

- <xref:System.IO.IsolatedStorage.IsolatedStorageFile?displayProperty=nameWithType>

- <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream?displayProperty=nameWithType>

- <xref:System.IO.IsolatedStorage.IsolatedStorageScope?displayProperty=nameWithType>
