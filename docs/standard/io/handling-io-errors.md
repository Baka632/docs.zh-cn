---
title: 处理 .NET 中的 I/O 错误
description: 了解如何处理 .NET 中的 I/O 错误。 将错误代码映射到异常、处理 I/O 操作中的异常，以及处理 IOException。
ms.date: 08/27/2018
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- I/O, exception handling
- I/O, errors
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: bd7112b3052f246a01e4a36d6d425b37cb6174dd
ms.sourcegitcommit: 7588b1f16b7608bc6833c05f91ae670c22ef56f8
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/02/2020
ms.locfileid: "93188037"
---
# <a name="handling-io-errors-in-net"></a><span data-ttu-id="a05a1-104">处理 .NET 中的 I/O 错误</span><span class="sxs-lookup"><span data-stu-id="a05a1-104">Handling I/O errors in .NET</span></span>

<span data-ttu-id="a05a1-105">除了可能在任何方法调用中引发异常（如系统压力过大导致 <xref:System.OutOfMemoryException> 或由于编程器错误导致 <xref:System.NullReferenceException>），.NET 文件系统方法还可能引发以下异常：</span><span class="sxs-lookup"><span data-stu-id="a05a1-105">In addition to the exceptions that can be thrown in any method call (such as an <xref:System.OutOfMemoryException> when a system is stressed or an <xref:System.NullReferenceException> due to programmer error), .NET file system methods can throw the following exceptions:</span></span>

- <span data-ttu-id="a05a1-106"><xref:System.IO.IOException?displayProperty=nameWithType>，所有 <xref:System.IO> 异常类型的基类。</span><span class="sxs-lookup"><span data-stu-id="a05a1-106"><xref:System.IO.IOException?displayProperty=nameWithType>, the base class of all <xref:System.IO> exception types.</span></span> <span data-ttu-id="a05a1-107">当出现操作系统的返回代码不直接映射到任何其他异常类型的错误时将引发此异常。</span><span class="sxs-lookup"><span data-stu-id="a05a1-107">It is thrown for errors whose return codes from the operating system don't directly map to any other exception type.</span></span>
- <span data-ttu-id="a05a1-108"><xref:System.IO.FileNotFoundException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a05a1-108"><xref:System.IO.FileNotFoundException?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="a05a1-109"><xref:System.IO.DirectoryNotFoundException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a05a1-109"><xref:System.IO.DirectoryNotFoundException?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="a05a1-110"><xref:System.IO.DriveNotFoundException??displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a05a1-110"><xref:System.IO.DriveNotFoundException??displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="a05a1-111"><xref:System.IO.PathTooLongException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a05a1-111"><xref:System.IO.PathTooLongException?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="a05a1-112"><xref:System.OperationCanceledException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a05a1-112"><xref:System.OperationCanceledException?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="a05a1-113"><xref:System.UnauthorizedAccessException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a05a1-113"><xref:System.UnauthorizedAccessException?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="a05a1-114">当 .NET Framework 和 .NET Core 2.0 以及先前版本上的路径字符无效时，将引发 <xref:System.ArgumentException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a05a1-114"><xref:System.ArgumentException?displayProperty=nameWithType>, which is thrown for invalid path characters on .NET Framework and on .NET Core 2.0 and previous versions.</span></span>
- <span data-ttu-id="a05a1-115">当 .NET Framework 中存在无效冒号时，将引发 <xref:System.NotSupportedException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a05a1-115"><xref:System.NotSupportedException?displayProperty=nameWithType>, which is thrown for invalid colons in .NET Framework.</span></span>
- <span data-ttu-id="a05a1-116">当在受限制的信任中运行的应用程序缺少仅限于 .NET Framework 的所需权限时，将引发 <xref:System.Security.SecurityException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a05a1-116"><xref:System.Security.SecurityException?displayProperty=nameWithType>, which is thrown for applications running in limited trust that lack the necessary permissions on .NET Framework only.</span></span> <span data-ttu-id="a05a1-117">（完全信任是 .NET Framework 的默认设置。）</span><span class="sxs-lookup"><span data-stu-id="a05a1-117">(Full trust is the default on .NET Framework.)</span></span>

## <a name="mapping-error-codes-to-exceptions"></a><span data-ttu-id="a05a1-118">将错误代码映射到异常</span><span class="sxs-lookup"><span data-stu-id="a05a1-118">Mapping error codes to exceptions</span></span>

<span data-ttu-id="a05a1-119">由于文件系统为操作系统资源，.NET Core 和 .NET Framework 中的 I/O 方法将包装对基础操作系统的调用。</span><span class="sxs-lookup"><span data-stu-id="a05a1-119">Because the file system is an operating system resource, I/O methods in both .NET Core and .NET Framework wrap calls to the underlying operating system.</span></span> <span data-ttu-id="a05a1-120">当由操作系统执行的代码出现 I/O 错误时，操作系统将对 .NET I/O 方法返回错误信息。</span><span class="sxs-lookup"><span data-stu-id="a05a1-120">When an I/O error occurs in code executed by the operating system, the operating system returns error information to the .NET I/O method.</span></span> <span data-ttu-id="a05a1-121">然后，该方法会将错误信息（通常采用错误代码形式）转换为 .NET 异常类型。</span><span class="sxs-lookup"><span data-stu-id="a05a1-121">The method then translates the error information, typically in the form of an error code, into a .NET exception type.</span></span> <span data-ttu-id="a05a1-122">大多数情况下，可以通过直接将错误代码转换为其相应异常类型来完成此操作；它不基于方法调用的上下文执行任何特殊的错误映射。</span><span class="sxs-lookup"><span data-stu-id="a05a1-122">In most cases, it does this by directly translating the error code into its corresponding exception type; it does not perform any special mapping of the error based on the context of the method call.</span></span>

<span data-ttu-id="a05a1-123">例如，在 Windows 操作系统，返回 `ERROR_FILE_NOT_FOUND`（或 0x02）错误代码的方法调用会映射到 <xref:System.IO.FileNotFoundException>，`ERROR_PATH_NOT_FOUND` 错误代码（或 0x03）则映射到 <xref:System.IO.DirectoryNotFoundException>。</span><span class="sxs-lookup"><span data-stu-id="a05a1-123">For example, on the Windows operating system, a method call that returns an error code of `ERROR_FILE_NOT_FOUND` (or 0x02) maps to a <xref:System.IO.FileNotFoundException>, and an error code of `ERROR_PATH_NOT_FOUND` (or 0x03) maps to a <xref:System.IO.DirectoryNotFoundException>.</span></span>

<span data-ttu-id="a05a1-124">但是，操作系统返回特定错误代码的精确条件通常未记录或记录不当。</span><span class="sxs-lookup"><span data-stu-id="a05a1-124">However, the precise conditions under which the operating system returns particular error codes is often undocumented or poorly documented.</span></span> <span data-ttu-id="a05a1-125">因此，会出现意外异常。</span><span class="sxs-lookup"><span data-stu-id="a05a1-125">As a result, unexpected exceptions can occur.</span></span> <span data-ttu-id="a05a1-126">例如，因为使用的是目录而不是文件，可以预料到向 <xref:System.IO.DirectoryInfo.%23ctor%2A> 构造函数提供无效目录路径将引发 <xref:System.IO.DirectoryNotFoundException>。</span><span class="sxs-lookup"><span data-stu-id="a05a1-126">For example, because you are working with a directory rather than a file, you would expect that providing an invalid directory path to the <xref:System.IO.DirectoryInfo.%23ctor%2A> constructor throws a <xref:System.IO.DirectoryNotFoundException>.</span></span> <span data-ttu-id="a05a1-127">但是，它也可能引发 <xref:System.IO.FileNotFoundException>。</span><span class="sxs-lookup"><span data-stu-id="a05a1-127">However, it may also throw a <xref:System.IO.FileNotFoundException>.</span></span>

## <a name="exception-handling-in-io-operations"></a><span data-ttu-id="a05a1-128">I/O 操作中的异常处理</span><span class="sxs-lookup"><span data-stu-id="a05a1-128">Exception handling in I/O operations</span></span>

<span data-ttu-id="a05a1-129">由于操作系统的这一依赖性，相同异常条件（例如在我们的示例中没有发现错误目录）可能会导致 I/O 方法引发任何一种 I/O 异常。</span><span class="sxs-lookup"><span data-stu-id="a05a1-129">Because of this reliance on the operating system, identical exception conditions (such as the directory not found error in our example) can result in an I/O method throwing any one of the entire class of I/O exceptions.</span></span> <span data-ttu-id="a05a1-130">这意味着，在调用 I/O API 时，代码应准备好处理大多数或者所有这些异常，如下表所示：</span><span class="sxs-lookup"><span data-stu-id="a05a1-130">This means that, when calling I/O APIs, your code should be prepared to handle most or all of these exceptions, as shown in the following table:</span></span>

| <span data-ttu-id="a05a1-131">异常类型</span><span class="sxs-lookup"><span data-stu-id="a05a1-131">Exception type</span></span> | <span data-ttu-id="a05a1-132">.NET Core/.NET 5+</span><span class="sxs-lookup"><span data-stu-id="a05a1-132">.NET Core/.NET 5+</span></span> | <span data-ttu-id="a05a1-133">.NET Framework</span><span class="sxs-lookup"><span data-stu-id="a05a1-133">.NET Framework</span></span> |
|---|---|---|
| <xref:System.IO.IOException> | <span data-ttu-id="a05a1-134">是</span><span class="sxs-lookup"><span data-stu-id="a05a1-134">Yes</span></span> | <span data-ttu-id="a05a1-135">是</span><span class="sxs-lookup"><span data-stu-id="a05a1-135">Yes</span></span> |
| <xref:System.IO.FileNotFoundException> | <span data-ttu-id="a05a1-136">是</span><span class="sxs-lookup"><span data-stu-id="a05a1-136">Yes</span></span> | <span data-ttu-id="a05a1-137">是</span><span class="sxs-lookup"><span data-stu-id="a05a1-137">Yes</span></span> |
| <xref:System.IO.DirectoryNotFoundException> | <span data-ttu-id="a05a1-138">是</span><span class="sxs-lookup"><span data-stu-id="a05a1-138">Yes</span></span> | <span data-ttu-id="a05a1-139">是</span><span class="sxs-lookup"><span data-stu-id="a05a1-139">Yes</span></span> |
| <xref:System.IO.DriveNotFoundException?> | <span data-ttu-id="a05a1-140">是</span><span class="sxs-lookup"><span data-stu-id="a05a1-140">Yes</span></span> | <span data-ttu-id="a05a1-141">是</span><span class="sxs-lookup"><span data-stu-id="a05a1-141">Yes</span></span> |
| <xref:System.IO.PathTooLongException> | <span data-ttu-id="a05a1-142">是</span><span class="sxs-lookup"><span data-stu-id="a05a1-142">Yes</span></span> | <span data-ttu-id="a05a1-143">是</span><span class="sxs-lookup"><span data-stu-id="a05a1-143">Yes</span></span> |
| <xref:System.OperationCanceledException> | <span data-ttu-id="a05a1-144">是</span><span class="sxs-lookup"><span data-stu-id="a05a1-144">Yes</span></span> | <span data-ttu-id="a05a1-145">是</span><span class="sxs-lookup"><span data-stu-id="a05a1-145">Yes</span></span> |
| <xref:System.UnauthorizedAccessException> | <span data-ttu-id="a05a1-146">是</span><span class="sxs-lookup"><span data-stu-id="a05a1-146">Yes</span></span> | <span data-ttu-id="a05a1-147">是</span><span class="sxs-lookup"><span data-stu-id="a05a1-147">Yes</span></span> |
| <xref:System.ArgumentException> | <span data-ttu-id="a05a1-148">.NET core 2.0 及早期版本</span><span class="sxs-lookup"><span data-stu-id="a05a1-148">.NET Core 2.0 and earlier</span></span>| <span data-ttu-id="a05a1-149">是</span><span class="sxs-lookup"><span data-stu-id="a05a1-149">Yes</span></span> |
| <xref:System.NotSupportedException> | <span data-ttu-id="a05a1-150">No</span><span class="sxs-lookup"><span data-stu-id="a05a1-150">No</span></span> | <span data-ttu-id="a05a1-151">是</span><span class="sxs-lookup"><span data-stu-id="a05a1-151">Yes</span></span> |
| <xref:System.Security.SecurityException> | <span data-ttu-id="a05a1-152">否</span><span class="sxs-lookup"><span data-stu-id="a05a1-152">No</span></span> | <span data-ttu-id="a05a1-153">仅受限的信任</span><span class="sxs-lookup"><span data-stu-id="a05a1-153">Limited trust only</span></span> |

## <a name="handling-ioexception"></a><span data-ttu-id="a05a1-154">处理 IOException</span><span class="sxs-lookup"><span data-stu-id="a05a1-154">Handling IOException</span></span>

<span data-ttu-id="a05a1-155">作为 <xref:System.IO> 命名空间中异常的基类，当任何错误代码未映射到预定义的异常类型时，也将引发 <xref:System.IO.IOException>。</span><span class="sxs-lookup"><span data-stu-id="a05a1-155">As the base class for exceptions in the <xref:System.IO> namespace, <xref:System.IO.IOException> is also thrown for any error code that does not map to a predefined exception type.</span></span> <span data-ttu-id="a05a1-156">这意味着异常可以由任何 I/O 操作引发。</span><span class="sxs-lookup"><span data-stu-id="a05a1-156">This means that it can be thrown by any I/O operation.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a05a1-157">因为 <xref:System.IO.IOException> 是 <xref:System.IO> 命名空间中其他异常类型的基类，应在处理其他 I/O 相关异常后处理 `catch` 块。</span><span class="sxs-lookup"><span data-stu-id="a05a1-157">Because <xref:System.IO.IOException> is the base class of the other exception types in the <xref:System.IO> namespace, you should handle in a `catch` block after you've handled the other I/O-related exceptions.</span></span>

<span data-ttu-id="a05a1-158">此外，从 .NET Core 2.1 开始，已删除对路径正确性（例如，为了确保路径中不存在无效字符）的验证检查，且运行时会引发从操作系统错误代码（而非从它自己的验证代码）映射的异常。</span><span class="sxs-lookup"><span data-stu-id="a05a1-158">In addition, starting with .NET Core 2.1, validation checks for path correctness (for example, to ensure that invalid characters are not present in a path) have been removed, and the runtime throws an exception mapped from an operating system error code rather than from its own validation code.</span></span> <span data-ttu-id="a05a1-159">在这种情况下，最有可能引发的异常是 <xref:System.IO.IOException>，虽然也可能引发任何其他异常类型。</span><span class="sxs-lookup"><span data-stu-id="a05a1-159">The most likely exception to be thrown in this case is an <xref:System.IO.IOException>, although any other exception type could also be thrown.</span></span>

<span data-ttu-id="a05a1-160">请注意，在异常处理代码中，应始终最后处理 <xref:System.IO.IOException>。</span><span class="sxs-lookup"><span data-stu-id="a05a1-160">Note that, in your exception handling code, you should always handle the <xref:System.IO.IOException> last.</span></span> <span data-ttu-id="a05a1-161">否则，因为它是所有其他 IO 异常的基类，将不会评估派生类的 catch 块。</span><span class="sxs-lookup"><span data-stu-id="a05a1-161">Otherwise, because it is the base class of all other IO exceptions, the catch blocks of derived classes will not be evaluated.</span></span>

<span data-ttu-id="a05a1-162">在 <xref:System.IO.IOException> 情况下，可以从 [IOException.HResult](xref:System.Exception.HResult) 属性获取更多错误信息。</span><span class="sxs-lookup"><span data-stu-id="a05a1-162">In the case of an <xref:System.IO.IOException>, you can get additional error information from the [IOException.HResult](xref:System.Exception.HResult) property.</span></span> <span data-ttu-id="a05a1-163">若要将 HResult 值转换为 Win32 错误代码，可以删除 32 位值的前 16 位。</span><span class="sxs-lookup"><span data-stu-id="a05a1-163">To convert the HResult value to a Win32 error code, you strip out the upper 16 bits of the 32-bit value.</span></span> <span data-ttu-id="a05a1-164">下表列出了可能包装在 <xref:System.IO.IOException> 中的错误代码。</span><span class="sxs-lookup"><span data-stu-id="a05a1-164">The following table lists error codes that may be wrapped in an <xref:System.IO.IOException>.</span></span>

| <span data-ttu-id="a05a1-165">HResult</span><span class="sxs-lookup"><span data-stu-id="a05a1-165">HResult</span></span> | <span data-ttu-id="a05a1-166">返回的常量</span><span class="sxs-lookup"><span data-stu-id="a05a1-166">Constant</span></span> | <span data-ttu-id="a05a1-167">描述</span><span class="sxs-lookup"><span data-stu-id="a05a1-167">Description</span></span> |
| --- | --- | --- |
| <span data-ttu-id="a05a1-168">ERROR_SHARING_VIOLATION</span><span class="sxs-lookup"><span data-stu-id="a05a1-168">ERROR_SHARING_VIOLATION</span></span> | <span data-ttu-id="a05a1-169">32</span><span class="sxs-lookup"><span data-stu-id="a05a1-169">32</span></span> | <span data-ttu-id="a05a1-170">缺少文件名称，或文件或目录正在使用中。</span><span class="sxs-lookup"><span data-stu-id="a05a1-170">The file name is missing, or the file or directory is in use.</span></span> |
| <span data-ttu-id="a05a1-171">ERROR_FILE_EXISTS</span><span class="sxs-lookup"><span data-stu-id="a05a1-171">ERROR_FILE_EXISTS</span></span> | <span data-ttu-id="a05a1-172">80</span><span class="sxs-lookup"><span data-stu-id="a05a1-172">80</span></span> | <span data-ttu-id="a05a1-173">该文件已存在。</span><span class="sxs-lookup"><span data-stu-id="a05a1-173">The file already exists.</span></span> |
| <span data-ttu-id="a05a1-174">ERROR_INVALID_PARAMETER</span><span class="sxs-lookup"><span data-stu-id="a05a1-174">ERROR_INVALID_PARAMETER</span></span> | <span data-ttu-id="a05a1-175">87</span><span class="sxs-lookup"><span data-stu-id="a05a1-175">87</span></span> | <span data-ttu-id="a05a1-176">提供给该方法的参数无效。</span><span class="sxs-lookup"><span data-stu-id="a05a1-176">An argument supplied to the method is invalid.</span></span> |
| <span data-ttu-id="a05a1-177">ERROR_ALREADY_EXISTS</span><span class="sxs-lookup"><span data-stu-id="a05a1-177">ERROR_ALREADY_EXISTS</span></span> | <span data-ttu-id="a05a1-178">183</span><span class="sxs-lookup"><span data-stu-id="a05a1-178">183</span></span> | <span data-ttu-id="a05a1-179">文件或目录已存在。</span><span class="sxs-lookup"><span data-stu-id="a05a1-179">The file or directory already exists.</span></span> |

<span data-ttu-id="a05a1-180">可以使用 catch 语句中的 `When` 子句来处理这些问题，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="a05a1-180">You can handle these using a `When` clause in a catch statement, as the following example shows.</span></span>

[!code-csharp[io-exception-handling](~/samples/snippets/standard/io/io-exceptions/cs/io-exceptions.cs)]
[!code-vb[io-exception-handling](~/samples/snippets/standard/io/io-exceptions/vb/io-exceptions.vb)]

## <a name="see-also"></a><span data-ttu-id="a05a1-181">请参阅</span><span class="sxs-lookup"><span data-stu-id="a05a1-181">See also</span></span>

- [<span data-ttu-id="a05a1-182">在 .NET 中处理和引发异常</span><span class="sxs-lookup"><span data-stu-id="a05a1-182">Handling and throwing exceptions in .NET</span></span>](../exceptions/index.md)
- [<span data-ttu-id="a05a1-183">异常处理（任务并行库）</span><span class="sxs-lookup"><span data-stu-id="a05a1-183">Exception handling (Task Parallel Library)</span></span>](../parallel-programming/exception-handling-task-parallel-library.md)
- [<span data-ttu-id="a05a1-184">针对异常的最佳做法</span><span class="sxs-lookup"><span data-stu-id="a05a1-184">Best practices for exceptions</span></span>](../exceptions/best-practices-for-exceptions.md)
- [<span data-ttu-id="a05a1-185">如何在 catch 块中使用特定异常</span><span class="sxs-lookup"><span data-stu-id="a05a1-185">How to use specific exceptions in a catch block</span></span>](../exceptions/how-to-use-specific-exceptions-in-a-catch-block.md)
