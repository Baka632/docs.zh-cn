---
title: 从 Newtonsoft.Json 迁移到 System.Text.Json - .NET
description: 了解如何从 Newtonsoft.Json 迁移到 System.Text.Json。 包含示例代码。
author: tdykstra
ms.author: tdykstra
no-loc:
- System.Text.Json
- Newtonsoft.Json
ms.date: 11/30/2020
zone_pivot_groups: dotnet-version
helpviewer_keywords:
- JSON serialization
- serializing objects
- serialization
- objects, serializing
ms.openlocfilehash: bc256c5129cd4a7306e632685474b159a43ce76c
ms.sourcegitcommit: 721c3e4bdbb1ea0bb420818ec944c538fe5c513a
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/01/2020
ms.locfileid: "96438063"
---
# <a name="how-to-migrate-from-no-locnewtonsoftjson-to-no-locsystemtextjson"></a><span data-ttu-id="2f54c-104">如何从 Newtonsoft.Json 迁移到 System.Text.Json</span><span class="sxs-lookup"><span data-stu-id="2f54c-104">How to migrate from Newtonsoft.Json to System.Text.Json</span></span>

<span data-ttu-id="2f54c-105">本文演示如何从 [Newtonsoft.Json](https://www.newtonsoft.com/json) 迁移到 <xref:System.Text.Json>。</span><span class="sxs-lookup"><span data-stu-id="2f54c-105">This article shows how to migrate from [Newtonsoft.Json](https://www.newtonsoft.com/json) to <xref:System.Text.Json>.</span></span>

<span data-ttu-id="2f54c-106">`System.Text.Json` 命名空间提供用于序列化和反序列化 JavaScript 对象表示法 (JSON) 的功能。</span><span class="sxs-lookup"><span data-stu-id="2f54c-106">The `System.Text.Json` namespace provides functionality for serializing to and deserializing from JavaScript Object Notation (JSON).</span></span> <span data-ttu-id="2f54c-107">`System.Text.Json` 库包含在 [.NET Core 3.1](https://dotnet.microsoft.com/download/dotnet-core/3.1) 和更高版本的运行时中。</span><span class="sxs-lookup"><span data-stu-id="2f54c-107">The `System.Text.Json` library is included in the runtime for [.NET Core 3.1](https://dotnet.microsoft.com/download/dotnet-core/3.1) and later versions.</span></span> <span data-ttu-id="2f54c-108">对于其他目标框架，请安装 [System.Text.Json](https://www.nuget.org/packages/System.Text.Json) NuGet 包。</span><span class="sxs-lookup"><span data-stu-id="2f54c-108">For other target frameworks, install the [System.Text.Json](https://www.nuget.org/packages/System.Text.Json) NuGet package.</span></span> <span data-ttu-id="2f54c-109">包支持以下框架：</span><span class="sxs-lookup"><span data-stu-id="2f54c-109">The package supports:</span></span>

* <span data-ttu-id="2f54c-110">.NET Standard 2.0 及更高版本</span><span class="sxs-lookup"><span data-stu-id="2f54c-110">.NET Standard 2.0 and later versions</span></span>
* <span data-ttu-id="2f54c-111">.NET Framework 4.7.2 及更高版本</span><span class="sxs-lookup"><span data-stu-id="2f54c-111">.NET Framework 4.7.2 and later versions</span></span>
* <span data-ttu-id="2f54c-112">.NET Core 2.0、2.1 和 2.2</span><span class="sxs-lookup"><span data-stu-id="2f54c-112">.NET Core 2.0, 2.1, and 2.2</span></span>

<span data-ttu-id="2f54c-113">`System.Text.Json` 主要关注性能、安全性和标准符合性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-113">`System.Text.Json` focuses primarily on performance, security, and standards compliance.</span></span> <span data-ttu-id="2f54c-114">它在默认行为方面有一些重要差异，不打算具有与 `Newtonsoft.Json` 相同的功能。</span><span class="sxs-lookup"><span data-stu-id="2f54c-114">It has some key differences in default behavior and doesn't aim to have feature parity with `Newtonsoft.Json`.</span></span> <span data-ttu-id="2f54c-115">对于某些方案，`System.Text.Json` 没有内置功能，但有建议解决方法。</span><span class="sxs-lookup"><span data-stu-id="2f54c-115">For some scenarios, `System.Text.Json` has no built-in functionality, but there are recommended workarounds.</span></span> <span data-ttu-id="2f54c-116">对于其他方案，解决方法是不切实际的。</span><span class="sxs-lookup"><span data-stu-id="2f54c-116">For other scenarios, workarounds are impractical.</span></span> <span data-ttu-id="2f54c-117">如果你的应用程序依赖于缺少的功能，请考虑[提交问题](https://github.com/dotnet/runtime/issues/new)以了解是否可以添加对你的方案的支持。</span><span class="sxs-lookup"><span data-stu-id="2f54c-117">If your application depends on a missing feature, consider [filing an issue](https://github.com/dotnet/runtime/issues/new) to find out if support for your scenario can be added.</span></span>

<span data-ttu-id="2f54c-118">本文的大部分内容介绍如何使用 <xref:System.Text.Json.JsonSerializer> API，不过也包含有关如何使用 <xref:System.Text.Json.JsonDocument>（表示文档对象模型或 DOM）、<xref:System.Text.Json.Utf8JsonReader> 和 <xref:System.Text.Json.Utf8JsonWriter> 类型的指导。</span><span class="sxs-lookup"><span data-stu-id="2f54c-118">Most of this article is about how to use the <xref:System.Text.Json.JsonSerializer> API, but it also includes guidance on how to use the <xref:System.Text.Json.JsonDocument> (which represents the Document Object Model or DOM), <xref:System.Text.Json.Utf8JsonReader>, and <xref:System.Text.Json.Utf8JsonWriter> types.</span></span>

## <a name="table-of-differences-between-no-locnewtonsoftjson-and-no-locsystemtextjson"></a><span data-ttu-id="2f54c-119">介绍 Newtonsoft.Json 与 System.Text.Json 之间差异的表格</span><span class="sxs-lookup"><span data-stu-id="2f54c-119">Table of differences between Newtonsoft.Json and System.Text.Json</span></span>

<span data-ttu-id="2f54c-120">下表列出 `Newtonsoft.Json` 功能和 `System.Text.Json` 等效功能。</span><span class="sxs-lookup"><span data-stu-id="2f54c-120">The following table lists `Newtonsoft.Json` features and `System.Text.Json` equivalents.</span></span> <span data-ttu-id="2f54c-121">这些等效功能分为以下类别：</span><span class="sxs-lookup"><span data-stu-id="2f54c-121">The equivalents fall into the following categories:</span></span>

* <span data-ttu-id="2f54c-122">受支持功能支持。</span><span class="sxs-lookup"><span data-stu-id="2f54c-122">Supported by built-in functionality.</span></span> <span data-ttu-id="2f54c-123">从 `System.Text.Json` 获取类似行为可能需要使用特性或全局选项。</span><span class="sxs-lookup"><span data-stu-id="2f54c-123">Getting similar behavior from `System.Text.Json` may require the use of an attribute or global option.</span></span>
* <span data-ttu-id="2f54c-124">不受支持，可能有解决方法。</span><span class="sxs-lookup"><span data-stu-id="2f54c-124">Not supported, workaround is possible.</span></span> <span data-ttu-id="2f54c-125">解决方法是[自定义转换器](system-text-json-converters-how-to.md)，它们可能无法提供与 `Newtonsoft.Json` 功能完全相同的功能。</span><span class="sxs-lookup"><span data-stu-id="2f54c-125">The workarounds are [custom converters](system-text-json-converters-how-to.md), which may not provide complete parity with `Newtonsoft.Json` functionality.</span></span> <span data-ttu-id="2f54c-126">对于其中一些功能，提供示例代码作为示例。</span><span class="sxs-lookup"><span data-stu-id="2f54c-126">For some of these, sample code is provided as examples.</span></span> <span data-ttu-id="2f54c-127">如果你依赖于这些 `Newtonsoft.Json` 功能，迁移需要修改 .NET 对象模型或进行其他代码更改。</span><span class="sxs-lookup"><span data-stu-id="2f54c-127">If you rely on these `Newtonsoft.Json` features, migration will require modifications to your .NET object models or other code changes.</span></span>
* <span data-ttu-id="2f54c-128">不受支持，解决方法不可行或无法提供。</span><span class="sxs-lookup"><span data-stu-id="2f54c-128">Not supported, workaround is not practical or possible.</span></span> <span data-ttu-id="2f54c-129">如果你依赖于这些 `Newtonsoft.Json` 功能，则无法在不进行重大更改的情况下进行迁移。</span><span class="sxs-lookup"><span data-stu-id="2f54c-129">If you rely on these `Newtonsoft.Json` features, migration will not be possible without significant changes.</span></span>

::: zone pivot="dotnet-5-0"
| <span data-ttu-id="2f54c-130">Newtonsoft.Json 功能</span><span class="sxs-lookup"><span data-stu-id="2f54c-130">Newtonsoft.Json feature</span></span>                               | <span data-ttu-id="2f54c-131">System.Text.Json 等效</span><span class="sxs-lookup"><span data-stu-id="2f54c-131">System.Text.Json equivalent</span></span> |
|-------------------------------------------------------|-----------------------------|
| <span data-ttu-id="2f54c-132">默认情况下不区分大小写的反序列化</span><span class="sxs-lookup"><span data-stu-id="2f54c-132">Case-insensitive deserialization by default</span></span>           | <span data-ttu-id="2f54c-133">✔️ [PropertyNameCaseInsensitive 全局设置](#case-insensitive-deserialization)</span><span class="sxs-lookup"><span data-stu-id="2f54c-133">✔️ [PropertyNameCaseInsensitive global setting](#case-insensitive-deserialization)</span></span> |
| <span data-ttu-id="2f54c-134">Camel 大小写属性名称</span><span class="sxs-lookup"><span data-stu-id="2f54c-134">Camel-case property names</span></span>                             | <span data-ttu-id="2f54c-135">✔️ [PropertyNamingPolicy 全局设置](system-text-json-customize-properties.md#use-camel-case-for-all-json-property-names)</span><span class="sxs-lookup"><span data-stu-id="2f54c-135">✔️ [PropertyNamingPolicy global setting](system-text-json-customize-properties.md#use-camel-case-for-all-json-property-names)</span></span> |
| <span data-ttu-id="2f54c-136">最小字符转义</span><span class="sxs-lookup"><span data-stu-id="2f54c-136">Minimal character escaping</span></span>                            | <span data-ttu-id="2f54c-137">✔️ [严格字符转义，可配置](#minimal-character-escaping)</span><span class="sxs-lookup"><span data-stu-id="2f54c-137">✔️ [Strict character escaping, configurable](#minimal-character-escaping)</span></span> |
| <span data-ttu-id="2f54c-138">`NullValueHandling.Ignore` 全局设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-138">`NullValueHandling.Ignore` global setting</span></span>             | <span data-ttu-id="2f54c-139">✔️ [DefaultIgnoreCondition 全局选项](system-text-json-ignore-properties.md#ignore-all-null-value-properties)</span><span class="sxs-lookup"><span data-stu-id="2f54c-139">✔️ [DefaultIgnoreCondition global option](system-text-json-ignore-properties.md#ignore-all-null-value-properties)</span></span> |[<span data-ttu-id="2f54c-140">有条件地忽略属性</span><span class="sxs-lookup"><span data-stu-id="2f54c-140">Conditionally ignore a property</span></span>](#conditionally-ignore-a-property)
| <span data-ttu-id="2f54c-141">允许注释</span><span class="sxs-lookup"><span data-stu-id="2f54c-141">Allow comments</span></span>                                        | <span data-ttu-id="2f54c-142">✔️ [ReadCommentHandling 全局设置](#comments)</span><span class="sxs-lookup"><span data-stu-id="2f54c-142">✔️ [ReadCommentHandling global setting](#comments)</span></span> |
| <span data-ttu-id="2f54c-143">允许尾随逗号</span><span class="sxs-lookup"><span data-stu-id="2f54c-143">Allow trailing commas</span></span>                                 | <span data-ttu-id="2f54c-144">✔️ [AllowTrailingCommas 全局设置](#trailing-commas)</span><span class="sxs-lookup"><span data-stu-id="2f54c-144">✔️ [AllowTrailingCommas global setting](#trailing-commas)</span></span> |
| <span data-ttu-id="2f54c-145">自定义转换器注册</span><span class="sxs-lookup"><span data-stu-id="2f54c-145">Custom converter registration</span></span>                         | <span data-ttu-id="2f54c-146">✔️ [优先级顺序不同](#converter-registration-precedence)</span><span class="sxs-lookup"><span data-stu-id="2f54c-146">✔️ [Order of precedence differs](#converter-registration-precedence)</span></span> |
| <span data-ttu-id="2f54c-147">默认情况下无最大深度</span><span class="sxs-lookup"><span data-stu-id="2f54c-147">No maximum depth by default</span></span>                           | <span data-ttu-id="2f54c-148">✔️ [默认最大深度为 64，可配置](#maximum-depth)</span><span class="sxs-lookup"><span data-stu-id="2f54c-148">✔️ [Default maximum depth 64, configurable](#maximum-depth)</span></span> |
| <span data-ttu-id="2f54c-149">`PreserveReferencesHandling` 全局设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-149">`PreserveReferencesHandling` global setting</span></span>           | <span data-ttu-id="2f54c-150">✔️ [ReferenceHandling 全局设置](#preserve-object-references-and-handle-loops)</span><span class="sxs-lookup"><span data-stu-id="2f54c-150">✔️ [ReferenceHandling global setting](#preserve-object-references-and-handle-loops)</span></span> |
| <span data-ttu-id="2f54c-151">序列化或反序列化带引号的数字</span><span class="sxs-lookup"><span data-stu-id="2f54c-151">Serialize or deserialize numbers in quotes</span></span>            | <span data-ttu-id="2f54c-152">✔️ [NumberHandling 全局设置，[JsonNumberHandling] 特性](#allow-or-write-numbers-in-quotes)</span><span class="sxs-lookup"><span data-stu-id="2f54c-152">✔️ [NumberHandling global setting, [JsonNumberHandling] attribute](#allow-or-write-numbers-in-quotes)</span></span> |
| <span data-ttu-id="2f54c-153">反序列化为不可变类和结构</span><span class="sxs-lookup"><span data-stu-id="2f54c-153">Deserialize to immutable classes and structs</span></span>          | <span data-ttu-id="2f54c-154">✔️ [JsonConstructor，C# 9 记录](#deserialize-to-immutable-classes-and-structs)</span><span class="sxs-lookup"><span data-stu-id="2f54c-154">✔️ [JsonConstructor, C# 9 Records](#deserialize-to-immutable-classes-and-structs)</span></span> |
| <span data-ttu-id="2f54c-155">支持字段</span><span class="sxs-lookup"><span data-stu-id="2f54c-155">Support for fields</span></span>                                    | <span data-ttu-id="2f54c-156">✔️ [IncludeFields 全局设置，[JsonInclude] 特性](#public-and-non-public-fields)</span><span class="sxs-lookup"><span data-stu-id="2f54c-156">✔️ [IncludeFields global setting, [JsonInclude] attribute](#public-and-non-public-fields)</span></span> |
| <span data-ttu-id="2f54c-157">`DefaultValueHandling` 全局设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-157">`DefaultValueHandling` global setting</span></span>                 | <span data-ttu-id="2f54c-158">✔️ [DefaultIgnoreCondition 全局设置](#conditionally-ignore-a-property)</span><span class="sxs-lookup"><span data-stu-id="2f54c-158">✔️ [DefaultIgnoreCondition global setting](#conditionally-ignore-a-property)</span></span> |
| <span data-ttu-id="2f54c-159">`[JsonProperty]` 上的 `NullValueHandling` 设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-159">`NullValueHandling` setting on `[JsonProperty]`</span></span>       | <span data-ttu-id="2f54c-160">✔️ [JsonIgnore 特性](#conditionally-ignore-a-property)</span><span class="sxs-lookup"><span data-stu-id="2f54c-160">✔️ [JsonIgnore attribute](#conditionally-ignore-a-property)</span></span>  |
| <span data-ttu-id="2f54c-161">`[JsonProperty]` 上的 `DefaultValueHandling` 设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-161">`DefaultValueHandling` setting on `[JsonProperty]`</span></span>    | <span data-ttu-id="2f54c-162">✔️ [JsonIgnore 特性](#conditionally-ignore-a-property)</span><span class="sxs-lookup"><span data-stu-id="2f54c-162">✔️ [JsonIgnore attribute](#conditionally-ignore-a-property)</span></span>  |
| <span data-ttu-id="2f54c-163">反序列化具有非字符串键的 `Dictionary`</span><span class="sxs-lookup"><span data-stu-id="2f54c-163">Deserialize `Dictionary` with non-string key</span></span>          | <span data-ttu-id="2f54c-164">✔️ [受支持](#dictionary-with-non-string-key)</span><span class="sxs-lookup"><span data-stu-id="2f54c-164">✔️ [Supported](#dictionary-with-non-string-key)</span></span> |
| <span data-ttu-id="2f54c-165">支持非公共属性资源库和 Getter</span><span class="sxs-lookup"><span data-stu-id="2f54c-165">Support for non-public property setters and getters</span></span>   | <span data-ttu-id="2f54c-166">✔️ [JsonInclude 特性](#non-public-property-setters-and-getters)</span><span class="sxs-lookup"><span data-stu-id="2f54c-166">✔️ [JsonInclude attribute](#non-public-property-setters-and-getters)</span></span> |
| <span data-ttu-id="2f54c-167">`[JsonConstructor]` 特性</span><span class="sxs-lookup"><span data-stu-id="2f54c-167">`[JsonConstructor]` attribute</span></span>                         | <span data-ttu-id="2f54c-168">✔️ [[JsonConstructor] 特性](#specify-constructor-to-use-when-deserializing)</span><span class="sxs-lookup"><span data-stu-id="2f54c-168">✔️ [[JsonConstructor] attribute](#specify-constructor-to-use-when-deserializing)</span></span> |
| <span data-ttu-id="2f54c-169">支持范围广泛的类型</span><span class="sxs-lookup"><span data-stu-id="2f54c-169">Support for a broad range of types</span></span>                    | <span data-ttu-id="2f54c-170">⚠️ [某些类型需要自定义转换器](#types-without-built-in-support)</span><span class="sxs-lookup"><span data-stu-id="2f54c-170">⚠️ [Some types require custom converters](#types-without-built-in-support)</span></span> |
| <span data-ttu-id="2f54c-171">多态序列化</span><span class="sxs-lookup"><span data-stu-id="2f54c-171">Polymorphic serialization</span></span>                             | <span data-ttu-id="2f54c-172">⚠️ [不受支持，解决方法，示例](#polymorphic-serialization)</span><span class="sxs-lookup"><span data-stu-id="2f54c-172">⚠️ [Not supported, workaround, sample](#polymorphic-serialization)</span></span> |
| <span data-ttu-id="2f54c-173">多态反序列化</span><span class="sxs-lookup"><span data-stu-id="2f54c-173">Polymorphic deserialization</span></span>                           | <span data-ttu-id="2f54c-174">⚠️ [不受支持，解决方法，示例](#polymorphic-deserialization)</span><span class="sxs-lookup"><span data-stu-id="2f54c-174">⚠️ [Not supported, workaround, sample](#polymorphic-deserialization)</span></span> |
| <span data-ttu-id="2f54c-175">将推断类型反序列化为 `object` 属性</span><span class="sxs-lookup"><span data-stu-id="2f54c-175">Deserialize inferred type to `object` properties</span></span>      | <span data-ttu-id="2f54c-176">⚠️ [不受支持，解决方法，示例](#deserialization-of-object-properties)</span><span class="sxs-lookup"><span data-stu-id="2f54c-176">⚠️ [Not supported, workaround, sample](#deserialization-of-object-properties)</span></span> |
| <span data-ttu-id="2f54c-177">将 JSON `null` 文本反序列化为不可为 null 的值类型</span><span class="sxs-lookup"><span data-stu-id="2f54c-177">Deserialize JSON `null` literal to non-nullable value types</span></span> | <span data-ttu-id="2f54c-178">⚠️ [不受支持，解决方法，示例](#deserialize-null-to-non-nullable-type)</span><span class="sxs-lookup"><span data-stu-id="2f54c-178">⚠️ [Not supported, workaround, sample](#deserialize-null-to-non-nullable-type)</span></span> |
| <span data-ttu-id="2f54c-179">`[JsonProperty]` 特性上的 `Required` 设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-179">`Required` setting on `[JsonProperty]` attribute</span></span>        | <span data-ttu-id="2f54c-180">⚠️ [不受支持，解决方法，示例](#required-properties)</span><span class="sxs-lookup"><span data-stu-id="2f54c-180">⚠️ [Not supported, workaround, sample](#required-properties)</span></span> |
| <span data-ttu-id="2f54c-181">`DefaultContractResolver` 用于忽略属性</span><span class="sxs-lookup"><span data-stu-id="2f54c-181">`DefaultContractResolver` to ignore properties</span></span>       | <span data-ttu-id="2f54c-182">⚠️ [不受支持，解决方法，示例](#conditionally-ignore-a-property)</span><span class="sxs-lookup"><span data-stu-id="2f54c-182">⚠️ [Not supported, workaround, sample](#conditionally-ignore-a-property)</span></span> |
| <span data-ttu-id="2f54c-183">`DateTimeZoneHandling`、`DateFormatString` 设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-183">`DateTimeZoneHandling`, `DateFormatString` settings</span></span>   | <span data-ttu-id="2f54c-184">⚠️ [不受支持，解决方法，示例](#specify-date-format)</span><span class="sxs-lookup"><span data-stu-id="2f54c-184">⚠️ [Not supported, workaround, sample](#specify-date-format)</span></span> |
| <span data-ttu-id="2f54c-185">回调</span><span class="sxs-lookup"><span data-stu-id="2f54c-185">Callbacks</span></span>                                             | <span data-ttu-id="2f54c-186">⚠️ [不受支持，解决方法，示例](#callbacks)</span><span class="sxs-lookup"><span data-stu-id="2f54c-186">⚠️ [Not supported, workaround, sample](#callbacks)</span></span> |
| <span data-ttu-id="2f54c-187">`JsonConvert.PopulateObject` 方法</span><span class="sxs-lookup"><span data-stu-id="2f54c-187">`JsonConvert.PopulateObject` method</span></span>                   | <span data-ttu-id="2f54c-188">⚠️ [不受支持，解决方法](#populate-existing-objects)</span><span class="sxs-lookup"><span data-stu-id="2f54c-188">⚠️ [Not supported, workaround](#populate-existing-objects)</span></span> |
| <span data-ttu-id="2f54c-189">`ObjectCreationHandling` 全局设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-189">`ObjectCreationHandling` global setting</span></span>               | <span data-ttu-id="2f54c-190">⚠️ [不受支持，解决方法](#reuse-rather-than-replace-properties)</span><span class="sxs-lookup"><span data-stu-id="2f54c-190">⚠️ [Not supported, workaround](#reuse-rather-than-replace-properties)</span></span> |
| <span data-ttu-id="2f54c-191">在不带 setter 的情况下添加到集合</span><span class="sxs-lookup"><span data-stu-id="2f54c-191">Add to collections without setters</span></span>                    | <span data-ttu-id="2f54c-192">⚠️ [不受支持，解决方法](#add-to-collections-without-setters)</span><span class="sxs-lookup"><span data-stu-id="2f54c-192">⚠️ [Not supported, workaround](#add-to-collections-without-setters)</span></span> |
| <span data-ttu-id="2f54c-193">`ReferenceLoopHandling` 全局设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-193">`ReferenceLoopHandling` global setting</span></span>                | <span data-ttu-id="2f54c-194">❌ [不受支持](#preserve-object-references-and-handle-loops)</span><span class="sxs-lookup"><span data-stu-id="2f54c-194">❌ [Not supported](#preserve-object-references-and-handle-loops)</span></span> |
| <span data-ttu-id="2f54c-195">支持 `System.Runtime.Serialization` 特性</span><span class="sxs-lookup"><span data-stu-id="2f54c-195">Support for `System.Runtime.Serialization` attributes</span></span> | <span data-ttu-id="2f54c-196">❌ [不受支持](#systemruntimeserialization-attributes)</span><span class="sxs-lookup"><span data-stu-id="2f54c-196">❌ [Not supported](#systemruntimeserialization-attributes)</span></span> |
| <span data-ttu-id="2f54c-197">`MissingMemberHandling` 全局设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-197">`MissingMemberHandling` global setting</span></span>                | <span data-ttu-id="2f54c-198">❌ [不受支持](#missingmemberhandling)</span><span class="sxs-lookup"><span data-stu-id="2f54c-198">❌ [Not supported](#missingmemberhandling)</span></span> |
| <span data-ttu-id="2f54c-199">允许不带引号的属性名称</span><span class="sxs-lookup"><span data-stu-id="2f54c-199">Allow property names without quotes</span></span>                   | <span data-ttu-id="2f54c-200">❌ [不受支持](#json-strings-property-names-and-string-values)</span><span class="sxs-lookup"><span data-stu-id="2f54c-200">❌ [Not supported](#json-strings-property-names-and-string-values)</span></span> |
| <span data-ttu-id="2f54c-201">字符串值前后允许单引号</span><span class="sxs-lookup"><span data-stu-id="2f54c-201">Allow single quotes around string values</span></span>              | <span data-ttu-id="2f54c-202">❌ [不受支持](#json-strings-property-names-and-string-values)</span><span class="sxs-lookup"><span data-stu-id="2f54c-202">❌ [Not supported](#json-strings-property-names-and-string-values)</span></span> |
| <span data-ttu-id="2f54c-203">对字符串属性允许非字符串 JSON 值</span><span class="sxs-lookup"><span data-stu-id="2f54c-203">Allow non-string JSON values for string properties</span></span>    | <span data-ttu-id="2f54c-204">❌ [不受支持](#non-string-values-for-string-properties)</span><span class="sxs-lookup"><span data-stu-id="2f54c-204">❌ [Not supported](#non-string-values-for-string-properties)</span></span> |
::: zone-end

::: zone pivot="dotnet-core-3-1"
| <span data-ttu-id="2f54c-205">Newtonsoft.Json 功能</span><span class="sxs-lookup"><span data-stu-id="2f54c-205">Newtonsoft.Json feature</span></span>                               | <span data-ttu-id="2f54c-206">System.Text.Json 等效</span><span class="sxs-lookup"><span data-stu-id="2f54c-206">System.Text.Json equivalent</span></span> |
|-------------------------------------------------------|-----------------------------|
| <span data-ttu-id="2f54c-207">默认情况下不区分大小写的反序列化</span><span class="sxs-lookup"><span data-stu-id="2f54c-207">Case-insensitive deserialization by default</span></span>           | <span data-ttu-id="2f54c-208">✔️ [PropertyNameCaseInsensitive 全局设置](#case-insensitive-deserialization)</span><span class="sxs-lookup"><span data-stu-id="2f54c-208">✔️ [PropertyNameCaseInsensitive global setting](#case-insensitive-deserialization)</span></span> |
| <span data-ttu-id="2f54c-209">Camel 大小写属性名称</span><span class="sxs-lookup"><span data-stu-id="2f54c-209">Camel-case property names</span></span>                             | <span data-ttu-id="2f54c-210">✔️ [PropertyNamingPolicy 全局设置](system-text-json-customize-properties.md#use-camel-case-for-all-json-property-names)</span><span class="sxs-lookup"><span data-stu-id="2f54c-210">✔️ [PropertyNamingPolicy global setting](system-text-json-customize-properties.md#use-camel-case-for-all-json-property-names)</span></span> |
| <span data-ttu-id="2f54c-211">最小字符转义</span><span class="sxs-lookup"><span data-stu-id="2f54c-211">Minimal character escaping</span></span>                            | <span data-ttu-id="2f54c-212">✔️ [严格字符转义，可配置](#minimal-character-escaping)</span><span class="sxs-lookup"><span data-stu-id="2f54c-212">✔️ [Strict character escaping, configurable](#minimal-character-escaping)</span></span> |
| <span data-ttu-id="2f54c-213">`NullValueHandling.Ignore` 全局设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-213">`NullValueHandling.Ignore` global setting</span></span>             | <span data-ttu-id="2f54c-214">✔️ [IgnoreNullValues 全局选项](system-text-json-ignore-properties.md#ignore-all-null-value-properties)</span><span class="sxs-lookup"><span data-stu-id="2f54c-214">✔️ [IgnoreNullValues global option](system-text-json-ignore-properties.md#ignore-all-null-value-properties)</span></span> |
| <span data-ttu-id="2f54c-215">允许注释</span><span class="sxs-lookup"><span data-stu-id="2f54c-215">Allow comments</span></span>                                        | <span data-ttu-id="2f54c-216">✔️ [ReadCommentHandling 全局设置](#comments)</span><span class="sxs-lookup"><span data-stu-id="2f54c-216">✔️ [ReadCommentHandling global setting](#comments)</span></span> |
| <span data-ttu-id="2f54c-217">允许尾随逗号</span><span class="sxs-lookup"><span data-stu-id="2f54c-217">Allow trailing commas</span></span>                                 | <span data-ttu-id="2f54c-218">✔️ [AllowTrailingCommas 全局设置](#trailing-commas)</span><span class="sxs-lookup"><span data-stu-id="2f54c-218">✔️ [AllowTrailingCommas global setting](#trailing-commas)</span></span> |
| <span data-ttu-id="2f54c-219">自定义转换器注册</span><span class="sxs-lookup"><span data-stu-id="2f54c-219">Custom converter registration</span></span>                         | <span data-ttu-id="2f54c-220">✔️ [优先级顺序不同](#converter-registration-precedence)</span><span class="sxs-lookup"><span data-stu-id="2f54c-220">✔️ [Order of precedence differs](#converter-registration-precedence)</span></span> |
| <span data-ttu-id="2f54c-221">默认情况下无最大深度</span><span class="sxs-lookup"><span data-stu-id="2f54c-221">No maximum depth by default</span></span>                           | <span data-ttu-id="2f54c-222">✔️ [默认最大深度为 64，可配置](#maximum-depth)</span><span class="sxs-lookup"><span data-stu-id="2f54c-222">✔️ [Default maximum depth 64, configurable](#maximum-depth)</span></span> |
| <span data-ttu-id="2f54c-223">支持范围广泛的类型</span><span class="sxs-lookup"><span data-stu-id="2f54c-223">Support for a broad range of types</span></span>                    | <span data-ttu-id="2f54c-224">⚠️ [某些类型需要自定义转换器](#types-without-built-in-support)</span><span class="sxs-lookup"><span data-stu-id="2f54c-224">⚠️ [Some types require custom converters](#types-without-built-in-support)</span></span> |
| <span data-ttu-id="2f54c-225">将字符串反序列化为数字</span><span class="sxs-lookup"><span data-stu-id="2f54c-225">Deserialize strings as numbers</span></span>                        | <span data-ttu-id="2f54c-226">⚠️ [不受支持，解决方法，示例](#allow-or-write-numbers-in-quotes)</span><span class="sxs-lookup"><span data-stu-id="2f54c-226">⚠️ [Not supported, workaround, sample](#allow-or-write-numbers-in-quotes)</span></span> |
| <span data-ttu-id="2f54c-227">反序列化具有非字符串键的 `Dictionary`</span><span class="sxs-lookup"><span data-stu-id="2f54c-227">Deserialize `Dictionary` with non-string key</span></span>          | <span data-ttu-id="2f54c-228">⚠️ [不受支持，解决方法，示例](#dictionary-with-non-string-key)</span><span class="sxs-lookup"><span data-stu-id="2f54c-228">⚠️ [Not supported, workaround, sample](#dictionary-with-non-string-key)</span></span> |
| <span data-ttu-id="2f54c-229">多态序列化</span><span class="sxs-lookup"><span data-stu-id="2f54c-229">Polymorphic serialization</span></span>                             | <span data-ttu-id="2f54c-230">⚠️ [不受支持，解决方法，示例](#polymorphic-serialization)</span><span class="sxs-lookup"><span data-stu-id="2f54c-230">⚠️ [Not supported, workaround, sample](#polymorphic-serialization)</span></span> |
| <span data-ttu-id="2f54c-231">多态反序列化</span><span class="sxs-lookup"><span data-stu-id="2f54c-231">Polymorphic deserialization</span></span>                           | <span data-ttu-id="2f54c-232">⚠️ [不受支持，解决方法，示例](#polymorphic-deserialization)</span><span class="sxs-lookup"><span data-stu-id="2f54c-232">⚠️ [Not supported, workaround, sample](#polymorphic-deserialization)</span></span> |
| <span data-ttu-id="2f54c-233">将推断类型反序列化为 `object` 属性</span><span class="sxs-lookup"><span data-stu-id="2f54c-233">Deserialize inferred type to `object` properties</span></span>      | <span data-ttu-id="2f54c-234">⚠️ [不受支持，解决方法，示例](#deserialization-of-object-properties)</span><span class="sxs-lookup"><span data-stu-id="2f54c-234">⚠️ [Not supported, workaround, sample](#deserialization-of-object-properties)</span></span> |
| <span data-ttu-id="2f54c-235">将 JSON `null` 文本反序列化为不可为 null 的值类型</span><span class="sxs-lookup"><span data-stu-id="2f54c-235">Deserialize JSON `null` literal to non-nullable value types</span></span> | <span data-ttu-id="2f54c-236">⚠️ [不受支持，解决方法，示例](#deserialize-null-to-non-nullable-type)</span><span class="sxs-lookup"><span data-stu-id="2f54c-236">⚠️ [Not supported, workaround, sample](#deserialize-null-to-non-nullable-type)</span></span> |
| <span data-ttu-id="2f54c-237">反序列化为不可变类和结构</span><span class="sxs-lookup"><span data-stu-id="2f54c-237">Deserialize to immutable classes and structs</span></span>          | <span data-ttu-id="2f54c-238">⚠️ [不受支持，解决方法，示例](#deserialize-to-immutable-classes-and-structs)</span><span class="sxs-lookup"><span data-stu-id="2f54c-238">⚠️ [Not supported, workaround, sample](#deserialize-to-immutable-classes-and-structs)</span></span> |
| <span data-ttu-id="2f54c-239">`[JsonConstructor]` 特性</span><span class="sxs-lookup"><span data-stu-id="2f54c-239">`[JsonConstructor]` attribute</span></span>                         | <span data-ttu-id="2f54c-240">⚠️ [不受支持，解决方法，示例](#specify-constructor-to-use-when-deserializing)</span><span class="sxs-lookup"><span data-stu-id="2f54c-240">⚠️ [Not supported, workaround, sample](#specify-constructor-to-use-when-deserializing)</span></span> |
| <span data-ttu-id="2f54c-241">`[JsonProperty]` 特性上的 `Required` 设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-241">`Required` setting on `[JsonProperty]` attribute</span></span>        | <span data-ttu-id="2f54c-242">⚠️ [不受支持，解决方法，示例](#required-properties)</span><span class="sxs-lookup"><span data-stu-id="2f54c-242">⚠️ [Not supported, workaround, sample](#required-properties)</span></span> |
| <span data-ttu-id="2f54c-243">`[JsonProperty]` 特性上的 `NullValueHandling` 设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-243">`NullValueHandling` setting on `[JsonProperty]` attribute</span></span> | <span data-ttu-id="2f54c-244">⚠️ [不受支持，解决方法，示例](#conditionally-ignore-a-property)</span><span class="sxs-lookup"><span data-stu-id="2f54c-244">⚠️ [Not supported, workaround, sample](#conditionally-ignore-a-property)</span></span>  |
| <span data-ttu-id="2f54c-245">`[JsonProperty]` 特性上的 `DefaultValueHandling` 设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-245">`DefaultValueHandling` setting on `[JsonProperty]` attribute</span></span> | <span data-ttu-id="2f54c-246">⚠️ [不受支持，解决方法，示例](#conditionally-ignore-a-property)</span><span class="sxs-lookup"><span data-stu-id="2f54c-246">⚠️ [Not supported, workaround, sample](#conditionally-ignore-a-property)</span></span>  |
| <span data-ttu-id="2f54c-247">`DefaultValueHandling` 全局设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-247">`DefaultValueHandling` global setting</span></span>                 | <span data-ttu-id="2f54c-248">⚠️ [不受支持，解决方法，示例](#conditionally-ignore-a-property)</span><span class="sxs-lookup"><span data-stu-id="2f54c-248">⚠️ [Not supported, workaround, sample](#conditionally-ignore-a-property)</span></span> |
| <span data-ttu-id="2f54c-249">`DefaultContractResolver` 用于忽略属性</span><span class="sxs-lookup"><span data-stu-id="2f54c-249">`DefaultContractResolver` to ignore properties</span></span>       | <span data-ttu-id="2f54c-250">⚠️ [不受支持，解决方法，示例](#conditionally-ignore-a-property)</span><span class="sxs-lookup"><span data-stu-id="2f54c-250">⚠️ [Not supported, workaround, sample](#conditionally-ignore-a-property)</span></span> |
| <span data-ttu-id="2f54c-251">`DateTimeZoneHandling`、`DateFormatString` 设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-251">`DateTimeZoneHandling`, `DateFormatString` settings</span></span>   | <span data-ttu-id="2f54c-252">⚠️ [不受支持，解决方法，示例](#specify-date-format)</span><span class="sxs-lookup"><span data-stu-id="2f54c-252">⚠️ [Not supported, workaround, sample](#specify-date-format)</span></span> |
| <span data-ttu-id="2f54c-253">回调</span><span class="sxs-lookup"><span data-stu-id="2f54c-253">Callbacks</span></span>                                             | <span data-ttu-id="2f54c-254">⚠️ [不受支持，解决方法，示例](#callbacks)</span><span class="sxs-lookup"><span data-stu-id="2f54c-254">⚠️ [Not supported, workaround, sample](#callbacks)</span></span> |
| <span data-ttu-id="2f54c-255">支持公共和非公共字段</span><span class="sxs-lookup"><span data-stu-id="2f54c-255">Support for public and non-public fields</span></span>              | <span data-ttu-id="2f54c-256">⚠️ [不受支持，解决方法](#public-and-non-public-fields)</span><span class="sxs-lookup"><span data-stu-id="2f54c-256">⚠️ [Not supported, workaround](#public-and-non-public-fields)</span></span> |
| <span data-ttu-id="2f54c-257">支持非公共属性资源库和 Getter</span><span class="sxs-lookup"><span data-stu-id="2f54c-257">Support for non-public property setters and getters</span></span>   | <span data-ttu-id="2f54c-258">⚠️ [不受支持，解决方法](#non-public-property-setters-and-getters)</span><span class="sxs-lookup"><span data-stu-id="2f54c-258">⚠️ [Not supported, workaround](#non-public-property-setters-and-getters)</span></span> |
| <span data-ttu-id="2f54c-259">`JsonConvert.PopulateObject` 方法</span><span class="sxs-lookup"><span data-stu-id="2f54c-259">`JsonConvert.PopulateObject` method</span></span>                   | <span data-ttu-id="2f54c-260">⚠️ [不受支持，解决方法](#populate-existing-objects)</span><span class="sxs-lookup"><span data-stu-id="2f54c-260">⚠️ [Not supported, workaround](#populate-existing-objects)</span></span> |
| <span data-ttu-id="2f54c-261">`ObjectCreationHandling` 全局设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-261">`ObjectCreationHandling` global setting</span></span>               | <span data-ttu-id="2f54c-262">⚠️ [不受支持，解决方法](#reuse-rather-than-replace-properties)</span><span class="sxs-lookup"><span data-stu-id="2f54c-262">⚠️ [Not supported, workaround](#reuse-rather-than-replace-properties)</span></span> |
| <span data-ttu-id="2f54c-263">在不带 setter 的情况下添加到集合</span><span class="sxs-lookup"><span data-stu-id="2f54c-263">Add to collections without setters</span></span>                    | <span data-ttu-id="2f54c-264">⚠️ [不受支持，解决方法](#add-to-collections-without-setters)</span><span class="sxs-lookup"><span data-stu-id="2f54c-264">⚠️ [Not supported, workaround](#add-to-collections-without-setters)</span></span> |
| <span data-ttu-id="2f54c-265">`PreserveReferencesHandling` 全局设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-265">`PreserveReferencesHandling` global setting</span></span>           | <span data-ttu-id="2f54c-266">❌ [不受支持](#preserve-object-references-and-handle-loops)</span><span class="sxs-lookup"><span data-stu-id="2f54c-266">❌ [Not supported](#preserve-object-references-and-handle-loops)</span></span> |
| <span data-ttu-id="2f54c-267">`ReferenceLoopHandling` 全局设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-267">`ReferenceLoopHandling` global setting</span></span>                | <span data-ttu-id="2f54c-268">❌ [不受支持](#preserve-object-references-and-handle-loops)</span><span class="sxs-lookup"><span data-stu-id="2f54c-268">❌ [Not supported](#preserve-object-references-and-handle-loops)</span></span> |
| <span data-ttu-id="2f54c-269">支持 `System.Runtime.Serialization` 特性</span><span class="sxs-lookup"><span data-stu-id="2f54c-269">Support for `System.Runtime.Serialization` attributes</span></span> | <span data-ttu-id="2f54c-270">❌ [不受支持](#systemruntimeserialization-attributes)</span><span class="sxs-lookup"><span data-stu-id="2f54c-270">❌ [Not supported](#systemruntimeserialization-attributes)</span></span> |
| <span data-ttu-id="2f54c-271">`MissingMemberHandling` 全局设置</span><span class="sxs-lookup"><span data-stu-id="2f54c-271">`MissingMemberHandling` global setting</span></span>                | <span data-ttu-id="2f54c-272">❌ [不受支持](#missingmemberhandling)</span><span class="sxs-lookup"><span data-stu-id="2f54c-272">❌ [Not supported](#missingmemberhandling)</span></span> |
| <span data-ttu-id="2f54c-273">允许不带引号的属性名称</span><span class="sxs-lookup"><span data-stu-id="2f54c-273">Allow property names without quotes</span></span>                   | <span data-ttu-id="2f54c-274">❌ [不受支持](#json-strings-property-names-and-string-values)</span><span class="sxs-lookup"><span data-stu-id="2f54c-274">❌ [Not supported](#json-strings-property-names-and-string-values)</span></span> |
| <span data-ttu-id="2f54c-275">字符串值前后允许单引号</span><span class="sxs-lookup"><span data-stu-id="2f54c-275">Allow single quotes around string values</span></span>              | <span data-ttu-id="2f54c-276">❌ [不受支持](#json-strings-property-names-and-string-values)</span><span class="sxs-lookup"><span data-stu-id="2f54c-276">❌ [Not supported](#json-strings-property-names-and-string-values)</span></span> |
| <span data-ttu-id="2f54c-277">对字符串属性允许非字符串 JSON 值</span><span class="sxs-lookup"><span data-stu-id="2f54c-277">Allow non-string JSON values for string properties</span></span>    | <span data-ttu-id="2f54c-278">❌ [不受支持](#non-string-values-for-string-properties)</span><span class="sxs-lookup"><span data-stu-id="2f54c-278">❌ [Not supported](#non-string-values-for-string-properties)</span></span> |
::: zone-end

<span data-ttu-id="2f54c-279">这不是 `Newtonsoft.Json` 功能的详尽列表。</span><span class="sxs-lookup"><span data-stu-id="2f54c-279">This is not an exhaustive list of `Newtonsoft.Json` features.</span></span> <span data-ttu-id="2f54c-280">此列表包含在 [GitHub 问题](https://github.com/dotnet/runtime/issues?q=is%3Aopen+is%3Aissue+label%3Aarea-System.Text.Json)或 [StackOverflow](https://stackoverflow.com/questions/tagged/system.text.json) 文章中请求的许多方案。</span><span class="sxs-lookup"><span data-stu-id="2f54c-280">The list includes many of the scenarios that have been requested in [GitHub issues](https://github.com/dotnet/runtime/issues?q=is%3Aopen+is%3Aissue+label%3Aarea-System.Text.Json) or [StackOverflow](https://stackoverflow.com/questions/tagged/system.text.json) posts.</span></span> <span data-ttu-id="2f54c-281">如果对此处所列且当前没有示例代码的一个方案实现了解决方法，并且如果要共享解决方案，请在本页底部的“反馈”部分选择“此页面”。</span><span class="sxs-lookup"><span data-stu-id="2f54c-281">If you implement a workaround for one of the scenarios listed here that doesn't currently have sample code, and if you want to share your solution, select **This page** in the **Feedback** section at the bottom of this page.</span></span> <span data-ttu-id="2f54c-282">这会在本文档的 GitHub 存储库中创建一个问题，并将它也列在此页面上的“反馈”部分中。</span><span class="sxs-lookup"><span data-stu-id="2f54c-282">That creates an issue in this documentation's GitHub repo and lists it in the **Feedback** section on this page too.</span></span>

## <a name="differences-in-default-jsonserializer-behavior-compared-to-no-locnewtonsoftjson"></a><span data-ttu-id="2f54c-283">默认 JsonSerializer 行为相较于 Newtonsoft.Json 的差异</span><span class="sxs-lookup"><span data-stu-id="2f54c-283">Differences in default JsonSerializer behavior compared to Newtonsoft.Json</span></span>

<span data-ttu-id="2f54c-284"><xref:System.Text.Json> 在默认情况下十分严格，避免代表调用方进行任何猜测或解释，强调确定性行为。</span><span class="sxs-lookup"><span data-stu-id="2f54c-284"><xref:System.Text.Json> is strict by default and avoids any guessing or interpretation on the caller's behalf, emphasizing deterministic behavior.</span></span> <span data-ttu-id="2f54c-285">该库是为了实现性能和安全性而特意这样设计的。</span><span class="sxs-lookup"><span data-stu-id="2f54c-285">The library is intentionally designed this way for performance and security.</span></span> <span data-ttu-id="2f54c-286">`Newtonsoft.Json` 默认情况下十分灵活。</span><span class="sxs-lookup"><span data-stu-id="2f54c-286">`Newtonsoft.Json` is flexible by default.</span></span> <span data-ttu-id="2f54c-287">设计中的这种根本差异是默认行为中以下许多特定差异的背后原因。</span><span class="sxs-lookup"><span data-stu-id="2f54c-287">This fundamental difference in design is behind many of the following specific differences in default behavior.</span></span>

### <a name="case-insensitive-deserialization"></a><span data-ttu-id="2f54c-288">不区分大小写的反序列化</span><span class="sxs-lookup"><span data-stu-id="2f54c-288">Case-insensitive deserialization</span></span>

<span data-ttu-id="2f54c-289">在反序列化过程中，默认情况下 `Newtonsoft.Json` 进行不区分大小写的属性名称匹配。</span><span class="sxs-lookup"><span data-stu-id="2f54c-289">During deserialization, `Newtonsoft.Json` does case-insensitive property name matching by default.</span></span> <span data-ttu-id="2f54c-290"><xref:System.Text.Json> 默认值区分大小写，这可提供更好的性能，因为它执行精确匹配。</span><span class="sxs-lookup"><span data-stu-id="2f54c-290">The <xref:System.Text.Json> default is case-sensitive, which gives better performance since it's doing an exact match.</span></span> <span data-ttu-id="2f54c-291">有关如何执行不区分大小写的匹配的信息，请参阅[不区分大小写的属性匹配](system-text-json-character-casing.md)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-291">For information about how to do case-insensitive matching, see [Case-insensitive property matching](system-text-json-character-casing.md).</span></span>

<span data-ttu-id="2f54c-292">如果使用 ASP.NET Core 间接使用 `System.Text.Json`，则无需执行任何操作即可获得类似于 `Newtonsoft.Json` 的行为。</span><span class="sxs-lookup"><span data-stu-id="2f54c-292">If you're using `System.Text.Json` indirectly by using ASP.NET Core, you don't need to do anything to get behavior like `Newtonsoft.Json`.</span></span> <span data-ttu-id="2f54c-293">ASP.NET Core 在使用 `System.Text.Json` 时，会为 [camel 大小写属性名称](system-text-json-customize-properties.md#use-camel-case-for-all-json-property-names)和不区分大小写的匹配指定设置。</span><span class="sxs-lookup"><span data-stu-id="2f54c-293">ASP.NET Core specifies the settings for [camel-casing property names](system-text-json-customize-properties.md#use-camel-case-for-all-json-property-names) and case-insensitive matching when it uses `System.Text.Json`.</span></span>

::: zone pivot="dotnet-5-0"
<span data-ttu-id="2f54c-294">默认情况下，ASP.NET Core 还允许反序列化[带引号的数字](#allow-or-write-numbers-in-quotes)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-294">ASP.NET Core also enables deserializing [quoted numbers](#allow-or-write-numbers-in-quotes) by default.</span></span>
::: zone-end

### <a name="minimal-character-escaping"></a><span data-ttu-id="2f54c-295">最小字符转义</span><span class="sxs-lookup"><span data-stu-id="2f54c-295">Minimal character escaping</span></span>

<span data-ttu-id="2f54c-296">在序列化过程中，`Newtonsoft.Json` 对于让字符通过而不进行转义相对宽松。</span><span class="sxs-lookup"><span data-stu-id="2f54c-296">During serialization, `Newtonsoft.Json` is relatively permissive about letting characters through without escaping them.</span></span> <span data-ttu-id="2f54c-297">也就是说，它不会将它们替换为 `\uxxxx`（其中 `xxxx` 是字符的码位）。</span><span class="sxs-lookup"><span data-stu-id="2f54c-297">That is, it doesn't replace them with `\uxxxx` where `xxxx` is the character's code point.</span></span> <span data-ttu-id="2f54c-298">对字符进行转义时，它会通过在字符前发出 `\` 来实现此目的（例如，`"` 会变为 `\"`）。</span><span class="sxs-lookup"><span data-stu-id="2f54c-298">Where it does escape them, it does so by emitting a `\` before the character (for example, `"` becomes `\"`).</span></span> <span data-ttu-id="2f54c-299"><xref:System.Text.Json> 会在默认情况下转义较多字符，以对跨站点脚本 (XSS) 或信息泄露攻击提供深度防御保护，并使用六字符序列执行此操作。</span><span class="sxs-lookup"><span data-stu-id="2f54c-299"><xref:System.Text.Json> escapes more characters by default to provide defense-in-depth protections against cross-site scripting (XSS) or information-disclosure attacks and does so by using the six-character sequence.</span></span> <span data-ttu-id="2f54c-300">`System.Text.Json` 会在默认情况下转义所有非 ASCII 字符，因此如果在 `Newtonsoft.Json` 中使用 `StringEscapeHandling.EscapeNonAscii`，则无需执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="2f54c-300">`System.Text.Json` escapes all non-ASCII characters by default, so you don't need to do anything if you're using `StringEscapeHandling.EscapeNonAscii` in `Newtonsoft.Json`.</span></span> <span data-ttu-id="2f54c-301">`System.Text.Json` 在默认情况下还会转义 HTML 敏感字符。</span><span class="sxs-lookup"><span data-stu-id="2f54c-301">`System.Text.Json` also escapes HTML-sensitive characters, by default.</span></span> <span data-ttu-id="2f54c-302">有关如何替代默认 `System.Text.Json` 行为的信息，请参阅[自定义字符编码](system-text-json-character-encoding.md)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-302">For information about how to override the default `System.Text.Json` behavior, see [Customize character encoding](system-text-json-character-encoding.md).</span></span>

### <a name="comments"></a><span data-ttu-id="2f54c-303">注释</span><span class="sxs-lookup"><span data-stu-id="2f54c-303">Comments</span></span>

<span data-ttu-id="2f54c-304">在反序列化过程中，`Newtonsoft.Json` 在默认情况下会忽略 JSON 中的注释。</span><span class="sxs-lookup"><span data-stu-id="2f54c-304">During deserialization, `Newtonsoft.Json` ignores comments in the JSON by default.</span></span> <span data-ttu-id="2f54c-305"><xref:System.Text.Json> 默认值是对注释引发异常，因为 [RFC 8259](https://tools.ietf.org/html/rfc8259) 规范不包含它们。</span><span class="sxs-lookup"><span data-stu-id="2f54c-305">The <xref:System.Text.Json> default is to throw exceptions for comments because the [RFC 8259](https://tools.ietf.org/html/rfc8259) specification doesn't include them.</span></span> <span data-ttu-id="2f54c-306">有关如何允许注释的信息，请参阅[允许注释和尾随逗号](system-text-json-invalid-json.md)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-306">For information about how to allow comments, see [Allow comments and trailing commas](system-text-json-invalid-json.md).</span></span>

### <a name="trailing-commas"></a><span data-ttu-id="2f54c-307">尾随逗号</span><span class="sxs-lookup"><span data-stu-id="2f54c-307">Trailing commas</span></span>

<span data-ttu-id="2f54c-308">在反序列化过程中，默认情况下 `Newtonsoft.Json` 会忽略尾随逗号。</span><span class="sxs-lookup"><span data-stu-id="2f54c-308">During deserialization, `Newtonsoft.Json` ignores trailing commas by default.</span></span> <span data-ttu-id="2f54c-309">它还会忽略多个尾随逗号（例如 `[{"Color":"Red"},{"Color":"Green"},,]`）。</span><span class="sxs-lookup"><span data-stu-id="2f54c-309">It also ignores multiple trailing commas (for example, `[{"Color":"Red"},{"Color":"Green"},,]`).</span></span> <span data-ttu-id="2f54c-310"><xref:System.Text.Json> 默认值是对尾随逗号引发异常，因为 [RFC 8259](https://tools.ietf.org/html/rfc8259) 规范不允许使用它们。</span><span class="sxs-lookup"><span data-stu-id="2f54c-310">The <xref:System.Text.Json> default is to throw exceptions for trailing commas because the [RFC 8259](https://tools.ietf.org/html/rfc8259) specification doesn't allow them.</span></span> <span data-ttu-id="2f54c-311">有关如何使 `System.Text.Json` 接受它们的信息，请参阅[允许注释和尾随逗号](system-text-json-invalid-json.md)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-311">For information about how to make `System.Text.Json` accept them, see [Allow comments and trailing commas](system-text-json-invalid-json.md).</span></span> <span data-ttu-id="2f54c-312">无法允许多个尾随逗号。</span><span class="sxs-lookup"><span data-stu-id="2f54c-312">There's no way to allow multiple trailing commas.</span></span>

### <a name="converter-registration-precedence"></a><span data-ttu-id="2f54c-313">转换器注册优先级</span><span class="sxs-lookup"><span data-stu-id="2f54c-313">Converter registration precedence</span></span>

<span data-ttu-id="2f54c-314">自定义转换器的 `Newtonsoft.Json` 注册优先级如下所示：</span><span class="sxs-lookup"><span data-stu-id="2f54c-314">The `Newtonsoft.Json` registration precedence for custom converters is as follows:</span></span>

* <span data-ttu-id="2f54c-315">属性上的特性</span><span class="sxs-lookup"><span data-stu-id="2f54c-315">Attribute on property</span></span>
* <span data-ttu-id="2f54c-316">类型上的特性</span><span class="sxs-lookup"><span data-stu-id="2f54c-316">Attribute on type</span></span>
* <span data-ttu-id="2f54c-317">[转换器](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonSerializerSettings_Converters.htm) 集合</span><span class="sxs-lookup"><span data-stu-id="2f54c-317">[Converters](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonSerializerSettings_Converters.htm) collection</span></span>

<span data-ttu-id="2f54c-318">此顺序意味着 `Converters` 集合中的自定义转换器会由通过在类型级别应用特性而注册的转换器替代。</span><span class="sxs-lookup"><span data-stu-id="2f54c-318">This order means that a custom converter in the `Converters` collection is overridden by a converter that is registered by applying an attribute at the type level.</span></span> <span data-ttu-id="2f54c-319">这两个注册都会由属性级别的特性替代。</span><span class="sxs-lookup"><span data-stu-id="2f54c-319">Both of those registrations are overridden by an attribute at the property level.</span></span>

<span data-ttu-id="2f54c-320">自定义转换器的 <xref:System.Text.Json> 注册优先级是不同的：</span><span class="sxs-lookup"><span data-stu-id="2f54c-320">The <xref:System.Text.Json> registration precedence for custom converters is different:</span></span>

* <span data-ttu-id="2f54c-321">属性上的特性</span><span class="sxs-lookup"><span data-stu-id="2f54c-321">Attribute on property</span></span>
* <span data-ttu-id="2f54c-322"><xref:System.Text.Json.JsonSerializerOptions.Converters> 集合</span><span class="sxs-lookup"><span data-stu-id="2f54c-322"><xref:System.Text.Json.JsonSerializerOptions.Converters> collection</span></span>
* <span data-ttu-id="2f54c-323">类型上的特性</span><span class="sxs-lookup"><span data-stu-id="2f54c-323">Attribute on type</span></span>

<span data-ttu-id="2f54c-324">此处的差别在于 `Converters` 集合中的自定义转换器会替代类型级别的特性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-324">The difference here is that a custom converter in the `Converters` collection overrides an attribute at the type level.</span></span> <span data-ttu-id="2f54c-325">此优先级顺序的目的是使运行时更改替代设计时选项。</span><span class="sxs-lookup"><span data-stu-id="2f54c-325">The intention behind this order of precedence is to make run-time changes override design-time choices.</span></span> <span data-ttu-id="2f54c-326">无法更改优先级。</span><span class="sxs-lookup"><span data-stu-id="2f54c-326">There's no way to change the precedence.</span></span>

<span data-ttu-id="2f54c-327">有关自定义转换器注册的详细信息，请参阅[注册自定义转换器](system-text-json-converters-how-to.md#register-a-custom-converter)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-327">For more information about custom converter registration, see [Register a custom converter](system-text-json-converters-how-to.md#register-a-custom-converter).</span></span>

### <a name="maximum-depth"></a><span data-ttu-id="2f54c-328">最大深度</span><span class="sxs-lookup"><span data-stu-id="2f54c-328">Maximum depth</span></span>

<span data-ttu-id="2f54c-329">`Newtonsoft.Json` 默认情况下没有最大深度限制。</span><span class="sxs-lookup"><span data-stu-id="2f54c-329">`Newtonsoft.Json` doesn't have a maximum depth limit by default.</span></span> <span data-ttu-id="2f54c-330">对于 <xref:System.Text.Json>，默认限制为 64，可通过设置 <xref:System.Text.Json.JsonSerializerOptions.MaxDepth?displayProperty=nameWithType> 进行配置。</span><span class="sxs-lookup"><span data-stu-id="2f54c-330">For <xref:System.Text.Json> there's a default limit  of 64, and it's configurable by setting <xref:System.Text.Json.JsonSerializerOptions.MaxDepth?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="2f54c-331">如果使用 ASP.NET Core 时间接使用 `System.Text.Json`，则默认的最大深度限制为 32。</span><span class="sxs-lookup"><span data-stu-id="2f54c-331">If you're using `System.Text.Json` indirectly by using ASP.NET Core, the default maximum depth limit is 32.</span></span> <span data-ttu-id="2f54c-332">默认值与模型绑定的默认值相同，并且在 [JsonOptions 类](https://github.com/dotnet/aspnetcore/blob/1f56888ea03f6a113587a6c4ac4d8b2ded326ffa/src/Mvc/Mvc.Core/src/JsonOptions.cs#L17-L20)中设置。</span><span class="sxs-lookup"><span data-stu-id="2f54c-332">The default value is the same as for model binding and is set in the [JsonOptions class](https://github.com/dotnet/aspnetcore/blob/1f56888ea03f6a113587a6c4ac4d8b2ded326ffa/src/Mvc/Mvc.Core/src/JsonOptions.cs#L17-L20).</span></span>

### <a name="json-strings-property-names-and-string-values"></a><span data-ttu-id="2f54c-333">JSON 字符串（属性名称和字符串值）</span><span class="sxs-lookup"><span data-stu-id="2f54c-333">JSON strings (property names and string values)</span></span>

<span data-ttu-id="2f54c-334">在反序列化过程中，`Newtonsoft.Json` 接受用双引号、单引号括起来或不带引号的属性名称。</span><span class="sxs-lookup"><span data-stu-id="2f54c-334">During deserialization, `Newtonsoft.Json` accepts property names surrounded by double quotes, single quotes, or without quotes.</span></span> <span data-ttu-id="2f54c-335">它接受用双引号或单引号括起来的字符串值。</span><span class="sxs-lookup"><span data-stu-id="2f54c-335">It accepts string values surrounded by double quotes or single quotes.</span></span> <span data-ttu-id="2f54c-336">例如，`Newtonsoft.Json` 接受以下 JSON：</span><span class="sxs-lookup"><span data-stu-id="2f54c-336">For example, `Newtonsoft.Json` accepts the following JSON:</span></span>

```json
{
  "name1": "value",
  'name2': "value",
  name3: 'value'
}
```

<span data-ttu-id="2f54c-337">`System.Text.Json` 仅接受双引号中的属性名称和字符串值，因为 [RFC 8259](https://tools.ietf.org/html/rfc8259) 规范要求使用该格式，这是唯一视为有效 JSON 的格式。</span><span class="sxs-lookup"><span data-stu-id="2f54c-337">`System.Text.Json` only accepts property names and string values in double quotes because that format is required by the [RFC 8259](https://tools.ietf.org/html/rfc8259) specification and is the only format considered valid JSON.</span></span>

<span data-ttu-id="2f54c-338">用单引号括起来的值会导致 [JsonException](xref:System.Text.Json.JsonException)，并出现以下消息：</span><span class="sxs-lookup"><span data-stu-id="2f54c-338">A value enclosed in single quotes results in a [JsonException](xref:System.Text.Json.JsonException) with the following message:</span></span>

```output
''' is an invalid start of a value.
```

### <a name="non-string-values-for-string-properties"></a><span data-ttu-id="2f54c-339">字符串属性的非字符串值</span><span class="sxs-lookup"><span data-stu-id="2f54c-339">Non-string values for string properties</span></span>

<span data-ttu-id="2f54c-340">`Newtonsoft.Json` 接受非字符串值（如数字或文本 `true` 和 `false`），以便反序列化为类型字符串的属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-340">`Newtonsoft.Json` accepts non-string values, such as a number or the literals `true` and `false`, for deserialization to properties of type string.</span></span> <span data-ttu-id="2f54c-341">下面是 `Newtonsoft.Json` 成功反序列化为以下类的 JSON 示例：</span><span class="sxs-lookup"><span data-stu-id="2f54c-341">Here's an example of JSON that `Newtonsoft.Json` successfully deserializes to the following class:</span></span>

```json
{
  "String1": 1,
  "String2": true,
  "String3": false
}
```

```csharp
public class ExampleClass
{
    public string String1 { get; set; }
    public string String2 { get; set; }
    public string String3 { get; set; }
}
```

<span data-ttu-id="2f54c-342">`System.Text.Json` 不将非字符串值反序列化为字符串属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-342">`System.Text.Json` doesn't deserialize non-string values into string properties.</span></span> <span data-ttu-id="2f54c-343">字符串字段接收的非字符串值会导致 [JsonException](xref:System.Text.Json.JsonException)，并出现以下消息：</span><span class="sxs-lookup"><span data-stu-id="2f54c-343">A non-string value received for a string field results in a [JsonException](xref:System.Text.Json.JsonException) with the following message:</span></span>

```output
The JSON value could not be converted to System.String.
```

## <a name="scenarios-using-jsonserializer"></a><span data-ttu-id="2f54c-344">使用 JsonSerializer 的方案</span><span class="sxs-lookup"><span data-stu-id="2f54c-344">Scenarios using JsonSerializer</span></span>

<span data-ttu-id="2f54c-345">下面一部分方案不受内置功能支持，但有解决方法可用。</span><span class="sxs-lookup"><span data-stu-id="2f54c-345">Some of the following scenarios aren't supported by built-in functionality, but workarounds are possible.</span></span> <span data-ttu-id="2f54c-346">解决方法是[自定义转换器](system-text-json-converters-how-to.md)，它们可能无法提供与 `Newtonsoft.Json` 功能完全相同的功能。</span><span class="sxs-lookup"><span data-stu-id="2f54c-346">The workarounds are [custom converters](system-text-json-converters-how-to.md), which may not provide complete parity with `Newtonsoft.Json` functionality.</span></span> <span data-ttu-id="2f54c-347">对于其中一些功能，提供示例代码作为示例。</span><span class="sxs-lookup"><span data-stu-id="2f54c-347">For some of these, sample code is provided as examples.</span></span> <span data-ttu-id="2f54c-348">如果你依赖于这些 `Newtonsoft.Json` 功能，迁移需要修改 .NET 对象模型或进行其他代码更改。</span><span class="sxs-lookup"><span data-stu-id="2f54c-348">If you rely on these `Newtonsoft.Json` features, migration will require modifications to your .NET object models or other code changes.</span></span>

<span data-ttu-id="2f54c-349">对于下面的一部分方案，解决方法不可行或无法提供。</span><span class="sxs-lookup"><span data-stu-id="2f54c-349">For some of the following scenarios, workarounds are not practical or possible.</span></span> <span data-ttu-id="2f54c-350">如果你依赖于这些 `Newtonsoft.Json` 功能，则无法在不进行重大更改的情况下进行迁移。</span><span class="sxs-lookup"><span data-stu-id="2f54c-350">If you rely on these `Newtonsoft.Json` features, migration will not be possible without significant changes.</span></span>

### <a name="allow-or-write-numbers-in-quotes"></a><span data-ttu-id="2f54c-351">允许或写入带引号的数字</span><span class="sxs-lookup"><span data-stu-id="2f54c-351">Allow or write numbers in quotes</span></span>

::: zone pivot="dotnet-5-0"
<span data-ttu-id="2f54c-352">`Newtonsoft.Json` 可以序列化或反序列化由 JSON 字符串表示的数字（括在引号中）。</span><span class="sxs-lookup"><span data-stu-id="2f54c-352">`Newtonsoft.Json` can serialize or deserialize numbers represented by JSON strings (surrounded by quotes).</span></span> <span data-ttu-id="2f54c-353">例如，它可以接受 `{"DegreesCelsius":"23"}` 而不是 `{"DegreesCelsius":23}`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-353">For example, it can accept: `{"DegreesCelsius":"23"}` instead of `{"DegreesCelsius":23}`.</span></span> <span data-ttu-id="2f54c-354">若要在 <xref:System.Text.Json> 中启用该行为，请将 <xref:System.Text.Json.JsonSerializerOptions.NumberHandling%2A?displayProperty=nameWithType> 设置为 <xref:System.Text.Json.Serialization.JsonNumberHandling.WriteAsString> 或 <xref:System.Text.Json.Serialization.JsonNumberHandling.AllowReadingFromString>，或使用 [[JsonNumberHandling]](xref:System.Text.Json.Serialization.JsonNumberHandlingAttribute) 特性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-354">To enable that behavior in <xref:System.Text.Json>, set <xref:System.Text.Json.JsonSerializerOptions.NumberHandling%2A?displayProperty=nameWithType> to <xref:System.Text.Json.Serialization.JsonNumberHandling.WriteAsString> or <xref:System.Text.Json.Serialization.JsonNumberHandling.AllowReadingFromString>, or use the [[JsonNumberHandling]](xref:System.Text.Json.Serialization.JsonNumberHandlingAttribute) attribute.</span></span>

<span data-ttu-id="2f54c-355">如果使用 ASP.NET Core 间接使用 `System.Text.Json`，则无需执行任何操作即可获得类似于 `Newtonsoft.Json` 的行为。</span><span class="sxs-lookup"><span data-stu-id="2f54c-355">If you're using `System.Text.Json` indirectly by using ASP.NET Core, you don't need to do anything to get behavior like `Newtonsoft.Json`.</span></span> <span data-ttu-id="2f54c-356">ASP.NET Core 在使用 `System.Text.Json` 时指定 [Web 默认值](system-text-json-configure-options.md#web-defaults-for-jsonserializeroptions)，Web 默认值允许带引号的数字。</span><span class="sxs-lookup"><span data-stu-id="2f54c-356">ASP.NET Core specifies [web defaults](system-text-json-configure-options.md#web-defaults-for-jsonserializeroptions) when it uses `System.Text.Json`, and web defaults allow quoted numbers.</span></span>

<span data-ttu-id="2f54c-357">有关详细信息，请参阅[允许或写入带引号的数字](system-text-json-invalid-json.md)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-357">For more information, see [Allow or write numbers in quotes](system-text-json-invalid-json.md).</span></span>
::: zone-end

::: zone pivot="dotnet-core-3-1"
<span data-ttu-id="2f54c-358">`Newtonsoft.Json` 可以序列化或反序列化由 JSON 字符串表示的数字（括在引号中）。</span><span class="sxs-lookup"><span data-stu-id="2f54c-358">`Newtonsoft.Json` can serialize or deserialize numbers represented by JSON strings (surrounded by quotes).</span></span> <span data-ttu-id="2f54c-359">例如，它可以接受 `{"DegreesCelsius":"23"}` 而不是 `{"DegreesCelsius":23}`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-359">For example, it can accept: `{"DegreesCelsius":"23"}` instead of `{"DegreesCelsius":23}`.</span></span> <span data-ttu-id="2f54c-360">若要在 .NET Core 3.1 的 <xref:System.Text.Json> 中启用该行为，请实现类似于以下示例的自定义转换器。</span><span class="sxs-lookup"><span data-stu-id="2f54c-360">To enable that behavior in <xref:System.Text.Json> in .NET Core 3.1, implement a custom converter like the following example.</span></span> <span data-ttu-id="2f54c-361">该转换器处理定义为 `long` 的属性：</span><span class="sxs-lookup"><span data-stu-id="2f54c-361">The converter handles properties defined as `long`:</span></span>

* <span data-ttu-id="2f54c-362">它将这些属性序列化为 JSON 字符串。</span><span class="sxs-lookup"><span data-stu-id="2f54c-362">It serializes them as JSON strings.</span></span>
* <span data-ttu-id="2f54c-363">它在反序列化期间接受 JSON 数字和括在引号中的数字。</span><span class="sxs-lookup"><span data-stu-id="2f54c-363">It accepts JSON numbers and numbers within quotes while deserializing.</span></span>

:::code language="csharp" source="snippets/system-text-json-how-to/csharp/LongToStringConverter.cs":::

<span data-ttu-id="2f54c-364">通过对各个 `long` 属性[使用特性](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-property)或是通过向 [ 集合](system-text-json-converters-how-to.md#registration-sample---converters-collection)添加转换器<xref:System.Text.Json.JsonSerializerOptions.Converters>来注册此自定义转换器。</span><span class="sxs-lookup"><span data-stu-id="2f54c-364">Register this custom converter by [using an attribute](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-property) on individual `long` properties or by [adding the converter](system-text-json-converters-how-to.md#registration-sample---converters-collection) to the <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span></span>
::: zone-end

### <a name="specify-constructor-to-use-when-deserializing"></a><span data-ttu-id="2f54c-365">指定要在反序列化时使用的构造函数</span><span class="sxs-lookup"><span data-stu-id="2f54c-365">Specify constructor to use when deserializing</span></span>

<span data-ttu-id="2f54c-366">使用 `Newtonsoft.Json` `[JsonConstructor]` 特性可以指定在反序列化为 POCO 时要调用的构造函数。</span><span class="sxs-lookup"><span data-stu-id="2f54c-366">The `Newtonsoft.Json` `[JsonConstructor]` attribute lets you specify which constructor to call when deserializing to a POCO.</span></span>

::: zone pivot="dotnet-5-0"
<span data-ttu-id="2f54c-367">`System.Text.Json` 还具有 [[JsonConstructor]](xref:System.Text.Json.Serialization.JsonConstructorAttribute) 特性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-367">`System.Text.Json` also has a [[JsonConstructor]](xref:System.Text.Json.Serialization.JsonConstructorAttribute) attribute.</span></span> <span data-ttu-id="2f54c-368">有关详细信息，请参阅[不可变类型和记录](system-text-json-immutability.md)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-368">For more information, see [Immutable types and Records](system-text-json-immutability.md).</span></span>
::: zone-end

::: zone pivot="dotnet-core-3-1"
<span data-ttu-id="2f54c-369">.NET Core 3.1 中的 <xref:System.Text.Json> 仅支持无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="2f54c-369"><xref:System.Text.Json> in .NET Core 3.1 supports only parameterless constructors.</span></span> <span data-ttu-id="2f54c-370">作为一种解决方法，可以在自定义转换器中调用所需的任何构造函数。</span><span class="sxs-lookup"><span data-stu-id="2f54c-370">As a workaround, you can call whichever constructor you need in a custom converter.</span></span> <span data-ttu-id="2f54c-371">请参阅[反序列化为不可变类和结构](#deserialize-to-immutable-classes-and-structs)的示例。</span><span class="sxs-lookup"><span data-stu-id="2f54c-371">See the example for [Deserialize to immutable classes and structs](#deserialize-to-immutable-classes-and-structs).</span></span>
::: zone-end

### <a name="conditionally-ignore-a-property"></a><span data-ttu-id="2f54c-372">有条件地忽略属性</span><span class="sxs-lookup"><span data-stu-id="2f54c-372">Conditionally ignore a property</span></span>

<span data-ttu-id="2f54c-373">`Newtonsoft.Json` 有多种方法可在序列化或反序列化时有条件地忽略属性：</span><span class="sxs-lookup"><span data-stu-id="2f54c-373">`Newtonsoft.Json` has several ways to conditionally ignore a property on serialization or deserialization:</span></span>

* <span data-ttu-id="2f54c-374">`DefaultContractResolver` 使你可以基于任意条件选择要包含或忽略的属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-374">`DefaultContractResolver` lets you select properties to include or ignore, based on arbitrary criteria.</span></span>
* <span data-ttu-id="2f54c-375">`JsonSerializerSettings` 上的 `NullValueHandling` 和 `DefaultValueHandling` 设置使你指定应忽略所有 null 值或默认值属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-375">The `NullValueHandling` and `DefaultValueHandling` settings on `JsonSerializerSettings` let you specify that all null-value or default-value properties should be ignored.</span></span>
* <span data-ttu-id="2f54c-376">`[JsonProperty]` 特性上的 `NullValueHandling` 和 `DefaultValueHandling` 设置使你可以指定在设置为 null 或默认值时应忽略的单个属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-376">The `NullValueHandling` and `DefaultValueHandling` settings on the `[JsonProperty]` attribute let you specify individual properties that should be ignored when set to null or the default value.</span></span>

::: zone pivot="dotnet-5-0"

<span data-ttu-id="2f54c-377"><xref:System.Text.Json> 提供以下方法，用于在序列化期间忽略属性或字段：</span><span class="sxs-lookup"><span data-stu-id="2f54c-377"><xref:System.Text.Json> provides the following ways to ignore properties or fields while serializing:</span></span>

* <span data-ttu-id="2f54c-378">属性上的 [[JsonIgnore]](system-text-json-ignore-properties.md#ignore-individual-properties) 特性会导致在序列化过程中从 JSON 中省略属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-378">The [[JsonIgnore]](system-text-json-ignore-properties.md#ignore-individual-properties) attribute on a property causes the property to be omitted from the JSON during serialization.</span></span>
* <span data-ttu-id="2f54c-379">[IgnoreReadOnlyProperties](system-text-json-ignore-properties.md#ignore-all-read-only-properties) 全局选项使你可以忽略所有只读属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-379">The [IgnoreReadOnlyProperties](system-text-json-ignore-properties.md#ignore-all-read-only-properties) global option lets you ignore all read-only properties.</span></span>
* <span data-ttu-id="2f54c-380">如果你[包含字段](system-text-json-how-to.md#include-fields)，则 <xref:System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyFields%2A?displayProperty=nameWithType> 全局选项使你可以忽略所有只读字段。</span><span class="sxs-lookup"><span data-stu-id="2f54c-380">If you're [Including fields](system-text-json-how-to.md#include-fields), the <xref:System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyFields%2A?displayProperty=nameWithType> global option lets you ignore all read-only fields.</span></span>
* <span data-ttu-id="2f54c-381">使用 `DefaultIgnoreCondition` 全局选项，你可以[忽略具有默认值的所有值类型属性](system-text-json-ignore-properties.md#ignore-all-default-value-properties)，或[忽略具有 null 值的所有引用类型属性](system-text-json-ignore-properties.md#ignore-all-null-value-properties)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-381">The `DefaultIgnoreCondition` global option lets you [ignore all value type properties that have default values](system-text-json-ignore-properties.md#ignore-all-default-value-properties), or [ignore all reference type properties that have null values](system-text-json-ignore-properties.md#ignore-all-null-value-properties).</span></span>

::: zone-end

::: zone pivot="dotnet-core-3-1"

<span data-ttu-id="2f54c-382">.NET Core 3.1 中的 <xref:System.Text.Json> 提供以下方法，用于在序列化期间忽略属性：</span><span class="sxs-lookup"><span data-stu-id="2f54c-382"><xref:System.Text.Json> in .NET Core 3.1 provides the following ways to ignore properties while serializing:</span></span>

* <span data-ttu-id="2f54c-383">属性上的 [[JsonIgnore]](system-text-json-ignore-properties.md#ignore-individual-properties) 特性会导致在序列化过程中从 JSON 中省略属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-383">The [[JsonIgnore]](system-text-json-ignore-properties.md#ignore-individual-properties) attribute on a property causes the property to be omitted from the JSON during serialization.</span></span>
* <span data-ttu-id="2f54c-384">[IgnoreNullValues](system-text-json-ignore-properties.md#ignore-all-null-value-properties) 全局选项使你可以忽略所有 null 值属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-384">The [IgnoreNullValues](system-text-json-ignore-properties.md#ignore-all-null-value-properties) global option lets you ignore all null-value properties.</span></span>
* <span data-ttu-id="2f54c-385">[IgnoreReadOnlyProperties](system-text-json-ignore-properties.md#ignore-all-read-only-properties) 全局选项使你可以忽略所有只读属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-385">The [IgnoreReadOnlyProperties](system-text-json-ignore-properties.md#ignore-all-read-only-properties) global option lets you ignore all read-only properties.</span></span>
::: zone-end

<span data-ttu-id="2f54c-386">不能通过这些选项：</span><span class="sxs-lookup"><span data-stu-id="2f54c-386">These options **don't** let you:</span></span>

::: zone pivot="dotnet-5-0"

* <span data-ttu-id="2f54c-387">基于运行时计算的任意条件忽略所选属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-387">Ignore selected properties based on arbitrary criteria evaluated at run time.</span></span>

::: zone-end

::: zone pivot="dotnet-core-3-1"

* <span data-ttu-id="2f54c-388">忽略具有类型的默认值的所有属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-388">Ignore all properties that have the default value for the type.</span></span>
* <span data-ttu-id="2f54c-389">忽略具有类型的默认值的所选属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-389">Ignore selected properties that have the default value for the type.</span></span>
* <span data-ttu-id="2f54c-390">忽略值为 null 的所选属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-390">Ignore selected properties if their value is null.</span></span>
* <span data-ttu-id="2f54c-391">基于运行时计算的任意条件忽略所选属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-391">Ignore selected properties based on arbitrary criteria evaluated at run time.</span></span>

::: zone-end

<span data-ttu-id="2f54c-392">对于该功能，可以编写自定义转换器。</span><span class="sxs-lookup"><span data-stu-id="2f54c-392">For that functionality, you can write a custom converter.</span></span> <span data-ttu-id="2f54c-393">下面是一个示例 POCO 和一个适用于它的自定义转换器，用于说明此方法：</span><span class="sxs-lookup"><span data-stu-id="2f54c-393">Here's a sample POCO and a custom converter for it that illustrates this approach:</span></span>

:::code language="csharp" source="snippets/system-text-json-how-to/csharp/WeatherForecast.cs" id="WF":::

:::code language="csharp" source="snippets/system-text-json-how-to/csharp/WeatherForecastRuntimeIgnoreConverter.cs":::

<span data-ttu-id="2f54c-394">如果值为 null、空字符串或 "N/A"，则转换器会导致从序列化中省略 `Summary` 属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-394">The converter causes the `Summary` property to be omitted from serialization if its value is null, an empty string, or "N/A".</span></span>

<span data-ttu-id="2f54c-395">通过[对类使用特性](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-type)或是通过向 <xref:System.Text.Json.JsonSerializerOptions.Converters> 集合[添加转换器](system-text-json-converters-how-to.md#registration-sample---converters-collection)来注册此自定义转换器。</span><span class="sxs-lookup"><span data-stu-id="2f54c-395">Register this custom converter by [using an attribute on the class](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-type) or by [adding the converter](system-text-json-converters-how-to.md#registration-sample---converters-collection) to the <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span></span>

<span data-ttu-id="2f54c-396">此方法在以下情况下需要其他逻辑：</span><span class="sxs-lookup"><span data-stu-id="2f54c-396">This approach requires additional logic if:</span></span>

* <span data-ttu-id="2f54c-397">POCO 包含复杂属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-397">The POCO includes complex properties.</span></span>
* <span data-ttu-id="2f54c-398">需要处理特性（如 `[JsonIgnore]`）或选项（如自定义编码器）。</span><span class="sxs-lookup"><span data-stu-id="2f54c-398">You need to handle attributes such as `[JsonIgnore]` or options such as custom encoders.</span></span>

### <a name="public-and-non-public-fields"></a><span data-ttu-id="2f54c-399">公共和非公共字段</span><span class="sxs-lookup"><span data-stu-id="2f54c-399">Public and non-public fields</span></span>

<span data-ttu-id="2f54c-400">`Newtonsoft.Json` 可以序列化和反序列化字段以及属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-400">`Newtonsoft.Json` can serialize and deserialize fields as well as properties.</span></span>

::: zone pivot="dotnet-5-0"
<span data-ttu-id="2f54c-401">在 <xref:System.Text.Json> 中，在序列化或反序列化时，使用 <xref:System.Text.Json.JsonSerializerOptions.IncludeFields?displayProperty=nameWithType> 全局设置或 [[JsonInclude]](xref:System.Text.Json.Serialization.JsonIncludeAttribute) 特性来包含公共字段。</span><span class="sxs-lookup"><span data-stu-id="2f54c-401">In <xref:System.Text.Json>, use the <xref:System.Text.Json.JsonSerializerOptions.IncludeFields?displayProperty=nameWithType> global setting or the [[JsonInclude]](xref:System.Text.Json.Serialization.JsonIncludeAttribute) attribute to include public fields when serializing or deserializing.</span></span> <span data-ttu-id="2f54c-402">有关示例，请参阅[包含字段](system-text-json-how-to.md#include-fields)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-402">For an example, see [Include fields](system-text-json-how-to.md#include-fields).</span></span>
::: zone-end

::: zone pivot="dotnet-core-3-1"
<span data-ttu-id="2f54c-403">.NET Core 3.1 中的 <xref:System.Text.Json> 仅适用于公共属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-403"><xref:System.Text.Json> in .NET Core 3.1 only works with public properties.</span></span> <span data-ttu-id="2f54c-404">自定义转换器可提供此功能。</span><span class="sxs-lookup"><span data-stu-id="2f54c-404">Custom converters can provide this functionality.</span></span>
::: zone-end

### <a name="preserve-object-references-and-handle-loops"></a><span data-ttu-id="2f54c-405">保留对象引用并处理循环</span><span class="sxs-lookup"><span data-stu-id="2f54c-405">Preserve object references and handle loops</span></span>

<span data-ttu-id="2f54c-406">默认情况下，`Newtonsoft.Json` 按值进行序列化。</span><span class="sxs-lookup"><span data-stu-id="2f54c-406">By default, `Newtonsoft.Json` serializes by value.</span></span> <span data-ttu-id="2f54c-407">例如，如果对象包含两个属性，而这些属性包含对同一个 `Person` 对象的引用，该 `Person` 对象属性的值会在 JSON 重复。</span><span class="sxs-lookup"><span data-stu-id="2f54c-407">For example, if an object contains two properties that contain a reference to the same `Person` object, the values of that `Person` object's properties are duplicated in the JSON.</span></span>

<span data-ttu-id="2f54c-408">`Newtonsoft.Json` 在 `JsonSerializerSettings` 上有一个 `PreserveReferencesHandling` 设置，可让你按引用进行序列化：</span><span class="sxs-lookup"><span data-stu-id="2f54c-408">`Newtonsoft.Json` has a `PreserveReferencesHandling` setting on `JsonSerializerSettings` that lets you serialize by reference:</span></span>

* <span data-ttu-id="2f54c-409">标识符元数据会添加到为第一个 `Person` 对象创建的 JSON。</span><span class="sxs-lookup"><span data-stu-id="2f54c-409">An identifier metadata is added to the JSON created for the first `Person` object.</span></span>
* <span data-ttu-id="2f54c-410">为第二个 `Person` 对象创建的 JSON 包含对该标识符（而不是属性值）的引用。</span><span class="sxs-lookup"><span data-stu-id="2f54c-410">The JSON that is created for the second `Person` object contains a reference to that identifier instead of property values.</span></span>

<span data-ttu-id="2f54c-411">`Newtonsoft.Json` 还具有一个 `ReferenceLoopHandling` 设置，使你可以忽略循环引用，而不是引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f54c-411">`Newtonsoft.Json` also has a `ReferenceLoopHandling` setting that lets you ignore circular references rather than throw an exception.</span></span>

::: zone pivot="dotnet-5-0"
<span data-ttu-id="2f54c-412">若要在 <xref:System.Text.Json> 中保留引用并处理循环引用，请将 <xref:System.Text.Json.JsonSerializerOptions.ReferenceHandler%2A?displayProperty=nameWithType> 设置为 <xref:System.Text.Json.Serialization.ReferenceHandler.Preserve%2A>。</span><span class="sxs-lookup"><span data-stu-id="2f54c-412">To preserve references and handle circular references in <xref:System.Text.Json>, set <xref:System.Text.Json.JsonSerializerOptions.ReferenceHandler%2A?displayProperty=nameWithType> to <xref:System.Text.Json.Serialization.ReferenceHandler.Preserve%2A>.</span></span> <span data-ttu-id="2f54c-413">`ReferenceHandler.Preserve` 设置等效于 `Newtonsoft.Json` 中的 `PreserveReferencesHandling` = `PreserveReferencesHandling.All`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-413">The `ReferenceHandler.Preserve` setting is equivalent to `PreserveReferencesHandling` = `PreserveReferencesHandling.All` in `Newtonsoft.Json`.</span></span>

<span data-ttu-id="2f54c-414">与 Newtonsoft.Json [ReferenceResolver](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonSerializer_ReferenceResolver.htm) 一样，<xref:System.Text.Json.Serialization.ReferenceResolver?displayProperty=fullName> 类定义在序列化和反序列化过程中保留引用的行为。</span><span class="sxs-lookup"><span data-stu-id="2f54c-414">Like the Newtonsoft.Json [ReferenceResolver](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonSerializer_ReferenceResolver.htm), the <xref:System.Text.Json.Serialization.ReferenceResolver?displayProperty=fullName> class defines the behavior of preserving references on serialization and deserialization.</span></span> <span data-ttu-id="2f54c-415">创建派生类以指定自定义行为。</span><span class="sxs-lookup"><span data-stu-id="2f54c-415">Create a derived class to specify custom behavior.</span></span> <span data-ttu-id="2f54c-416">有关示例，请参阅 [GuidReferenceResolver](https://github.com/dotnet/docs/blob/9d5e88edbd7f12be463775ffebbf07ac8415fe18/docs/standard/serialization/snippets/system-text-json-how-to-5-0/csharp/GuidReferenceResolverExample.cs)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-416">For an example, see [GuidReferenceResolver](https://github.com/dotnet/docs/blob/9d5e88edbd7f12be463775ffebbf07ac8415fe18/docs/standard/serialization/snippets/system-text-json-how-to-5-0/csharp/GuidReferenceResolverExample.cs).</span></span>

<span data-ttu-id="2f54c-417">一些相关的 `Newtonsoft.Json` 功能不受支持：</span><span class="sxs-lookup"><span data-stu-id="2f54c-417">Some related `Newtonsoft.Json` features are not supported:</span></span>

* [<span data-ttu-id="2f54c-418">JsonPropertyAttribute.IsReference</span><span class="sxs-lookup"><span data-stu-id="2f54c-418">JsonPropertyAttribute.IsReference</span></span>](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonPropertyAttribute_IsReference.htm)
* [<span data-ttu-id="2f54c-419">JsonPropertyAttribute.ReferenceLoopHandling</span><span class="sxs-lookup"><span data-stu-id="2f54c-419">JsonPropertyAttribute.ReferenceLoopHandling</span></span>](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonPropertyAttribute_ReferenceLoopHandling.htm)
* [<span data-ttu-id="2f54c-420">JsonSerializerSettings.ReferenceLoopHandling</span><span class="sxs-lookup"><span data-stu-id="2f54c-420">JsonSerializerSettings.ReferenceLoopHandling</span></span>](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonSerializerSettings_ReferenceLoopHandling.htm)

<span data-ttu-id="2f54c-421">有关详细信息，请参阅[保留引用并处理循环引用](system-text-json-preserve-references.md)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-421">For more information, see [Preserve references and handle circular references](system-text-json-preserve-references.md).</span></span>
::: zone-end

::: zone pivot="dotnet-core-3-1"
<span data-ttu-id="2f54c-422">.NET Core 3.1 中的 <xref:System.Text.Json> 仅支持按值进行进行序列化，并对循环引用引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f54c-422"><xref:System.Text.Json> in .NET Core 3.1 only supports serialization by value and throws an exception for circular references.</span></span>
::: zone-end

### <a name="dictionary-with-non-string-key"></a><span data-ttu-id="2f54c-423">包含非字符串键的字典</span><span class="sxs-lookup"><span data-stu-id="2f54c-423">Dictionary with non-string key</span></span>

::: zone pivot="dotnet-5-0"
<span data-ttu-id="2f54c-424">`Newtonsoft.Json` 和 `System.Text.Json` 都支持 `Dictionary<TKey, TValue>` 类型的集合。</span><span class="sxs-lookup"><span data-stu-id="2f54c-424">Both `Newtonsoft.Json` and `System.Text.Json` support collections of type `Dictionary<TKey, TValue>`.</span></span>
::: zone-end

::: zone pivot="dotnet-core-3-1"
<span data-ttu-id="2f54c-425">`Newtonsoft.Json` 支持类型 `Dictionary<TKey, TValue>` 的集合。</span><span class="sxs-lookup"><span data-stu-id="2f54c-425">`Newtonsoft.Json` supports collections of type `Dictionary<TKey, TValue>`.</span></span> <span data-ttu-id="2f54c-426">.NET Core 3.1 的 <xref:System.Text.Json> 中对字典集合的内置支持仅限于 `Dictionary<string, TValue>`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-426">The built-in support for dictionary collections in <xref:System.Text.Json> in .NET Core 3.1 is limited to `Dictionary<string, TValue>`.</span></span> <span data-ttu-id="2f54c-427">即，键必须是字符串。</span><span class="sxs-lookup"><span data-stu-id="2f54c-427">That is, the key must be a string.</span></span>

<span data-ttu-id="2f54c-428">若要在 .NET Core 3.1 中支持将整数或某种其他类型用作键的字典，请创建转换器（类似于[如何编写自定义转换器](system-text-json-converters-how-to.md#support-dictionary-with-non-string-key)中的示例）。</span><span class="sxs-lookup"><span data-stu-id="2f54c-428">To support a dictionary with an integer or some other type as the key in .NET Core 3.1, create a converter like the example in [How to write custom converters](system-text-json-converters-how-to.md#support-dictionary-with-non-string-key).</span></span>
::: zone-end

### <a name="types-without-built-in-support"></a><span data-ttu-id="2f54c-429">没有内置支持的类型</span><span class="sxs-lookup"><span data-stu-id="2f54c-429">Types without built-in support</span></span>

<span data-ttu-id="2f54c-430"><xref:System.Text.Json> 不为以下类型提供内置支持：</span><span class="sxs-lookup"><span data-stu-id="2f54c-430"><xref:System.Text.Json> doesn't provide built-in support for the following types:</span></span>

* <span data-ttu-id="2f54c-431"><xref:System.Data.DataTable> 和相关类型</span><span class="sxs-lookup"><span data-stu-id="2f54c-431"><xref:System.Data.DataTable> and related types</span></span>
* <span data-ttu-id="2f54c-432">F# 类型（如[可区分联合](../../fsharp/language-reference/discriminated-unions.md)、[记录类型](../../fsharp/language-reference/records.md)和[匿名记录类型](../../fsharp/language-reference/anonymous-records.md)）。</span><span class="sxs-lookup"><span data-stu-id="2f54c-432">F# types, such as [discriminated unions](../../fsharp/language-reference/discriminated-unions.md), [record types](../../fsharp/language-reference/records.md), and [anonymous record types](../../fsharp/language-reference/anonymous-records.md).</span></span>
* <xref:System.Dynamic.ExpandoObject>
* <xref:System.TimeZoneInfo>
* <xref:System.Numerics.BigInteger>
* <xref:System.TimeSpan>
* <xref:System.DBNull>
* <xref:System.Type>
* <span data-ttu-id="2f54c-433"><xref:System.ValueTuple> 及其关联泛型类型</span><span class="sxs-lookup"><span data-stu-id="2f54c-433"><xref:System.ValueTuple> and its associated generic types</span></span>

<span data-ttu-id="2f54c-434">对于没有内置支持的类型，可以实现自定义转换器。</span><span class="sxs-lookup"><span data-stu-id="2f54c-434">Custom converters can be implemented for types that don't have built-in support.</span></span>

### <a name="polymorphic-serialization"></a><span data-ttu-id="2f54c-435">多态序列化</span><span class="sxs-lookup"><span data-stu-id="2f54c-435">Polymorphic serialization</span></span>

<span data-ttu-id="2f54c-436">`Newtonsoft.Json` 会自动执行多态序列化。</span><span class="sxs-lookup"><span data-stu-id="2f54c-436">`Newtonsoft.Json` automatically does polymorphic serialization.</span></span> <span data-ttu-id="2f54c-437">有关 <xref:System.Text.Json> 的有限多态序列化功能的信息，请参阅[序列化派生类的属性](system-text-json-polymorphism.md)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-437">For information about the limited polymorphic serialization capabilities of <xref:System.Text.Json>, see [Serialize properties of derived classes](system-text-json-polymorphism.md).</span></span>

<span data-ttu-id="2f54c-438">所述的解决方法是定义可能以类型 `object` 的形式包含派生类的属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-438">The workaround described there is to define properties that may contain derived classes as type `object`.</span></span> <span data-ttu-id="2f54c-439">如果无法这样，则另一种选择是为整个继承类型层次结构创建带有 `Write` 方法的转换器（类似于[如何编写自定义转换器](system-text-json-converters-how-to.md#support-polymorphic-deserialization)中的示例）。</span><span class="sxs-lookup"><span data-stu-id="2f54c-439">If that isn't possible, another option is to create a converter with a `Write` method for the whole inheritance type hierarchy like the example in [How to write custom converters](system-text-json-converters-how-to.md#support-polymorphic-deserialization).</span></span>

### <a name="polymorphic-deserialization"></a><span data-ttu-id="2f54c-440">多态反序列化</span><span class="sxs-lookup"><span data-stu-id="2f54c-440">Polymorphic deserialization</span></span>

<span data-ttu-id="2f54c-441">`Newtonsoft.Json` 具有 `TypeNameHandling` 设置，它在序列化期间将类型名称元数据添加到 JSON。</span><span class="sxs-lookup"><span data-stu-id="2f54c-441">`Newtonsoft.Json` has a `TypeNameHandling` setting that adds type name metadata to the JSON while serializing.</span></span> <span data-ttu-id="2f54c-442">它在反序列化期间使用元数据执行多态反序列化。</span><span class="sxs-lookup"><span data-stu-id="2f54c-442">It uses the metadata while deserializing to do polymorphic deserialization.</span></span> <span data-ttu-id="2f54c-443"><xref:System.Text.Json> 可以执行有限范围的[多态序列化](system-text-json-polymorphism.md)，但不能执行多态反序列化。</span><span class="sxs-lookup"><span data-stu-id="2f54c-443"><xref:System.Text.Json> can do a limited range of [polymorphic serialization](system-text-json-polymorphism.md) but not polymorphic deserialization.</span></span>

<span data-ttu-id="2f54c-444">若要支持多态反序列化，请创建转换器（类似于[如何编写自定义转换器](system-text-json-converters-how-to.md#support-polymorphic-deserialization)中的示例）。</span><span class="sxs-lookup"><span data-stu-id="2f54c-444">To support polymorphic deserialization, create a converter like the example in [How to write custom converters](system-text-json-converters-how-to.md#support-polymorphic-deserialization).</span></span>

### <a name="deserialization-of-object-properties"></a><span data-ttu-id="2f54c-445">对象属性的反序列化</span><span class="sxs-lookup"><span data-stu-id="2f54c-445">Deserialization of object properties</span></span>

<span data-ttu-id="2f54c-446">当 `Newtonsoft.Json` 反序列化为 <xref:System.Object> 时，它会：</span><span class="sxs-lookup"><span data-stu-id="2f54c-446">When `Newtonsoft.Json` deserializes to <xref:System.Object>, it:</span></span>

* <span data-ttu-id="2f54c-447">推断 JSON 有效负载中的基元值的类型（不是 `null`），并以装箱对象的形式返回存储的 `string`、`long`、`double`、`boolean` 或 `DateTime`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-447">Infers the type of primitive values in the JSON payload (other than `null`) and returns the stored `string`, `long`, `double`, `boolean`, or `DateTime` as a boxed object.</span></span> <span data-ttu-id="2f54c-448">基元值是单个 JSON 值，如 JSON 数字、字符串、`true`、`false` 或 `null`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-448">*Primitive values* are single JSON values such as a JSON number, string, `true`, `false`, or `null`.</span></span>
* <span data-ttu-id="2f54c-449">为 JSON 有效负载中的复杂值返回 `JObject` 或 `JArray`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-449">Returns a `JObject` or `JArray` for complex values in the JSON payload.</span></span> <span data-ttu-id="2f54c-450">复杂值是括在大括号 (`{}`) 中的 JSON 键值对的集合或括在方括号 (`[]`) 中的值的列表。</span><span class="sxs-lookup"><span data-stu-id="2f54c-450">*Complex values* are collections of JSON key-value pairs within braces (`{}`) or lists of values within brackets (`[]`).</span></span> <span data-ttu-id="2f54c-451">括在大括号或方括号中的属性和值可以具有附加属性或值。</span><span class="sxs-lookup"><span data-stu-id="2f54c-451">The properties and values within the braces or brackets can have additional properties or values.</span></span>
* <span data-ttu-id="2f54c-452">当有效负载具有 `null` JSON 文本时，返回空引用。</span><span class="sxs-lookup"><span data-stu-id="2f54c-452">Returns a null reference when the payload has the `null` JSON literal.</span></span>

<span data-ttu-id="2f54c-453"><xref:System.Text.Json> 在每次反序列化为 <xref:System.Object> 时，为基元和复数值存储装箱 `JsonElement`，例如：</span><span class="sxs-lookup"><span data-stu-id="2f54c-453"><xref:System.Text.Json> stores a boxed `JsonElement` for both primitive and complex values whenever deserializing to <xref:System.Object>, for example:</span></span>

* <span data-ttu-id="2f54c-454">`object` 属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-454">An `object` property.</span></span>
* <span data-ttu-id="2f54c-455">`object` 字典值。</span><span class="sxs-lookup"><span data-stu-id="2f54c-455">An `object` dictionary value.</span></span>
* <span data-ttu-id="2f54c-456">`object` 数组值。</span><span class="sxs-lookup"><span data-stu-id="2f54c-456">An `object` array value.</span></span>
* <span data-ttu-id="2f54c-457">根 `object`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-457">A root `object`.</span></span>

<span data-ttu-id="2f54c-458">但是，`System.Text.Json` 处理 `null` 的方式与 `Newtonsoft.Json` 相同，会在有效负载中包含 `null` JSON 文本时返回空引用。</span><span class="sxs-lookup"><span data-stu-id="2f54c-458">However, `System.Text.Json` treats `null` the same as `Newtonsoft.Json` and returns a null reference when the payload has the `null` JSON literal in it.</span></span>

<span data-ttu-id="2f54c-459">若要为 `object` 实现类型推理，请创建转换器（类似于[如何编写自定义转换器](system-text-json-converters-how-to.md#deserialize-inferred-types-to-object-properties)中的示例）。</span><span class="sxs-lookup"><span data-stu-id="2f54c-459">To implement type inference for `object` properties, create a converter like the example in [How to write custom converters](system-text-json-converters-how-to.md#deserialize-inferred-types-to-object-properties).</span></span>

### <a name="deserialize-null-to-non-nullable-type"></a><span data-ttu-id="2f54c-460">将 null 反序列化为不可为 null 的类型</span><span class="sxs-lookup"><span data-stu-id="2f54c-460">Deserialize null to non-nullable type</span></span>

<span data-ttu-id="2f54c-461">`Newtonsoft.Json` 在以下方案中不会引发异常：</span><span class="sxs-lookup"><span data-stu-id="2f54c-461">`Newtonsoft.Json` doesn't throw an exception in the following scenario:</span></span>

* <span data-ttu-id="2f54c-462">`NullValueHandling` 设置为 `Ignore`，并且</span><span class="sxs-lookup"><span data-stu-id="2f54c-462">`NullValueHandling` is set to `Ignore`, and</span></span>
* <span data-ttu-id="2f54c-463">在反序列化过程中，JSON 对于不可为 null 的值类型包含 null 值。</span><span class="sxs-lookup"><span data-stu-id="2f54c-463">During deserialization, the JSON contains a null value for a non-nullable value type.</span></span>

<span data-ttu-id="2f54c-464">在相同方案中，<xref:System.Text.Json> 会引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f54c-464">In the same scenario, <xref:System.Text.Json> does throw an exception.</span></span> <span data-ttu-id="2f54c-465">（`System.Text.Json` 中对应的 null 处理设置为 <xref:System.Text.Json.JsonSerializerOptions.IgnoreNullValues?displayProperty=nameWithType> = `true`。）</span><span class="sxs-lookup"><span data-stu-id="2f54c-465">(The corresponding null-handling setting in `System.Text.Json` is <xref:System.Text.Json.JsonSerializerOptions.IgnoreNullValues?displayProperty=nameWithType> = `true`.)</span></span>

<span data-ttu-id="2f54c-466">如果你拥有目标类型，在最佳解决方法是使相关属性可为 null（例如，将 `int` 更改为 `int?`）。</span><span class="sxs-lookup"><span data-stu-id="2f54c-466">If you own the target type, the best workaround is to make the property in question nullable (for example, change `int` to `int?`).</span></span>

<span data-ttu-id="2f54c-467">另一种解决方法是为类型创建转换器，如以下为 `DateTimeOffset` 类型处理 null 值的示例：</span><span class="sxs-lookup"><span data-stu-id="2f54c-467">Another workaround is to make a converter for the type, such as the following example that handles null values for `DateTimeOffset` types:</span></span>

:::code language="csharp" source="snippets/system-text-json-how-to/csharp/DateTimeOffsetNullHandlingConverter.cs":::

<span data-ttu-id="2f54c-468">通过[对属性使用特性](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-property)或是通过向 <xref:System.Text.Json.JsonSerializerOptions.Converters> 集合[添加转换器](system-text-json-converters-how-to.md#registration-sample---converters-collection)来注册此自定义转换器。</span><span class="sxs-lookup"><span data-stu-id="2f54c-468">Register this custom converter by [using an attribute on the property](system-text-json-converters-how-to.md#registration-sample---jsonconverter-on-a-property) or by [adding the converter](system-text-json-converters-how-to.md#registration-sample---converters-collection) to the <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span></span>

<span data-ttu-id="2f54c-469">**注意：** 前面的转换器处理 null 值的方式与 `Newtonsoft.Json` 为指定默认值的 POCO 进行处理的方式不同。</span><span class="sxs-lookup"><span data-stu-id="2f54c-469">**Note:** The preceding converter **handles null values differently** than `Newtonsoft.Json` does for POCOs that specify default values.</span></span> <span data-ttu-id="2f54c-470">例如，假设以下代码表示目标对象：</span><span class="sxs-lookup"><span data-stu-id="2f54c-470">For example, suppose the following code represents your target object:</span></span>

:::code language="csharp" source="snippets/system-text-json-how-to/csharp/WeatherForecast.cs" id="WFWithDefault":::

<span data-ttu-id="2f54c-471">并且假设使用前面的转换器反序列化以下 JSON：</span><span class="sxs-lookup"><span data-stu-id="2f54c-471">And suppose the following JSON is deserialized by using the preceding converter:</span></span>

```json
{
  "Date": null,
  "TemperatureCelsius": 25,
  "Summary": null
}
```

<span data-ttu-id="2f54c-472">反序列化之后，`Date` 属性具有 1/1/0001 (`default(DateTimeOffset)`)，即，在构造函数中设置的值会被覆盖。</span><span class="sxs-lookup"><span data-stu-id="2f54c-472">After deserialization, the `Date` property has 1/1/0001 (`default(DateTimeOffset)`), that is, the value set in the constructor is overwritten.</span></span> <span data-ttu-id="2f54c-473">给定相同 POCO 和 JSON，`Newtonsoft.Json` 反序列化会将 1/1/2001 保留在 `Date` 属性中。</span><span class="sxs-lookup"><span data-stu-id="2f54c-473">Given the same POCO and JSON, `Newtonsoft.Json` deserialization would leave 1/1/2001 in the `Date` property.</span></span>

### <a name="deserialize-to-immutable-classes-and-structs"></a><span data-ttu-id="2f54c-474">反序列化为不可变类和结构</span><span class="sxs-lookup"><span data-stu-id="2f54c-474">Deserialize to immutable classes and structs</span></span>

<span data-ttu-id="2f54c-475">`Newtonsoft.Json` 可以反序列化为不可变类和结构，因为它可以使用具有参数的构造函数。</span><span class="sxs-lookup"><span data-stu-id="2f54c-475">`Newtonsoft.Json` can deserialize to immutable classes and structs because it can use constructors that have parameters.</span></span>

::: zone pivot="dotnet-5-0"
<span data-ttu-id="2f54c-476">在 <xref:System.Text.Json> 中，使用 [[JsonConstructor]](xref:System.Text.Json.Serialization.JsonConstructorAttribute) 特性来指定参数化构造函数的用法。</span><span class="sxs-lookup"><span data-stu-id="2f54c-476">In <xref:System.Text.Json>, use the [[JsonConstructor]](xref:System.Text.Json.Serialization.JsonConstructorAttribute) attribute to specify use of a parameterized constructor.</span></span> <span data-ttu-id="2f54c-477">C# 9 记录也是不可变的，并且支持作为反序列化目标。</span><span class="sxs-lookup"><span data-stu-id="2f54c-477">Records in C# 9 are also immutable and are supported as deserialization targets.</span></span> <span data-ttu-id="2f54c-478">有关详细信息，请参阅[不可变类型和记录](system-text-json-immutability.md)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-478">For more information, see [Immutable types and Records](system-text-json-immutability.md).</span></span>
::: zone-end

::: zone pivot="dotnet-core-3-1"
<span data-ttu-id="2f54c-479">.NET Core 3.1 中的 <xref:System.Text.Json> 仅支持公共无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="2f54c-479"><xref:System.Text.Json> in .NET Core 3.1 supports only public parameterless constructors.</span></span> <span data-ttu-id="2f54c-480">作为一种解决方法，可以在自定义转换器中调用具有参数的构造函数。</span><span class="sxs-lookup"><span data-stu-id="2f54c-480">As a workaround, you can call a constructor with parameters in a custom converter.</span></span>

<span data-ttu-id="2f54c-481">下面是具有多个构造函数参数的不可变结构：</span><span class="sxs-lookup"><span data-stu-id="2f54c-481">Here's an immutable struct with multiple constructor parameters:</span></span>

:::code language="csharp" source="snippets/system-text-json-how-to/csharp/ImmutablePoint.cs" id="ImmutablePoint":::

<span data-ttu-id="2f54c-482">下面是序列化和反序列化此结构的转换器：</span><span class="sxs-lookup"><span data-stu-id="2f54c-482">And here's a converter that serializes and deserializes this struct:</span></span>

:::code language="csharp" source="snippets/system-text-json-how-to/csharp/ImmutablePointConverter.cs":::

<span data-ttu-id="2f54c-483">通过向 <xref:System.Text.Json.JsonSerializerOptions.Converters> 集合[添加转换器](system-text-json-converters-how-to.md#registration-sample---converters-collection)来注册此自定义转换器。</span><span class="sxs-lookup"><span data-stu-id="2f54c-483">Register this custom converter by [adding the converter](system-text-json-converters-how-to.md#registration-sample---converters-collection) to the <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span></span>

<span data-ttu-id="2f54c-484">有关处理开放式泛型属性的类似转换器的示例，请参阅[用于键/值对的内置转换器](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/JsonValueConverterKeyValuePair.cs)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-484">For an example of a similar converter that handles open generic properties, see the [built-in converter for key-value pairs](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/JsonValueConverterKeyValuePair.cs).</span></span>
::: zone-end

### <a name="required-properties"></a><span data-ttu-id="2f54c-485">必需的属性</span><span class="sxs-lookup"><span data-stu-id="2f54c-485">Required properties</span></span>

<span data-ttu-id="2f54c-486">在 `Newtonsoft.Json` 中，通过对 `[JsonProperty]` 特性设置 `Required` 来指定属性是必需的。</span><span class="sxs-lookup"><span data-stu-id="2f54c-486">In `Newtonsoft.Json`, you specify that a property is required by setting `Required` on the `[JsonProperty]` attribute.</span></span> <span data-ttu-id="2f54c-487">如果在 JSON 中没有为标记为必需的属性收到值，`Newtonsoft.Json` 会引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f54c-487">`Newtonsoft.Json` throws an exception if no value is received in the JSON for a property marked as required.</span></span>

<span data-ttu-id="2f54c-488">如果没有为目标类型的某个属性收到值，<xref:System.Text.Json> 不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f54c-488"><xref:System.Text.Json> doesn't throw an exception if no value is received for one of the properties of the target type.</span></span> <span data-ttu-id="2f54c-489">例如，如果具有 `WeatherForecast` 类：</span><span class="sxs-lookup"><span data-stu-id="2f54c-489">For example, if you have a `WeatherForecast` class:</span></span>

:::code language="csharp" source="snippets/system-text-json-how-to/csharp/WeatherForecast.cs" id="WF":::

<span data-ttu-id="2f54c-490">以下 JSON 可反序列化，不会发生错误：</span><span class="sxs-lookup"><span data-stu-id="2f54c-490">The following JSON is deserialized without error:</span></span>

```json
{
    "TemperatureCelsius": 25,
    "Summary": "Hot"
}
```

<span data-ttu-id="2f54c-491">若要使反序列化在 JSON 中没有 `Date` 属性时失败，请实现自定义转换器。</span><span class="sxs-lookup"><span data-stu-id="2f54c-491">To make deserialization fail if no `Date` property is in the JSON, implement a custom converter.</span></span> <span data-ttu-id="2f54c-492">如果反序列化完成之后未设置 `Date` 属性，则以下示例转换器代码会引发异常：</span><span class="sxs-lookup"><span data-stu-id="2f54c-492">The following sample converter code throws an exception if the `Date` property isn't set after deserialization is complete:</span></span>

:::code language="csharp" source="snippets/system-text-json-how-to/csharp/WeatherForecastRequiredPropertyConverter.cs":::

<span data-ttu-id="2f54c-493">通过向 <xref:System.Text.Json.JsonSerializerOptions.Converters?displayProperty=nameWithType> 集合[添加转换器](system-text-json-converters-how-to.md#registration-sample---converters-collection)来注册此自定义转换器。</span><span class="sxs-lookup"><span data-stu-id="2f54c-493">Register this custom converter by [adding the converter](system-text-json-converters-how-to.md#registration-sample---converters-collection) to the <xref:System.Text.Json.JsonSerializerOptions.Converters?displayProperty=nameWithType> collection.</span></span>

<span data-ttu-id="2f54c-494">这种以递归方式调用转换器的模式要求使用 <xref:System.Text.Json.JsonSerializerOptions> 而不是使用属性注册转换器。</span><span class="sxs-lookup"><span data-stu-id="2f54c-494">This pattern of recursively calling the converter requires that you register the converter by using <xref:System.Text.Json.JsonSerializerOptions>, not by using an attribute.</span></span> <span data-ttu-id="2f54c-495">如果使用属性注册转换器，则自定义转换器将以递归方式调入其自身。</span><span class="sxs-lookup"><span data-stu-id="2f54c-495">If you register the converter by using an attribute, the custom converter recursively calls into itself.</span></span> <span data-ttu-id="2f54c-496">结果是一个以堆栈溢出异常结尾的无限循环。</span><span class="sxs-lookup"><span data-stu-id="2f54c-496">The result is an infinite loop that ends in a stack overflow exception.</span></span>

<span data-ttu-id="2f54c-497">使用选项对象注册转换器时，请通过在以递归方式调用 <xref:System.Text.Json.JsonSerializer.Serialize%2A> 或 <xref:System.Text.Json.JsonSerializer.Deserialize%2A> 时不传入选项对象来避免无限循环。</span><span class="sxs-lookup"><span data-stu-id="2f54c-497">When you register the converter by using the options object, avoid an infinite loop by not passing in the options object when recursively calling <xref:System.Text.Json.JsonSerializer.Serialize%2A> or <xref:System.Text.Json.JsonSerializer.Deserialize%2A>.</span></span> <span data-ttu-id="2f54c-498">选项对象包含 <xref:System.Text.Json.JsonSerializerOptions.Converters%2A> 集合。</span><span class="sxs-lookup"><span data-stu-id="2f54c-498">The options object contains the <xref:System.Text.Json.JsonSerializerOptions.Converters%2A> collection.</span></span> <span data-ttu-id="2f54c-499">如果将它传递给 `Serialize` 或 `Deserialize`，则自定义转换器会调入其自身，从而产生导致堆栈溢出异常的无限循环。</span><span class="sxs-lookup"><span data-stu-id="2f54c-499">If you pass it in to `Serialize` or `Deserialize`, the custom converter calls into itself, making an infinite loop that results in a stack overflow exception.</span></span> <span data-ttu-id="2f54c-500">如果默认选项不可行，请使用所需设置创建选项的新实例。</span><span class="sxs-lookup"><span data-stu-id="2f54c-500">If the default options are not feasible, create a new instance of the options with the settings that you need.</span></span> <span data-ttu-id="2f54c-501">此方法会速度较慢，因为每个新实例都会独立缓存。</span><span class="sxs-lookup"><span data-stu-id="2f54c-501">This approach will be slow since each new instance caches independently.</span></span>

<span data-ttu-id="2f54c-502">有一种替代模式，可在要转换的类上使用 `JsonConverterAttribute` 注册。</span><span class="sxs-lookup"><span data-stu-id="2f54c-502">There is an alternative pattern that can use `JsonConverterAttribute` registration on the class to be converted.</span></span> <span data-ttu-id="2f54c-503">在此方法中，转换器代码对派生自要转换的类的类调用 `Serialize` 或 `Deserialize`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-503">In this approach, the converter code calls `Serialize` or `Deserialize` on a class that derives from the class to be converted.</span></span> <span data-ttu-id="2f54c-504">派生类没有应用 `JsonConverterAttribute`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-504">The derived class doesn't have a `JsonConverterAttribute` applied to it.</span></span> <span data-ttu-id="2f54c-505">在此替代的以下示例中：</span><span class="sxs-lookup"><span data-stu-id="2f54c-505">In the following example of this alternative:</span></span>

* <span data-ttu-id="2f54c-506">`WeatherForecastWithRequiredPropertyConverterAttribute` 是要进行反序列化并应用 `JsonConverterAttribute` 的类。</span><span class="sxs-lookup"><span data-stu-id="2f54c-506">`WeatherForecastWithRequiredPropertyConverterAttribute` is the class to be deserialized and has the `JsonConverterAttribute` applied to it.</span></span>
* <span data-ttu-id="2f54c-507">`WeatherForecastWithoutRequiredPropertyConverterAttribute` 是不具有转换器属性的派生类。</span><span class="sxs-lookup"><span data-stu-id="2f54c-507">`WeatherForecastWithoutRequiredPropertyConverterAttribute` is the derived class that doesn't have the converter attribute.</span></span>
* <span data-ttu-id="2f54c-508">转换器中的代码调用 `WeatherForecastWithoutRequiredPropertyConverterAttribute` 上的 `Serialize`和 `Deserialize` 以避免无限循环。</span><span class="sxs-lookup"><span data-stu-id="2f54c-508">The code in the converter calls `Serialize`and `Deserialize` on `WeatherForecastWithoutRequiredPropertyConverterAttribute` to avoid an infinite loop.</span></span> <span data-ttu-id="2f54c-509">此方法对于序列化是一种性能开销，因为需要实例化额外的对象和复制属性值。</span><span class="sxs-lookup"><span data-stu-id="2f54c-509">There is a performance cost to this approach on serialization due to an extra object instantiation and copying of property values.</span></span>

<span data-ttu-id="2f54c-510">`WeatherForecast*` 类型如下：</span><span class="sxs-lookup"><span data-stu-id="2f54c-510">Here are the `WeatherForecast*` types:</span></span>

:::code language="csharp" source="snippets/system-text-json-how-to/csharp/WeatherForecast.cs" id="WFWithReqPptyConverterAttr":::

<span data-ttu-id="2f54c-511">下面是转换器：</span><span class="sxs-lookup"><span data-stu-id="2f54c-511">And here is the converter:</span></span>

:::code language="csharp" source="snippets/system-text-json-how-to/csharp/WeatherForecastRequiredPropertyConverterForAttributeRegistration.cs":::

<span data-ttu-id="2f54c-512">如果需要处理特性（例如 [[JsonIgnore]](xref:System.Text.Json.Serialization.JsonIgnoreAttribute)）或不同选项（如自定义编码器），必需的属性转换器需要其他逻辑。</span><span class="sxs-lookup"><span data-stu-id="2f54c-512">The required properties converter would require additional logic if you need to handle attributes such as [[JsonIgnore]](xref:System.Text.Json.Serialization.JsonIgnoreAttribute) or different options, such as custom encoders.</span></span> <span data-ttu-id="2f54c-513">此外，示例代码不处理在构造函数中为其设置了默认值的属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-513">Also, the example code doesn't handle properties for which a default value is set in the constructor.</span></span> <span data-ttu-id="2f54c-514">而且此方法不区分以下情况：</span><span class="sxs-lookup"><span data-stu-id="2f54c-514">And this approach doesn't differentiate between the following scenarios:</span></span>

* <span data-ttu-id="2f54c-515">JSON 中缺少属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-515">A property is missing from the JSON.</span></span>
* <span data-ttu-id="2f54c-516">JSON 中存在不可为 null 的类型的属性，但值是该类型的默认值，如 `int` 的值为零。</span><span class="sxs-lookup"><span data-stu-id="2f54c-516">A property for a non-nullable type is present in the JSON, but the value is the default for the type, such as zero for an `int`.</span></span>
* <span data-ttu-id="2f54c-517">JSON 中存在可为 null 的值类型的属性，但值为 null。</span><span class="sxs-lookup"><span data-stu-id="2f54c-517">A property for a nullable value type is present in the JSON, but the value is null.</span></span>

### <a name="specify-date-format"></a><span data-ttu-id="2f54c-518">指定日期格式</span><span class="sxs-lookup"><span data-stu-id="2f54c-518">Specify date format</span></span>

<span data-ttu-id="2f54c-519">`Newtonsoft.Json` 提供多种方法来控制如何序列化和反序列化 `DateTime` 和 `DateTimeOffset` 类型的属性：</span><span class="sxs-lookup"><span data-stu-id="2f54c-519">`Newtonsoft.Json` provides several ways to control how properties of `DateTime` and `DateTimeOffset` types are serialized and deserialized:</span></span>

* <span data-ttu-id="2f54c-520">`DateTimeZoneHandling` 设置可用于将所有 `DateTime` 值序列化为 UTC 日期。</span><span class="sxs-lookup"><span data-stu-id="2f54c-520">The `DateTimeZoneHandling` setting can be used to serialize all `DateTime` values as UTC dates.</span></span>
* <span data-ttu-id="2f54c-521">`DateFormatString` 设置和 `DateTime` 转换器可用于自定义日期字符串的格式。</span><span class="sxs-lookup"><span data-stu-id="2f54c-521">The `DateFormatString` setting and `DateTime` converters can be used to customize the format of date strings.</span></span>

<span data-ttu-id="2f54c-522">在 <xref:System.Text.Json> 中，具有内置支持的唯一格式是 ISO 8601-1:2019，因为它被广泛采用、意义明确并且可精确地进行往返。</span><span class="sxs-lookup"><span data-stu-id="2f54c-522">In <xref:System.Text.Json>, the only format that has built-in support is ISO 8601-1:2019 since it's widely adopted, unambiguous, and makes round trips precisely.</span></span> <span data-ttu-id="2f54c-523">若要使用任何其他格式，请创建自定义转换器。</span><span class="sxs-lookup"><span data-stu-id="2f54c-523">To use any other format, create a custom converter.</span></span> <span data-ttu-id="2f54c-524">有关详细信息，请参阅 [System.Text.Json 中的 DateTime 和 DateTimeOffset 支持](../datetime/system-text-json-support.md)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-524">For more information, see [DateTime and DateTimeOffset support in System.Text.Json](../datetime/system-text-json-support.md).</span></span>

### <a name="callbacks"></a><span data-ttu-id="2f54c-525">回调</span><span class="sxs-lookup"><span data-stu-id="2f54c-525">Callbacks</span></span>

<span data-ttu-id="2f54c-526">`Newtonsoft.Json` 使你可以在序列化或反序列化过程中的多个点执行自定义代码：</span><span class="sxs-lookup"><span data-stu-id="2f54c-526">`Newtonsoft.Json` lets you execute custom code at several points in the serialization or deserialization process:</span></span>

* <span data-ttu-id="2f54c-527">OnDeserializing（开始反序列化对象时）</span><span class="sxs-lookup"><span data-stu-id="2f54c-527">OnDeserializing (when beginning to deserialize an object)</span></span>
* <span data-ttu-id="2f54c-528">OnDeserialized（对象反序列化完成时）</span><span class="sxs-lookup"><span data-stu-id="2f54c-528">OnDeserialized (when finished deserializing an object)</span></span>
* <span data-ttu-id="2f54c-529">OnSerializing（开始序列化对象时）</span><span class="sxs-lookup"><span data-stu-id="2f54c-529">OnSerializing (when beginning to serialize an object)</span></span>
* <span data-ttu-id="2f54c-530">OnSerialized（对象序列化完成时）</span><span class="sxs-lookup"><span data-stu-id="2f54c-530">OnSerialized (when finished serializing an object)</span></span>

<span data-ttu-id="2f54c-531">在 <xref:System.Text.Json> 中，可以通过编写自定义转换器来模拟回调。</span><span class="sxs-lookup"><span data-stu-id="2f54c-531">In <xref:System.Text.Json>, you can simulate callbacks by writing a custom converter.</span></span> <span data-ttu-id="2f54c-532">以下示例演示适用于 POCO 的自定义转换器。</span><span class="sxs-lookup"><span data-stu-id="2f54c-532">The following example shows a custom converter for a POCO.</span></span> <span data-ttu-id="2f54c-533">该转换器包含在与 `Newtonsoft.Json` 回调相对应的每个点显示消息的代码。</span><span class="sxs-lookup"><span data-stu-id="2f54c-533">The converter includes code that displays a message at each point that corresponds to a `Newtonsoft.Json` callback.</span></span>

:::code language="csharp" source="snippets/system-text-json-how-to/csharp/WeatherForecastCallbacksConverter.cs":::

<span data-ttu-id="2f54c-534">通过向 <xref:System.Text.Json.JsonSerializerOptions.Converters> 集合[添加转换器](system-text-json-converters-how-to.md#registration-sample---converters-collection)来注册此自定义转换器。</span><span class="sxs-lookup"><span data-stu-id="2f54c-534">Register this custom converter by [adding the converter](system-text-json-converters-how-to.md#registration-sample---converters-collection) to the <xref:System.Text.Json.JsonSerializerOptions.Converters> collection.</span></span>

<span data-ttu-id="2f54c-535">如果使用遵循前面示例的自定义转换器：</span><span class="sxs-lookup"><span data-stu-id="2f54c-535">If you use a custom converter that follows the preceding sample:</span></span>

* <span data-ttu-id="2f54c-536">`OnDeserializing` 代码无权访问新 POCO 实例。</span><span class="sxs-lookup"><span data-stu-id="2f54c-536">The `OnDeserializing` code doesn't have access to the new POCO instance.</span></span> <span data-ttu-id="2f54c-537">若要在反序列化开始时操作新 POCO 实例，请将该代码放入 POCO 构造函数中。</span><span class="sxs-lookup"><span data-stu-id="2f54c-537">To manipulate the new POCO instance at the start of deserialization, put that code in the POCO constructor.</span></span>
* <span data-ttu-id="2f54c-538">通过在选项对象中注册转换器而在以递归方式调用 `Serialize` 或 `Deserialize` 时不传入选项对象，避免无限循环。</span><span class="sxs-lookup"><span data-stu-id="2f54c-538">Avoid an infinite loop by registering the converter in the options object and not passing in the options object when recursively calling `Serialize` or `Deserialize`.</span></span>

<span data-ttu-id="2f54c-539">若要详细了解递归调用 `Serialize` 或 `Deserialize` 的自定义转换器，请参阅本文前面的[必需属性](#required-properties)部分。</span><span class="sxs-lookup"><span data-stu-id="2f54c-539">For more information about custom converters that recursively call `Serialize` or `Deserialize`, see the [Required properties](#required-properties) section earlier in this article.</span></span>

### <a name="non-public-property-setters-and-getters"></a><span data-ttu-id="2f54c-540">非公共属性资源库和 Getter</span><span class="sxs-lookup"><span data-stu-id="2f54c-540">Non-public property setters and getters</span></span>

<span data-ttu-id="2f54c-541">`Newtonsoft.Json` 可以通过 `JsonProperty` 特性使用私有和内部属性 setter 和 getter。</span><span class="sxs-lookup"><span data-stu-id="2f54c-541">`Newtonsoft.Json` can use private and internal property setters and getters via the `JsonProperty` attribute.</span></span>

::: zone pivot="dotnet-5-0"
<span data-ttu-id="2f54c-542"><xref:System.Text.Json> 支持通过 [[JsonInclude]](xref:System.Text.Json.Serialization.JsonIncludeAttribute) 特性使用私有和内部属性资源库和 Getter。</span><span class="sxs-lookup"><span data-stu-id="2f54c-542"><xref:System.Text.Json> supports private and internal property setters and getters via the [[JsonInclude]](xref:System.Text.Json.Serialization.JsonIncludeAttribute) attribute.</span></span> <span data-ttu-id="2f54c-543">有关示例代码，请参阅[非公共属性访问器](system-text-json-immutability.md)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-543">For sample code, see [Non-public property accessors](system-text-json-immutability.md).</span></span>
::: zone-end

::: zone pivot="dotnet-core-3-1"
<span data-ttu-id="2f54c-544">.NET Core 3.1 中的 <xref:System.Text.Json> 仅支持公共资源库。</span><span class="sxs-lookup"><span data-stu-id="2f54c-544"><xref:System.Text.Json> in .NET Core 3.1 supports only public setters.</span></span> <span data-ttu-id="2f54c-545">自定义转换器可提供此功能。</span><span class="sxs-lookup"><span data-stu-id="2f54c-545">Custom converters can provide this functionality.</span></span>
::: zone-end

### <a name="populate-existing-objects"></a><span data-ttu-id="2f54c-546">填充现有对象</span><span class="sxs-lookup"><span data-stu-id="2f54c-546">Populate existing objects</span></span>

<span data-ttu-id="2f54c-547">`Newtonsoft.Json` 中的 `JsonConvert.PopulateObject` 方法将 JSON 文档反序列化为类的现有实例，而不是创建新实例。</span><span class="sxs-lookup"><span data-stu-id="2f54c-547">The `JsonConvert.PopulateObject` method in `Newtonsoft.Json` deserializes a JSON document to an existing instance of a class, instead of creating a new instance.</span></span> <span data-ttu-id="2f54c-548"><xref:System.Text.Json> 始终使用默认公共无参数构造函数创建目标类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="2f54c-548"><xref:System.Text.Json> always creates a new instance of the target type by using the default public parameterless constructor.</span></span> <span data-ttu-id="2f54c-549">自定义转换器可以反序列化为现有实例。</span><span class="sxs-lookup"><span data-stu-id="2f54c-549">Custom converters can deserialize to an existing instance.</span></span>

### <a name="reuse-rather-than-replace-properties"></a><span data-ttu-id="2f54c-550">重用而不是替换属性</span><span class="sxs-lookup"><span data-stu-id="2f54c-550">Reuse rather than replace properties</span></span>

<span data-ttu-id="2f54c-551">`Newtonsoft.Json` `ObjectCreationHandling` 设置使你可以指定在反序列化过程中应重用属性中的对象，而不是进行替换。</span><span class="sxs-lookup"><span data-stu-id="2f54c-551">The `Newtonsoft.Json` `ObjectCreationHandling` setting lets you specify that objects in properties should be reused rather than replaced during deserialization.</span></span> <span data-ttu-id="2f54c-552"><xref:System.Text.Json> 始终替换属性中的对象。</span><span class="sxs-lookup"><span data-stu-id="2f54c-552"><xref:System.Text.Json> always replaces objects in properties.</span></span>  <span data-ttu-id="2f54c-553">自定义转换器可提供此功能。</span><span class="sxs-lookup"><span data-stu-id="2f54c-553">Custom converters can provide this functionality.</span></span>

### <a name="add-to-collections-without-setters"></a><span data-ttu-id="2f54c-554">在不带 setter 的情况下添加到集合</span><span class="sxs-lookup"><span data-stu-id="2f54c-554">Add to collections without setters</span></span>

<span data-ttu-id="2f54c-555">在反序列化过程中，`Newtonsoft.Json` 会将对象添加到集合，即使属性没有 setter。</span><span class="sxs-lookup"><span data-stu-id="2f54c-555">During deserialization, `Newtonsoft.Json` adds objects to a collection even if the property has no setter.</span></span> <span data-ttu-id="2f54c-556"><xref:System.Text.Json> 会忽略没有 setter 的属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-556"><xref:System.Text.Json> ignores properties that don't have setters.</span></span> <span data-ttu-id="2f54c-557">自定义转换器可提供此功能。</span><span class="sxs-lookup"><span data-stu-id="2f54c-557">Custom converters can provide this functionality.</span></span>

### <a name="systemruntimeserialization-attributes"></a><span data-ttu-id="2f54c-558">System.Runtime.Serialization 特性</span><span class="sxs-lookup"><span data-stu-id="2f54c-558">System.Runtime.Serialization attributes</span></span>

<span data-ttu-id="2f54c-559"><xref:System.Text.Json> 不支持 `System.Runtime.Serialization` 命名空间中的特性，如 `DataMemberAttribute` 和 `IgnoreDataMemberAttribute`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-559"><xref:System.Text.Json> doesn't support attributes from the `System.Runtime.Serialization` namespace, such as `DataMemberAttribute` and `IgnoreDataMemberAttribute`.</span></span>

### <a name="octal-numbers"></a><span data-ttu-id="2f54c-560">八进制数字</span><span class="sxs-lookup"><span data-stu-id="2f54c-560">Octal numbers</span></span>

<span data-ttu-id="2f54c-561">`Newtonsoft.Json` 将带前导零的数字视为八进制数字。</span><span class="sxs-lookup"><span data-stu-id="2f54c-561">`Newtonsoft.Json` treats numbers with a leading zero as octal numbers.</span></span> <span data-ttu-id="2f54c-562"><xref:System.Text.Json> 不允许存在前导零，因为 [RFC 8259](https://tools.ietf.org/html/rfc8259) 规范不允许。</span><span class="sxs-lookup"><span data-stu-id="2f54c-562"><xref:System.Text.Json> doesn't allow leading zeroes because the [RFC 8259](https://tools.ietf.org/html/rfc8259) specification doesn't allow them.</span></span>

### <a name="missingmemberhandling"></a><span data-ttu-id="2f54c-563">MissingMemberHandling</span><span class="sxs-lookup"><span data-stu-id="2f54c-563">MissingMemberHandling</span></span>

<span data-ttu-id="2f54c-564">`Newtonsoft.Json` 可以配置为在 JSON 包含目标类型中缺少的属性时，在反序列化过程中引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f54c-564">`Newtonsoft.Json` can be configured to throw exceptions during deserialization if the JSON includes properties that are missing in the target type.</span></span> <span data-ttu-id="2f54c-565"><xref:System.Text.Json> 会忽略 JSON 中的额外属性，但在使用 [[JsonExtensionData] 特性](system-text-json-handle-overflow.md)时除外。</span><span class="sxs-lookup"><span data-stu-id="2f54c-565"><xref:System.Text.Json> ignores extra properties in the JSON, except when you use the [[JsonExtensionData] attribute](system-text-json-handle-overflow.md).</span></span> <span data-ttu-id="2f54c-566">对于缺少成员功能，没有解决方法。</span><span class="sxs-lookup"><span data-stu-id="2f54c-566">There's no workaround for the missing member feature.</span></span>

### <a name="tracewriter"></a><span data-ttu-id="2f54c-567">TraceWriter</span><span class="sxs-lookup"><span data-stu-id="2f54c-567">TraceWriter</span></span>

<span data-ttu-id="2f54c-568">`Newtonsoft.Json` 使你可以使用 `TraceWriter` 进行调试，以查看序列化或反序列化所生成的日志。</span><span class="sxs-lookup"><span data-stu-id="2f54c-568">`Newtonsoft.Json` lets you debug by using a `TraceWriter` to view logs that are generated by serialization or deserialization.</span></span> <span data-ttu-id="2f54c-569"><xref:System.Text.Json> 不执行日志记录。</span><span class="sxs-lookup"><span data-stu-id="2f54c-569"><xref:System.Text.Json> doesn't do logging.</span></span>

## <a name="jsondocument-and-jsonelement-compared-to-jtoken-like-jobject-jarray"></a><span data-ttu-id="2f54c-570">与 JToken（如 JObject、JArray）相比的 JsonDocument 和 JsonElement</span><span class="sxs-lookup"><span data-stu-id="2f54c-570">JsonDocument and JsonElement compared to JToken (like JObject, JArray)</span></span>

<span data-ttu-id="2f54c-571"><xref:System.Text.Json.JsonDocument?displayProperty=fullName> 提供从现有 JSON 有效负载分析和生成只读文档对象模型 (DOM) 的功能。</span><span class="sxs-lookup"><span data-stu-id="2f54c-571"><xref:System.Text.Json.JsonDocument?displayProperty=fullName> provides the ability to parse and build a **read-only** Document Object Model (DOM) from existing JSON payloads.</span></span> <span data-ttu-id="2f54c-572">DOM 提供对 JSON 有效负载中的数据的随机访问。</span><span class="sxs-lookup"><span data-stu-id="2f54c-572">The DOM provides random access to data in a JSON payload.</span></span> <span data-ttu-id="2f54c-573">可以通过 <xref:System.Text.Json.JsonElement> 类型访问构成有效负载的 JSON 元素。</span><span class="sxs-lookup"><span data-stu-id="2f54c-573">The JSON elements that compose the payload can be accessed via the <xref:System.Text.Json.JsonElement> type.</span></span> <span data-ttu-id="2f54c-574">`JsonElement` 类型提供用于将 JSON 文本转换为常见 .NET 类型的 API。</span><span class="sxs-lookup"><span data-stu-id="2f54c-574">The `JsonElement` type provides APIs to convert JSON text to common .NET types.</span></span> <span data-ttu-id="2f54c-575">`JsonDocument` 公开了 <xref:System.Text.Json.JsonDocument.RootElement> 属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-575">`JsonDocument` exposes a <xref:System.Text.Json.JsonDocument.RootElement> property.</span></span>

### <a name="jsondocument-is-idisposable"></a><span data-ttu-id="2f54c-576">JsonDocument 为 IDisposable</span><span class="sxs-lookup"><span data-stu-id="2f54c-576">JsonDocument is IDisposable</span></span>

<span data-ttu-id="2f54c-577">`JsonDocument` 将内存中的数据视图生成到共用缓冲区中。</span><span class="sxs-lookup"><span data-stu-id="2f54c-577">`JsonDocument` builds an in-memory view of the data into a pooled buffer.</span></span> <span data-ttu-id="2f54c-578">因此，与 `Newtonsoft.Json` 中的 `JObject` 或 `JArray` 不同，`JsonDocument` 类型实现 `IDisposable` 并且需要在 using 块中使用。</span><span class="sxs-lookup"><span data-stu-id="2f54c-578">Therefore, unlike `JObject` or `JArray` from `Newtonsoft.Json`, the `JsonDocument` type implements `IDisposable` and needs to be used inside a using block.</span></span>

<span data-ttu-id="2f54c-579">如果要将生存期所有权和释放责任转移到调用方，则只需从 API 返回 `JsonDocument`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-579">Only return a `JsonDocument` from your API if you want to transfer lifetime ownership and dispose responsibility to the caller.</span></span> <span data-ttu-id="2f54c-580">在大多数情况下，这不是必需的。</span><span class="sxs-lookup"><span data-stu-id="2f54c-580">In most scenarios, that isn't necessary.</span></span> <span data-ttu-id="2f54c-581">如果调用方需要处理整个 JSON 文档，则返回 <xref:System.Text.Json.JsonDocument.RootElement%2A> 的 <xref:System.Text.Json.JsonElement.Clone%2A>，这是 <xref:System.Text.Json.JsonElement>。</span><span class="sxs-lookup"><span data-stu-id="2f54c-581">If the caller needs to work with the entire JSON document, return the <xref:System.Text.Json.JsonElement.Clone%2A> of the <xref:System.Text.Json.JsonDocument.RootElement%2A>, which is a <xref:System.Text.Json.JsonElement>.</span></span> <span data-ttu-id="2f54c-582">如果调用方需要处理 JSON 文档中的特定元素，则返回该 <xref:System.Text.Json.JsonElement> 的 <xref:System.Text.Json.JsonElement.Clone%2A>。</span><span class="sxs-lookup"><span data-stu-id="2f54c-582">If the caller needs to work with a particular element within the JSON document, return the <xref:System.Text.Json.JsonElement.Clone%2A> of that <xref:System.Text.Json.JsonElement>.</span></span> <span data-ttu-id="2f54c-583">如果在不进行 `Clone` 的情况下直接返回 `RootElement` 或子元素，则在释放拥有返回的 `JsonElement` 的 `JsonDocument` 之后，调用方将无法访问它。</span><span class="sxs-lookup"><span data-stu-id="2f54c-583">If you return the `RootElement` or a sub-element directly without making a `Clone`, the caller won't be able to access the returned `JsonElement` after the `JsonDocument` that owns it is disposed.</span></span>

<span data-ttu-id="2f54c-584">下面是一个要求你进行 `Clone` 的示例：</span><span class="sxs-lookup"><span data-stu-id="2f54c-584">Here's an example that requires you to make a `Clone`:</span></span>

```csharp
public JsonElement LookAndLoad(JsonElement source)
{
    string json = File.ReadAllText(source.GetProperty("fileName").GetString());

    using (JsonDocument doc = JsonDocument.Parse(json))
    {
        return doc.RootElement.Clone();
    }
}
```

<span data-ttu-id="2f54c-585">前面的代码需要包含 `fileName` 属性的 `JsonElement`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-585">The preceding code expects a `JsonElement` that contains a `fileName` property.</span></span> <span data-ttu-id="2f54c-586">它会打开 JSON 文件并创建一个 `JsonDocument`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-586">It opens the JSON file and creates a `JsonDocument`.</span></span> <span data-ttu-id="2f54c-587">该方法假设调用方要处理整个文档，因此会返回 `RootElement` 的 `Clone`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-587">The method assumes that the caller wants to work with the entire document, so it returns the `Clone` of the `RootElement`.</span></span>

<span data-ttu-id="2f54c-588">如果收到 `JsonElement` 并要返回子元素，则无需返回子元素的 `Clone`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-588">If you receive a `JsonElement` and are returning a sub-element, it's not necessary to return a `Clone` of the sub-element.</span></span> <span data-ttu-id="2f54c-589">调用方负责使传入的 `JsonElement` 所属的 `JsonDocument` 保持活动状态。</span><span class="sxs-lookup"><span data-stu-id="2f54c-589">The caller is responsible for keeping alive the `JsonDocument` that the passed-in `JsonElement` belongs to.</span></span> <span data-ttu-id="2f54c-590">例如：</span><span class="sxs-lookup"><span data-stu-id="2f54c-590">For example:</span></span>

```csharp
public JsonElement ReturnFileName(JsonElement source)
{
   return source.GetProperty("fileName");
}
```

### <a name="jsondocument-is-read-only"></a><span data-ttu-id="2f54c-591">JsonDocument 为只读</span><span class="sxs-lookup"><span data-stu-id="2f54c-591">JsonDocument is read-only</span></span>

<span data-ttu-id="2f54c-592"><xref:System.Text.Json> DOM 无法添加、删除或修改 JSON 元素。</span><span class="sxs-lookup"><span data-stu-id="2f54c-592">The <xref:System.Text.Json> DOM can't add, remove, or modify JSON elements.</span></span> <span data-ttu-id="2f54c-593">它这样设计是为了实现性能，并减少用于分析常见 JSON 有效负载大小（即 < 1 MB）的分配。</span><span class="sxs-lookup"><span data-stu-id="2f54c-593">It's designed this way for performance and to reduce allocations for parsing common JSON payload sizes (that is, < 1 MB).</span></span> <span data-ttu-id="2f54c-594">如果你的方案当前使用可修改的 DOM，则以下解决方法之一可能是可行的：</span><span class="sxs-lookup"><span data-stu-id="2f54c-594">If your scenario currently uses a modifiable DOM, one of the following workarounds might be feasible:</span></span>

* <span data-ttu-id="2f54c-595">若要从头开始生成 `JsonDocument`（即，不将现有 JSON 有效负载传入到 `Parse` 方法），请使用 `Utf8JsonWriter` 编写 JSON 文本，并分析这样做的输出以创建新 `JsonDocument`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-595">To build a `JsonDocument` from scratch (that is, without passing in an existing JSON payload to the `Parse` method), write the JSON text by using the `Utf8JsonWriter` and parse the output from that to make a new `JsonDocument`.</span></span>
* <span data-ttu-id="2f54c-596">若要修改现有 `JsonDocument`，请使用它编写 JSON 文本（在编写时进行更改），并分析这样做的输出以创建新 `JsonDocument`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-596">To modify an existing `JsonDocument`, use it to write JSON text, making changes while you write, and parse the output from that to make a new `JsonDocument`.</span></span>
* <span data-ttu-id="2f54c-597">若要合并现有 JSON 文档（与 `Newtonsoft.Json` 中的 `JObject.Merge` 或 `JContainer.Merge` API 等效），请参阅[此 GitHub 问题](https://github.com/dotnet/corefx/issues/42466#issuecomment-570475853)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-597">To merge existing JSON documents, equivalent to the `JObject.Merge` or `JContainer.Merge` APIs from `Newtonsoft.Json`, see [this GitHub issue](https://github.com/dotnet/corefx/issues/42466#issuecomment-570475853).</span></span>

### <a name="jsonelement-is-a-union-struct"></a><span data-ttu-id="2f54c-598">JsonElement 是联合结构</span><span class="sxs-lookup"><span data-stu-id="2f54c-598">JsonElement is a union struct</span></span>

<span data-ttu-id="2f54c-599">`JsonDocument` 将 `RootElement` 公开为类型 <xref:System.Text.Json.JsonElement> 的属性，该类型是包含任何 JSON 元素的联合结构类型。</span><span class="sxs-lookup"><span data-stu-id="2f54c-599">`JsonDocument` exposes the `RootElement` as a property of type <xref:System.Text.Json.JsonElement>, which is a union, struct type that encompasses any JSON element.</span></span> <span data-ttu-id="2f54c-600">`Newtonsoft.Json` 使用专用分层类型，如 `JObject`、`JArray`、`JToken` 等。</span><span class="sxs-lookup"><span data-stu-id="2f54c-600">`Newtonsoft.Json` uses dedicated hierarchical types like `JObject`,`JArray`, `JToken`, and so forth.</span></span> <span data-ttu-id="2f54c-601">`JsonElement` 是可以搜索和枚举的内容，你可以使用 `JsonElement` 将 JSON 元素具体化为 .NET 类型。</span><span class="sxs-lookup"><span data-stu-id="2f54c-601">`JsonElement` is what you can search and enumerate over, and you can use `JsonElement` to materialize JSON elements into .NET types.</span></span>

### <a name="how-to-search-a-jsondocument-and-jsonelement-for-sub-elements"></a><span data-ttu-id="2f54c-602">如何搜索子元素的 JsonDocument 和 JsonElement</span><span class="sxs-lookup"><span data-stu-id="2f54c-602">How to search a JsonDocument and JsonElement for sub-elements</span></span>

<span data-ttu-id="2f54c-603">使用 `Newtonsoft.Json` 中的 `JObject` 或 `JArray` 搜索 JSON 令牌的速度往往相对较快，因为它们是在某个字典中查找。</span><span class="sxs-lookup"><span data-stu-id="2f54c-603">Searches for JSON tokens using `JObject` or `JArray` from `Newtonsoft.Json` tend to be relatively fast because they're lookups in some dictionary.</span></span> <span data-ttu-id="2f54c-604">相比之下，对 `JsonElement` 进行搜索需要对属性进行线性搜索，因此速度相对较慢（例如在使用 `TryGetProperty` 时）。</span><span class="sxs-lookup"><span data-stu-id="2f54c-604">By comparison, searches on `JsonElement` require a sequential search of the properties and hence is relatively slow (for example when using `TryGetProperty`).</span></span> <span data-ttu-id="2f54c-605"><xref:System.Text.Json> 旨在最大程度减少初始分析时间，而不是查找时间。</span><span class="sxs-lookup"><span data-stu-id="2f54c-605"><xref:System.Text.Json> is designed to minimize initial parse time rather than lookup time.</span></span> <span data-ttu-id="2f54c-606">因此，在通过 `JsonDocument` 对象搜索时，请使用以下方法优化性能：</span><span class="sxs-lookup"><span data-stu-id="2f54c-606">Therefore, use the following approaches to optimize performance when searching through a `JsonDocument` object:</span></span>

* <span data-ttu-id="2f54c-607">使用内置枚举器（<xref:System.Text.Json.JsonElement.EnumerateArray%2A> 和 <xref:System.Text.Json.JsonElement.EnumerateObject%2A>），而不是执行自己的索引或循环。</span><span class="sxs-lookup"><span data-stu-id="2f54c-607">Use the built-in enumerators (<xref:System.Text.Json.JsonElement.EnumerateArray%2A> and <xref:System.Text.Json.JsonElement.EnumerateObject%2A>) rather than doing your own indexing or loops.</span></span>
* <span data-ttu-id="2f54c-608">不要使用 `RootElement` 通过每个属性对整个 `JsonDocument` 执行线性搜索。</span><span class="sxs-lookup"><span data-stu-id="2f54c-608">Don't do a sequential search on the whole `JsonDocument` through every property by using `RootElement`.</span></span> <span data-ttu-id="2f54c-609">而是基于 JSON 数据的已知结构对嵌套 JSON 对象进行搜索。</span><span class="sxs-lookup"><span data-stu-id="2f54c-609">Instead, search on nested JSON objects based on the known structure of the JSON data.</span></span> <span data-ttu-id="2f54c-610">例如，如果要在 `Student` 对象中查找 `Grade` 属性，请循环访问 `Student` 对象，并获取每个对象的 `Grade` 值，而不是搜索所有 `Grade` 对象来查找 `JsonElement` 属性。</span><span class="sxs-lookup"><span data-stu-id="2f54c-610">For example, if you're looking for a `Grade` property in `Student` objects, loop through the `Student` objects and get the value of `Grade` for each, rather than searching through all `JsonElement` objects looking for `Grade` properties.</span></span> <span data-ttu-id="2f54c-611">执行后者将导致不必要浏览相同数据。</span><span class="sxs-lookup"><span data-stu-id="2f54c-611">Doing the latter will result in unnecessary passes over the same data.</span></span>

<span data-ttu-id="2f54c-612">有关代码示例，请参阅[使用 JsonDocument 访问数据](write-custom-serializer-deserializer.md#use-jsondocument-for-access-to-data)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-612">For a code example, see [Use JsonDocument for access to data](write-custom-serializer-deserializer.md#use-jsondocument-for-access-to-data).</span></span>

## <a name="utf8jsonreader-compared-to-jsontextreader"></a><span data-ttu-id="2f54c-613">Utf8JsonReader 与 JsonTextReader 的比较</span><span class="sxs-lookup"><span data-stu-id="2f54c-613">Utf8JsonReader compared to JsonTextReader</span></span>

<span data-ttu-id="2f54c-614"><xref:System.Text.Json.Utf8JsonReader?displayProperty=fullName> 是面向 UTF-8 编码 JSON 文本的一个高性能、低分配的只进读取器，从 [ReadOnlySpan\<byte>](xref:System.ReadOnlySpan%601) 或 [ReadOnlySequence\<byte>](xref:System.Buffers.ReadOnlySequence%601) 读取信息。</span><span class="sxs-lookup"><span data-stu-id="2f54c-614"><xref:System.Text.Json.Utf8JsonReader?displayProperty=fullName> is a high-performance, low allocation, forward-only reader for UTF-8 encoded JSON text, read from a [ReadOnlySpan\<byte>](xref:System.ReadOnlySpan%601) or [ReadOnlySequence\<byte>](xref:System.Buffers.ReadOnlySequence%601).</span></span> <span data-ttu-id="2f54c-615">`Utf8JsonReader` 是一种低级类型，可用于生成自定义分析器和反序列化程序。</span><span class="sxs-lookup"><span data-stu-id="2f54c-615">The `Utf8JsonReader` is a low-level type that can be used to build custom parsers and deserializers.</span></span>

<span data-ttu-id="2f54c-616">以下各节说明使用 `Utf8JsonReader` 的推荐编程模式。</span><span class="sxs-lookup"><span data-stu-id="2f54c-616">The following sections explain recommended programming patterns for using `Utf8JsonReader`.</span></span>

### <a name="utf8jsonreader-is-a-ref-struct"></a><span data-ttu-id="2f54c-617">Utf8JsonReader 是 ref struct</span><span class="sxs-lookup"><span data-stu-id="2f54c-617">Utf8JsonReader is a ref struct</span></span>

<span data-ttu-id="2f54c-618">由于 `Utf8JsonReader` 类型是 ref struct，因此它具有[某些限制](../../csharp/language-reference/builtin-types/struct.md#ref-struct)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-618">Because the `Utf8JsonReader` type is a *ref struct*, it has [certain limitations](../../csharp/language-reference/builtin-types/struct.md#ref-struct).</span></span> <span data-ttu-id="2f54c-619">例如，它无法作为字段存储在 ref struct 之外的类或结构中。</span><span class="sxs-lookup"><span data-stu-id="2f54c-619">For example, it can't be stored as a field on a class or struct other than a ref struct.</span></span> <span data-ttu-id="2f54c-620">若要实现高性能，此类型必须为 `ref struct`，因为它需要缓存输入 [ReadOnlySpan\<byte>](xref:System.ReadOnlySpan%601)（这本身便是 ref struct）。</span><span class="sxs-lookup"><span data-stu-id="2f54c-620">To achieve high performance, this type must be a `ref struct` since it needs to cache the input [ReadOnlySpan\<byte>](xref:System.ReadOnlySpan%601), which itself is a ref struct.</span></span> <span data-ttu-id="2f54c-621">此外，此类型是可变的，因为它包含状态。</span><span class="sxs-lookup"><span data-stu-id="2f54c-621">In addition, this type is mutable since it holds state.</span></span> <span data-ttu-id="2f54c-622">因此，它按引用传递而不是按值传递。</span><span class="sxs-lookup"><span data-stu-id="2f54c-622">Therefore, **pass it by ref** rather than by value.</span></span> <span data-ttu-id="2f54c-623">按值传递会产生结构副本，状态更改会对调用方不可见。</span><span class="sxs-lookup"><span data-stu-id="2f54c-623">Passing it by value would result in a struct copy and the state changes would not be visible to the caller.</span></span> <span data-ttu-id="2f54c-624">这与 `Newtonsoft.Json` 不同，因为 `Newtonsoft.Json` `JsonTextReader` 是一个类。</span><span class="sxs-lookup"><span data-stu-id="2f54c-624">This differs from `Newtonsoft.Json` since the `Newtonsoft.Json` `JsonTextReader` is a class.</span></span> <span data-ttu-id="2f54c-625">有关如何使用 ref struct 的详细信息，请参阅[编写安全有效的 C# 代码](../../csharp/write-safe-efficient-code.md)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-625">For more information about how to use ref structs, see [Write safe and efficient C# code](../../csharp/write-safe-efficient-code.md).</span></span>

### <a name="read-utf-8-text"></a><span data-ttu-id="2f54c-626">读取 UTF-8 文本</span><span class="sxs-lookup"><span data-stu-id="2f54c-626">Read UTF-8 text</span></span>

<span data-ttu-id="2f54c-627">若要在使用 `Utf8JsonReader` 时实现可能的最佳性能，请读取已编码为 UTF-8 文本（而不是 UTF-16 字符串）的 JSON 有效负载。</span><span class="sxs-lookup"><span data-stu-id="2f54c-627">To achieve the best possible performance while using the `Utf8JsonReader`, read JSON payloads already encoded as UTF-8 text rather than as UTF-16 strings.</span></span> <span data-ttu-id="2f54c-628">有关代码示例，请参阅[使用 Utf8JsonReader 筛选数据](write-custom-serializer-deserializer.md#filter-data-using-utf8jsonreader)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-628">For a code example, see [Filter data using Utf8JsonReader](write-custom-serializer-deserializer.md#filter-data-using-utf8jsonreader).</span></span>

### <a name="read-with-a-stream-or-pipereader"></a><span data-ttu-id="2f54c-629">使用流或 PipeReader 进行读取</span><span class="sxs-lookup"><span data-stu-id="2f54c-629">Read with a Stream or PipeReader</span></span>

<span data-ttu-id="2f54c-630">`Utf8JsonReader` 支持从 UTF-8 编码的 [ReadOnlySpan\<byte>](xref:System.ReadOnlySpan%601) 或 [ReadOnlySequence\<byte>](xref:System.Buffers.ReadOnlySequence%601)（这是从 <xref:System.IO.Pipelines.PipeReader> 读取的结果）进行读取。</span><span class="sxs-lookup"><span data-stu-id="2f54c-630">The `Utf8JsonReader` supports reading from a UTF-8 encoded [ReadOnlySpan\<byte>](xref:System.ReadOnlySpan%601) or [ReadOnlySequence\<byte>](xref:System.Buffers.ReadOnlySequence%601) (which is the result of reading from a <xref:System.IO.Pipelines.PipeReader>).</span></span>

<span data-ttu-id="2f54c-631">对于同步读取，可以读取 JSON 有效负载，直到流的末尾进入字节数组中，并将该数组传递给读取器。</span><span class="sxs-lookup"><span data-stu-id="2f54c-631">For synchronous reading, you could read the JSON payload until the end of the stream into a byte array and pass that into the reader.</span></span> <span data-ttu-id="2f54c-632">若要从字符串（编码为 UTF-16）进行读取，请调用 <xref:System.Text.Encoding.UTF8>.<xref:System.Text.Encoding.GetBytes%2A></span><span class="sxs-lookup"><span data-stu-id="2f54c-632">For reading from a string (which is encoded as UTF-16), call <xref:System.Text.Encoding.UTF8>.<xref:System.Text.Encoding.GetBytes%2A></span></span> <span data-ttu-id="2f54c-633">以首先将字符串转码为 UTF-8 编码的字节数组。</span><span class="sxs-lookup"><span data-stu-id="2f54c-633">to first transcode the string to a UTF-8 encoded byte array.</span></span> <span data-ttu-id="2f54c-634">然后将该数组传递给 `Utf8JsonReader`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-634">Then pass that to the `Utf8JsonReader`.</span></span>

<span data-ttu-id="2f54c-635">由于 `Utf8JsonReader` 将输入视为 JSON 文本，因此 UTF-8 字节顺序标记 (BOM) 被视为无效 JSON。</span><span class="sxs-lookup"><span data-stu-id="2f54c-635">Since the `Utf8JsonReader` considers the input to be JSON text, a UTF-8 byte order mark (BOM) is considered invalid JSON.</span></span> <span data-ttu-id="2f54c-636">调用方需要在将数据传递给读取器之前将该标记筛选出来。</span><span class="sxs-lookup"><span data-stu-id="2f54c-636">The caller needs to filter that out before passing the data to the reader.</span></span>

<span data-ttu-id="2f54c-637">有关代码示例，请参阅[使用 Utf8JsonReader](write-custom-serializer-deserializer.md#use-utf8jsonreader)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-637">For code examples, see [Use Utf8JsonReader](write-custom-serializer-deserializer.md#use-utf8jsonreader).</span></span>

### <a name="read-with-multi-segment-readonlysequence"></a><span data-ttu-id="2f54c-638">使用多段 ReadOnlySequence 进行读取</span><span class="sxs-lookup"><span data-stu-id="2f54c-638">Read with multi-segment ReadOnlySequence</span></span>

<span data-ttu-id="2f54c-639">如果 JSON 输入是 [ReadOnlySpan\<byte>](xref:System.ReadOnlySpan%601)，则在运行读取循环时，可以从读取器上的 `ValueSpan` 属性访问每个 JSON 元素。</span><span class="sxs-lookup"><span data-stu-id="2f54c-639">If your JSON input is a [ReadOnlySpan\<byte>](xref:System.ReadOnlySpan%601), each JSON element can be accessed from the `ValueSpan` property on the reader as you go through the read loop.</span></span> <span data-ttu-id="2f54c-640">但是，如果输入是 [ReadOnlySequence\<byte>](xref:System.Buffers.ReadOnlySequence%601)（这是从 <xref:System.IO.Pipelines.PipeReader> 读取的结果），则某些 JSON 元素可能会跨 `ReadOnlySequence<byte>` 对象的多个段。</span><span class="sxs-lookup"><span data-stu-id="2f54c-640">However, if your input is a [ReadOnlySequence\<byte>](xref:System.Buffers.ReadOnlySequence%601) (which is the result of reading from a <xref:System.IO.Pipelines.PipeReader>), some JSON elements might straddle multiple segments of the `ReadOnlySequence<byte>` object.</span></span> <span data-ttu-id="2f54c-641">无法在连续内存块中从 <xref:System.Text.Json.Utf8JsonReader.ValueSpan%2A> 访问这些元素。</span><span class="sxs-lookup"><span data-stu-id="2f54c-641">These elements would not be accessible from <xref:System.Text.Json.Utf8JsonReader.ValueSpan%2A> in a contiguous memory block.</span></span> <span data-ttu-id="2f54c-642">而是在每次将多段 `ReadOnlySequence<byte>` 作为输入时，轮询读取器上的 <xref:System.Text.Json.Utf8JsonReader.HasValueSequence%2A> 属性，以确定如何访问当前 JSON 元素。</span><span class="sxs-lookup"><span data-stu-id="2f54c-642">Instead, whenever you have a multi-segment `ReadOnlySequence<byte>` as input, poll the <xref:System.Text.Json.Utf8JsonReader.HasValueSequence%2A> property on the reader to figure out how to access the current JSON element.</span></span> <span data-ttu-id="2f54c-643">下面是推荐模式：</span><span class="sxs-lookup"><span data-stu-id="2f54c-643">Here's a recommended pattern:</span></span>

```csharp
while (reader.Read())
{
    switch (reader.TokenType)
    {
        // ...
        ReadOnlySpan<byte> jsonElement = reader.HasValueSequence ?
            reader.ValueSequence.ToArray() :
            reader.ValueSpan;
        // ...
    }
}
```

### <a name="use-valuetextequals-for-property-name-lookups"></a><span data-ttu-id="2f54c-644">使用 ValueTextEquals 进行属性名称查找</span><span class="sxs-lookup"><span data-stu-id="2f54c-644">Use ValueTextEquals for property name lookups</span></span>

<span data-ttu-id="2f54c-645">不要使用 <xref:System.Text.Json.Utf8JsonReader.ValueSpan%2A> 通过对属性名称查找调用 <xref:System.MemoryExtensions.SequenceEqual%2A> 来执行逐字节比较。</span><span class="sxs-lookup"><span data-stu-id="2f54c-645">Don't use <xref:System.Text.Json.Utf8JsonReader.ValueSpan%2A> to do byte-by-byte comparisons by calling <xref:System.MemoryExtensions.SequenceEqual%2A> for property name lookups.</span></span> <span data-ttu-id="2f54c-646">改为调用 <xref:System.Text.Json.Utf8JsonReader.ValueTextEquals%2A>，因为该方法会对在 JSON 中转义的任何字符取消转义。</span><span class="sxs-lookup"><span data-stu-id="2f54c-646">Call <xref:System.Text.Json.Utf8JsonReader.ValueTextEquals%2A> instead, because that method unescapes any characters that are escaped in the JSON.</span></span> <span data-ttu-id="2f54c-647">下面的示例演示如何搜索名为“name”的属性：</span><span class="sxs-lookup"><span data-stu-id="2f54c-647">Here's an example that shows how to search for a property that is named "name":</span></span>

:::code language="csharp" source="snippets/system-text-json-how-to/csharp/ValueTextEqualsExample.cs" id="DefineUtf8Var":::

:::code language="csharp" source="snippets/system-text-json-how-to/csharp/ValueTextEqualsExample.cs" id="UseUtf8Var" highlight="9":::

### <a name="read-null-values-into-nullable-value-types"></a><span data-ttu-id="2f54c-648">将 null 值读取到可为 null 的值类型中</span><span class="sxs-lookup"><span data-stu-id="2f54c-648">Read null values into nullable value types</span></span>

<span data-ttu-id="2f54c-649">`Newtonsoft.Json` 提供返回 <xref:System.Nullable%601> 的 API，如 `ReadAsBoolean`（它通过返回 `bool?` 来处理 `Null` `TokenType`）。</span><span class="sxs-lookup"><span data-stu-id="2f54c-649">`Newtonsoft.Json` provides APIs that return <xref:System.Nullable%601>, such as `ReadAsBoolean`, which handles a `Null` `TokenType` for you by returning a `bool?`.</span></span> <span data-ttu-id="2f54c-650">内置 `System.Text.Json` API 仅返回不可为 null 的值类型。</span><span class="sxs-lookup"><span data-stu-id="2f54c-650">The built-in `System.Text.Json` APIs return only non-nullable value types.</span></span> <span data-ttu-id="2f54c-651">例如，<xref:System.Text.Json.Utf8JsonReader.GetBoolean%2A?displayProperty=nameWithType> 返回 `bool`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-651">For example, <xref:System.Text.Json.Utf8JsonReader.GetBoolean%2A?displayProperty=nameWithType> returns a `bool`.</span></span> <span data-ttu-id="2f54c-652">如果它在 JSON 中发现 `Null`，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="2f54c-652">It throws an exception if it finds `Null` in the JSON.</span></span> <span data-ttu-id="2f54c-653">下面的示例演示两种用于处理 null 的方法，一种方法是返回可为 null 的值类型，另一种方法是返回默认值：</span><span class="sxs-lookup"><span data-stu-id="2f54c-653">The following examples show two ways to handle nulls, one by returning a nullable value type and one by returning the default value:</span></span>

```csharp
public bool? ReadAsNullableBoolean()
{
    _reader.Read();
    if (_reader.TokenType == JsonTokenType.Null)
    {
        return null;
    }
    if (_reader.TokenType != JsonTokenType.True && _reader.TokenType != JsonTokenType.False)
    {
        throw new JsonException();
    }
    return _reader.GetBoolean();
}
```

```csharp
public bool ReadAsBoolean(bool defaultValue)
{
    _reader.Read();
    if (_reader.TokenType == JsonTokenType.Null)
    {
        return defaultValue;
    }
    if (_reader.TokenType != JsonTokenType.True && _reader.TokenType != JsonTokenType.False)
    {
        throw new JsonException();
    }
    return _reader.GetBoolean();
}
```

### <a name="multi-targeting"></a><span data-ttu-id="2f54c-654">多目标</span><span class="sxs-lookup"><span data-stu-id="2f54c-654">Multi-targeting</span></span>

<span data-ttu-id="2f54c-655">如果需要继续为某些目标框架使用 `Newtonsoft.Json`，则可以使用多目标，并具有两种实现。</span><span class="sxs-lookup"><span data-stu-id="2f54c-655">If you need to continue to use `Newtonsoft.Json` for certain target frameworks, you can multi-target and have two implementations.</span></span> <span data-ttu-id="2f54c-656">但是，这并非易事，需要进行一些 `#ifdefs` 和源文件复制。</span><span class="sxs-lookup"><span data-stu-id="2f54c-656">However, this is not trivial and would require some `#ifdefs` and source duplication.</span></span> <span data-ttu-id="2f54c-657">共享尽可能多代码的一种方法是围绕 `Utf8JsonReader` 和 `Newtonsoft.Json` `JsonTextReader` 创建 `ref struct` 包装器。</span><span class="sxs-lookup"><span data-stu-id="2f54c-657">One way to share as much code as possible is to create a `ref struct` wrapper around `Utf8JsonReader` and `Newtonsoft.Json` `JsonTextReader`.</span></span> <span data-ttu-id="2f54c-658">此包装器会统一公共外围应用，同时隔离行为差异。</span><span class="sxs-lookup"><span data-stu-id="2f54c-658">This wrapper would unify the public surface area while isolating the behavioral differences.</span></span> <span data-ttu-id="2f54c-659">这使你可以隔离主要对类型的构造进行的更改，以及按引用传递新类型。</span><span class="sxs-lookup"><span data-stu-id="2f54c-659">This lets you isolate the changes mainly to the construction of the type, along with passing the new type around by reference.</span></span> <span data-ttu-id="2f54c-660">下面是 [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/3.1.0/) 库遵循的模式：</span><span class="sxs-lookup"><span data-stu-id="2f54c-660">This is the pattern that the [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/3.1.0/) library follows:</span></span>

* [<span data-ttu-id="2f54c-661">UnifiedJsonReader.JsonTextReader.cs</span><span class="sxs-lookup"><span data-stu-id="2f54c-661">UnifiedJsonReader.JsonTextReader.cs</span></span>](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/installer/managed/Microsoft.Extensions.DependencyModel/UnifiedJsonReader.JsonTextReader.cs)
* [<span data-ttu-id="2f54c-662">UnifiedJsonReader.Utf8JsonReader.cs</span><span class="sxs-lookup"><span data-stu-id="2f54c-662">UnifiedJsonReader.Utf8JsonReader.cs</span></span>](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/installer/managed/Microsoft.Extensions.DependencyModel/UnifiedJsonReader.Utf8JsonReader.cs)

## <a name="utf8jsonwriter-compared-to-jsontextwriter"></a><span data-ttu-id="2f54c-663">Utf8JsonWriter 与 JsonTextWriter 的比较</span><span class="sxs-lookup"><span data-stu-id="2f54c-663">Utf8JsonWriter compared to JsonTextWriter</span></span>

<span data-ttu-id="2f54c-664"><xref:System.Text.Json.Utf8JsonWriter?displayProperty=fullName> 是一种高性能方式，从常见 .NET 类型（例如，`String`、`Int32` 和 `DateTime`）编写 UTF-8 编码的 JSON 文本。</span><span class="sxs-lookup"><span data-stu-id="2f54c-664"><xref:System.Text.Json.Utf8JsonWriter?displayProperty=fullName> is a high-performance way to write UTF-8 encoded JSON text from common .NET types like `String`, `Int32`, and `DateTime`.</span></span> <span data-ttu-id="2f54c-665">该编写器是一种低级类型，可用于生成自定义序列化程序。</span><span class="sxs-lookup"><span data-stu-id="2f54c-665">The writer is a low-level type that can be used to build custom serializers.</span></span>

<span data-ttu-id="2f54c-666">以下各节说明使用 `Utf8JsonWriter` 的推荐编程模式。</span><span class="sxs-lookup"><span data-stu-id="2f54c-666">The following sections explain recommended programming patterns for using `Utf8JsonWriter`.</span></span>

### <a name="write-with-utf-8-text"></a><span data-ttu-id="2f54c-667">使用 UTF-8 文本进行编写</span><span class="sxs-lookup"><span data-stu-id="2f54c-667">Write with UTF-8 text</span></span>

<span data-ttu-id="2f54c-668">若要在使用 `Utf8JsonWriter` 时实现可能的最佳性能，请编写已编码为 UTF-8 文本（而不是 UTF-16 字符串）的 JSON 有效负载。</span><span class="sxs-lookup"><span data-stu-id="2f54c-668">To achieve the best possible performance while using the `Utf8JsonWriter`, write JSON payloads already encoded as UTF-8 text rather than as UTF-16 strings.</span></span> <span data-ttu-id="2f54c-669">使用 <xref:System.Text.Json.JsonEncodedText> 可缓存已知字符串属性名称和值并预先编码为静态，并将这些内容传递给编写器，而不是使用 UTF-16 字符串文本。</span><span class="sxs-lookup"><span data-stu-id="2f54c-669">Use <xref:System.Text.Json.JsonEncodedText> to cache and pre-encode known string property names and values as statics, and pass those to the writer, rather than using UTF-16 string literals.</span></span> <span data-ttu-id="2f54c-670">这比缓存并使用 UTF-8 字节数组更快。</span><span class="sxs-lookup"><span data-stu-id="2f54c-670">This is faster than caching and using UTF-8 byte arrays.</span></span>

<span data-ttu-id="2f54c-671">如果需要进行自定义转义，此方法也适用。</span><span class="sxs-lookup"><span data-stu-id="2f54c-671">This approach also works if you need to do custom escaping.</span></span> <span data-ttu-id="2f54c-672">`System.Text.Json` 不允许在编写字符串时禁用转义。</span><span class="sxs-lookup"><span data-stu-id="2f54c-672">`System.Text.Json` doesn't let you disable escaping while writing a string.</span></span> <span data-ttu-id="2f54c-673">但是，可以将自己的自定义 <xref:System.Text.Encodings.Web.JavaScriptEncoder> 作为一个选项传入编写器，或创建自己的 `JsonEncodedText` 以使用你的 `JavascriptEncoder` 进行转义，然后编写 `JsonEncodedText` 而不是字符串。</span><span class="sxs-lookup"><span data-stu-id="2f54c-673">However, you could pass in your own custom <xref:System.Text.Encodings.Web.JavaScriptEncoder> as an option to the writer, or create your own `JsonEncodedText` that uses your `JavascriptEncoder` to do the escaping, and then write the `JsonEncodedText` instead of the string.</span></span> <span data-ttu-id="2f54c-674">有关详细信息，请参阅[自定义字符编码](system-text-json-character-encoding.md)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-674">For more information, see [Customize character encoding](system-text-json-character-encoding.md).</span></span>

### <a name="write-raw-values"></a><span data-ttu-id="2f54c-675">编写原始值</span><span class="sxs-lookup"><span data-stu-id="2f54c-675">Write raw values</span></span>

<span data-ttu-id="2f54c-676">`Newtonsoft.Json` `WriteRawValue` 方法可编写原始 JSON（其中需要值）。</span><span class="sxs-lookup"><span data-stu-id="2f54c-676">The `Newtonsoft.Json` `WriteRawValue` method writes raw JSON where a value is expected.</span></span> <span data-ttu-id="2f54c-677"><xref:System.Text.Json> 没有直接等效项，但下面是确保仅编写有效 JSON 的解决方法：</span><span class="sxs-lookup"><span data-stu-id="2f54c-677"><xref:System.Text.Json> has no direct equivalent, but here's a workaround that ensures only valid JSON is written:</span></span>

```csharp
using JsonDocument doc = JsonDocument.Parse(string);
doc.WriteTo(writer);
```

### <a name="customize-character-escaping"></a><span data-ttu-id="2f54c-678">自定义字符转义</span><span class="sxs-lookup"><span data-stu-id="2f54c-678">Customize character escaping</span></span>

<span data-ttu-id="2f54c-679">`JsonTextWriter` 的 [StringEscapeHandling](https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_StringEscapeHandling.htm) 设置提供用于转移所有非 ASCII 字符或 HTML 字符的选项。</span><span class="sxs-lookup"><span data-stu-id="2f54c-679">The [StringEscapeHandling](https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_StringEscapeHandling.htm) setting of `JsonTextWriter` offers options to escape all non-ASCII characters **or** HTML characters.</span></span> <span data-ttu-id="2f54c-680">默认情况下，`Utf8JsonWriter` 会转义所有非 ASCII 和 HTML 字符。</span><span class="sxs-lookup"><span data-stu-id="2f54c-680">By default, `Utf8JsonWriter` escapes all non-ASCII **and** HTML characters.</span></span> <span data-ttu-id="2f54c-681">进行此转义是出于深度防御安全原因。</span><span class="sxs-lookup"><span data-stu-id="2f54c-681">This escaping is done for defense-in-depth security reasons.</span></span> <span data-ttu-id="2f54c-682">若要指定不同的转义策略，请创建 <xref:System.Text.Encodings.Web.JavaScriptEncoder> 并设置 <xref:System.Text.Json.JsonWriterOptions.Encoder?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2f54c-682">To specify a different escaping policy, create a <xref:System.Text.Encodings.Web.JavaScriptEncoder> and set <xref:System.Text.Json.JsonWriterOptions.Encoder?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2f54c-683">有关详细信息，请参阅[自定义字符编码](system-text-json-character-encoding.md)。</span><span class="sxs-lookup"><span data-stu-id="2f54c-683">For more information, see [Customize character encoding](system-text-json-character-encoding.md).</span></span>

### <a name="customize-json-format"></a><span data-ttu-id="2f54c-684">自定义 JSON 格式</span><span class="sxs-lookup"><span data-stu-id="2f54c-684">Customize JSON format</span></span>

<span data-ttu-id="2f54c-685">`JsonTextWriter` 包含以下设置（`Utf8JsonWriter` 对于它们没有等效项）：</span><span class="sxs-lookup"><span data-stu-id="2f54c-685">`JsonTextWriter` includes the following settings, for which `Utf8JsonWriter` has no equivalent:</span></span>

* <span data-ttu-id="2f54c-686">[缩进](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_Indentation.htm) - 指定要缩进的字符数。</span><span class="sxs-lookup"><span data-stu-id="2f54c-686">[Indentation](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_Indentation.htm) - Specifies how many characters to indent.</span></span> <span data-ttu-id="2f54c-687">`Utf8JsonWriter` 始终执行 2 字符缩进。</span><span class="sxs-lookup"><span data-stu-id="2f54c-687">`Utf8JsonWriter` always does 2-character indentation.</span></span>
* <span data-ttu-id="2f54c-688">[IndentChar](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_IndentChar.htm) - 指定要用于缩进的字符。</span><span class="sxs-lookup"><span data-stu-id="2f54c-688">[IndentChar](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_IndentChar.htm) - Specifies the character to use for indentation.</span></span>  <span data-ttu-id="2f54c-689">`Utf8JsonWriter` 始终使用空格。</span><span class="sxs-lookup"><span data-stu-id="2f54c-689">`Utf8JsonWriter` always uses whitespace.</span></span>
* <span data-ttu-id="2f54c-690">[QuoteChar](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_QuoteChar.htm) - 指定要用于围绕字符串值的字符。</span><span class="sxs-lookup"><span data-stu-id="2f54c-690">[QuoteChar](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_QuoteChar.htm) - Specifies the character to use to surround string values.</span></span>  <span data-ttu-id="2f54c-691">`Utf8JsonWriter` 始终使用双引号。</span><span class="sxs-lookup"><span data-stu-id="2f54c-691">`Utf8JsonWriter` always uses double quotes.</span></span>
* <span data-ttu-id="2f54c-692">[QuoteName](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_QuoteName.htm) - 指定是否要使用引号围绕属性名称。</span><span class="sxs-lookup"><span data-stu-id="2f54c-692">[QuoteName](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_QuoteName.htm) - Specifies whether or not to surround property names with quotes.</span></span>  <span data-ttu-id="2f54c-693">`Utf8JsonWriter` 始终使用引号围绕它们。</span><span class="sxs-lookup"><span data-stu-id="2f54c-693">`Utf8JsonWriter` always surrounds them with quotes.</span></span>

<span data-ttu-id="2f54c-694">没有解决方法可让你自定义 `Utf8JsonWriter` 以这些方式生成的 JSON。</span><span class="sxs-lookup"><span data-stu-id="2f54c-694">There are no workarounds that would let you customize the JSON produced by `Utf8JsonWriter` in these ways.</span></span>

### <a name="write-null-values"></a><span data-ttu-id="2f54c-695">编写 null 值</span><span class="sxs-lookup"><span data-stu-id="2f54c-695">Write null values</span></span>

<span data-ttu-id="2f54c-696">若要使用 `Utf8JsonWriter` 编写 null 值，请调用：</span><span class="sxs-lookup"><span data-stu-id="2f54c-696">To write null values by using `Utf8JsonWriter`, call:</span></span>

* <span data-ttu-id="2f54c-697"><xref:System.Text.Json.Utf8JsonWriter.WriteNull%2A>，用于将具有 null 的键值对编写为值。</span><span class="sxs-lookup"><span data-stu-id="2f54c-697"><xref:System.Text.Json.Utf8JsonWriter.WriteNull%2A> to write a key-value pair with null as the value.</span></span>
* <span data-ttu-id="2f54c-698"><xref:System.Text.Json.Utf8JsonWriter.WriteNullValue%2A>用于将 null 编写为 JSON 数组的元素。</span><span class="sxs-lookup"><span data-stu-id="2f54c-698"><xref:System.Text.Json.Utf8JsonWriter.WriteNullValue%2A> to write null as an element of a JSON array.</span></span>

<span data-ttu-id="2f54c-699">对于字符串属性，如果字符串为 null，则 <xref:System.Text.Json.Utf8JsonWriter.WriteString%2A> 和 <xref:System.Text.Json.Utf8JsonWriter.WriteStringValue%2A> 等效于 `WriteNull` 和 `WriteNullValue`。</span><span class="sxs-lookup"><span data-stu-id="2f54c-699">For a string property, if the string is null, <xref:System.Text.Json.Utf8JsonWriter.WriteString%2A> and <xref:System.Text.Json.Utf8JsonWriter.WriteStringValue%2A> are equivalent to `WriteNull` and `WriteNullValue`.</span></span>

### <a name="write-timespan-uri-or-char-values"></a><span data-ttu-id="2f54c-700">编写 Timespan、Uri 或 char 值</span><span class="sxs-lookup"><span data-stu-id="2f54c-700">Write Timespan, Uri, or char values</span></span>

<span data-ttu-id="2f54c-701">`JsonTextWriter` 提供 `WriteValue` 方法以用于 [TimeSpan](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_JsonTextWriter_WriteValue_18.htm)、[Uri](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_JsonTextWriter_WriteValue_22.htm) 和 [char](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_JsonTextWriter_WriteValue_3.htm) 值。</span><span class="sxs-lookup"><span data-stu-id="2f54c-701">`JsonTextWriter` provides `WriteValue` methods for [TimeSpan](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_JsonTextWriter_WriteValue_18.htm), [Uri](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_JsonTextWriter_WriteValue_22.htm), and [char](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_JsonTextWriter_WriteValue_3.htm) values.</span></span> <span data-ttu-id="2f54c-702">`Utf8JsonWriter` 没有等效方法。</span><span class="sxs-lookup"><span data-stu-id="2f54c-702">`Utf8JsonWriter` doesn't have equivalent methods.</span></span> <span data-ttu-id="2f54c-703">而是将这些值格式化为字符串（例如，通过调用 `ToString()`）并调用 <xref:System.Text.Json.Utf8JsonWriter.WriteStringValue%2A>。</span><span class="sxs-lookup"><span data-stu-id="2f54c-703">Instead, format these values as strings (by calling `ToString()`, for example) and call <xref:System.Text.Json.Utf8JsonWriter.WriteStringValue%2A>.</span></span>

### <a name="multi-targeting"></a><span data-ttu-id="2f54c-704">多目标</span><span class="sxs-lookup"><span data-stu-id="2f54c-704">Multi-targeting</span></span>

<span data-ttu-id="2f54c-705">如果需要继续为某些目标框架使用 `Newtonsoft.Json`，则可以使用多目标，并具有两种实现。</span><span class="sxs-lookup"><span data-stu-id="2f54c-705">If you need to continue to use `Newtonsoft.Json` for certain target frameworks, you can multi-target and have two implementations.</span></span> <span data-ttu-id="2f54c-706">但是，这并非易事，需要进行一些 `#ifdefs` 和源文件复制。</span><span class="sxs-lookup"><span data-stu-id="2f54c-706">However, this is not trivial and would require some `#ifdefs` and source duplication.</span></span> <span data-ttu-id="2f54c-707">共享尽可能多代码的一种方法是围绕 `Utf8JsonWriter` 和 `Newtonsoft` `JsonTextWriter` 创建包装器。</span><span class="sxs-lookup"><span data-stu-id="2f54c-707">One way to share as much code as possible is to create a wrapper around `Utf8JsonWriter` and `Newtonsoft` `JsonTextWriter`.</span></span> <span data-ttu-id="2f54c-708">此包装器会统一公共外围应用，同时隔离行为差异。</span><span class="sxs-lookup"><span data-stu-id="2f54c-708">This wrapper would unify the public surface area while isolating the behavioral differences.</span></span> <span data-ttu-id="2f54c-709">这使你可以隔离主要对类型的构造进行的更改。</span><span class="sxs-lookup"><span data-stu-id="2f54c-709">This lets you isolate the changes mainly to the construction of the type.</span></span> <span data-ttu-id="2f54c-710">[Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/3.1.0/) 库遵循：</span><span class="sxs-lookup"><span data-stu-id="2f54c-710">[Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/3.1.0/) library follows:</span></span>

* [<span data-ttu-id="2f54c-711">UnifiedJsonWriter.JsonTextWriter.cs</span><span class="sxs-lookup"><span data-stu-id="2f54c-711">UnifiedJsonWriter.JsonTextWriter.cs</span></span>](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/installer/managed/Microsoft.Extensions.DependencyModel/UnifiedJsonWriter.JsonTextWriter.cs)
* [<span data-ttu-id="2f54c-712">UnifiedJsonWriter.Utf8JsonWriter.cs</span><span class="sxs-lookup"><span data-stu-id="2f54c-712">UnifiedJsonWriter.Utf8JsonWriter.cs</span></span>](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/installer/managed/Microsoft.Extensions.DependencyModel/UnifiedJsonWriter.Utf8JsonWriter.cs)

## <a name="additional-resources"></a><span data-ttu-id="2f54c-713">其他资源</span><span class="sxs-lookup"><span data-stu-id="2f54c-713">Additional resources</span></span>

<!-- * [System.Text.Json roadmap](https://github.com/dotnet/runtime/blob/81bf79fd9aa75305e55abe2f7e9ef3f60624a3a1/src/libraries/System.Text.Json/roadmap/README.md)[Restore this when the roadmap is updated.]-->
* [<span data-ttu-id="2f54c-714">System.Text.Json 概述</span><span class="sxs-lookup"><span data-stu-id="2f54c-714">System.Text.Json overview</span></span>](system-text-json-overview.md)
* [<span data-ttu-id="2f54c-715">如何使用 System.Text.Json</span><span class="sxs-lookup"><span data-stu-id="2f54c-715">How to use System.Text.Json</span></span>](system-text-json-how-to.md)
* [<span data-ttu-id="2f54c-716">如何编写自定义转换器</span><span class="sxs-lookup"><span data-stu-id="2f54c-716">How to write custom converters</span></span>](system-text-json-converters-how-to.md)
* [<span data-ttu-id="2f54c-717">System.Text.Json 中的 DateTime 和 DateTimeOffset 支持</span><span class="sxs-lookup"><span data-stu-id="2f54c-717">DateTime and DateTimeOffset support in System.Text.Json</span></span>](../datetime/system-text-json-support.md)
* <span data-ttu-id="2f54c-718">[System.Text.Json API 参考](xref:System.Text.Json)</span><span class="sxs-lookup"><span data-stu-id="2f54c-718">[System.Text.Json API reference](xref:System.Text.Json)</span></span>
* <span data-ttu-id="2f54c-719">[System.Text.Json.Serialization API 参考](xref:System.Text.Json.Serialization)</span><span class="sxs-lookup"><span data-stu-id="2f54c-719">[System.Text.Json.Serialization API reference](xref:System.Text.Json.Serialization)</span></span>
