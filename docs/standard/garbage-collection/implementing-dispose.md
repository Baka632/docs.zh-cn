---
title: 实现 Dispose 方法
description: 本文介绍如何实现 Dispose 方法，该方法用于释放 .NET 中的代码使用的非托管资源。
ms.date: 09/08/2020
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
ms.openlocfilehash: ec731ff4c1020100c2b7ff5041d42291141a5209
ms.sourcegitcommit: 6d1ae17e60384f3b5953ca7b45ac859ec6d4c3a0
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/20/2020
ms.locfileid: "94982402"
---
# <a name="implement-a-dispose-method"></a><span data-ttu-id="5a732-103">实现 Dispose 方法</span><span class="sxs-lookup"><span data-stu-id="5a732-103">Implement a Dispose method</span></span>

<span data-ttu-id="5a732-104">实现 <xref:System.IDisposable.Dispose%2A> 方法主要用于释放非托管资源。</span><span class="sxs-lookup"><span data-stu-id="5a732-104">Implementing the <xref:System.IDisposable.Dispose%2A> method is primarily for releasing unmanaged resources.</span></span> <span data-ttu-id="5a732-105">处理 <xref:System.IDisposable> 实现的实例成员时，通常会级联 <xref:System.IDisposable.Dispose%2A> 调用。</span><span class="sxs-lookup"><span data-stu-id="5a732-105">When working with instance members that are <xref:System.IDisposable> implementations, it's common to cascade <xref:System.IDisposable.Dispose%2A> calls.</span></span> <span data-ttu-id="5a732-106">实现 <xref:System.IDisposable.Dispose%2A> 有其他原因，例如，为了释放已分配的内存、删除已添加到集合中的项，或发出释放已获取的锁的信号。</span><span class="sxs-lookup"><span data-stu-id="5a732-106">There are additional reasons for implementing <xref:System.IDisposable.Dispose%2A>, for example, to free memory that was allocated, remove an item that was added to a collection, or signal the release of a lock that was acquired.</span></span>

<span data-ttu-id="5a732-107">[.NET 垃圾回收器](index.md)不会分配或释放非托管内存。</span><span class="sxs-lookup"><span data-stu-id="5a732-107">The [.NET garbage collector](index.md) does not allocate or release unmanaged memory.</span></span> <span data-ttu-id="5a732-108">对象释放模式（称为“释放模式”）会对对象生存期强制施加顺序。</span><span class="sxs-lookup"><span data-stu-id="5a732-108">The pattern for disposing an object, referred to as the dispose pattern, imposes order on the lifetime of an object.</span></span> <span data-ttu-id="5a732-109">释放模式用于实现 <xref:System.IDisposable> 接口的对象，在与文件和管道句柄、注册表句柄、等待句柄或指向非托管内存块的指针交互时较为常见。</span><span class="sxs-lookup"><span data-stu-id="5a732-109">The dispose pattern is used for objects that implement the <xref:System.IDisposable> interface, and is common when interacting with file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="5a732-110">这是因为垃圾回收器无法回收非托管对象。</span><span class="sxs-lookup"><span data-stu-id="5a732-110">This is because the garbage collector is unable to reclaim unmanaged objects.</span></span>

<span data-ttu-id="5a732-111">若要帮助确保始终适当地清理资源，<xref:System.IDisposable.Dispose%2A> 方法应为幂等，这样可以多次调用而不引发异常。</span><span class="sxs-lookup"><span data-stu-id="5a732-111">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be idempotent, such that it is callable multiple times without throwing an exception.</span></span> <span data-ttu-id="5a732-112">此外，<xref:System.IDisposable.Dispose%2A> 的后续调用不应执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="5a732-112">Furthermore, subsequent invocations of <xref:System.IDisposable.Dispose%2A> should do nothing.</span></span>

<span data-ttu-id="5a732-113">为 <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> 方法提供的代码示例演示了垃圾回收如何引起终结器运行，而对该对象或其成员的非托管引用仍在使用中。</span><span class="sxs-lookup"><span data-stu-id="5a732-113">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how garbage collection can cause a finalizer to run, while an unmanaged reference to the object or its members is still in use.</span></span> <span data-ttu-id="5a732-114">利用 <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType>使对象从当前例程开始到调用此方法的那一刻为止都不适合进行垃圾回收，这是可行的。</span><span class="sxs-lookup"><span data-stu-id="5a732-114">It may make sense to utilize <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> to make the object ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span>

## <a name="safe-handles"></a><span data-ttu-id="5a732-115">安全句柄</span><span class="sxs-lookup"><span data-stu-id="5a732-115">Safe handles</span></span>

<span data-ttu-id="5a732-116">编写对象终结器的代码是一项复杂的任务，如果处理不好可能会出现问题。</span><span class="sxs-lookup"><span data-stu-id="5a732-116">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="5a732-117">因此，建议你构造 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> 对象，而非实现终结器。</span><span class="sxs-lookup"><span data-stu-id="5a732-117">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>

<span data-ttu-id="5a732-118"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> 是一种抽象托管类型，该类型包装了可标识非托管资源的 <xref:System.IntPtr?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5a732-118">A <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract managed type that wraps an <xref:System.IntPtr?displayProperty=nameWithType> that identifies an unmanaged resource.</span></span> <span data-ttu-id="5a732-119">在 Windows 上，它可能标识一个句柄，而在 Unix 上则可能标识一个文件描述符。</span><span class="sxs-lookup"><span data-stu-id="5a732-119">On Windows it might identify a handle while on Unix, a file descriptor.</span></span> <span data-ttu-id="5a732-120">它提供了所有必要的逻辑，以确保在处理 `SafeHandle` 或删除对 `SafeHandle` 的所有引用并最终完成 `SafeHandle` 实例时，只释放该资源一次。</span><span class="sxs-lookup"><span data-stu-id="5a732-120">It provides all of the logic necessary to ensure that this resource is released once and only once, when the `SafeHandle` is disposed of or when all references to the `SafeHandle` have been dropped and the `SafeHandle` instance is finalized.</span></span>

<span data-ttu-id="5a732-121"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> 是抽象基类。</span><span class="sxs-lookup"><span data-stu-id="5a732-121">The <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract base class.</span></span> <span data-ttu-id="5a732-122">派生类会为不同类型的句柄提供特定实例。</span><span class="sxs-lookup"><span data-stu-id="5a732-122">Derived classes provide specific instances for different kinds of handle.</span></span> <span data-ttu-id="5a732-123">这些派生类可验证 <xref:System.IntPtr?displayProperty=nameWithType> 的哪些值被视为无效，以及如何实际释放句柄。</span><span class="sxs-lookup"><span data-stu-id="5a732-123">These derived classes validate what values for the <xref:System.IntPtr?displayProperty=nameWithType> are considered invalid and how to actually free the handle.</span></span> <span data-ttu-id="5a732-124">例如，<xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 派生自 `SafeHandle` 以包装可标识打开的文件句柄/描述符的 `IntPtrs`，并重写其 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> 方法来关闭它（通过 Unix 上的 `close` 函数或 Windows 上的 `CloseHandle` 函数）。</span><span class="sxs-lookup"><span data-stu-id="5a732-124">For example, <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> derives from `SafeHandle` to wrap `IntPtrs` that identify open file handles/descriptors, and overrides its <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> method to close it (via the `close` function on Unix or `CloseHandle` function on Windows).</span></span> <span data-ttu-id="5a732-125">.NET 库中创建非托管资源的大多数 API 会将其包装在 `SafeHandle` 中，并根据需要返回此 `SafeHandle`，而不是返回原始指针。</span><span class="sxs-lookup"><span data-stu-id="5a732-125">Most APIs in .NET libraries that create an unmanaged resource will wrap it in a `SafeHandle` and return that `SafeHandle` to you as needed, rather than handing back the raw pointer.</span></span> <span data-ttu-id="5a732-126">在与非托管组件进行交互并获取非托管资源的 `IntPtr` 的情况下，你可以创建自己的 `SafeHandle` 类型进行包装。</span><span class="sxs-lookup"><span data-stu-id="5a732-126">In situations where you interact with an unmanaged component and get an `IntPtr` for an unmanaged resource, you can create your own `SafeHandle` type to wrap it.</span></span> <span data-ttu-id="5a732-127">因此，极少数非 `SafeHandle` 类型需要实现终结器；大多数可释放模式实现最终只包装其他受管理资源，其中某些资源可能是 `SafeHandle`。</span><span class="sxs-lookup"><span data-stu-id="5a732-127">As a result, few non-`SafeHandle` types need to implement finalizers; most disposable pattern implementations only end up wrapping other managed resources, some of which may be `SafeHandle`s.</span></span>

<span data-ttu-id="5a732-128"><xref:Microsoft.Win32.SafeHandles> 命名空间中的以下派生类提供安全句柄：</span><span class="sxs-lookup"><span data-stu-id="5a732-128">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>

- <span data-ttu-id="5a732-129">用于文件、内存映射文件和管道的 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>、<xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> 和 <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> 类。</span><span class="sxs-lookup"><span data-stu-id="5a732-129">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>
- <span data-ttu-id="5a732-130">用于内存视图的 <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> 类。</span><span class="sxs-lookup"><span data-stu-id="5a732-130">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>
- <span data-ttu-id="5a732-131">用于加密构造的 <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>、<xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle> 和 <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> 类。</span><span class="sxs-lookup"><span data-stu-id="5a732-131">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>
- <span data-ttu-id="5a732-132">用于注册表项的 <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 类。</span><span class="sxs-lookup"><span data-stu-id="5a732-132">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>
- <span data-ttu-id="5a732-133">用于等待句柄的 <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 类。</span><span class="sxs-lookup"><span data-stu-id="5a732-133">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>

## <a name="dispose-and-disposebool"></a><span data-ttu-id="5a732-134">Dispose() 和 Dispose(bool)</span><span class="sxs-lookup"><span data-stu-id="5a732-134">Dispose() and Dispose(bool)</span></span>

<span data-ttu-id="5a732-135"><xref:System.IDisposable> 接口需要实现单个无参数的方法 <xref:System.IDisposable.Dispose%2A>。</span><span class="sxs-lookup"><span data-stu-id="5a732-135">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="5a732-136">此外，任何非密封类都应具有要实现的附加 `Dispose(bool)` 重载方法：</span><span class="sxs-lookup"><span data-stu-id="5a732-136">Also, any non-sealed class should have an additional `Dispose(bool)` overload method to be implemented:</span></span>

- <span data-ttu-id="5a732-137">一种没有参数的 `public` 非虚拟的（Visual Basic 中的 `NonInheritable`）<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 实现。</span><span class="sxs-lookup"><span data-stu-id="5a732-137">A `public` non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>

- <span data-ttu-id="5a732-138">`protected virtual`（Visual Basic 中为 `Overridable`）`Dispose` 方法，其签名为：</span><span class="sxs-lookup"><span data-stu-id="5a732-138">A `protected virtual` (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>

  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]

  > [!IMPORTANT]
  > <span data-ttu-id="5a732-139">从终结器调用时，`disposing` 参数应为 `false`，从 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 方法调用时应为 `true`。</span><span class="sxs-lookup"><span data-stu-id="5a732-139">The `disposing` parameter should be `false` when called from a finalizer, and `true` when called from the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5a732-140">换言之，确定情况下调用时为 `true`，而在不确定情况下调用时为 `false`。</span><span class="sxs-lookup"><span data-stu-id="5a732-140">In other words, it is `true` when deterministically called and `false` when non-deterministically called.</span></span>

### <a name="the-dispose-method"></a><span data-ttu-id="5a732-141">Dispose() 方法</span><span class="sxs-lookup"><span data-stu-id="5a732-141">The Dispose() method</span></span>

<span data-ttu-id="5a732-142">由于 `public`、非虚拟（Visual Basic 中为 `NonInheritable`）、无参数的 `Dispose` 方法由该类型的使用者调用，因此其用途是释放非托管资源，执行常规清理，以及指示终结器（如果存在）不必运行。</span><span class="sxs-lookup"><span data-stu-id="5a732-142">Because the `public`, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources, perform general cleanup, and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="5a732-143">释放与托管对象关联的实际内存始终是[垃圾回收器](index.md)的域。</span><span class="sxs-lookup"><span data-stu-id="5a732-143">Freeing the actual memory associated with a managed object is always the domain of the [garbage collector](index.md).</span></span> <span data-ttu-id="5a732-144">因此，它具有标准实现：</span><span class="sxs-lookup"><span data-stu-id="5a732-144">Because of this, it has a standard implementation:</span></span>

[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]

<span data-ttu-id="5a732-145">`Dispose` 方法执行所有对象清理，使垃圾回收器不再需要调用对象的 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 重写。</span><span class="sxs-lookup"><span data-stu-id="5a732-145">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="5a732-146">因此，调用 <xref:System.GC.SuppressFinalize%2A> 方法会阻止垃圾回收器运行终结器。</span><span class="sxs-lookup"><span data-stu-id="5a732-146">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="5a732-147">如果类型没有终结器，则对 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 的调用不起作用。</span><span class="sxs-lookup"><span data-stu-id="5a732-147">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="5a732-148">请注意，实际清除由 `Dispose(bool)` 方法重载执行。</span><span class="sxs-lookup"><span data-stu-id="5a732-148">Note that the actual cleanup is performed by the `Dispose(bool)` method overload.</span></span>

### <a name="the-disposebool-method-overload"></a><span data-ttu-id="5a732-149">Dispose(bool) 方法重载</span><span class="sxs-lookup"><span data-stu-id="5a732-149">The Dispose(bool) method overload</span></span>

<span data-ttu-id="5a732-150">在重载中，`disposing` 参数是一个 <xref:System.Boolean>，它指示方法调用是来自 <xref:System.IDisposable.Dispose%2A> 方法（其值为 `true`）还是来自终结器（其值为 `false`）。</span><span class="sxs-lookup"><span data-stu-id="5a732-150">In the overload, the `disposing` parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>

<span data-ttu-id="5a732-151">方法的主体包含两个代码块：</span><span class="sxs-lookup"><span data-stu-id="5a732-151">The body of the method consists of two blocks of code:</span></span>

- <span data-ttu-id="5a732-152">释放非托管资源的块。</span><span class="sxs-lookup"><span data-stu-id="5a732-152">A block that frees unmanaged resources.</span></span> <span data-ttu-id="5a732-153">无论 `disposing` 参数的值如何，都会执行此块。</span><span class="sxs-lookup"><span data-stu-id="5a732-153">This block executes regardless of the value of the `disposing` parameter.</span></span>
- <span data-ttu-id="5a732-154">释放托管资源的条件块。</span><span class="sxs-lookup"><span data-stu-id="5a732-154">A conditional block that frees managed resources.</span></span> <span data-ttu-id="5a732-155">如果 `disposing` 的值为 `true`，则执行此块。</span><span class="sxs-lookup"><span data-stu-id="5a732-155">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="5a732-156">它释放的托管资源可包括：</span><span class="sxs-lookup"><span data-stu-id="5a732-156">The managed resources that it frees can include:</span></span>

  - <span data-ttu-id="5a732-157">**实现 <xref:System.IDisposable> 的托管对象。**</span><span class="sxs-lookup"><span data-stu-id="5a732-157">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="5a732-158">可用于调用其 <xref:System.IDisposable.Dispose%2A> 实现（级联释放）的条件块。</span><span class="sxs-lookup"><span data-stu-id="5a732-158">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation (cascade dispose).</span></span> <span data-ttu-id="5a732-159">如果你已使用 <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> 的派生类来包装非托管资源，则应在此处调用 <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> 实现。</span><span class="sxs-lookup"><span data-stu-id="5a732-159">If you have used a derived class of <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> implementation here.</span></span>

  - <span data-ttu-id="5a732-160">**占用大量内存或使用短缺资源的托管对象。**</span><span class="sxs-lookup"><span data-stu-id="5a732-160">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="5a732-161">将大型托管对象引用分配到 `null`，使它们更有可能无法访问。</span><span class="sxs-lookup"><span data-stu-id="5a732-161">Assign large managed object references to `null` to make them more likely to be unreachable.</span></span> <span data-ttu-id="5a732-162">相比以非确定性方式回收它们，这样做释放的速度更快，此操作通常在条件块之外完成。</span><span class="sxs-lookup"><span data-stu-id="5a732-162">This releases them faster than if they were reclaimed non-deterministically, and this is usually done outside of the conditional block.</span></span>

<span data-ttu-id="5a732-163">如果方法调用来自终结器，则应仅执行释放非托管资源的代码。</span><span class="sxs-lookup"><span data-stu-id="5a732-163">If the method call comes from a finalizer, only the code that frees unmanaged resources should execute.</span></span> <span data-ttu-id="5a732-164">实施者负责确保假路径不会与可能已被回收的托管对象交互。</span><span class="sxs-lookup"><span data-stu-id="5a732-164">The implementer is responsible for ensuring that the false path doesn't interact with managed objects that may have been reclaimed.</span></span> <span data-ttu-id="5a732-165">这一点很重要，因为垃圾回收器在终止期间销毁托管对象的顺序是不确定的。</span><span class="sxs-lookup"><span data-stu-id="5a732-165">This is important because the order in which the garbage collector destroys managed objects during finalization is non-deterministic.</span></span>

## <a name="cascade-dispose-calls"></a><span data-ttu-id="5a732-166">级联释放调用</span><span class="sxs-lookup"><span data-stu-id="5a732-166">Cascade dispose calls</span></span>

<span data-ttu-id="5a732-167">如果你的类拥有一个字段或属性，并且其类型实现 <xref:System.IDisposable>，则包含类本身还应实现 <xref:System.IDisposable>。</span><span class="sxs-lookup"><span data-stu-id="5a732-167">If your class owns a field or property, and its type implements <xref:System.IDisposable>, the containing class itself should also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="5a732-168">实例化 <xref:System.IDisposable> 实现并将其存储为实例成员的类，也负责清理。</span><span class="sxs-lookup"><span data-stu-id="5a732-168">A class that instantiates an <xref:System.IDisposable> implementation and storing it as an instance member, is also responsible for its cleanup.</span></span> <span data-ttu-id="5a732-169">这是为了帮助确保引用的可释放类型可通过 <xref:System.IDisposable.Dispose%2A> 方法明确执行清理。</span><span class="sxs-lookup"><span data-stu-id="5a732-169">This is to help ensure that the referenced disposable types are given the opportunity to deterministically perform clean up through the <xref:System.IDisposable.Dispose%2A> method.</span></span> <span data-ttu-id="5a732-170">在本例中，类为 `sealed`（Visual Basic 中为 `NotInheritable`）。</span><span class="sxs-lookup"><span data-stu-id="5a732-170">In this example, the class is `sealed` (or `NotInheritable` in Visual Basic).</span></span>

[!code-csharp[Conceptual.Disposable#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/disposable1.cs#1)]
[!code-vb[Conceptual.Disposable#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/disposable1.vb#1)]

## <a name="implement-the-dispose-pattern"></a><span data-ttu-id="5a732-171">实现释放模式</span><span class="sxs-lookup"><span data-stu-id="5a732-171">Implement the dispose pattern</span></span>

<span data-ttu-id="5a732-172">所有非密封类或（未修改为 `NotInheritable` 的 Visual Basic 类）都应被视为潜在的基类，因为它们可以被继承。</span><span class="sxs-lookup"><span data-stu-id="5a732-172">All non-sealed classes or (Visual Basic classes not modified as `NotInheritable`) should be considered a potential base class, because they could be inherited.</span></span> <span data-ttu-id="5a732-173">如果为任何潜在基类实现释放模式，则必须提供以下内容：</span><span class="sxs-lookup"><span data-stu-id="5a732-173">If you implement the dispose pattern for any potential base class, you must provide the following:</span></span>

- <span data-ttu-id="5a732-174">调用 <xref:System.IDisposable.Dispose%2A> 方法的 `Dispose(bool)` 实现。</span><span class="sxs-lookup"><span data-stu-id="5a732-174">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(bool)` method.</span></span>
- <span data-ttu-id="5a732-175">执行实际清理的 `Dispose(bool)` 方法。</span><span class="sxs-lookup"><span data-stu-id="5a732-175">A `Dispose(bool)` method that performs the actual cleanup.</span></span>
- <span data-ttu-id="5a732-176">从包装非托管资源的 <xref:System.Runtime.InteropServices.SafeHandle> 派生的类（推荐），或对 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 方法的重写。</span><span class="sxs-lookup"><span data-stu-id="5a732-176">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5a732-177"><xref:System.Runtime.InteropServices.SafeHandle> 类提供了终结器，因此你无需自行编写。</span><span class="sxs-lookup"><span data-stu-id="5a732-177">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer, so you do not have to write one yourself.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a732-178">基类可以只引用托管对象，并实现释放模式。</span><span class="sxs-lookup"><span data-stu-id="5a732-178">It is possible for a base class to only reference managed objects, and implement the dispose pattern.</span></span> <span data-ttu-id="5a732-179">在这些情况下，不需要终结器。</span><span class="sxs-lookup"><span data-stu-id="5a732-179">In these cases, a finalizer is unnecessary.</span></span> <span data-ttu-id="5a732-180">仅当直接引用非托管资源时，才需要终结器。</span><span class="sxs-lookup"><span data-stu-id="5a732-180">A finalizer is only required if you directly reference unmanaged resources.</span></span>

<span data-ttu-id="5a732-181">以下是一个常规模式，用于实现使用安全句柄的基类的释放模式：</span><span class="sxs-lookup"><span data-stu-id="5a732-181">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>

[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]

> [!NOTE]
> <span data-ttu-id="5a732-182">上一个示例使用 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 对象阐释模式；可以使用派生自 <xref:System.Runtime.InteropServices.SafeHandle> 的任何对象来替代。</span><span class="sxs-lookup"><span data-stu-id="5a732-182">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="5a732-183">请注意，该示例不会正确实例化其 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 对象。</span><span class="sxs-lookup"><span data-stu-id="5a732-183">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="5a732-184">以下是一个常规模式，用于实现重写 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 的基类的释放模式。</span><span class="sxs-lookup"><span data-stu-id="5a732-184">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>

[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]

> [!TIP]
> <span data-ttu-id="5a732-185">在 C# 中，通过重写 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 创建一个[终结器](../../csharp/programming-guide/classes-and-structs/destructors.md)。</span><span class="sxs-lookup"><span data-stu-id="5a732-185">In C#, you create a [finalizer](../../csharp/programming-guide/classes-and-structs/destructors.md) by overriding <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5a732-186">在 Visual Basic 中，这是通过 `Protected Overrides Sub Finalize()` 完成的。</span><span class="sxs-lookup"><span data-stu-id="5a732-186">In Visual Basic, this is done with `Protected Overrides Sub Finalize()`.</span></span>

## <a name="implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="5a732-187">实现派生类的释放模式</span><span class="sxs-lookup"><span data-stu-id="5a732-187">Implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="5a732-188">从实现 <xref:System.IDisposable> 接口的类派生的类不应实现 <xref:System.IDisposable>，因为 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 的基类实现由其派生类继承。</span><span class="sxs-lookup"><span data-stu-id="5a732-188">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="5a732-189">若要清理派生类，请提供以下内容：</span><span class="sxs-lookup"><span data-stu-id="5a732-189">Instead, to cleanup a derived class, you provide the following:</span></span>

- <span data-ttu-id="5a732-190">`protected override void Dispose(bool)` 方法，用于替代基类方法并执行派生类的实际清理。</span><span class="sxs-lookup"><span data-stu-id="5a732-190">A `protected override void Dispose(bool)` method that overrides the base class method and performs the actual cleanup of the derived class.</span></span> <span data-ttu-id="5a732-191">此方法还必须调用基类的 `base.Dispose(bool)`（Visual Basic 中为 `MyBase.Dispose(bool)`）方法，并传递参数的释放状态。</span><span class="sxs-lookup"><span data-stu-id="5a732-191">This method must also call the `base.Dispose(bool)` (`MyBase.Dispose(bool)` in Visual Basic) method of the base class and pass its disposing status for the argument.</span></span>
- <span data-ttu-id="5a732-192">从包装非托管资源的 <xref:System.Runtime.InteropServices.SafeHandle> 派生的类（推荐），或对 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 方法的重写。</span><span class="sxs-lookup"><span data-stu-id="5a732-192">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5a732-193"><xref:System.Runtime.InteropServices.SafeHandle> 类提供了一个使你无需编写代码的终结器。</span><span class="sxs-lookup"><span data-stu-id="5a732-193">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="5a732-194">如果你提供了终结器，它必须调用 `disposing` 参数为 `false` 的 `Dispose(bool)` 重载。</span><span class="sxs-lookup"><span data-stu-id="5a732-194">If you do provide a finalizer, it must call the `Dispose(bool)` overload with a `disposing` argument of `false`.</span></span>

<span data-ttu-id="5a732-195">以下是一个常规模式，用于实现使用安全句柄的派生类的释放模式：</span><span class="sxs-lookup"><span data-stu-id="5a732-195">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>

[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]

> [!NOTE]
> <span data-ttu-id="5a732-196">上一个示例使用 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 对象阐释模式；可以使用派生自 <xref:System.Runtime.InteropServices.SafeHandle> 的任何对象来替代。</span><span class="sxs-lookup"><span data-stu-id="5a732-196">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="5a732-197">请注意，该示例不会正确实例化其 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 对象。</span><span class="sxs-lookup"><span data-stu-id="5a732-197">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="5a732-198">以下是一个常规模式，用于实现重写 <xref:System.Object.Finalize%2A?displayProperty=nameWithType> 的派生类的释放模式：</span><span class="sxs-lookup"><span data-stu-id="5a732-198">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>

[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]

## <a name="implement-the-dispose-pattern-with-safe-handles"></a><span data-ttu-id="5a732-199">使用安全句柄实现释放模式</span><span class="sxs-lookup"><span data-stu-id="5a732-199">Implement the dispose pattern with safe handles</span></span>

<span data-ttu-id="5a732-200">下面的示例阐释了基类 `DisposableStreamResource` 的释放模式，此模式使用安全句柄封装非托管资源。</span><span class="sxs-lookup"><span data-stu-id="5a732-200">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="5a732-201">它定义 `DisposableStreamResource` 类，该类使用 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 包装表示打开的文件的 <xref:System.IO.Stream> 对象。</span><span class="sxs-lookup"><span data-stu-id="5a732-201">It defines a `DisposableStreamResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="5a732-202">此类还包含一个属性 `Size`，该属性返回文件流中的总字节数。</span><span class="sxs-lookup"><span data-stu-id="5a732-202">The class also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>

[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]

## <a name="implement-the-dispose-pattern-for-a-derived-class-with-safe-handles"></a><span data-ttu-id="5a732-203">使用安全句柄实现派生类的释放模式</span><span class="sxs-lookup"><span data-stu-id="5a732-203">Implement the dispose pattern for a derived class with safe handles</span></span>

<span data-ttu-id="5a732-204">下面的示例阐释派生类 `DisposableStreamResource2` 的释放模式，该类继承自上一个示例中显示的 `DisposableStreamResource` 类。</span><span class="sxs-lookup"><span data-stu-id="5a732-204">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="5a732-205">此类额外添加一种方法（即 `WriteFileInfo`），并使用 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 对象包装可写文件的句柄。</span><span class="sxs-lookup"><span data-stu-id="5a732-205">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>

[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]

## <a name="see-also"></a><span data-ttu-id="5a732-206">请参阅</span><span class="sxs-lookup"><span data-stu-id="5a732-206">See also</span></span>

- <xref:System.GC.SuppressFinalize%2A>
- <xref:System.IDisposable>
- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>
- <xref:Microsoft.Win32.SafeHandles>
- <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>
- [<span data-ttu-id="5a732-207">定义和使用类和结构 (C++/CLI)</span><span class="sxs-lookup"><span data-stu-id="5a732-207">Define and consume classes and structs (C++/CLI)</span></span>](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)
