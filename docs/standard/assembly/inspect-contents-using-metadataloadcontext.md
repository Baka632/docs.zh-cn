---
title: 如何：使用 MetadataLoadContext 检查程序集内容
description: 了解如何使用 MetadataLoadContext（可实现加载的 API）加载要检查的 .NET 程序集。
author: MSDN-WhiteKnight
ms.date: 03/10/2020
ms.technology: dotnet-standard
ms.openlocfilehash: 7f90149a98632ea57e8d241a0ccdf4b50264ac5c
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/15/2020
ms.locfileid: "90552019"
---
# <a name="how-to-inspect-assembly-contents-using-metadataloadcontext"></a><span data-ttu-id="1d8bc-103">如何：使用 MetadataLoadContext 检查程序集内容</span><span class="sxs-lookup"><span data-stu-id="1d8bc-103">How to: Inspect assembly contents using MetadataLoadContext</span></span>

<span data-ttu-id="1d8bc-104">默认情况下，开发人员可以使用 .NET 中的反射 API 检查加载到主执行上下文的程序集内容。</span><span class="sxs-lookup"><span data-stu-id="1d8bc-104">The reflection API in .NET by default enables developers to inspect the contents of assemblies loaded into the main execution context.</span></span> <span data-ttu-id="1d8bc-105">不过，有时无法将程序集加载到执行上下文，例如当程序集是面向其他平台或处理器体系结构编译时，或者它是[引用程序集](reference-assemblies.md)时。</span><span class="sxs-lookup"><span data-stu-id="1d8bc-105">However, sometimes it isn't possible to load an assembly into the execution context, for example, because it was compiled for another platform or processor architecture, or it's a [reference assembly](reference-assemblies.md).</span></span> <span data-ttu-id="1d8bc-106">借助 <xref:System.Reflection.MetadataLoadContext?displayProperty=fullName> API，可以加载并检查此类程序集。</span><span class="sxs-lookup"><span data-stu-id="1d8bc-106">The <xref:System.Reflection.MetadataLoadContext?displayProperty=fullName> API allows you to load and inspect such assemblies.</span></span> <span data-ttu-id="1d8bc-107">加载到 <xref:System.Reflection.MetadataLoadContext> 的程序集仅被作为元数据处理，即可以检查此程序集中的类型，但无法执行其中包含的任何代码。</span><span class="sxs-lookup"><span data-stu-id="1d8bc-107">Assemblies loaded into the <xref:System.Reflection.MetadataLoadContext> are treated only as metadata, that is, you can examine types in the assembly, but you can't execute any code contained in it.</span></span> <span data-ttu-id="1d8bc-108"><xref:System.Reflection.MetadataLoadContext> 不同于主执行上下文，它不会自动加载当前目录中的依赖项；而是使用传递给它的 <xref:System.Reflection.MetadataAssemblyResolver> 所提供自定义绑定逻辑。</span><span class="sxs-lookup"><span data-stu-id="1d8bc-108">Unlike the main execution context, the <xref:System.Reflection.MetadataLoadContext> doesn't automatically load dependencies from the current directory; instead it uses the custom binding logic provided by the <xref:System.Reflection.MetadataAssemblyResolver> passed to it.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="1d8bc-109">先决条件</span><span class="sxs-lookup"><span data-stu-id="1d8bc-109">Prerequisites</span></span>

<span data-ttu-id="1d8bc-110">安装 [System.Reflection.MetadataLoadContext](https://www.nuget.org/packages/System.Reflection.MetadataLoadContext) NuGet 包，以使用 <xref:System.Reflection.MetadataLoadContext>。</span><span class="sxs-lookup"><span data-stu-id="1d8bc-110">To use <xref:System.Reflection.MetadataLoadContext>, install the [System.Reflection.MetadataLoadContext](https://www.nuget.org/packages/System.Reflection.MetadataLoadContext) NuGet package.</span></span> <span data-ttu-id="1d8bc-111">任意 .NET Standard 2.0 兼容的目标框架均支持它，如 NET Core 2.0 或 .NET Framework 4.6.1。</span><span class="sxs-lookup"><span data-stu-id="1d8bc-111">It is supported on any .NET Standard 2.0-compliant target framework, for example, .NET Core 2.0 or .NET Framework 4.6.1.</span></span>

## <a name="create-metadataassemblyresolver-for-metadataloadcontext"></a><span data-ttu-id="1d8bc-112">创建 MetadataLoadContext 的 MetadataAssemblyResolver</span><span class="sxs-lookup"><span data-stu-id="1d8bc-112">Create MetadataAssemblyResolver for MetadataLoadContext</span></span>

<span data-ttu-id="1d8bc-113">创建 <xref:System.Reflection.MetadataLoadContext> 需要提供 <xref:System.Reflection.MetadataAssemblyResolver> 的实例。</span><span class="sxs-lookup"><span data-stu-id="1d8bc-113">Creating the <xref:System.Reflection.MetadataLoadContext> requires providing the instance of the <xref:System.Reflection.MetadataAssemblyResolver>.</span></span> <span data-ttu-id="1d8bc-114">提供此实例的最简单方法是使用 <xref:System.Reflection.PathAssemblyResolver>，它会从给定程序集路径字符串集合解析程序集。</span><span class="sxs-lookup"><span data-stu-id="1d8bc-114">The simplest way to provide one is to use the <xref:System.Reflection.PathAssemblyResolver>, which resolves assemblies from the given collection of assembly path strings.</span></span> <span data-ttu-id="1d8bc-115">除了包含你想要直接检查的程序集之外，此集合还应包括所有所需的依赖项。</span><span class="sxs-lookup"><span data-stu-id="1d8bc-115">This collection, besides assemblies you want to inspect directly, should also include all needed dependencies.</span></span> <span data-ttu-id="1d8bc-116">例如，若要读取位于外部程序集中的自定义属性，则应包含该程序集，否则将引发异常。</span><span class="sxs-lookup"><span data-stu-id="1d8bc-116">For example, to read the custom attribute located in an external assembly, you should include that assembly or an exception will be thrown.</span></span> <span data-ttu-id="1d8bc-117">多数情况下，应至少包含核心程序集，即包含内置系统类型（如 <xref:System.Object?displayProperty=nameWithType>）的程序集。 </span><span class="sxs-lookup"><span data-stu-id="1d8bc-117">In most cases, you should include at least the *core assembly*, that is, the assembly containing built-in system types, such as <xref:System.Object?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1d8bc-118">下面的代码显示如何使用由检查的程序集和当前运行时的核心程序集组成的集合创建 <xref:System.Reflection.PathAssemblyResolver>：</span><span class="sxs-lookup"><span data-stu-id="1d8bc-118">The following code shows how to create the <xref:System.Reflection.PathAssemblyResolver> using the collection consisting of the inspected assembly and the current runtime's core assembly:</span></span>

[!code-csharp[](snippets/inspect-contents-using-metadataloadcontext/MetadataLoadContextSnippets.cs#CoreAssembly)]

<span data-ttu-id="1d8bc-119">如需访问所有 BCL 类型，可以包含此集合中的所有运行时程序集。</span><span class="sxs-lookup"><span data-stu-id="1d8bc-119">If you need access to all BCL types, you can include all runtime assemblies in the collection.</span></span> <span data-ttu-id="1d8bc-120">下面的代码显示如何使用由检查的程序集和当前运行时的所有程序集组成的集合创建 <xref:System.Reflection.PathAssemblyResolver>：</span><span class="sxs-lookup"><span data-stu-id="1d8bc-120">The following code shows how to create the <xref:System.Reflection.PathAssemblyResolver> using the collection consisting of the inspected assembly and all assemblies of the current runtime:</span></span>

[!code-csharp[](snippets/inspect-contents-using-metadataloadcontext/MetadataLoadContextSnippets.cs#RuntimeAssemblies)]

## <a name="create-metadataloadcontext"></a><span data-ttu-id="1d8bc-121">创建 MetadataLoadContext</span><span class="sxs-lookup"><span data-stu-id="1d8bc-121">Create MetadataLoadContext</span></span>

<span data-ttu-id="1d8bc-122">若要创建 <xref:System.Reflection.MetadataLoadContext>请调用它的构造函数 <xref:System.Reflection.MetadataLoadContext.%23ctor%28System.Reflection.MetadataAssemblyResolver%2CSystem.String%29>，将之前创建的 <xref:System.Reflection.MetadataAssemblyResolver> 作为第一个参数并将核心程序集名称作为第二个参数传递。</span><span class="sxs-lookup"><span data-stu-id="1d8bc-122">To create the <xref:System.Reflection.MetadataLoadContext>, invoke its constructor <xref:System.Reflection.MetadataLoadContext.%23ctor%28System.Reflection.MetadataAssemblyResolver%2CSystem.String%29>, passing the previously created <xref:System.Reflection.MetadataAssemblyResolver> as the first parameter and the core assembly name as the second parameter.</span></span> <span data-ttu-id="1d8bc-123">可以省略核心程序集名称，在这种情况下，该构造函数将试图使用默认名称：“mscorlib”、“System.Runtime”或“netstandard”。</span><span class="sxs-lookup"><span data-stu-id="1d8bc-123">You can omit the core assembly name, in which case the constructor will attempt to use default names: "mscorlib", "System.Runtime", or "netstandard".</span></span>

<span data-ttu-id="1d8bc-124">创建上下文后，可以使用 <xref:System.Reflection.MetadataLoadContext.LoadFromAssemblyPath%2A> 等方法将程序集加载到上下文中。</span><span class="sxs-lookup"><span data-stu-id="1d8bc-124">After you've created the context, you can load assemblies into it using methods such as <xref:System.Reflection.MetadataLoadContext.LoadFromAssemblyPath%2A>.</span></span> <span data-ttu-id="1d8bc-125">可以将所有反射 API 用于加载的程序集，涉及代码执行的 API 除外。</span><span class="sxs-lookup"><span data-stu-id="1d8bc-125">You can use all reflection APIs on loaded assemblies except ones that involve code execution.</span></span> <span data-ttu-id="1d8bc-126"><xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> 方法涉及执行构造函数，因此在需要检查 <xref:System.Reflection.MetadataLoadContext> 中的自定义属性时改为使用 <xref:System.Reflection.MemberInfo.GetCustomAttributesData%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="1d8bc-126">The <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method does involve the execution of constructors, so use the <xref:System.Reflection.MemberInfo.GetCustomAttributesData%2A> method instead when you need to examine custom attributes in the <xref:System.Reflection.MetadataLoadContext>.</span></span>

<span data-ttu-id="1d8bc-127">下面的代码示例创建 <xref:System.Reflection.MetadataLoadContext>，将程序集加载到其中，并将程序集属性输出到控制台：</span><span class="sxs-lookup"><span data-stu-id="1d8bc-127">The following code sample creates <xref:System.Reflection.MetadataLoadContext>, loads the assembly into it, and outputs assembly attributes into the console:</span></span>

[!code-csharp[](snippets/inspect-contents-using-metadataloadcontext/MetadataLoadContextSnippets.cs#CreateContext)]

## <a name="example"></a><span data-ttu-id="1d8bc-128">示例</span><span class="sxs-lookup"><span data-stu-id="1d8bc-128">Example</span></span>

<span data-ttu-id="1d8bc-129">若要查看完整的代码示例，请参阅[使用 MetadataLoadContext 检查程序集内容示例](/samples/dotnet/samples/inspect-assembly-contents-using-metadataloadcontext/)。</span><span class="sxs-lookup"><span data-stu-id="1d8bc-129">For a complete code example, see the [Inspect assembly contents using MetadataLoadContext sample](/samples/dotnet/samples/inspect-assembly-contents-using-metadataloadcontext/).</span></span>
