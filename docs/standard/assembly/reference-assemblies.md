---
title: 引用程序集
description: 了解引用程序集，这是 .NET 中一种特殊类型的程序集，它只包含库的公共 API 外围应用
author: MSDN-WhiteKnight
ms.date: 09/12/2019
ms.openlocfilehash: 2f7f026c7fca4b772be85671dcc3a2a6d50a385c
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/18/2020
ms.locfileid: "94831047"
---
# <a name="reference-assemblies"></a><span data-ttu-id="4f3bc-103">引用程序集</span><span class="sxs-lookup"><span data-stu-id="4f3bc-103">Reference assemblies</span></span>

<span data-ttu-id="4f3bc-104">引用程序集  是一种特殊类型的程序集，它只包含表示库的公共 API 外围应用所需的最少元数据量。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-104">*Reference assemblies* are a special type of assembly that contain only the minimum amount of metadata required to represent the library's public API surface.</span></span> <span data-ttu-id="4f3bc-105">它们包括在生成工具中引用程序集时所需的所有成员的声明，但不包括所有成员实现以及对其 API 协定没有明显影响的私有成员的声明。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-105">They include declarations for all members that are significant when referencing an assembly in build tools, but exclude all member implementations and declarations of private members that have no observable impact on their API contract.</span></span> <span data-ttu-id="4f3bc-106">相比较下，常规程序集称为“实现程序集”  。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-106">In contrast, regular assemblies are called *implementation assemblies*.</span></span>

<span data-ttu-id="4f3bc-107">无法加载引用程序集用于执行，但可以将它们作为编译器输入进行传递，其传递方式与实现程序集相同。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-107">Reference assemblies can't be loaded for execution, but they can be passed as compiler input in the same way as implementation assemblies.</span></span> <span data-ttu-id="4f3bc-108">引用程序集通常随特定平台或库的软件开发工具包 (SDK) 一起分发。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-108">Reference assemblies are usually distributed with the Software Development Kit (SDK) of a particular platform or library.</span></span>

<span data-ttu-id="4f3bc-109">使用引用程序集，开发人员可以生成面向特定库版本的程序，而无需具有该版本的完整实现程序集。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-109">Using a reference assembly enables developers to build programs that target a specific library version without having the full implementation assembly for that version.</span></span> <span data-ttu-id="4f3bc-110">假设计算机上只有某个库的最新版本，但你想要生成一个面向该库的早期版本的程序。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-110">Suppose, you have only the latest version of some library on your machine, but you want to build a program that targets an earlier version of that library.</span></span> <span data-ttu-id="4f3bc-111">如果直接针对实现程序集进行编译，可能会在无意中使用在早期版本中不可用的 API 成员。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-111">If you compile directly against the implementation assembly, you might inadvertently use API members that aren't available in the earlier version.</span></span> <span data-ttu-id="4f3bc-112">只有在目标计算机上测试程序时才会发现这种错误。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-112">You'll only find this mistake when testing the program on the target machine.</span></span> <span data-ttu-id="4f3bc-113">如果针对早期版本的引用程序集进行编译，则会立即出现编译时错误。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-113">If you compile against the reference assembly for the earlier version, you'll immediately get a compile-time error.</span></span>

<span data-ttu-id="4f3bc-114">此外，引用程序集还可以表示协定，即一组不与具体实现程序集对应的 API。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-114">A reference assembly can also represent a contract, that is, a set of APIs that don't correspond to the concrete implementation assembly.</span></span> <span data-ttu-id="4f3bc-115">此类引用程序集称为“协定程序集”  ，可用于面向支持同一组 API 的多个平台。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-115">Such reference assemblies, called the *contract assembly*, can be used to target multiple platforms that support the same set of APIs.</span></span> <span data-ttu-id="4f3bc-116">例如，.NET Standard 提供协定程序集 netstandard .dll  ，它表示在不同的 .NET 平台之间共享的一组公共 API。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-116">For example, .NET Standard provides the contract assembly, *netstandard.dll*, that represents the set of common APIs shared between different .NET platforms.</span></span> <span data-ttu-id="4f3bc-117">这些 API 的实现包含在不同平台上的不同程序集中，例如 .NET Framework 上的 mscorlib.dll 或 .NET Core 上的 System.Private.CoreLib.dll   。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-117">The implementations of these APIs are contained in different assemblies on different platforms, such as *mscorlib.dll* on .NET Framework or *System.Private.CoreLib.dll* on .NET Core.</span></span> <span data-ttu-id="4f3bc-118">面向 .NET Standard 的库可以在支持 .NET Standard 的所有平台上运行。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-118">A library that targets .NET Standard can run on all platforms that support .NET Standard.</span></span>

## <a name="using-reference-assemblies"></a><span data-ttu-id="4f3bc-119">使用引用程序集</span><span class="sxs-lookup"><span data-stu-id="4f3bc-119">Using reference assemblies</span></span>

<span data-ttu-id="4f3bc-120">若要使用项目中的某些 API，必须添加对其程序集的引用。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-120">To use certain APIs from your project, you must add references to their assemblies.</span></span> <span data-ttu-id="4f3bc-121">可以将引用添加到实现程序集，也可以将其添加到引用程序集。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-121">You can add references to either implementation assemblies or to reference assemblies.</span></span> <span data-ttu-id="4f3bc-122">建议在引用程序集可用时使用它。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-122">It's recommended you use reference assemblies whenever they're available.</span></span> <span data-ttu-id="4f3bc-123">这样做可确保仅使用目标版本中受支持的 API 成员，即供 API 设计人员使用。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-123">Doing so ensures that you're using only the supported API members in the target version, meant to be used by API designers.</span></span> <span data-ttu-id="4f3bc-124">使用引用程序集可确保不依赖于实现详细信息。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-124">Using the reference assembly ensures you're not taking a dependency on implementation details.</span></span>

<span data-ttu-id="4f3bc-125">.NET Framework 库的引用程序集与目标包一起分发。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-125">Reference assemblies for the .NET Framework libraries are distributed with targeting packs.</span></span> <span data-ttu-id="4f3bc-126">可以通过下载独立安装程序或在 Visual Studio 安装程序中选择组件来获取它们。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-126">You can obtain them by downloading a standalone installer or by selecting a component in Visual Studio installer.</span></span> <span data-ttu-id="4f3bc-127">有关详细信息，请参阅[安装面向开发人员的 .NET Framework](../../framework/install/guide-for-developers.md)。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-127">For more information, see [Install the .NET Framework for developers](../../framework/install/guide-for-developers.md).</span></span> <span data-ttu-id="4f3bc-128">对于 .NET Core 和 .NET Standard，引用程序集将在必要时（通过 NuGet）进行自动下载和引用。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-128">For .NET Core and .NET Standard, reference assemblies are automatically downloaded as necessary (via NuGet) and referenced.</span></span> <span data-ttu-id="4f3bc-129">对于 .NET Core 3.0 和更高版本，核心框架的引用程序集位于 [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) 包中（使用 [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) 包代替 3.0 之前的版本）。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-129">For .NET Core 3.0 and higher, the reference assemblies for the core framework are in the [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) package (the [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) package is used instead for versions before 3.0).</span></span>

<span data-ttu-id="4f3bc-130">使用“添加引用”对话框在 Visual Studio 中添加对 .NET Framework 程序集的引用时，可以从列表中选择一个程序集，Visual Studio 会自动查找对应于项目中选择的目标框架版本的引用程序集。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-130">When you add references to .NET Framework assemblies in Visual Studio using the **Add reference** dialog, you select an assembly from the list, and Visual Studio automatically finds reference assemblies that correspond to the target framework version selected in your project.</span></span> <span data-ttu-id="4f3bc-131">这同样适用于使用 [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference) 项目项直接在 MSBuild 项目中添加引用的情形：只需指定程序集名称，无需指定完整的文件路径。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-131">The same applies to adding references directly into MSBuild project using the  [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference) project item: you only need to specify the assembly name, not the full file path.</span></span> <span data-ttu-id="4f3bc-132">使用 `-reference` 编译器选项（在 [C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) 和 [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md) 中），或者使用 Roslyn API 中的 <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> 方法在命令行中添加对这些程序集的引用时，必须为正确的目标平台版本手动指定引用程序集文件。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-132">When you add references to these assemblies in the command line by using the `-reference` compiler option ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) and in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) or by using the <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> method in the Roslyn API, you must manually specify reference assembly files for the correct target platform version.</span></span> <span data-ttu-id="4f3bc-133">.NET Framework 引用程序集文件位于 %ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework 目录中。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-133">.NET Framework reference assembly files are located in the *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* directory.</span></span> <span data-ttu-id="4f3bc-134">对于 .NET Core，可以通过将 `PreserveCompilationContext` 项目属性设置为 `true` 强制发布操作，以便将目标平台的引用程序集复制到输出目录的 publish/refs 子目录。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-134">For .NET Core, you can force publish operation to copy reference assemblies for your target platform into the *publish/refs* subdirectory of your output directory by setting the `PreserveCompilationContext` project property to `true`.</span></span> <span data-ttu-id="4f3bc-135">然后，可以将这些引用程序集文件传递给编译器。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-135">Then you can pass these reference assembly files to the compiler.</span></span> <span data-ttu-id="4f3bc-136">使用 [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) 包中的 `DependencyContext` 有助于找到其路径。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-136">Using `DependencyContext` from [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) package can help locate their paths.</span></span>

<span data-ttu-id="4f3bc-137">由于它们不包含任何实现，因此无法加载引用程序集用于执行。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-137">Because they contain no implementation, reference assemblies can't be loaded for execution.</span></span> <span data-ttu-id="4f3bc-138">如果尝试这样做，则会导致 <xref:System.BadImageFormatException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-138">Trying to do so results in a <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4f3bc-139">如果要检查引用程序集的内容，你可将其加载到 .NET Framework 中的仅反射上下文中（使用 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> 方法），或者加载到 .NET Core 中的 <xref:System.Reflection.MetadataLoadContext>。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-139">If you want to examine the contents of a reference assembly, you can load it into the reflection-only context in .NET Framework (using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method) or into the <xref:System.Reflection.MetadataLoadContext> in .NET Core.</span></span>

## <a name="generating-reference-assemblies"></a><span data-ttu-id="4f3bc-140">生成引用程序集</span><span class="sxs-lookup"><span data-stu-id="4f3bc-140">Generating reference assemblies</span></span>

<span data-ttu-id="4f3bc-141">当库使用者需要针对多个不同版本的库生成程序时，为库生成引用程序集会很有用。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-141">Generating reference assemblies for your libraries can be useful when your library consumers need to build their programs against many different versions of the library.</span></span> <span data-ttu-id="4f3bc-142">对于所有这些版本，分发实现程序集可能不切实际，因为它的大小太大。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-142">Distributing implementation assemblies for all these versions might be impractical because of their large size.</span></span> <span data-ttu-id="4f3bc-143">引用程序集的大小较小，将它们作为库 SDK 的一部分进行分发可减少下载大小并节省磁盘空间。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-143">Reference assemblies are smaller in size, and distributing them as a part of your library's SDK reduces download size and saves disk space.</span></span>

<span data-ttu-id="4f3bc-144">IDE 和生成工具还可以利用引用程序集来减少由多个类库组成的大型解决方案的生成时间。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-144">IDEs and build tools also can take advantage of reference assemblies to reduce build times in case of large solutions consisting of multiple class libraries.</span></span> <span data-ttu-id="4f3bc-145">通常，在增量生成方案中，当某个项目的任何输入文件发生更改时，将重新生成该项目（包括它所依赖的程序集）。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-145">Usually, in incremental build scenarios a project is rebuilt when any of its input files are changed, including the assemblies it depends on.</span></span> <span data-ttu-id="4f3bc-146">每当程序员更改任何成员的实现时，实现程序集就会发生更改。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-146">The implementation assembly changes whenever the programmer changes the implementation of any member.</span></span> <span data-ttu-id="4f3bc-147">仅当引用程序集的公共 API 受到影响时，它才会发生更改。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-147">The reference assembly only changes when its public API is affected.</span></span> <span data-ttu-id="4f3bc-148">因此，将引用程序集用作输入文件而不是实现程序集，可以在某些情况下跳过生成依赖项目的步骤。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-148">So, using the reference assembly as an input file instead of the implementation assembly allows skipping the build of the dependent project in some cases.</span></span>

<span data-ttu-id="4f3bc-149">可以通过以下方式生成引用程序集：</span><span class="sxs-lookup"><span data-stu-id="4f3bc-149">You can generate reference assemblies:</span></span>

- <span data-ttu-id="4f3bc-150">在 MSBuild 项目中，通过使用 [`ProduceReferenceAssembly` 项目属性](/visualstudio/msbuild/common-msbuild-project-properties)生成。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-150">In an MSBuild project, by using the [`ProduceReferenceAssembly` project property](/visualstudio/msbuild/common-msbuild-project-properties).</span></span>
- <span data-ttu-id="4f3bc-151">从命令行编译程序时，方法是指定 `-refonly` ([C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md)) 和 `-refout` ([C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) 编译器选项。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-151">When compiling program from command line, by specifiying `-refonly` ([C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) or `-refout` ([C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) compiler options.</span></span>
- <span data-ttu-id="4f3bc-152">使用 Roslyn API 时，通过在传递到 <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> 方法的对象中将 <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> 设置为 `true`，并将 <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> 设置为 `false` 来生成。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-152">When using the Roslyn API, by setting <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> to `true` and <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> to `false` in an object passed to the <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="4f3bc-153">如果要将引用程序集与 NuGet 包一起分发，必须将它们包含在包目录下的 ref\\ 子目录中（而不是用于实现程序集的 lib\\ 子目录中）。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-153">If you want to distribute reference assemblies with NuGet packages, you must include them in the *ref\\* subdirectory under the package directory instead of in the *lib\\* subdirectory used for implementation assemblies.</span></span>

## <a name="reference-assemblies-structure"></a><span data-ttu-id="4f3bc-154">引用程序集结构</span><span class="sxs-lookup"><span data-stu-id="4f3bc-154">Reference assemblies structure</span></span>

<span data-ttu-id="4f3bc-155">引用程序集是对相关概念“仅元数据程序集”的扩展。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-155">Reference assemblies are an expansion of the related concept, *metadata-only assemblies*.</span></span> <span data-ttu-id="4f3bc-156">仅包含元数据的程序集会将方法主体替换为一个 `throw null` 主体，但包括除匿名类型以外的所有成员。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-156">Metadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types.</span></span> <span data-ttu-id="4f3bc-157">使用 `throw null` 主体（而非不使用主体）的原因在于，这样做可以运行和传递 PEVerify（从而验证元数据的完整性）。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-157">The reason for using `throw null` bodies (as opposed to no bodies) is so that **PEVerify** can run and pass (thus validating the completeness of the metadata).</span></span>

<span data-ttu-id="4f3bc-158">引用程序集进一步从仅包含元数据的程序集中删除元数据（私有成员）：</span><span class="sxs-lookup"><span data-stu-id="4f3bc-158">Reference assemblies further remove metadata (private members) from metadata-only assemblies:</span></span>

- <span data-ttu-id="4f3bc-159">引用程序集只包含在 API 外围应用中所需的引用。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-159">A reference assembly only has references for what it needs in the API surface.</span></span> <span data-ttu-id="4f3bc-160">实际程序集可能包含与特定实现相关的其他引用。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-160">The real assembly may have additional references related to specific implementations.</span></span> <span data-ttu-id="4f3bc-161">例如，`class C { private void M() { dynamic d = 1; ... } }` 的引用程序集不引用 `dynamic` 所需的任何类型。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-161">For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` doesn't reference any types required for `dynamic`.</span></span>
- <span data-ttu-id="4f3bc-162">删除私有函数成员（方法、属性和事件），前提是这不会对编译造成显著影响。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-162">Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation.</span></span> <span data-ttu-id="4f3bc-163">如果没有 [InternalsVisibleTo ](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) 属性，则会同时删除内部函数成员。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-163">If there are no [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) attributes, internal function members are also removed.</span></span>

<span data-ttu-id="4f3bc-164">引用程序集中的元数据继续保留以下信息：</span><span class="sxs-lookup"><span data-stu-id="4f3bc-164">The metadata in reference assemblies continues to keep the following information:</span></span>

- <span data-ttu-id="4f3bc-165">所有类型，包括专用类型和嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-165">All types, including private and nested types.</span></span>
- <span data-ttu-id="4f3bc-166">所有属性（甚至是内部属性）。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-166">All attributes, even internal ones.</span></span>
- <span data-ttu-id="4f3bc-167">所有虚拟方法。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-167">All virtual methods.</span></span>
- <span data-ttu-id="4f3bc-168">显式接口实现。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-168">Explicit interface implementations.</span></span>
- <span data-ttu-id="4f3bc-169">显式实现的属性和事件，因为它们的访问器是虚拟的。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-169">Explicitly implemented properties and events, because their accessors are virtual.</span></span>
- <span data-ttu-id="4f3bc-170">结构的所有字段。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-170">All fields of structures.</span></span>

<span data-ttu-id="4f3bc-171">引用程序集包括程序集级 [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) 属性。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-171">Reference assemblies include an assembly-level [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) attribute.</span></span> <span data-ttu-id="4f3bc-172">可以在源中指定此属性；之后编译器就不需要进行合成。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-172">This attribute may be specified in source; then the compiler won't need to synthesize it.</span></span> <span data-ttu-id="4f3bc-173">由于有此属性，运行时会拒绝加载用于执行的引用程序集（但可在仅限反射的模式下加载）。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-173">Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can be loaded in reflection-only mode).</span></span>

<span data-ttu-id="4f3bc-174">具体引用程序集结构详细信息取决于编译器版本。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-174">Exact reference assembly structure details depend on the compiler version.</span></span> <span data-ttu-id="4f3bc-175">如果确定较新的版本不影响公共 API 外围应用，则可以选择在较新版本中排除更多元数据。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-175">Newer versions may choose to exclude more metadata if it's determined as not affecting the public API surface.</span></span>

> [!NOTE]
> <span data-ttu-id="4f3bc-176">本节中的信息仅适用于从 C# 7.1 版或 Visual Basic 15.3 版开始由 Roslyn 编译器生成的引用程序集。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-176">Information in this section is applicable only to reference assemblies generated by Roslyn compilers starting from C# version 7.1 or Visual Basic version 15.3.</span></span> <span data-ttu-id="4f3bc-177">.NET Framework 和 .NET Core 库的引用程序集结构在某些细节上可能有所不同，因为它们使用各自生成引用程序集的机制。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-177">The structure of reference assemblies for .NET Framework and .NET Core libraries can differ in some details, because they use their own mechanism of generating reference assemblies.</span></span> <span data-ttu-id="4f3bc-178">例如，它们可能具有完全为空的方法主体，而不是使用 `throw null` 正文。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-178">For example, they might have totally empty method bodies instead of the `throw null` body.</span></span> <span data-ttu-id="4f3bc-179">但一般原则仍适用：它们没有可用的方法实现，并且仅包含从公共 API 角度具有明显影响的成员的元数据。</span><span class="sxs-lookup"><span data-stu-id="4f3bc-179">But the general principle still applies: they don't have usable method implementations and contain metadata only for members that have an observable impact from a public API perspective.</span></span>

## <a name="see-also"></a><span data-ttu-id="4f3bc-180">请参阅</span><span class="sxs-lookup"><span data-stu-id="4f3bc-180">See also</span></span>

- [<span data-ttu-id="4f3bc-181">.NET 中的程序集</span><span class="sxs-lookup"><span data-stu-id="4f3bc-181">Assemblies in .NET</span></span>](index.md)
- [<span data-ttu-id="4f3bc-182">框架定位概述</span><span class="sxs-lookup"><span data-stu-id="4f3bc-182">Framework targeting overview</span></span>](/visualstudio/ide/visual-studio-multi-targeting-overview)
- [<span data-ttu-id="4f3bc-183">如何：使用引用管理器添加或删除引用</span><span class="sxs-lookup"><span data-stu-id="4f3bc-183">How to: Add or remove references by using the Reference Manager</span></span>](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager)
