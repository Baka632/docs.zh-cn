---
title: 泛型中的协变和逆变
description: 了解 .NET 泛型中的协变和逆变，使用前者则可使用派生程度更大的类型，而使用后者则可使用派生程度更小的派生类型。
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- generics, covariance and contravariance
- generics, variance
- covariance and contravariance in generics
- generic type parameters
ms.assetid: 2678dc63-c7f9-4590-9ddc-0a4df684d42e
ms.openlocfilehash: 1606238b22bd355b997b54cf94e0c28d16ec5cac
ms.sourcegitcommit: b1442669f1982d3a1cb18ea35b5acfb0fc7d93e4
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/30/2020
ms.locfileid: "93063171"
---
# <a name="covariance-and-contravariance-in-generics"></a><span data-ttu-id="396cc-103">泛型中的协变和逆变</span><span class="sxs-lookup"><span data-stu-id="396cc-103">Covariance and contravariance in generics</span></span>

<span data-ttu-id="396cc-104">协变和逆变都是术语，前者指能够使用比原始指定的派生类型的派生程度更大（更具体的）的类型，后者指能够使用比原始指定的派生类型的派生程度更小（不太具体的）的类型 。</span><span class="sxs-lookup"><span data-stu-id="396cc-104">*Covariance* and *contravariance* are terms that refer to the ability to use a more derived type (more specific) or a less derived type (less specific) than originally specified.</span></span> <span data-ttu-id="396cc-105">泛型类型参数支持协变和逆变，可在分配和使用泛型类型方面提供更大的灵活性。</span><span class="sxs-lookup"><span data-stu-id="396cc-105">Generic type parameters support covariance and contravariance to provide greater flexibility in assigning and using generic types.</span></span>

<span data-ttu-id="396cc-106">在引用类型系统时，协变、逆变和不变性具有如下定义。</span><span class="sxs-lookup"><span data-stu-id="396cc-106">When you're referring to a type system, covariance, contravariance, and invariance have the following definitions.</span></span> <span data-ttu-id="396cc-107">这些示例假定一个名为 `Base` 的基类和一个名为 `Derived`的派生类。</span><span class="sxs-lookup"><span data-stu-id="396cc-107">The examples assume a base class named `Base` and a derived class named `Derived`.</span></span>  
  
- `Covariance`  
  
     <span data-ttu-id="396cc-108">使你能够使用比原始指定的类型派生程度更大的类型。</span><span class="sxs-lookup"><span data-stu-id="396cc-108">Enables you to use a more derived type than originally specified.</span></span>  
  
     <span data-ttu-id="396cc-109">你可以将 `IEnumerable<Derived>` 的实例分配给 `IEnumerable<Base>` 类型的变量。</span><span class="sxs-lookup"><span data-stu-id="396cc-109">You can assign an instance of `IEnumerable<Derived>` to a variable of type `IEnumerable<Base>`.</span></span>  
  
- `Contravariance`  
  
     <span data-ttu-id="396cc-110">使你能够使用比原始指定的类型更泛型（派生程度更小）的类型。</span><span class="sxs-lookup"><span data-stu-id="396cc-110">Enables you to use a more generic (less derived) type than originally specified.</span></span>  
  
     <span data-ttu-id="396cc-111">你可以将 `Action<Base>` 的实例分配给 `Action<Derived>` 类型的变量。</span><span class="sxs-lookup"><span data-stu-id="396cc-111">You can assign an instance of `Action<Base>` to a variable of type `Action<Derived>`.</span></span>  
  
- `Invariance`  
  
     <span data-ttu-id="396cc-112">表示只能使用最初指定的类型。</span><span class="sxs-lookup"><span data-stu-id="396cc-112">Means that you can use only the type originally specified.</span></span> <span data-ttu-id="396cc-113">固定泛型类型参数既不是协变，也不是逆变。</span><span class="sxs-lookup"><span data-stu-id="396cc-113">An invariant generic type parameter is neither covariant nor contravariant.</span></span>  
  
     <span data-ttu-id="396cc-114">你无法将 `List<Base>` 的实例分配给 `List<Derived>` 类型的变量，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="396cc-114">You cannot assign an instance of `List<Base>` to a variable of type `List<Derived>` or vice versa.</span></span>  
  
 <span data-ttu-id="396cc-115">利用协变类型参数，你可以执行非常类似于普通的[多态性](../../csharp/programming-guide/classes-and-structs/polymorphism.md)的分配，如以下代码中所示。</span><span class="sxs-lookup"><span data-stu-id="396cc-115">Covariant type parameters enable you to make assignments that look much like ordinary [Polymorphism](../../csharp/programming-guide/classes-and-structs/polymorphism.md), as shown in the following code.</span></span>  
  
 [!code-csharp[CoContraSimpleIEnum#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleienum/cs/example.cs#1)]
 [!code-vb[CoContraSimpleIEnum#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleienum/vb/example.vb#1)]  
  
 <span data-ttu-id="396cc-116"><xref:System.Collections.Generic.List%601> 类实现 <xref:System.Collections.Generic.IEnumerable%601> 接口，因此 `List<Derived>` （在 Visual Basic 中为`List(Of Derived)` ）实现 `IEnumerable<Derived>`。</span><span class="sxs-lookup"><span data-stu-id="396cc-116">The <xref:System.Collections.Generic.List%601> class implements the <xref:System.Collections.Generic.IEnumerable%601> interface, so `List<Derived>` (`List(Of Derived)` in Visual Basic) implements `IEnumerable<Derived>`.</span></span> <span data-ttu-id="396cc-117">协变类型参数将执行其余的工作。</span><span class="sxs-lookup"><span data-stu-id="396cc-117">The covariant type parameter does the rest.</span></span>  
  
 <span data-ttu-id="396cc-118">相反，逆变看起来却不够直观。</span><span class="sxs-lookup"><span data-stu-id="396cc-118">Contravariance, on the other hand, seems counterintuitive.</span></span> <span data-ttu-id="396cc-119">下面的示例创建类型 `Action<Base>` （在 Visual Basic 中为`Action(Of Base)` ）的委托，然后将此委托分配给类型 `Action<Derived>`的变量。</span><span class="sxs-lookup"><span data-stu-id="396cc-119">The following example creates a delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic), and then assigns that delegate to a variable of type `Action<Derived>`.</span></span>  
  
 [!code-csharp[CoContraSimpleAction#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleaction/cs/example.cs#1)]
 [!code-vb[CoContraSimpleAction#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleaction/vb/example.vb#1)]  
  
 <span data-ttu-id="396cc-120">此示例看起来是倒退了，但它是可编译和运行的类型安全代码。</span><span class="sxs-lookup"><span data-stu-id="396cc-120">This seems backward, but it is type-safe code that compiles and runs.</span></span> <span data-ttu-id="396cc-121">由于 Lambda 表达式与其自身所分配到的委托相匹配，因此它会定义一个方法，此方法采用一个 `Base` 类型的参数且没有返回值。</span><span class="sxs-lookup"><span data-stu-id="396cc-121">The lambda expression matches the delegate it's assigned to, so it defines a method that takes one parameter of type `Base` and that has no return value.</span></span> <span data-ttu-id="396cc-122">可以将结果委托分配给类型类型 `Action<Derived>` 的变量，因为 `T` 委托的类型参数 <xref:System.Action%601> 是逆变类型参数。</span><span class="sxs-lookup"><span data-stu-id="396cc-122">The resulting delegate can be assigned to a variable of type `Action<Derived>` because the type parameter `T` of the <xref:System.Action%601> delegate is contravariant.</span></span> <span data-ttu-id="396cc-123">由于 `T` 指定了一个参数类型，因此该代码是类型安全代码。</span><span class="sxs-lookup"><span data-stu-id="396cc-123">The code is type-safe because `T` specifies a parameter type.</span></span> <span data-ttu-id="396cc-124">在调用类型 `Action<Base>` 的委托（就像它是类型 `Action<Derived>`的委托一样）时，其参数必须属于类型 `Derived`。</span><span class="sxs-lookup"><span data-stu-id="396cc-124">When the delegate of type `Action<Base>` is invoked as if it were a delegate of type `Action<Derived>`, its argument must be of type `Derived`.</span></span> <span data-ttu-id="396cc-125">始终可以将此实参安全地传递给基础方法，因为该方法的形参属于类型 `Base`。</span><span class="sxs-lookup"><span data-stu-id="396cc-125">This argument can always be passed safely to the underlying method, because the method's parameter is of type `Base`.</span></span>  
  
 <span data-ttu-id="396cc-126">通常，协变类型参数可用作委托的返回类型，而逆变类型参数可用作参数类型。</span><span class="sxs-lookup"><span data-stu-id="396cc-126">In general, a covariant type parameter can be used as the return type of a delegate, and contravariant type parameters can be used as parameter types.</span></span> <span data-ttu-id="396cc-127">对于接口，协变类型参数可用作接口的方法的返回类型，而逆变类型参数可用作接口的方法的参数类型。</span><span class="sxs-lookup"><span data-stu-id="396cc-127">For an interface, covariant type parameters can be used as the return types of the interface's methods, and contravariant type parameters can be used as the parameter types of the interface's methods.</span></span>  
  
 <span data-ttu-id="396cc-128">协变和逆变统称为“变体”。</span><span class="sxs-lookup"><span data-stu-id="396cc-128">Covariance and contravariance are collectively referred to as *variance*.</span></span> <span data-ttu-id="396cc-129">未标记为协变或逆变的泛型类型参数称为“固定参数” 。</span><span class="sxs-lookup"><span data-stu-id="396cc-129">A generic type parameter that is not marked covariant or contravariant is referred to as *invariant*.</span></span> <span data-ttu-id="396cc-130">有关公共语言运行时中变体的事项的简短摘要：</span><span class="sxs-lookup"><span data-stu-id="396cc-130">A brief summary of facts about variance in the common language runtime:</span></span>  
  
- <span data-ttu-id="396cc-131">Variant 类型参数仅限于泛型接口和泛型委托类型。</span><span class="sxs-lookup"><span data-stu-id="396cc-131">Variant type parameters are restricted to generic interface and generic delegate types.</span></span>  
  
- <span data-ttu-id="396cc-132">泛型接口或泛型委托类型可以同时具有协变和逆变类型参数。</span><span class="sxs-lookup"><span data-stu-id="396cc-132">A generic interface or generic delegate type can have both covariant and contravariant type parameters.</span></span>  
  
- <span data-ttu-id="396cc-133">变体仅适用于引用类型；如果为 Variant 类型参数指定值类型，则该类型参数对于生成的构造类型是不变的。</span><span class="sxs-lookup"><span data-stu-id="396cc-133">Variance applies only to reference types; if you specify a value type for a variant type parameter, that type parameter is invariant for the resulting constructed type.</span></span>  
  
- <span data-ttu-id="396cc-134">变体不适用于委托组合。</span><span class="sxs-lookup"><span data-stu-id="396cc-134">Variance does not apply to delegate combination.</span></span> <span data-ttu-id="396cc-135">也就是说，在给定类型 `Action<Derived>` 和 `Action<Base>` （在 Visual Basic 中为`Action(Of Derived)` 和 `Action(Of Base)` ）的两个委托的情况下，无法将第二个委托与第一个委托结合起来，尽管结果将是类型安全的。</span><span class="sxs-lookup"><span data-stu-id="396cc-135">That is, given two delegates of types `Action<Derived>` and `Action<Base>` (`Action(Of Derived)` and `Action(Of Base)` in Visual Basic), you cannot combine the second delegate with the first although the result would be type safe.</span></span> <span data-ttu-id="396cc-136">变体允许将第二个委托分配给类型 `Action<Derived>`的变量，但只能在这两个委托的类型完全匹配的情况下对它们进行组合。</span><span class="sxs-lookup"><span data-stu-id="396cc-136">Variance allows the second delegate to be assigned to a variable of type `Action<Derived>`, but delegates can combine only if their types match exactly.</span></span>

- <span data-ttu-id="396cc-137">从 C# 9 开始，支持协变返回类型。</span><span class="sxs-lookup"><span data-stu-id="396cc-137">Starting in C# 9, covariant return types are supported.</span></span> <span data-ttu-id="396cc-138">重写方法可以声明比它重写的方法派生程度更高的返回类型，而重写的只读属性可以声明派生程度更高的类型。</span><span class="sxs-lookup"><span data-stu-id="396cc-138">An overriding method can declare a more derived return type the method it overrides, and an overriding, read-only property can declare a more derived type.</span></span>

<a name="InterfaceCovariantTypeParameters"></a>
## <a name="generic-interfaces-with-covariant-type-parameters"></a><span data-ttu-id="396cc-139">具有协变类型参数的泛型接口</span><span class="sxs-lookup"><span data-stu-id="396cc-139">Generic interfaces with covariant type parameters</span></span>

<span data-ttu-id="396cc-140">某些泛型接口具有协变类型参数；例如：<xref:System.Collections.Generic.IEnumerable%601>、<xref:System.Collections.Generic.IEnumerator%601>、<xref:System.Linq.IQueryable%601> 和 <xref:System.Linq.IGrouping%602>。</span><span class="sxs-lookup"><span data-stu-id="396cc-140">Several generic interfaces have covariant type parameters, for example, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601>, and <xref:System.Linq.IGrouping%602>.</span></span> <span data-ttu-id="396cc-141">由于这些接口的所有类型参数都是协变类型参数，因此这些类型参数只用于成员的返回类型。</span><span class="sxs-lookup"><span data-stu-id="396cc-141">All the type parameters of these interfaces are covariant, so the type parameters are used only for the return types of the members.</span></span>  
  
 <span data-ttu-id="396cc-142">下面的示例阐释了协变类型参数。</span><span class="sxs-lookup"><span data-stu-id="396cc-142">The following example illustrates covariant type parameters.</span></span> <span data-ttu-id="396cc-143">此示例定义了两个类型： `Base` 具有一个名为 `PrintBases` 的静态方法，该方法采用 `IEnumerable<Base>` （在 Visual Basic 中为`IEnumerable(Of Base)` ）并输出元素。</span><span class="sxs-lookup"><span data-stu-id="396cc-143">The example defines two types: `Base` has a static method named `PrintBases` that takes an `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) and prints the elements.</span></span> <span data-ttu-id="396cc-144">`Derived` 继承自 `Base`。</span><span class="sxs-lookup"><span data-stu-id="396cc-144">`Derived` inherits from `Base`.</span></span> <span data-ttu-id="396cc-145">此示例创建一个空 `List<Derived>` （在 Visual Basic 中为`List(Of Derived)` ），并且说明可以将该类型传递给 `PrintBases` 且在不进行强制转换的情况下将该类型分配给类型 `IEnumerable<Base>` 的变量。</span><span class="sxs-lookup"><span data-stu-id="396cc-145">The example creates an empty `List<Derived>` (`List(Of Derived)` in Visual Basic) and demonstrates that this type can be passed to `PrintBases` and assigned to a variable of type `IEnumerable<Base>` without casting.</span></span> <span data-ttu-id="396cc-146"><xref:System.Collections.Generic.List%601> 实现 <xref:System.Collections.Generic.IEnumerable%601>，它具有一个协变类型参数。</span><span class="sxs-lookup"><span data-stu-id="396cc-146"><xref:System.Collections.Generic.List%601> implements <xref:System.Collections.Generic.IEnumerable%601>, which has a single covariant type parameter.</span></span> <span data-ttu-id="396cc-147">协变类型参数是可使用 `IEnumerable<Derived>` 的实例而非 `IEnumerable<Base>`的原因。</span><span class="sxs-lookup"><span data-stu-id="396cc-147">The covariant type parameter is the reason why an instance of `IEnumerable<Derived>` can be used instead of `IEnumerable<Base>`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici/vb/example.vb#1)]  
  
## <a name="generic-interfaces-with-contravariant-type-parameters"></a><span data-ttu-id="396cc-148">具有逆变类型参数的泛型接口</span><span class="sxs-lookup"><span data-stu-id="396cc-148">Generic interfaces with contravariant type parameters</span></span>

<span data-ttu-id="396cc-149">某些泛型接口具有逆变类型参数；例如：<xref:System.Collections.Generic.IComparer%601>、<xref:System.IComparable%601> 和 <xref:System.Collections.Generic.IEqualityComparer%601>。</span><span class="sxs-lookup"><span data-stu-id="396cc-149">Several generic interfaces have contravariant type parameters; for example: <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601>, and <xref:System.Collections.Generic.IEqualityComparer%601>.</span></span> <span data-ttu-id="396cc-150">由于这些接口只具有逆变类型参数，因此这些类型参数只用作接口成员中的参数类型。</span><span class="sxs-lookup"><span data-stu-id="396cc-150">These interfaces have only contravariant type parameters, so the type parameters are used only as parameter types in the members of the interfaces.</span></span>  
  
 <span data-ttu-id="396cc-151">下面的示例阐释了逆变类型参数。</span><span class="sxs-lookup"><span data-stu-id="396cc-151">The following example illustrates contravariant type parameters.</span></span> <span data-ttu-id="396cc-152">该示例定义具有 `Area` 属性的抽象（在 Visual Basic 中为 `MustInherit`）`Shape` 类。</span><span class="sxs-lookup"><span data-stu-id="396cc-152">The example defines an abstract (`MustInherit` in Visual Basic) `Shape` class with an `Area` property.</span></span> <span data-ttu-id="396cc-153">该示例还定义一个实现 `IComparer<Shape>`（在 Visual Basic 中为 `IComparer(Of Shape)`）的 `ShapeAreaComparer` 类。</span><span class="sxs-lookup"><span data-stu-id="396cc-153">The example also defines a `ShapeAreaComparer` class that implements `IComparer<Shape>` (`IComparer(Of Shape)` in Visual Basic).</span></span> <span data-ttu-id="396cc-154"><xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> 方法的实现基于 `Area` 属性的值，所以 `ShapeAreaComparer` 可用于按区域对 `Shape` 对象排序。</span><span class="sxs-lookup"><span data-stu-id="396cc-154">The implementation of the <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> method is based on the value of the `Area` property, so `ShapeAreaComparer` can be used to sort `Shape` objects by area.</span></span>  
  
 <span data-ttu-id="396cc-155">`Circle` 类继承 `Shape` 并替代 `Area`。</span><span class="sxs-lookup"><span data-stu-id="396cc-155">The `Circle` class inherits `Shape` and overrides `Area`.</span></span> <span data-ttu-id="396cc-156">该示例使用一个采用 `IComparer<Circle>`（在 Visual Basic 中为 `IComparer(Of Circle)`）的构造函数创建 `Circle` 对象的 <xref:System.Collections.Generic.SortedSet%601>。</span><span class="sxs-lookup"><span data-stu-id="396cc-156">The example creates a <xref:System.Collections.Generic.SortedSet%601> of `Circle` objects, using a constructor that takes an `IComparer<Circle>` (`IComparer(Of Circle)` in Visual Basic).</span></span> <span data-ttu-id="396cc-157">但是，该示例不传递 `IComparer<Circle>`，而是传递一个用于实现 `IComparer<Shape>` 的 `ShapeAreaComparer` 对象。</span><span class="sxs-lookup"><span data-stu-id="396cc-157">However, instead of passing an `IComparer<Circle>`, the example passes a `ShapeAreaComparer` object, which implements `IComparer<Shape>`.</span></span> <span data-ttu-id="396cc-158">当代码调用派生程度较高的类型 (`Circle`) 的比较器时，该示例可以传递派生程度较低的类型 (`Shape`) 的比较器，因为 <xref:System.Collections.Generic.IComparer%601> 泛型接口的类型参数是逆变参数。</span><span class="sxs-lookup"><span data-stu-id="396cc-158">The example can pass a comparer of a less derived type (`Shape`) when the code calls for a comparer of a more derived type (`Circle`), because the type parameter of the <xref:System.Collections.Generic.IComparer%601> generic interface is contravariant.</span></span>  
  
 <span data-ttu-id="396cc-159">向 `Circle` 中添加新 `SortedSet<Circle>`对象时，每次将新元素与现有元素进行比较时，都会调用 `IComparer<Shape>.Compare` 对象的`IComparer(Of Shape).Compare` 方法（在 Visual Basic 中为 `ShapeAreaComparer` 方法）。</span><span class="sxs-lookup"><span data-stu-id="396cc-159">When a new `Circle` object is added to the `SortedSet<Circle>`, the `IComparer<Shape>.Compare` method (`IComparer(Of Shape).Compare` method in Visual Basic) of the `ShapeAreaComparer` object is called each time the new element is compared to an existing element.</span></span> <span data-ttu-id="396cc-160">该方法的参数类型 (`Shape`) 比所传递的类型 (`Circle`) 的派生程度低，所以调用是类型安全的。</span><span class="sxs-lookup"><span data-stu-id="396cc-160">The parameter type of the method (`Shape`) is less derived than the type that is being passed (`Circle`), so the call is type safe.</span></span> <span data-ttu-id="396cc-161">逆变使 `ShapeAreaComparer` 可以对派生自 `Shape` 的任意单个类型的集合以及混合类型的集合排序。</span><span class="sxs-lookup"><span data-stu-id="396cc-161">Contravariance enables `ShapeAreaComparer` to sort a collection of any single type, as well as a mixed collection of types, that derive from `Shape`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI2#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici2/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI2#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici2/vb/example.vb#1)]  

## <a name="generic-delegates-with-variant-type-parameters"></a><span data-ttu-id="396cc-162">具有 Variant 类型参数的泛型委托</span><span class="sxs-lookup"><span data-stu-id="396cc-162">Generic delegates with variant type parameters</span></span>

<span data-ttu-id="396cc-163">`Func` 泛型委托（如 <xref:System.Func%602>）具有协变返回类型和逆变参数类型。</span><span class="sxs-lookup"><span data-stu-id="396cc-163">The `Func` generic delegates, such as <xref:System.Func%602>, have covariant return types and contravariant parameter types.</span></span> <span data-ttu-id="396cc-164">`Action` 泛型委托（如 <xref:System.Action%602>）具有逆变参数类型。</span><span class="sxs-lookup"><span data-stu-id="396cc-164">The `Action` generic delegates, such as <xref:System.Action%602>, have contravariant parameter types.</span></span> <span data-ttu-id="396cc-165">这意味着，可以将委托指派给具有派生程度较高的参数类型和（对于 `Func` 泛型委托）派生程度较低的返回类型的变量。</span><span class="sxs-lookup"><span data-stu-id="396cc-165">This means that the delegates can be assigned to variables that have more derived parameter types and (in the case of the `Func` generic delegates) less derived return types.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="396cc-166">`Func` 泛型委托的最后一个泛型类型参数指定委托签名中返回值的类型。</span><span class="sxs-lookup"><span data-stu-id="396cc-166">The last generic type parameter of the `Func` generic delegates specifies the type of the return value in the delegate signature.</span></span> <span data-ttu-id="396cc-167">该参数是协变的（`out` 关键字），而其他泛型类型参数是逆变的（`in` 关键字）。</span><span class="sxs-lookup"><span data-stu-id="396cc-167">It is covariant (`out` keyword), whereas the other generic type parameters are contravariant (`in` keyword).</span></span>  
  
 <span data-ttu-id="396cc-168">下面的代码阐释这一点。</span><span class="sxs-lookup"><span data-stu-id="396cc-168">The following code illustrates this.</span></span> <span data-ttu-id="396cc-169">第一段代码定义了一个名为 `Base` 的类、一个名为 `Derived` 的类（此类继承 `Base`）和另一个具有名为 `MyMethod` 的 `static` 方法（在 Visual Basic 中为 `Shared`）的类。</span><span class="sxs-lookup"><span data-stu-id="396cc-169">The first piece of code defines a class named `Base`, a class named `Derived` that inherits `Base`, and another class with a `static` method (`Shared` in Visual Basic) named `MyMethod`.</span></span> <span data-ttu-id="396cc-170">该方法接受 `Base` 的实例，并返回 `Derived` 的实例。</span><span class="sxs-lookup"><span data-stu-id="396cc-170">The method takes an instance of `Base` and returns an instance of `Derived`.</span></span> <span data-ttu-id="396cc-171">（如果参数是 `Derived` 的实例，则 `MyMethod` 将返回该实例；如果参数是 `Base` 的实例，则 `MyMethod` 将返回 `Derived` 的新实例。）在 `Main()` 中，该示例创建一个表示 `Func<Base, Derived>` 的 `Func(Of Base, Derived)`（在 Visual Basic 中为 `MyMethod`）的实例，并将此实例存储在变量 `f1` 中。</span><span class="sxs-lookup"><span data-stu-id="396cc-171">(If the argument is an instance of `Derived`, `MyMethod` returns it; if the argument is an instance of `Base`, `MyMethod` returns a new instance of `Derived`.) In `Main()`, the example creates an instance of `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic) that represents `MyMethod`, and stores it in the variable `f1`.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#2](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#2)]
 [!code-vb[CoContravarianceDelegates#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#2)]  
  
 <span data-ttu-id="396cc-172">第二段代码说明可以将委托分配给类型 `Func<Base, Base>` （在 Visual Basic 中为`Func(Of Base, Base)` ）的变量，因为返回类型是协变的。</span><span class="sxs-lookup"><span data-stu-id="396cc-172">The second piece of code shows that the delegate can be assigned to a variable of type `Func<Base, Base>` (`Func(Of Base, Base)` in Visual Basic), because the return type is covariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#3](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#3)]
 [!code-vb[CoContravarianceDelegates#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#3)]  
  
 <span data-ttu-id="396cc-173">第三段代码说明可以将委托分配给类型 `Func<Derived, Derived>` （在 Visual Basic 中为`Func(Of Derived, Derived)` ）的变量，因为参数类型是逆变的。</span><span class="sxs-lookup"><span data-stu-id="396cc-173">The third piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Derived>` (`Func(Of Derived, Derived)` in Visual Basic), because the parameter type is contravariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#4](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#4)]
 [!code-vb[CoContravarianceDelegates#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#4)]  
  
 <span data-ttu-id="396cc-174">最后一段代码说明可以将委托分配给类型 `Func<Derived, Base>` （在 Visual Basic 中为`Func(Of Derived, Base)` ）的变量，从而将逆变参数类型和协变返回类型的作用结合起来。</span><span class="sxs-lookup"><span data-stu-id="396cc-174">The final piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Base>` (`Func(Of Derived, Base)` in Visual Basic), combining the effects of the contravariant parameter type and the covariant return type.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#5](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#5)]
 [!code-vb[CoContravarianceDelegates#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#5)]  
  
### <a name="variance-in-non-generic-delegates"></a><span data-ttu-id="396cc-175">非泛型委托中的变体</span><span class="sxs-lookup"><span data-stu-id="396cc-175">Variance in non-generic delegates</span></span>

 <span data-ttu-id="396cc-176">在上面的代码中， `MyMethod` 的签名与所构造的泛型委托 `Func<Base, Derived>` （在 Visual Basic 中为`Func(Of Base, Derived)` ）的签名完全匹配。</span><span class="sxs-lookup"><span data-stu-id="396cc-176">In the preceding code, the signature of `MyMethod` exactly matches the signature of the constructed generic delegate: `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic).</span></span> <span data-ttu-id="396cc-177">此示例说明，只要所有委托类型都是从泛型委托类型 <xref:System.Func%602>构造的，就可以将此泛型委托存储在具有派生程度更大的参数类型和派生程度更小的返回类型的变量或方法参数中。</span><span class="sxs-lookup"><span data-stu-id="396cc-177">The example shows that this generic delegate can be stored in variables or method parameters that have more derived parameter types and less derived return types, as long as all the delegate types are constructed from the generic delegate type <xref:System.Func%602>.</span></span>  
  
 <span data-ttu-id="396cc-178">这一点非常重要。</span><span class="sxs-lookup"><span data-stu-id="396cc-178">This is an important point.</span></span> <span data-ttu-id="396cc-179">泛型委托的类型参数中的协方差和逆变的效果类似于普通委托绑定中的协方差和逆变的效果（请参阅[委托中的差异 (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) 和[委托中的差异 (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)）。</span><span class="sxs-lookup"><span data-stu-id="396cc-179">The effects of covariance and contravariance in the type parameters of generic delegates are similar to the effects of covariance and contravariance in ordinary delegate binding (see [Variance in Delegates (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) and [Variance in Delegates (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)).</span></span> <span data-ttu-id="396cc-180">但是，委托绑定中的变化适用于所有委托类型，而不仅仅适用于具有 Variant 类型参数的泛型委托类型。</span><span class="sxs-lookup"><span data-stu-id="396cc-180">However, variance in delegate binding works with all delegate types, not just with generic delegate types that have variant type parameters.</span></span> <span data-ttu-id="396cc-181">此外，通过委托绑定中的变化，可以将方法绑定到具有限制较多的参数类型和限制较少的返回类型的任何委托，而对于泛型委托的指派，只有在委托类型是基于同一个泛型类型定义构造的时才可以进行。</span><span class="sxs-lookup"><span data-stu-id="396cc-181">Furthermore, variance in delegate binding enables a method to be bound to any delegate that has more restrictive parameter types and a less restrictive return type, whereas the assignment of generic delegates works only if both delegate types are constructed from the same generic type definition.</span></span>  
  
 <span data-ttu-id="396cc-182">下面的示例演示委托绑定中的变化和泛型类型参数中的变化的组合效果。</span><span class="sxs-lookup"><span data-stu-id="396cc-182">The following example shows the combined effects of variance in delegate binding and variance in generic type parameters.</span></span> <span data-ttu-id="396cc-183">该示例定义了一个类型层次结构，其中包含三个按派生程度从低到高排列的类型，即`Type1`的派生程度最低，`Type3`的派生程度最高。</span><span class="sxs-lookup"><span data-stu-id="396cc-183">The example defines a type hierarchy that includes three types, from least derived (`Type1`) to most derived (`Type3`).</span></span> <span data-ttu-id="396cc-184">普通委托绑定中的变化用于将参数类型为 `Type1` 、返回类型为 `Type3` 的方法绑定到参数类型为 `Type2` 、返回类型为 `Type2`的泛型委托。</span><span class="sxs-lookup"><span data-stu-id="396cc-184">Variance in ordinary delegate binding is used to bind a method with a parameter type of `Type1` and a return type of `Type3` to a generic delegate with a parameter type of `Type2` and a return type of `Type2`.</span></span> <span data-ttu-id="396cc-185">然后，使用泛型类型参数的协变和逆变，将得到的泛型委托指派给另一个变量，此变量的泛型委托类型的参数类型为 `Type3` ，返回类型为 `Type1`。</span><span class="sxs-lookup"><span data-stu-id="396cc-185">The resulting generic delegate is then assigned to another variable whose generic delegate type has a parameter of type `Type3` and a return type of `Type1`, using the covariance and contravariance of generic type parameters.</span></span> <span data-ttu-id="396cc-186">第二个指派要求变量类型和委托类型是基于同一个泛型类型定义（在本例中为 <xref:System.Func%602>）构造的。</span><span class="sxs-lookup"><span data-stu-id="396cc-186">The second assignment requires both the variable type and the delegate type to be constructed from the same generic type definition, in this case, <xref:System.Func%602>.</span></span>  
  
 [!code-csharp[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/cs/example.cs#1)]
 [!code-vb[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/vb/example.vb#1)]  

## <a name="define-variant-generic-interfaces-and-delegates"></a><span data-ttu-id="396cc-187">定义变体泛型接口和委托</span><span class="sxs-lookup"><span data-stu-id="396cc-187">Define variant generic interfaces and delegates</span></span>

<span data-ttu-id="396cc-188">Visual Basic 和 C# 提供了一些关键字，利用这些关键字，可以将接口和委托的泛型类型参数标记为协变或逆变。</span><span class="sxs-lookup"><span data-stu-id="396cc-188">Visual Basic and C# have keywords that enable you to mark the generic type parameters of interfaces and delegates as covariant or contravariant.</span></span>
  
 <span data-ttu-id="396cc-189">协变类型参数用 `out` 关键字（在 Visual Basic 中为`Out` 关键字）标记。</span><span class="sxs-lookup"><span data-stu-id="396cc-189">A covariant type parameter is marked with the `out` keyword (`Out` keyword in Visual Basic).</span></span> <span data-ttu-id="396cc-190">可以将协变类型参数用作属于接口的方法的返回值，或用作委托的返回类型。</span><span class="sxs-lookup"><span data-stu-id="396cc-190">You can use a covariant type parameter as the return value of a method that belongs to an interface, or as the return type of a delegate.</span></span> <span data-ttu-id="396cc-191">但不能将协变类型参数用作接口方法的泛型类型约束。</span><span class="sxs-lookup"><span data-stu-id="396cc-191">You cannot use a covariant type parameter as a generic type constraint for interface methods.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="396cc-192">如果接口的方法具有泛型委托类型的参数，则接口类型的协变类型参数可用于指定委托类型的逆变类型参数。</span><span class="sxs-lookup"><span data-stu-id="396cc-192">If a method of an interface has a parameter that is a generic delegate type, a covariant type parameter of the interface type can be used to specify a contravariant type parameter of the delegate type.</span></span>  
  
 <span data-ttu-id="396cc-193">逆变类型参数用 `in` 关键字（在 Visual Basic 中为`In` 关键字）标记。</span><span class="sxs-lookup"><span data-stu-id="396cc-193">A contravariant type parameter is marked with the `in` keyword (`In` keyword in Visual Basic).</span></span> <span data-ttu-id="396cc-194">可以将逆变类型参数用作属于接口的方法的参数类型，或用作委托的参数类型。</span><span class="sxs-lookup"><span data-stu-id="396cc-194">You can use a contravariant type parameter as the type of a parameter of a method that belongs to an interface, or as the type of a parameter of a delegate.</span></span> <span data-ttu-id="396cc-195">也可以将逆变类型参数用作接口方法的泛型类型约束。</span><span class="sxs-lookup"><span data-stu-id="396cc-195">You can use a contravariant type parameter as a generic type constraint for an interface method.</span></span>  
  
 <span data-ttu-id="396cc-196">只有接口类型和委托类型才能具有 Variant 类型参数。</span><span class="sxs-lookup"><span data-stu-id="396cc-196">Only interface types and delegate types can have variant type parameters.</span></span> <span data-ttu-id="396cc-197">接口或委托类型可以同时具有协变和逆变类型参数。</span><span class="sxs-lookup"><span data-stu-id="396cc-197">An interface or delegate type can have both covariant and contravariant type parameters.</span></span>  
  
 <span data-ttu-id="396cc-198">Visual Basic 和 C# 不允许违反协变和逆变类型参数的使用规则，也不允许将协变和逆变批注添加到接口和委托类型之外的类型参数中。</span><span class="sxs-lookup"><span data-stu-id="396cc-198">Visual Basic and C# do not allow you to violate the rules for using covariant and contravariant type parameters, or to add covariance and contravariance annotations to the type parameters of types other than interfaces and delegates.</span></span>
  
 <span data-ttu-id="396cc-199">有关信息和示例代码，请参阅[泛型接口中的差异 (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) 和[泛型接口中的差异 (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md)。</span><span class="sxs-lookup"><span data-stu-id="396cc-199">For information and example code, see [Variance in Generic Interfaces (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) and [Variance in Generic Interfaces (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span></span>  

## <a name="list-of-types"></a><span data-ttu-id="396cc-200">类型列表</span><span class="sxs-lookup"><span data-stu-id="396cc-200">List of types</span></span>

<span data-ttu-id="396cc-201">下面的接口和委托类型具有协变和/或逆变类型参数。</span><span class="sxs-lookup"><span data-stu-id="396cc-201">The following interface and delegate types have covariant and/or contravariant type parameters.</span></span>  
  
|<span data-ttu-id="396cc-202">类型</span><span class="sxs-lookup"><span data-stu-id="396cc-202">Type</span></span>|<span data-ttu-id="396cc-203">协变类型参数</span><span class="sxs-lookup"><span data-stu-id="396cc-203">Covariant type parameters</span></span>|<span data-ttu-id="396cc-204">逆变类型参数</span><span class="sxs-lookup"><span data-stu-id="396cc-204">Contravariant type parameters</span></span>|  
|----------|-------------------------------|-----------------------------------|  
|<span data-ttu-id="396cc-205"><xref:System.Action%601> 至 <xref:System.Action%6016></span><span class="sxs-lookup"><span data-stu-id="396cc-205"><xref:System.Action%601> to <xref:System.Action%6016></span></span>||<span data-ttu-id="396cc-206">是</span><span class="sxs-lookup"><span data-stu-id="396cc-206">Yes</span></span>|  
|<xref:System.Comparison%601>||<span data-ttu-id="396cc-207">是</span><span class="sxs-lookup"><span data-stu-id="396cc-207">Yes</span></span>|  
|<xref:System.Converter%602>|<span data-ttu-id="396cc-208">是</span><span class="sxs-lookup"><span data-stu-id="396cc-208">Yes</span></span>|<span data-ttu-id="396cc-209">是</span><span class="sxs-lookup"><span data-stu-id="396cc-209">Yes</span></span>|  
|<xref:System.Func%601>|<span data-ttu-id="396cc-210">是</span><span class="sxs-lookup"><span data-stu-id="396cc-210">Yes</span></span>||  
|<span data-ttu-id="396cc-211"><xref:System.Func%602> 至 <xref:System.Func%6017></span><span class="sxs-lookup"><span data-stu-id="396cc-211"><xref:System.Func%602> to <xref:System.Func%6017></span></span>|<span data-ttu-id="396cc-212">是</span><span class="sxs-lookup"><span data-stu-id="396cc-212">Yes</span></span>|<span data-ttu-id="396cc-213">是</span><span class="sxs-lookup"><span data-stu-id="396cc-213">Yes</span></span>|  
|<xref:System.IComparable%601>||<span data-ttu-id="396cc-214">是</span><span class="sxs-lookup"><span data-stu-id="396cc-214">Yes</span></span>|  
|<xref:System.Predicate%601>||<span data-ttu-id="396cc-215">是</span><span class="sxs-lookup"><span data-stu-id="396cc-215">Yes</span></span>|  
|<xref:System.Collections.Generic.IComparer%601>||<span data-ttu-id="396cc-216">是</span><span class="sxs-lookup"><span data-stu-id="396cc-216">Yes</span></span>|  
|<xref:System.Collections.Generic.IEnumerable%601>|<span data-ttu-id="396cc-217">是</span><span class="sxs-lookup"><span data-stu-id="396cc-217">Yes</span></span>||  
|<xref:System.Collections.Generic.IEnumerator%601>|<span data-ttu-id="396cc-218">是</span><span class="sxs-lookup"><span data-stu-id="396cc-218">Yes</span></span>||  
|<xref:System.Collections.Generic.IEqualityComparer%601>||<span data-ttu-id="396cc-219">是</span><span class="sxs-lookup"><span data-stu-id="396cc-219">Yes</span></span>|  
|<xref:System.Linq.IGrouping%602>|<span data-ttu-id="396cc-220">是</span><span class="sxs-lookup"><span data-stu-id="396cc-220">Yes</span></span>||  
|<xref:System.Linq.IOrderedEnumerable%601>|<span data-ttu-id="396cc-221">是</span><span class="sxs-lookup"><span data-stu-id="396cc-221">Yes</span></span>||  
|<xref:System.Linq.IOrderedQueryable%601>|<span data-ttu-id="396cc-222">是</span><span class="sxs-lookup"><span data-stu-id="396cc-222">Yes</span></span>||  
|<xref:System.Linq.IQueryable%601>|<span data-ttu-id="396cc-223">是</span><span class="sxs-lookup"><span data-stu-id="396cc-223">Yes</span></span>||  
  
## <a name="see-also"></a><span data-ttu-id="396cc-224">请参阅</span><span class="sxs-lookup"><span data-stu-id="396cc-224">See also</span></span>

- [<span data-ttu-id="396cc-225">协变和逆变 (C#)</span><span class="sxs-lookup"><span data-stu-id="396cc-225">Covariance and Contravariance (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="396cc-226">协变和逆变 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="396cc-226">Covariance and Contravariance (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="396cc-227">委托中的变体 (C#)</span><span class="sxs-lookup"><span data-stu-id="396cc-227">Variance in Delegates (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
- [<span data-ttu-id="396cc-228">委托中的变体 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="396cc-228">Variance in Delegates (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
