---
title: 观察者设计模式
description: 了解 .NET 中的观察程序设计模式。 此模式使订阅者能够从提供程序注册并接收通知。
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- IObserver(Of T) interface
- IObservable<T> interface
- IObserver<T> interface
- IObservable(Of T) interface
- observer design pattern [.NET Framework]
ms.assetid: 3680171f-f522-453c-aa4a-54f755a78f88
ms.openlocfilehash: 80dac36199dd13abeab295d4b53a52615e7ae625
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/15/2020
ms.locfileid: "90559156"
---
# <a name="observer-design-pattern"></a><span data-ttu-id="c0983-104">观察者设计模式</span><span class="sxs-lookup"><span data-stu-id="c0983-104">Observer Design Pattern</span></span>

<span data-ttu-id="c0983-105">观察者设计模式使订阅者能够从提供程序注册并接收通知。</span><span class="sxs-lookup"><span data-stu-id="c0983-105">The observer design pattern enables a subscriber to register with and receive notifications from a provider.</span></span> <span data-ttu-id="c0983-106">它适用于需要基于推送的通知的任何方案。</span><span class="sxs-lookup"><span data-stu-id="c0983-106">It is suitable for any scenario that requires push-based notification.</span></span> <span data-ttu-id="c0983-107">此模式定义提供程序（亦称为“使用者”或“可观察对象”），以及零个、一个或多个观察者。   </span><span class="sxs-lookup"><span data-stu-id="c0983-107">The pattern defines a *provider* (also known as a *subject* or an *observable*) and zero, one, or more *observers*.</span></span> <span data-ttu-id="c0983-108">观察者注册提供程序，并且每当预定义的条件、事件或状态发生更改时，该提供程序会通过调用其方法之一来自动通知所有观察者。</span><span class="sxs-lookup"><span data-stu-id="c0983-108">Observers register with the provider, and whenever a predefined condition, event, or state change occurs, the provider automatically notifies all observers by calling one of their methods.</span></span> <span data-ttu-id="c0983-109">在此方法调用中，该提供程序还可向观察者提供当前状态信息。</span><span class="sxs-lookup"><span data-stu-id="c0983-109">In this method call, the provider can also provide current state information to observers.</span></span> <span data-ttu-id="c0983-110">在 .NET Framework 中，通过实现泛型 <xref:System.IObservable%601?displayProperty=nameWithType> 和 <xref:System.IObserver%601?displayProperty=nameWithType> 接口来应用观察者设计模式。 泛型类型参数表示提供通知信息的类型。</span><span class="sxs-lookup"><span data-stu-id="c0983-110">In the .NET Framework, the observer design pattern is applied by implementing the generic <xref:System.IObservable%601?displayProperty=nameWithType> and <xref:System.IObserver%601?displayProperty=nameWithType> interfaces.</span></span> <span data-ttu-id="c0983-111">泛型类型参数表示提供通知信息的类型。</span><span class="sxs-lookup"><span data-stu-id="c0983-111">The generic type parameter represents the type that provides notification information.</span></span>

## <a name="applying-the-pattern"></a><span data-ttu-id="c0983-112">应用模式</span><span class="sxs-lookup"><span data-stu-id="c0983-112">Applying the Pattern</span></span>

<span data-ttu-id="c0983-113">观察者设计模式适用于分布式基于推送的通知，因为它支持两个不同的组件或应用程序层（如数据源（业务逻辑）层和用户界面（显示）层）之间完全分离。</span><span class="sxs-lookup"><span data-stu-id="c0983-113">The observer design pattern is suitable for distributed push-based notifications, because it supports a clean separation between two different components or application layers, such as a data source (business logic) layer and a user interface (display) layer.</span></span> <span data-ttu-id="c0983-114">每当提供程序使用回调向其客户端提供当前信息时，均可以实现此模式。</span><span class="sxs-lookup"><span data-stu-id="c0983-114">The pattern can be implemented whenever a provider uses callbacks to supply its clients with current information.</span></span>

<span data-ttu-id="c0983-115">实现此模式要求提供以下内容：</span><span class="sxs-lookup"><span data-stu-id="c0983-115">Implementing the pattern requires that you provide the following:</span></span>

- <span data-ttu-id="c0983-116">提供程序或主题，即将通知发送给观察者的对象。</span><span class="sxs-lookup"><span data-stu-id="c0983-116">A provider or subject, which is the object that sends notifications to observers.</span></span> <span data-ttu-id="c0983-117">提供程序是实现 <xref:System.IObservable%601> 接口的类或结构。</span><span class="sxs-lookup"><span data-stu-id="c0983-117">A provider is a class or structure that implements the <xref:System.IObservable%601> interface.</span></span> <span data-ttu-id="c0983-118">提供程序必须实现单个方法 <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType>，该方法由希望从提供程序接收通知的观察者调用。</span><span class="sxs-lookup"><span data-stu-id="c0983-118">The provider must implement a single method, <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType>, which is called by observers that wish to receive notifications from the provider.</span></span>

- <span data-ttu-id="c0983-119">观察者，即从提供程序接收通知的对象。</span><span class="sxs-lookup"><span data-stu-id="c0983-119">An observer, which is an object that receives notifications from a provider.</span></span> <span data-ttu-id="c0983-120">观察者是实现 <xref:System.IObserver%601> 接口的类或结构。</span><span class="sxs-lookup"><span data-stu-id="c0983-120">An observer is a class or structure that implements the <xref:System.IObserver%601> interface.</span></span> <span data-ttu-id="c0983-121">观察者必须实现以下三个方法，这三个方法均由提供程序调用：</span><span class="sxs-lookup"><span data-stu-id="c0983-121">The observer must implement three methods, all of which are called by the provider:</span></span>

  - <span data-ttu-id="c0983-122"><xref:System.IObserver%601.OnNext%2A?displayProperty=nameWithType>，它向观察者提供新信息或当前信息。</span><span class="sxs-lookup"><span data-stu-id="c0983-122"><xref:System.IObserver%601.OnNext%2A?displayProperty=nameWithType>, which supplies the observer with new or current information.</span></span>

  - <span data-ttu-id="c0983-123"><xref:System.IObserver%601.OnError%2A?displayProperty=nameWithType>，它通知观察者已发生错误。</span><span class="sxs-lookup"><span data-stu-id="c0983-123"><xref:System.IObserver%601.OnError%2A?displayProperty=nameWithType>, which informs the observer that an error has occurred.</span></span>

  - <span data-ttu-id="c0983-124"><xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType>，它指示提供程序已完成发送通知。</span><span class="sxs-lookup"><span data-stu-id="c0983-124"><xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType>, which indicates that the provider has finished sending notifications.</span></span>

- <span data-ttu-id="c0983-125">允许提供程序跟踪观察者的一种机制。</span><span class="sxs-lookup"><span data-stu-id="c0983-125">A mechanism that allows the provider to keep track of observers.</span></span> <span data-ttu-id="c0983-126">通常情况下，提供程序使用容器对象（如 <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> 对象）来保存对已订阅通知的 <xref:System.IObserver%601> 实现的引用。</span><span class="sxs-lookup"><span data-stu-id="c0983-126">Typically, the provider uses a container object, such as a <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> object, to hold references to the <xref:System.IObserver%601> implementations that have subscribed to notifications.</span></span> <span data-ttu-id="c0983-127">将存储容器用于此目的使提供程序能够处理零到无限数量的观察者。</span><span class="sxs-lookup"><span data-stu-id="c0983-127">Using a storage container for this purpose enables the provider to handle zero to an unlimited number of observers.</span></span> <span data-ttu-id="c0983-128">未定义观察者接收通知的顺序；提供程序可以随意使用任何方法来确定顺序。</span><span class="sxs-lookup"><span data-stu-id="c0983-128">The order in which observers receive notifications is not defined; the provider is free to use any method to determine the order.</span></span>

- <span data-ttu-id="c0983-129"><xref:System.IDisposable> 实现，它使提供程序在能够通知完成时删除观察者。</span><span class="sxs-lookup"><span data-stu-id="c0983-129">An <xref:System.IDisposable> implementation that enables the provider to remove observers when notification is complete.</span></span> <span data-ttu-id="c0983-130">观察者从 <xref:System.IObservable%601.Subscribe%2A> 方法接收对 <xref:System.IDisposable> 实现的引用，因此它们还可以调用 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 方法，以便在提供程序已完成发送通知之前取消订阅。</span><span class="sxs-lookup"><span data-stu-id="c0983-130">Observers receive a reference to the <xref:System.IDisposable> implementation from the <xref:System.IObservable%601.Subscribe%2A> method, so they can also call the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method to unsubscribe before the provider has finished sending notifications.</span></span>

- <span data-ttu-id="c0983-131">包含提供程序发送到其观察者的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="c0983-131">An object that contains the data that the provider sends to its observers.</span></span> <span data-ttu-id="c0983-132">此对象的类型对应 <xref:System.IObservable%601> 和 <xref:System.IObserver%601> 接口的泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="c0983-132">The type of this object corresponds to the generic type parameter of the <xref:System.IObservable%601> and <xref:System.IObserver%601> interfaces.</span></span> <span data-ttu-id="c0983-133">尽管此对象可与 <xref:System.IObservable%601> 实现相同，但通常情况下，它是一个单独的类型。</span><span class="sxs-lookup"><span data-stu-id="c0983-133">Although this object can be the same as the <xref:System.IObservable%601> implementation, most commonly it is a separate type.</span></span>

> [!NOTE]
> <span data-ttu-id="c0983-134">除实现观察者设计模式外，你还可能对浏览使用 <xref:System.IObservable%601> 和 <xref:System.IObserver%601> 接口构建的库感兴趣。</span><span class="sxs-lookup"><span data-stu-id="c0983-134">In addition to implementing the observer design pattern, you may be interested in exploring libraries that are built using the <xref:System.IObservable%601> and <xref:System.IObserver%601> interfaces.</span></span> <span data-ttu-id="c0983-135">例如，[Reactive Extensions for .NET (Rx)](/previous-versions/dotnet/reactive-extensions/hh242985(v=vs.103)) 包含一组支持异步编程的扩展方法和 LINQ 标准序列运算符。</span><span class="sxs-lookup"><span data-stu-id="c0983-135">For example, [Reactive Extensions for .NET (Rx)](/previous-versions/dotnet/reactive-extensions/hh242985(v=vs.103)) consist of a set of extension methods and LINQ standard sequence operators to support asynchronous programming.</span></span>

## <a name="implementing-the-pattern"></a><span data-ttu-id="c0983-136">实现模式</span><span class="sxs-lookup"><span data-stu-id="c0983-136">Implementing the Pattern</span></span>

<span data-ttu-id="c0983-137">下面的示例使用观察者设计模式来实现机场行李认领信息系统。</span><span class="sxs-lookup"><span data-stu-id="c0983-137">The following example uses the observer design pattern to implement an airport baggage claim information system.</span></span> <span data-ttu-id="c0983-138">`BaggageInfo` 类提供有关到达航班以及可领取每次航班行李的行李传送带的信息。</span><span class="sxs-lookup"><span data-stu-id="c0983-138">A `BaggageInfo` class provides information about arriving flights and the carousels where baggage from each flight is available for pickup.</span></span> <span data-ttu-id="c0983-139">如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="c0983-139">It is shown in the following example.</span></span>

[!code-csharp[Conceptual.ObserverDesignPattern#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.observerdesignpattern/cs/provider.cs#1)]
[!code-vb[Conceptual.ObserverDesignPattern#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.observerdesignpattern/vb/provider.vb#1)]

<span data-ttu-id="c0983-140">`BaggageHandler` 类负责接收有关到达航班和行李认领传送带的信息。</span><span class="sxs-lookup"><span data-stu-id="c0983-140">A `BaggageHandler` class is responsible for receiving information about arriving flights and baggage claim carousels.</span></span> <span data-ttu-id="c0983-141">在内部，它维护两个集合：</span><span class="sxs-lookup"><span data-stu-id="c0983-141">Internally, it maintains two collections:</span></span>

- <span data-ttu-id="c0983-142">`observers` - 将接收更新的信息的客户端集合。</span><span class="sxs-lookup"><span data-stu-id="c0983-142">`observers` - A collection of clients that will receive updated information.</span></span>

- <span data-ttu-id="c0983-143">`flights` - 航班及其指定行李传送带的集合。</span><span class="sxs-lookup"><span data-stu-id="c0983-143">`flights` - A collection of flights and their assigned carousels.</span></span>

<span data-ttu-id="c0983-144">这两个集合都由在 `BaggageHandler` 类构造函数中实例化的泛型 <xref:System.Collections.Generic.List%601> 对象表示。</span><span class="sxs-lookup"><span data-stu-id="c0983-144">Both collections are represented by generic <xref:System.Collections.Generic.List%601> objects that are instantiated in the `BaggageHandler` class constructor.</span></span> <span data-ttu-id="c0983-145">下面的示例演示了 `BaggageHandler` 类的源代码。</span><span class="sxs-lookup"><span data-stu-id="c0983-145">The source code for the `BaggageHandler` class is shown in the following example.</span></span>

[!code-csharp[Conceptual.ObserverDesignPattern#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.observerdesignpattern/cs/provider.cs#2)]
[!code-vb[Conceptual.ObserverDesignPattern#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.observerdesignpattern/vb/provider.vb#2)]

<span data-ttu-id="c0983-146">想要接收更新的信息的客户端调用 `BaggageHandler.Subscribe` 方法。</span><span class="sxs-lookup"><span data-stu-id="c0983-146">Clients that wish to receive updated information call the `BaggageHandler.Subscribe` method.</span></span> <span data-ttu-id="c0983-147">如果客户端以前未订阅通知，则将对客户端的 <xref:System.IObserver%601> 实现的引用添加到 `observers` 集合中。</span><span class="sxs-lookup"><span data-stu-id="c0983-147">If the client has not previously subscribed to notifications, a reference to the client's <xref:System.IObserver%601> implementation is added to the `observers` collection.</span></span>

<span data-ttu-id="c0983-148">可调用重载的 `BaggageHandler.BaggageStatus` 方法来指示是正在卸载航班行李还是不再卸载航班行李。</span><span class="sxs-lookup"><span data-stu-id="c0983-148">The overloaded `BaggageHandler.BaggageStatus` method can be called to indicate that baggage from a flight either is being unloaded or is no longer being unloaded.</span></span> <span data-ttu-id="c0983-149">在第一种情况下，该方法传递航班号、航班起飞机场和正在卸载行李的传送带。</span><span class="sxs-lookup"><span data-stu-id="c0983-149">In the first case, the method is passed a flight number, the airport from which the flight originated, and the carousel where baggage is being unloaded.</span></span> <span data-ttu-id="c0983-150">在第二种情况下，该方法仅传递航班号。</span><span class="sxs-lookup"><span data-stu-id="c0983-150">In the second case, the method is passed only a flight number.</span></span> <span data-ttu-id="c0983-151">对于正在卸载的行李，该方法检查传递到方法的 `BaggageInfo` 信息是否存在于 `flights` 集合中。</span><span class="sxs-lookup"><span data-stu-id="c0983-151">For baggage that is being unloaded, the method checks whether the `BaggageInfo` information passed to the method exists in the `flights` collection.</span></span> <span data-ttu-id="c0983-152">如果不存在，该方法将添加信息，并调用每个观察者的 `OnNext` 方法。</span><span class="sxs-lookup"><span data-stu-id="c0983-152">If it does not, the method adds the information and calls each observer's `OnNext` method.</span></span> <span data-ttu-id="c0983-153">对于不再卸载其行李的航班，该方法检查此航班的相关信息是否存储在 `flights` 集合中。</span><span class="sxs-lookup"><span data-stu-id="c0983-153">For flights whose baggage is no longer being unloaded, the method checks whether information on that flight is stored in the `flights` collection.</span></span> <span data-ttu-id="c0983-154">如果是，则该方法调用每个观察者的 `OnNext` 方法，并从 `flights` 集合中删除 `BaggageInfo` 对象。</span><span class="sxs-lookup"><span data-stu-id="c0983-154">If it is, the method calls each observer's `OnNext` method and removes the `BaggageInfo` object from the `flights` collection.</span></span>

<span data-ttu-id="c0983-155">当一天中的最后一个航班已着陆并且已处理了其行李时，调用 `BaggageHandler.LastBaggageClaimed` 方法。</span><span class="sxs-lookup"><span data-stu-id="c0983-155">When the last flight of the day has landed and its baggage has been processed, the `BaggageHandler.LastBaggageClaimed` method is called.</span></span> <span data-ttu-id="c0983-156">此方法调用每个观察者的 `OnCompleted` 方法来指示所有通知均已完成，然后再清除 `observers` 集合。</span><span class="sxs-lookup"><span data-stu-id="c0983-156">This method calls each observer's `OnCompleted` method to indicate that all notifications have completed, and then clears the `observers` collection.</span></span>

<span data-ttu-id="c0983-157">提供程序的 <xref:System.IObservable%601.Subscribe%2A> 方法将返回 <xref:System.IDisposable> 实现，该实现可使观察者在调用 <xref:System.IObserver%601.OnCompleted%2A> 方法之前停止接收通知。</span><span class="sxs-lookup"><span data-stu-id="c0983-157">The provider's <xref:System.IObservable%601.Subscribe%2A> method returns an <xref:System.IDisposable> implementation that enables observers to stop receiving notifications before the <xref:System.IObserver%601.OnCompleted%2A> method is called.</span></span> <span data-ttu-id="c0983-158">下面的示例演示了 `Unsubscriber(Of BaggageInfo)` 类的源代码。</span><span class="sxs-lookup"><span data-stu-id="c0983-158">The source code for this `Unsubscriber(Of BaggageInfo)` class is shown in the following example.</span></span> <span data-ttu-id="c0983-159">此类在 `BaggageHandler.Subscribe` 方法中实例化时，它将传递对 `observers` 集合的引用以及对添加到集合中的观察者的引用。</span><span class="sxs-lookup"><span data-stu-id="c0983-159">When the class is instantiated in the `BaggageHandler.Subscribe` method, it is passed a reference to the `observers` collection and a reference to the observer that is added to the collection.</span></span> <span data-ttu-id="c0983-160">这些引用被分配给局部变量。</span><span class="sxs-lookup"><span data-stu-id="c0983-160">These references are assigned to local variables.</span></span> <span data-ttu-id="c0983-161">调用对象的 `Dispose` 方法时，它会检查观察者是否仍存在于 `observers` 集合中，如果存在，则删除观察者。</span><span class="sxs-lookup"><span data-stu-id="c0983-161">When the object's `Dispose` method is called, it checks whether the observer still exists in the `observers` collection, and, if it does, removes the observer.</span></span>

[!code-csharp[Conceptual.ObserverDesignPattern#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.observerdesignpattern/cs/provider.cs#3)]
[!code-vb[Conceptual.ObserverDesignPattern#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.observerdesignpattern/vb/provider.vb#3)]

<span data-ttu-id="c0983-162">下面的示例提供了名为 `ArrivalsMonitor` 的 <xref:System.IObserver%601> 实现，它是一个显示行李认领信息的基类。</span><span class="sxs-lookup"><span data-stu-id="c0983-162">The following example provides an <xref:System.IObserver%601> implementation named `ArrivalsMonitor`, which is a base class that displays baggage claim information.</span></span> <span data-ttu-id="c0983-163">根据始发城市的名称，按字母顺序显示信息。</span><span class="sxs-lookup"><span data-stu-id="c0983-163">The information is displayed alphabetically, by the name of the originating city.</span></span> <span data-ttu-id="c0983-164">将 `ArrivalsMonitor` 的方法标记为 `overridable`（在 Visual Basic 中）或 `virtual`（在 C# 中），因此它们都可由派生类重写。</span><span class="sxs-lookup"><span data-stu-id="c0983-164">The methods of `ArrivalsMonitor` are marked as `overridable` (in Visual Basic) or `virtual` (in C#), so they can all be overridden by a derived class.</span></span>

[!code-csharp[Conceptual.ObserverDesignPattern#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.observerdesignpattern/cs/observer.cs#4)]
[!code-vb[Conceptual.ObserverDesignPattern#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.observerdesignpattern/vb/observer.vb#4)]

<span data-ttu-id="c0983-165">`ArrivalsMonitor` 类包括 `Subscribe` 和 `Unsubscribe` 方法。</span><span class="sxs-lookup"><span data-stu-id="c0983-165">The `ArrivalsMonitor` class includes the `Subscribe` and `Unsubscribe` methods.</span></span> <span data-ttu-id="c0983-166">`Subscribe` 方法使类可将由对 <xref:System.IObservable%601.Subscribe%2A> 的调用返回的 <xref:System.IDisposable> 实现保存到私有变量中。</span><span class="sxs-lookup"><span data-stu-id="c0983-166">The `Subscribe` method enables the class to save the <xref:System.IDisposable> implementation returned by the call to <xref:System.IObservable%601.Subscribe%2A> to a private variable.</span></span> <span data-ttu-id="c0983-167">`Unsubscribe` 方法使类可以通过调用提供程序的 <xref:System.IDisposable.Dispose%2A> 实现来取消订阅通知。</span><span class="sxs-lookup"><span data-stu-id="c0983-167">The `Unsubscribe` method enables the class to unsubscribe from notifications by calling the provider's <xref:System.IDisposable.Dispose%2A> implementation.</span></span> <span data-ttu-id="c0983-168">`ArrivalsMonitor` 也提供 <xref:System.IObserver%601.OnNext%2A>、<xref:System.IObserver%601.OnError%2A> 和 <xref:System.IObserver%601.OnCompleted%2A> 方法的实现。</span><span class="sxs-lookup"><span data-stu-id="c0983-168">`ArrivalsMonitor` also provides implementations of the <xref:System.IObserver%601.OnNext%2A>, <xref:System.IObserver%601.OnError%2A>, and <xref:System.IObserver%601.OnCompleted%2A> methods.</span></span> <span data-ttu-id="c0983-169">仅 <xref:System.IObserver%601.OnNext%2A> 实现包含大量的代码。</span><span class="sxs-lookup"><span data-stu-id="c0983-169">Only the <xref:System.IObserver%601.OnNext%2A> implementation contains a significant amount of code.</span></span> <span data-ttu-id="c0983-170">该方法处理私有的、已排序的泛型 <xref:System.Collections.Generic.List%601> 对象，该对象维护有关抵港航班的始发机场以及可提取行李的传送带的信息。</span><span class="sxs-lookup"><span data-stu-id="c0983-170">The method works with a private, sorted, generic <xref:System.Collections.Generic.List%601> object that maintains information about the airports of origin for arriving flights and the carousels on which their baggage is available.</span></span> <span data-ttu-id="c0983-171">如果 `BaggageHandler` 类报告新的航班抵达，则 <xref:System.IObserver%601.OnNext%2A> 方法实现将该航班的相关信息添加到列表中。</span><span class="sxs-lookup"><span data-stu-id="c0983-171">If the `BaggageHandler` class reports a new flight arrival, the <xref:System.IObserver%601.OnNext%2A> method implementation adds information about that flight to the list.</span></span> <span data-ttu-id="c0983-172">如果 `BaggageHandler` 类报告已卸载该航班的行李，则 <xref:System.IObserver%601.OnNext%2A> 方法从列表中移除该航班。</span><span class="sxs-lookup"><span data-stu-id="c0983-172">If the `BaggageHandler` class reports that the flight's baggage has been unloaded, the <xref:System.IObserver%601.OnNext%2A> method removes that flight from the list.</span></span> <span data-ttu-id="c0983-173">每当进行了更改，就会对列表进行排序并向控制台显示。</span><span class="sxs-lookup"><span data-stu-id="c0983-173">Whenever a change is made, the list is sorted and displayed to the console.</span></span>

<span data-ttu-id="c0983-174">下面的示例包含对 `BaggageHandler` 类以及对 `ArrivalsMonitor` 类的两个实例进行实例化的应用程序入口点，并使用 `BaggageHandler.BaggageStatus` 方法来添加和删除有关抵港航班的信息。</span><span class="sxs-lookup"><span data-stu-id="c0983-174">The following example contains the application entry point that instantiates the `BaggageHandler` class as well as two instances of the `ArrivalsMonitor` class, and uses the `BaggageHandler.BaggageStatus` method to add and remove information about arriving flights.</span></span> <span data-ttu-id="c0983-175">在每种情况下，观察者均接收更新，并且正确显示行李认领信息。</span><span class="sxs-lookup"><span data-stu-id="c0983-175">In each case, the observers receive updates and correctly display baggage claim information.</span></span>

[!code-csharp[Conceptual.ObserverDesignPattern#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.observerdesignpattern/cs/program.cs#5)]
[!code-vb[Conceptual.ObserverDesignPattern#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.observerdesignpattern/vb/module1.vb#5)]

## <a name="related-topics"></a><span data-ttu-id="c0983-176">相关主题</span><span class="sxs-lookup"><span data-stu-id="c0983-176">Related Topics</span></span>

|<span data-ttu-id="c0983-177">Title</span><span class="sxs-lookup"><span data-stu-id="c0983-177">Title</span></span>|<span data-ttu-id="c0983-178">描述</span><span class="sxs-lookup"><span data-stu-id="c0983-178">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="c0983-179">监视程序设计模式最佳做法</span><span class="sxs-lookup"><span data-stu-id="c0983-179">Observer Design Pattern Best Practices</span></span>](observer-design-pattern-best-practices.md)|<span data-ttu-id="c0983-180">描述开发实现观察者设计模式的应用程序时要采用的最佳做法。</span><span class="sxs-lookup"><span data-stu-id="c0983-180">Describes best practices to adopt when developing applications that implement the observer design pattern.</span></span>|
|[<span data-ttu-id="c0983-181">如何：实现提供程序</span><span class="sxs-lookup"><span data-stu-id="c0983-181">How to: Implement a Provider</span></span>](how-to-implement-a-provider.md)|<span data-ttu-id="c0983-182">为温度监控应用程序提供一个提供程序的分步实现。</span><span class="sxs-lookup"><span data-stu-id="c0983-182">Provides a step-by-step implementation of a provider for a temperature monitoring application.</span></span>|
|[<span data-ttu-id="c0983-183">如何：实现监视程序</span><span class="sxs-lookup"><span data-stu-id="c0983-183">How to: Implement an Observer</span></span>](how-to-implement-an-observer.md)|<span data-ttu-id="c0983-184">为温度监控应用程序提供一个观察者的分步实现。</span><span class="sxs-lookup"><span data-stu-id="c0983-184">Provides a step-by-step implementation of an observer for a temperature monitoring application.</span></span>|
