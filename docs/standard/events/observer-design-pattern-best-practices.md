---
title: 观察程序设计模式最佳做法
ms.date: 03/30/2017
helpviewer_keywords:
- observer design pattern [.NET], best practices
- best practices [.NET], observer design pattern
ms.assetid: c834760f-ddd4-417f-abb7-a059679d5b8c
ms.openlocfilehash: d88b092e681258566da685e3bb130b3d6131be08
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/24/2020
ms.locfileid: "95697579"
---
# <a name="observer-design-pattern-best-practices"></a><span data-ttu-id="85f5f-102">观察程序设计模式最佳做法</span><span class="sxs-lookup"><span data-stu-id="85f5f-102">Observer Design Pattern Best Practices</span></span>

<span data-ttu-id="85f5f-103">在 .NET 中，将观察者设计模式作为一组接口实现。</span><span class="sxs-lookup"><span data-stu-id="85f5f-103">In .NET, the observer design pattern is implemented as a set of interfaces.</span></span> <span data-ttu-id="85f5f-104"><xref:System.IObservable%601?displayProperty=nameWithType> 接口表示数据提供程序，也负责提供允许观察者取消订阅通知的 <xref:System.IDisposable> 实现。</span><span class="sxs-lookup"><span data-stu-id="85f5f-104">The <xref:System.IObservable%601?displayProperty=nameWithType> interface represents the data provider, which is also responsible for providing an <xref:System.IDisposable> implementation that lets observers unsubscribe from notifications.</span></span> <span data-ttu-id="85f5f-105"><xref:System.IObserver%601?displayProperty=nameWithType> 接口表示观察者。</span><span class="sxs-lookup"><span data-stu-id="85f5f-105">The <xref:System.IObserver%601?displayProperty=nameWithType> interface represents the observer.</span></span> <span data-ttu-id="85f5f-106">本主题描述使用这些接口实现观察者设计模式时开发人员应遵循的最佳做法。</span><span class="sxs-lookup"><span data-stu-id="85f5f-106">This topic describes the best practices that developers should follow when implementing the observer design pattern using these interfaces.</span></span>  
  
## <a name="threading"></a><span data-ttu-id="85f5f-107">线程</span><span class="sxs-lookup"><span data-stu-id="85f5f-107">Threading</span></span>  

 <span data-ttu-id="85f5f-108">提供程序通常通过向由一些集合对象表示的订阅者列表添加特定观察者来实现 <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType> 方法，并通过从订阅者列表中删除特定观察者来实现 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="85f5f-108">Typically, a provider implements the <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType> method by adding a particular observer to a subscriber list that is represented by some collection object, and it implements the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method by removing a particular observer from the subscriber list.</span></span> <span data-ttu-id="85f5f-109">观察者可在任何时候调用这些方法。</span><span class="sxs-lookup"><span data-stu-id="85f5f-109">An observer can call these methods at any time.</span></span> <span data-ttu-id="85f5f-110">此外，由于提供程序/观察者协定未指定由谁负责在 <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> 回调方法后取消订阅，因此提供程序和观察者都可能尝试从列表中删除相同成员。</span><span class="sxs-lookup"><span data-stu-id="85f5f-110">In addition, because the provider/observer contract does not specify who is responsible for unsubscribing after the <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> callback method, the provider and observer may both try to remove the same member from the list.</span></span> <span data-ttu-id="85f5f-111">由于这种可能性，<xref:System.IObservable%601.Subscribe%2A> 和 <xref:System.IDisposable.Dispose%2A> 方法都应该是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="85f5f-111">Because of this possibility, both the <xref:System.IObservable%601.Subscribe%2A> and <xref:System.IDisposable.Dispose%2A> methods should be thread-safe.</span></span> <span data-ttu-id="85f5f-112">这通常需要使用[并发回收](../parallel-programming/data-structures-for-parallel-programming.md)或锁。</span><span class="sxs-lookup"><span data-stu-id="85f5f-112">Typically, this involves using a [concurrent collection](../parallel-programming/data-structures-for-parallel-programming.md) or a lock.</span></span> <span data-ttu-id="85f5f-113">非线程安全的实现应显式注明它们非线程安全。</span><span class="sxs-lookup"><span data-stu-id="85f5f-113">Implementations that are not thread-safe should explicitly document that they are not.</span></span>  
  
 <span data-ttu-id="85f5f-114">任何其他保证均须在提供程序/观察者协定之上指定。</span><span class="sxs-lookup"><span data-stu-id="85f5f-114">Any additional guarantees have to be specified in a layer on top of the provider/observer contract.</span></span> <span data-ttu-id="85f5f-115">实施者应清楚地调出何时施加其他需求，从而避免用户对观察者协定产生混淆。</span><span class="sxs-lookup"><span data-stu-id="85f5f-115">Implementers should clearly call out when they impose additional requirements to avoid user confusion about the observer contract.</span></span>  
  
## <a name="handling-exceptions"></a><span data-ttu-id="85f5f-116">处理异常</span><span class="sxs-lookup"><span data-stu-id="85f5f-116">Handling Exceptions</span></span>  

 <span data-ttu-id="85f5f-117">由于数据提供程序和观察者之间的松耦合，观察者设计模式中的异常旨在提供信息。</span><span class="sxs-lookup"><span data-stu-id="85f5f-117">Because of the loose coupling between a data provider and an observer, exceptions in the observer design pattern are intended to be informational.</span></span> <span data-ttu-id="85f5f-118">这会影响提供程序和观察者处理观察者设计模式中的异常的方式。</span><span class="sxs-lookup"><span data-stu-id="85f5f-118">This affects how providers and observers handle exceptions in the observer design pattern.</span></span>  
  
### <a name="the-provider----calling-the-onerror-method"></a><span data-ttu-id="85f5f-119">提供者 -- 调用 OnError 方法</span><span class="sxs-lookup"><span data-stu-id="85f5f-119">The Provider -- Calling the OnError Method</span></span>  

 <span data-ttu-id="85f5f-120"><xref:System.IObserver%601.OnError%2A> 方法提供旨在给观察者提供信息性消息，正如 <xref:System.IObserver%601.OnNext%2A?displayProperty=nameWithType> 方法一样。</span><span class="sxs-lookup"><span data-stu-id="85f5f-120">The <xref:System.IObserver%601.OnError%2A> method is intended as an informational message to observers, much like the <xref:System.IObserver%601.OnNext%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="85f5f-121">然而，<xref:System.IObserver%601.OnNext%2A> 方法旨在为观察者提供当前数据或已更新数据，而 <xref:System.IObserver%601.OnError%2A> 方法旨在表明该提供程序不能提供有效的数据。</span><span class="sxs-lookup"><span data-stu-id="85f5f-121">However, the <xref:System.IObserver%601.OnNext%2A> method is designed to provide an observer with current or updated data, whereas the <xref:System.IObserver%601.OnError%2A> method is designed to indicate that the provider is unable to provide valid data.</span></span>  
  
 <span data-ttu-id="85f5f-122">在处理异常和调用 <xref:System.IObserver%601.OnError%2A> 方法时，提供程序应遵循以下最佳做法并：</span><span class="sxs-lookup"><span data-stu-id="85f5f-122">The provider should follow these best practices when handling exceptions and calling the <xref:System.IObserver%601.OnError%2A> method:</span></span>  
  
- <span data-ttu-id="85f5f-123">如果提供程序有任何具体需求，则它必须处理自己的异常。</span><span class="sxs-lookup"><span data-stu-id="85f5f-123">The provider must handle its own exceptions if it has any specific requirements.</span></span>  
  
- <span data-ttu-id="85f5f-124">提供程序不应期望或要求观察者以任何特定方式处理异常。</span><span class="sxs-lookup"><span data-stu-id="85f5f-124">The provider should not expect or require that observers handle exceptions in any particular way.</span></span>  
  
- <span data-ttu-id="85f5f-125">提供程序应在处理削弱其提供更新的能力的异常时调用 <xref:System.IObserver%601.OnError%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="85f5f-125">The provider should call the <xref:System.IObserver%601.OnError%2A> method when it handles an exception that compromises its ability to provide updates.</span></span> <span data-ttu-id="85f5f-126">可将有关这种异常的信息传递给观察者。</span><span class="sxs-lookup"><span data-stu-id="85f5f-126">Information on such exceptions can be passed to the observer.</span></span> <span data-ttu-id="85f5f-127">在其他情况下，则无需通知观察器有异常。</span><span class="sxs-lookup"><span data-stu-id="85f5f-127">In other cases, there is no need to notify observers of an exception.</span></span>  
  
 <span data-ttu-id="85f5f-128">只要提供程序调用了 <xref:System.IObserver%601.OnError%2A> 或 <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> 方法，就不应有进一步的通知，并且提供程序可以取消订阅其观察者。</span><span class="sxs-lookup"><span data-stu-id="85f5f-128">Once the provider calls the <xref:System.IObserver%601.OnError%2A> or <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> method, there should be no further notifications, and the provider can unsubscribe its observers.</span></span> <span data-ttu-id="85f5f-129">然而，观察者也可以在任何时候取消订阅他们自己，包括在他们收到 <xref:System.IObserver%601.OnError%2A> 或<xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> 通知前后。</span><span class="sxs-lookup"><span data-stu-id="85f5f-129">However, the observers can also unsubscribe themselves at any time, including both before and after they receive an <xref:System.IObserver%601.OnError%2A> or <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> notification.</span></span> <span data-ttu-id="85f5f-130">观察者设计模式并未规定负责取消订阅的提供程序还是观察者；因此，可能这两者都试图取消订阅。</span><span class="sxs-lookup"><span data-stu-id="85f5f-130">The observer design pattern does not dictate whether the provider or the observer is responsible for unsubscribing; therefore, there is a possibility that both may attempt to unsubscribe.</span></span> <span data-ttu-id="85f5f-131">通常情况下，当观察者取消订阅时，会从订阅者集合中把他们删除。</span><span class="sxs-lookup"><span data-stu-id="85f5f-131">Typically, when observers unsubscribe, they are removed from a subscribers collection.</span></span> <span data-ttu-id="85f5f-132">在单线程应用程序中，<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 实现应确保对象引用有效，并在尝试删除对象前确保该对象是订阅者集合的成员。</span><span class="sxs-lookup"><span data-stu-id="85f5f-132">In a single-threaded application, the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation should ensure that an object reference is valid and that the object is a member of the subscribers collection before attempting to remove it.</span></span> <span data-ttu-id="85f5f-133">在多线程应用程序中，应使用诸如 <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> 对象的线程安全集合对象。</span><span class="sxs-lookup"><span data-stu-id="85f5f-133">In a multithreaded application, a thread-safe collection object, such as a <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> object, should be used.</span></span>  
  
### <a name="the-observer----implementing-the-onerror-method"></a><span data-ttu-id="85f5f-134">观察者 -- 实现 OnError 方法</span><span class="sxs-lookup"><span data-stu-id="85f5f-134">The Observer -- Implementing the OnError Method</span></span>  

 <span data-ttu-id="85f5f-135">当观察者收到来自提供程序的错误通知时，应将异常视为信息，且不需采取任何特殊操作。</span><span class="sxs-lookup"><span data-stu-id="85f5f-135">When an observer receives an error notification from a provider, the observer should treat the exception as informational and should not be required to take any particular action.</span></span>  
  
 <span data-ttu-id="85f5f-136">在回应从提供程序调用的 <xref:System.IObserver%601.OnError%2A> 方法时，观察者应遵循以下最佳做法：</span><span class="sxs-lookup"><span data-stu-id="85f5f-136">The observer should follow these best practices when responding to an <xref:System.IObserver%601.OnError%2A> method call from a provider:</span></span>  
  
- <span data-ttu-id="85f5f-137">观察者不应从其接口实现引发异常，如 <xref:System.IObserver%601.OnNext%2A> 或 <xref:System.IObserver%601.OnError%2A>。</span><span class="sxs-lookup"><span data-stu-id="85f5f-137">The observer should not throw exceptions from its interface implementations, such as <xref:System.IObserver%601.OnNext%2A> or <xref:System.IObserver%601.OnError%2A>.</span></span> <span data-ttu-id="85f5f-138">但如果观察者确实引发了异常，应预计到这些异常不会得到处理。</span><span class="sxs-lookup"><span data-stu-id="85f5f-138">However, if the observer does throw exceptions, it should expect these exceptions to go unhandled.</span></span>  
  
- <span data-ttu-id="85f5f-139">若要保留调用堆栈，希望引发传递到 <xref:System.Exception> 方法的 <xref:System.IObserver%601.OnError%2A> 对象的观察者应在引发之前包装该异常。</span><span class="sxs-lookup"><span data-stu-id="85f5f-139">To preserve the call stack, an observer that wishes to throw an <xref:System.Exception> object that was passed to its <xref:System.IObserver%601.OnError%2A> method should wrap the exception before throwing it.</span></span> <span data-ttu-id="85f5f-140">为此，应使用标准异常对象。</span><span class="sxs-lookup"><span data-stu-id="85f5f-140">A standard exception object should be used for this purpose.</span></span>  
  
## <a name="additional-best-practices"></a><span data-ttu-id="85f5f-141">其他最佳做法</span><span class="sxs-lookup"><span data-stu-id="85f5f-141">Additional Best Practices</span></span>  

 <span data-ttu-id="85f5f-142">尝试在 <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType> 方法中取消注册可能会导致空引用。</span><span class="sxs-lookup"><span data-stu-id="85f5f-142">Attempting to unregister in the <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType> method may result in a null reference.</span></span> <span data-ttu-id="85f5f-143">因此，我们建议你避免这种做法。</span><span class="sxs-lookup"><span data-stu-id="85f5f-143">Therefore, we recommend that you avoid this practice.</span></span>  
  
 <span data-ttu-id="85f5f-144">虽然可将观察者附加到多个提供程序到，建议的模式是将 <xref:System.IObserver%601> 实例附加到唯一的 <xref:System.IObservable%601> 实例。</span><span class="sxs-lookup"><span data-stu-id="85f5f-144">Although it is possible to attach an observer to multiple providers, the recommended pattern is to attach an <xref:System.IObserver%601> instance to only one <xref:System.IObservable%601> instance.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="85f5f-145">另请参阅</span><span class="sxs-lookup"><span data-stu-id="85f5f-145">See also</span></span>

- [<span data-ttu-id="85f5f-146">观察程序设计模式</span><span class="sxs-lookup"><span data-stu-id="85f5f-146">Observer Design Pattern</span></span>](observer-design-pattern.md)
- [<span data-ttu-id="85f5f-147">如何：实现监视程序</span><span class="sxs-lookup"><span data-stu-id="85f5f-147">How to: Implement an Observer</span></span>](how-to-implement-an-observer.md)
- [<span data-ttu-id="85f5f-148">如何：实现提供程序</span><span class="sxs-lookup"><span data-stu-id="85f5f-148">How to: Implement a Provider</span></span>](how-to-implement-a-provider.md)
