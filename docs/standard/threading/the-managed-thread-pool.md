---
title: 托管线程池
description: 了解提供后台工作线程的 .NET 线程池
ms.date: 08/02/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- thread pooling [.NET]
- thread pools [.NET]
- threading [.NET], thread pool
- threading [.NET], pooling
ms.assetid: 2be05b06-a42e-4c9d-a739-96c21d673927
ms.openlocfilehash: 2671ce7c9721b15de8a3805da27040e973a62804
ms.sourcegitcommit: 67ebdb695fd017d79d9f1f7f35d145042d5a37f7
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/20/2020
ms.locfileid: "92223788"
---
# <a name="the-managed-thread-pool"></a><span data-ttu-id="539ac-103">托管线程池</span><span class="sxs-lookup"><span data-stu-id="539ac-103">The managed thread pool</span></span>

<span data-ttu-id="539ac-104"><xref:System.Threading.ThreadPool?displayProperty=nameWithType> 类为你的应用程序提供一个受系统管理的辅助线程池，从而使你能够专注于应用程序任务，而非线程管理。</span><span class="sxs-lookup"><span data-stu-id="539ac-104">The <xref:System.Threading.ThreadPool?displayProperty=nameWithType> class provides your application with a pool of worker threads that are managed by the system, allowing you to concentrate on application tasks rather than thread management.</span></span> <span data-ttu-id="539ac-105">如果有需要后台处理的短任务，托管的线程池则为利用多个线程的简便方法。</span><span class="sxs-lookup"><span data-stu-id="539ac-105">If you have short tasks that require background processing, the managed thread pool is an easy way to take advantage of multiple threads.</span></span> <span data-ttu-id="539ac-106">在 Framework 4 及更高版本中使用线程池容易得多，因为可以创建在线程池线程上执行异步任务的 <xref:System.Threading.Tasks.Task> 和 <xref:System.Threading.Tasks.Task%601> 对象。</span><span class="sxs-lookup"><span data-stu-id="539ac-106">Use of the thread pool is significantly easier in Framework 4 and later, since you can create <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects that perform asynchronous tasks on thread pool threads.</span></span>  
  
<span data-ttu-id="539ac-107">.NET 将线程池线程用于多种用途，包括[任务并行库 (TPL)](../parallel-programming/task-parallel-library-tpl.md) 操作、异步 I/O 完成、[计时器](timers.md)回调、注册的等待操作、使用委托的异步方法调用和 <xref:System.Net?displayProperty=nameWithType> 套接字连接。</span><span class="sxs-lookup"><span data-stu-id="539ac-107">.NET uses thread pool threads for many purposes, including [Task Parallel Library (TPL)](../parallel-programming/task-parallel-library-tpl.md) operations, asynchronous I/O completion, [timer](timers.md) callbacks, registered wait operations, asynchronous method calls using delegates, and <xref:System.Net?displayProperty=nameWithType> socket connections.</span></span>  

## <a name="thread-pool-characteristics"></a><span data-ttu-id="539ac-108">线程池特征</span><span class="sxs-lookup"><span data-stu-id="539ac-108">Thread pool characteristics</span></span>

<span data-ttu-id="539ac-109">线程池线程是[后台](foreground-and-background-threads.md)线程。</span><span class="sxs-lookup"><span data-stu-id="539ac-109">Thread pool threads are [background](foreground-and-background-threads.md) threads.</span></span> <span data-ttu-id="539ac-110">每个线程均使用默认的堆栈大小，以默认的优先级运行，并且位于多线程单元中。</span><span class="sxs-lookup"><span data-stu-id="539ac-110">Each thread uses the default stack size, runs at the default priority, and is in the multithreaded apartment.</span></span> <span data-ttu-id="539ac-111">一旦线程池中的线程完成任务，它将返回到等待线程队列中。</span><span class="sxs-lookup"><span data-stu-id="539ac-111">Once a thread in the thread pool completes its task, it's returned to a queue of waiting threads.</span></span> <span data-ttu-id="539ac-112">这时开始即可重用它。</span><span class="sxs-lookup"><span data-stu-id="539ac-112">From this moment it can be reused.</span></span> <span data-ttu-id="539ac-113">通过这种重复使用，应用程序可以避免产生为每个任务创建新线程的开销。</span><span class="sxs-lookup"><span data-stu-id="539ac-113">This reuse enables applications to avoid the cost of creating a new thread for each task.</span></span>
  
<span data-ttu-id="539ac-114">每个进程只有一个线程池。</span><span class="sxs-lookup"><span data-stu-id="539ac-114">There is only one thread pool per process.</span></span>  
  
### <a name="exceptions-in-thread-pool-threads"></a><span data-ttu-id="539ac-115">线程池线程中的异常</span><span class="sxs-lookup"><span data-stu-id="539ac-115">Exceptions in thread pool threads</span></span>

<span data-ttu-id="539ac-116">线程池线程中未经处理的异常终止该进程。</span><span class="sxs-lookup"><span data-stu-id="539ac-116">Unhandled exceptions in thread pool threads terminate the process.</span></span> <span data-ttu-id="539ac-117">以下为此规则的三种例外情况：</span><span class="sxs-lookup"><span data-stu-id="539ac-117">There are three exceptions to this rule:</span></span>  
  
- <span data-ttu-id="539ac-118"><xref:System.Threading.ThreadAbortException?displayProperty=nameWithType> 在线程池线程中引发，因为调用了 <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="539ac-118">A <xref:System.Threading.ThreadAbortException?displayProperty=nameWithType> is thrown in a thread pool thread because <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> was called.</span></span>  
- <span data-ttu-id="539ac-119"><xref:System.AppDomainUnloadedException?displayProperty=nameWithType> 在线程池线程中引发，因为正在卸载应用程序域。</span><span class="sxs-lookup"><span data-stu-id="539ac-119">A <xref:System.AppDomainUnloadedException?displayProperty=nameWithType> is thrown in a thread pool thread because the application domain is being unloaded.</span></span>  
- <span data-ttu-id="539ac-120">公共语言运行时或主机进程将终止该线程。</span><span class="sxs-lookup"><span data-stu-id="539ac-120">The common language runtime or a host process terminates the thread.</span></span>  
  
<span data-ttu-id="539ac-121">有关详细信息，请参阅[托管线程异常](exceptions-in-managed-threads.md)。</span><span class="sxs-lookup"><span data-stu-id="539ac-121">For more information, see [Exceptions in Managed Threads](exceptions-in-managed-threads.md).</span></span>  
  
### <a name="maximum-number-of-thread-pool-threads"></a><span data-ttu-id="539ac-122">最大线程池线程数</span><span class="sxs-lookup"><span data-stu-id="539ac-122">Maximum number of thread pool threads</span></span>

<span data-ttu-id="539ac-123">可以排队到线程池中的操作数仅受可用内存限制。</span><span class="sxs-lookup"><span data-stu-id="539ac-123">The number of operations that can be queued to the thread pool is limited only by available memory.</span></span> <span data-ttu-id="539ac-124">但是，线程池会限制进程中可同时处于活动状态的线程数。</span><span class="sxs-lookup"><span data-stu-id="539ac-124">However, the thread pool limits the number of threads that can be active in the process simultaneously.</span></span> <span data-ttu-id="539ac-125">如果所有线程池线程都处于忙碌状态，则其他工作项将进行排队，直到要执行它们的线程空闲。</span><span class="sxs-lookup"><span data-stu-id="539ac-125">If all thread pool threads are busy, additional work items are queued until threads to execute them become available.</span></span> <span data-ttu-id="539ac-126">从 .NET Framework 4 开始，进程的线程池的默认大小取决于若干因素，例如虚拟地址空间的大小。</span><span class="sxs-lookup"><span data-stu-id="539ac-126">Beginning with the .NET Framework 4, the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="539ac-127">进程可以调用 <xref:System.Threading.ThreadPool.GetMaxThreads%2A?displayProperty=nameWithType> 方法，以确定线程数。</span><span class="sxs-lookup"><span data-stu-id="539ac-127">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A?displayProperty=nameWithType> method to determine the number of threads.</span></span>  
  
<span data-ttu-id="539ac-128">可以使用 <xref:System.Threading.ThreadPool.GetMaxThreads%2A?displayProperty=nameWithType> 和 <xref:System.Threading.ThreadPool.SetMaxThreads%2A?displayProperty=nameWithType> 方法来控制最大线程数。</span><span class="sxs-lookup"><span data-stu-id="539ac-128">You can control the maximum number of threads by using the <xref:System.Threading.ThreadPool.GetMaxThreads%2A?displayProperty=nameWithType> and <xref:System.Threading.ThreadPool.SetMaxThreads%2A?displayProperty=nameWithType> methods.</span></span>  

> [!NOTE]
> <span data-ttu-id="539ac-129">承载公共语言运行时的代码可使用 [`ICorThreadpool::CorSetMaxThreads`](../../framework/unmanaged-api/hosting/icorthreadpool-corsetmaxthreads-method.md) 方法来设置大小。</span><span class="sxs-lookup"><span data-stu-id="539ac-129">Code that hosts the common language runtime can set the size using the [`ICorThreadpool::CorSetMaxThreads`](../../framework/unmanaged-api/hosting/icorthreadpool-corsetmaxthreads-method.md) method.</span></span>  
  
### <a name="thread-pool-minimums"></a><span data-ttu-id="539ac-130">线程池最小值</span><span class="sxs-lookup"><span data-stu-id="539ac-130">Thread pool minimums</span></span>

<span data-ttu-id="539ac-131">线程池根据需要提供新的工作线程或 I/O 完成线程，直到它达到每个类别的指定最小值。</span><span class="sxs-lookup"><span data-stu-id="539ac-131">The thread pool provides new worker threads or I/O completion threads on demand until it reaches a specified minimum for each category.</span></span> <span data-ttu-id="539ac-132">可以使用 <xref:System.Threading.ThreadPool.GetMinThreads%2A?displayProperty=nameWithType> 方法来获取这些最小值。</span><span class="sxs-lookup"><span data-stu-id="539ac-132">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A?displayProperty=nameWithType> method to obtain these minimum values.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="539ac-133">需求较低时，线程池线程的实际数量可以低于最小值。</span><span class="sxs-lookup"><span data-stu-id="539ac-133">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
<span data-ttu-id="539ac-134">达到最小值时，线程池可以创建其他线程或等待，直到一些任务完成。</span><span class="sxs-lookup"><span data-stu-id="539ac-134">When a minimum is reached, the thread pool can create additional threads or wait until some tasks complete.</span></span> <span data-ttu-id="539ac-135">从 .NET Framework 4 开始，线程池创建和销毁工作线程以优化吞吐量，吞吐量被定义为每个单位时间完成的任务数。</span><span class="sxs-lookup"><span data-stu-id="539ac-135">Beginning with the .NET Framework 4, the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="539ac-136">线程过少可能无法实现可用资源的最优利用，而线程过多则可能增加资源争用。</span><span class="sxs-lookup"><span data-stu-id="539ac-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="539ac-137">可以使用 <xref:System.Threading.ThreadPool.SetMinThreads%2A?displayProperty=nameWithType> 方法来增加最小空闲线程数。</span><span class="sxs-lookup"><span data-stu-id="539ac-137">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A?displayProperty=nameWithType> method to increase the minimum number of idle threads.</span></span> <span data-ttu-id="539ac-138">但是，不必要地增加这些值可能导致性能问题。</span><span class="sxs-lookup"><span data-stu-id="539ac-138">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="539ac-139">如果在同一时间开始太多的任务，则所有任务均可能会很慢。</span><span class="sxs-lookup"><span data-stu-id="539ac-139">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="539ac-140">大多数情况下，使用自己的分配线程算法，线程池将更好地执行任务。</span><span class="sxs-lookup"><span data-stu-id="539ac-140">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  

## <a name="using-the-thread-pool"></a><span data-ttu-id="539ac-141">使用线程池</span><span class="sxs-lookup"><span data-stu-id="539ac-141">Using the thread pool</span></span>

<span data-ttu-id="539ac-142">自 .NET Framework 4 起，使用线程池的最简单方法是使用[任务并行库 (TPL)](../parallel-programming/task-parallel-library-tpl.md)。</span><span class="sxs-lookup"><span data-stu-id="539ac-142">Beginning with the .NET Framework 4, the easiest way to use the thread pool is to use the [Task Parallel Library (TPL)](../parallel-programming/task-parallel-library-tpl.md).</span></span> <span data-ttu-id="539ac-143">默认情况下，TPL 类型（例如 <xref:System.Threading.Tasks.Task> 和 <xref:System.Threading.Tasks.Task%601>）使用线程池线程来运行任务。</span><span class="sxs-lookup"><span data-stu-id="539ac-143">By default, TPL types like <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> use thread pool threads to run tasks.</span></span>

<span data-ttu-id="539ac-144">也可以通过从托管代码调用 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType>（或从非托管代码调用 [`ICorThreadpool::CorQueueUserWorkItem`](../../framework/unmanaged-api/hosting/icorthreadpool-corqueueuserworkitem-method.md)）并传递表示执行任务的方法的 <xref:System.Threading.WaitCallback?displayProperty=nameWithType> 委托来使用线程池。</span><span class="sxs-lookup"><span data-stu-id="539ac-144">You can also use the thread pool by calling <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> from managed code (or [`ICorThreadpool::CorQueueUserWorkItem`](../../framework/unmanaged-api/hosting/icorthreadpool-corqueueuserworkitem-method.md) from unmanaged code) and passing a <xref:System.Threading.WaitCallback?displayProperty=nameWithType> delegate representing the method that performs the task.</span></span>

<span data-ttu-id="539ac-145">使用线程池的另一种方法是通过使用 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A?displayProperty=nameWithType> 方法并传递在发出信号或超时的时候调用 <xref:System.Threading.WaitOrTimerCallback?displayProperty=nameWithType> 委托所表示的方法的 <xref:System.Threading.WaitHandle?displayProperty=nameWithType>，从而对与等待操作相关的工作项排队。</span><span class="sxs-lookup"><span data-stu-id="539ac-145">Another way to use the thread pool is to queue work items that are related to a wait operation by using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A?displayProperty=nameWithType> method and passing a <xref:System.Threading.WaitHandle?displayProperty=nameWithType> that, when signaled or when timed out, calls the method represented by the <xref:System.Threading.WaitOrTimerCallback?displayProperty=nameWithType> delegate.</span></span> <span data-ttu-id="539ac-146">线程池线程用于调用回调方法。</span><span class="sxs-lookup"><span data-stu-id="539ac-146">Thread pool threads are used to invoke callback methods.</span></span>  

<span data-ttu-id="539ac-147">有关示例，请查看引用的 API 页面。</span><span class="sxs-lookup"><span data-stu-id="539ac-147">For the examples, check the referenced API pages.</span></span>
  
## <a name="skipping-security-checks"></a><span data-ttu-id="539ac-148">跳过安全检查</span><span class="sxs-lookup"><span data-stu-id="539ac-148">Skipping security checks</span></span>

<span data-ttu-id="539ac-149">线程池还提供 <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType> 和 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="539ac-149">The thread pool also provides the <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType> and <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="539ac-150">仅当确定调用方的堆栈与执行排队的任务期间进行的任何安全检查无关时，方可使用这些方法。</span><span class="sxs-lookup"><span data-stu-id="539ac-150">Use these methods only when you are certain that the caller's stack is irrelevant to any security checks performed during the execution of the queued task.</span></span> <span data-ttu-id="539ac-151"><xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> 和 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A?displayProperty=nameWithType> 均捕获调用方堆栈，当线程开始执行任务时，调用方的堆栈被合并到线程池线程的堆栈中。</span><span class="sxs-lookup"><span data-stu-id="539ac-151"><xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> and <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A?displayProperty=nameWithType> both capture the caller's stack, which is merged into the stack of the thread pool thread when the thread begins to execute a task.</span></span> <span data-ttu-id="539ac-152">如果安全检查是必需的，则必须检查整个堆栈。</span><span class="sxs-lookup"><span data-stu-id="539ac-152">If a security check is required, the entire stack must be checked.</span></span> <span data-ttu-id="539ac-153">尽管此检查提供了安全性，但它也具有性能成本。</span><span class="sxs-lookup"><span data-stu-id="539ac-153">Although the check provides safety, it also has a performance cost.</span></span>  

## <a name="when-not-to-use-thread-pool-threads"></a><span data-ttu-id="539ac-154">何时不使用线程池线程</span><span class="sxs-lookup"><span data-stu-id="539ac-154">When not to use thread pool threads</span></span>

<span data-ttu-id="539ac-155">有几种应用场景，其中适合创建并管理自己的线程，而非使用线程池线程：</span><span class="sxs-lookup"><span data-stu-id="539ac-155">There are several scenarios in which it's appropriate to create and manage your own threads instead of using thread pool threads:</span></span>  
  
- <span data-ttu-id="539ac-156">需要一个前台线程。</span><span class="sxs-lookup"><span data-stu-id="539ac-156">You require a foreground thread.</span></span>  
- <span data-ttu-id="539ac-157">需要具有特定优先级的线程。</span><span class="sxs-lookup"><span data-stu-id="539ac-157">You require a thread to have a particular priority.</span></span>  
- <span data-ttu-id="539ac-158">拥有会导致线程长时间阻塞的任务。</span><span class="sxs-lookup"><span data-stu-id="539ac-158">You have tasks that cause the thread to block for long periods of time.</span></span> <span data-ttu-id="539ac-159">线程池具有最大线程数，因此大量被阻塞的线程池线程可能会阻止任务启动。</span><span class="sxs-lookup"><span data-stu-id="539ac-159">The thread pool has a maximum number of threads, so a large number of blocked thread pool threads might prevent tasks from starting.</span></span>  
- <span data-ttu-id="539ac-160">需将线程放入单线程单元。</span><span class="sxs-lookup"><span data-stu-id="539ac-160">You need to place threads into a single-threaded apartment.</span></span> <span data-ttu-id="539ac-161">所有 <xref:System.Threading.ThreadPool> 线程均位于多线程单元中。</span><span class="sxs-lookup"><span data-stu-id="539ac-161">All <xref:System.Threading.ThreadPool> threads are in the multithreaded apartment.</span></span>  
- <span data-ttu-id="539ac-162">需具有与线程关联的稳定标识，或需将一个线程专用于一项任务。</span><span class="sxs-lookup"><span data-stu-id="539ac-162">You need to have a stable identity associated with the thread, or to dedicate a thread to a task.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="539ac-163">另请参阅</span><span class="sxs-lookup"><span data-stu-id="539ac-163">See also</span></span>

- <xref:System.Threading.ThreadPool?displayProperty=nameWithType>
- <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>
- <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>
- [<span data-ttu-id="539ac-164">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="539ac-164">Task Parallel Library (TPL)</span></span>](../parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="539ac-165">如何：从任务中返回值</span><span class="sxs-lookup"><span data-stu-id="539ac-165">How to: Return a Value from a Task</span></span>](../parallel-programming/how-to-return-a-value-from-a-task.md)
- [<span data-ttu-id="539ac-166">线程处理对象和功能</span><span class="sxs-lookup"><span data-stu-id="539ac-166">Threading Objects and Features</span></span>](threading-objects-and-features.md)
- [<span data-ttu-id="539ac-167">线程与线程处理</span><span class="sxs-lookup"><span data-stu-id="539ac-167">Threads and Threading</span></span>](threads-and-threading.md)
- [<span data-ttu-id="539ac-168">异步文件 I/O</span><span class="sxs-lookup"><span data-stu-id="539ac-168">Asynchronous File I/O</span></span>](../io/asynchronous-file-i-o.md)
- [<span data-ttu-id="539ac-169">计时器</span><span class="sxs-lookup"><span data-stu-id="539ac-169">Timers</span></span>](timers.md)
