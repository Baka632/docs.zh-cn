---
title: 托管线程中的取消
description: 了解托管线程中的取消。 了解异步或长时间运行的同步操作的协作取消中的取消令牌。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- cancellation in .NET, overview
ms.assetid: eea11fe5-d8b0-4314-bb5d-8a58166fb1c3
ms.openlocfilehash: 578db725458ad5c4a90256a06744a58a6d1918da
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/18/2020
ms.locfileid: "94819950"
---
# <a name="cancellation-in-managed-threads"></a><span data-ttu-id="aca7b-104">托管线程中的取消</span><span class="sxs-lookup"><span data-stu-id="aca7b-104">Cancellation in Managed Threads</span></span>

<span data-ttu-id="aca7b-105">从 .NET Framework 4 开始，.NET 在协作式取消异步操作或长时间运行的同步操作时使用统一的模型。</span><span class="sxs-lookup"><span data-stu-id="aca7b-105">Starting with .NET Framework 4, .NET uses a unified model for cooperative cancellation of asynchronous or long-running synchronous operations.</span></span> <span data-ttu-id="aca7b-106">此模型基于被称为取消标记的轻量对象。</span><span class="sxs-lookup"><span data-stu-id="aca7b-106">This model is based on a lightweight object called a cancellation token.</span></span> <span data-ttu-id="aca7b-107">调用一个或多个可取消操作的对象（例如通过创建新线程或任务）将标记传递给每个操作。</span><span class="sxs-lookup"><span data-stu-id="aca7b-107">The object that invokes one or more cancelable operations, for example by creating new threads or tasks, passes the token to each operation.</span></span> <span data-ttu-id="aca7b-108">单个操作反过来可将标记的副本传递给其他操作。</span><span class="sxs-lookup"><span data-stu-id="aca7b-108">Individual operations can in turn pass copies of the token to other operations.</span></span> <span data-ttu-id="aca7b-109">稍后，创建标记的对象可使用此标记请求停止执行操作内容。</span><span class="sxs-lookup"><span data-stu-id="aca7b-109">At some later time, the object that created the token can use it to request that the operations stop what they are doing.</span></span> <span data-ttu-id="aca7b-110">只有发出请求的对象，才能发出取消请求，而每个侦听器负责侦听是否有请求，并及时适当地响应请求。</span><span class="sxs-lookup"><span data-stu-id="aca7b-110">Only the requesting object can issue the cancellation request, and each listener is responsible for noticing the request and responding to it in an appropriate and timely manner.</span></span>  
  
<span data-ttu-id="aca7b-111">用于实现协作取消模型的常规模式是：</span><span class="sxs-lookup"><span data-stu-id="aca7b-111">The general pattern for implementing the cooperative cancellation model is:</span></span>  
  
- <span data-ttu-id="aca7b-112">实例化 <xref:System.Threading.CancellationTokenSource> 对象，此对象管理取消通知并将其发送给单个取消标记。</span><span class="sxs-lookup"><span data-stu-id="aca7b-112">Instantiate a <xref:System.Threading.CancellationTokenSource> object, which manages and sends cancellation notification to the individual cancellation tokens.</span></span>  
  
- <span data-ttu-id="aca7b-113">将 <xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType> 属性返回的标记传递给每个侦听取消的任务或线程。</span><span class="sxs-lookup"><span data-stu-id="aca7b-113">Pass the token returned by the <xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType> property to each task or thread that listens for cancellation.</span></span>  
  
- <span data-ttu-id="aca7b-114">为每个任务或线程提供响应取消的机制。</span><span class="sxs-lookup"><span data-stu-id="aca7b-114">Provide a mechanism for each task or thread to respond to cancellation.</span></span>  
  
- <span data-ttu-id="aca7b-115">调用 <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> 方法以提供取消通知。</span><span class="sxs-lookup"><span data-stu-id="aca7b-115">Call the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method to provide notification of cancellation.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="aca7b-116"><xref:System.Threading.CancellationTokenSource> 类实现 <xref:System.IDisposable> 接口。</span><span class="sxs-lookup"><span data-stu-id="aca7b-116">The <xref:System.Threading.CancellationTokenSource> class implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="aca7b-117">使用取消标记源释放所包含的任何非托管资源后，应确保调用 <xref:System.Threading.CancellationTokenSource.Dispose%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="aca7b-117">You should be sure to call the <xref:System.Threading.CancellationTokenSource.Dispose%2A?displayProperty=nameWithType> method when you have finished using the cancellation token source to free any unmanaged resources it holds.</span></span>  
  
 <span data-ttu-id="aca7b-118">下图显示了标记源与标记的所有副本之间的关系。</span><span class="sxs-lookup"><span data-stu-id="aca7b-118">The following illustration shows the relationship between a token source and all the copies of its token.</span></span>  
  
 <span data-ttu-id="aca7b-119">![CancellationTokenSource 和取消标记](media/vs-cancellationtoken.png "VS_CancellationToken")</span><span class="sxs-lookup"><span data-stu-id="aca7b-119">![CancellationTokenSource and cancellation tokens](media/vs-cancellationtoken.png "VS_CancellationToken")</span></span>  
  
 <span data-ttu-id="aca7b-120">借助协作式取消模型，可更轻松地创建取消感知应用程序和库，并且该模型支持以下功能：</span><span class="sxs-lookup"><span data-stu-id="aca7b-120">The cooperative cancellation model makes it easier to create cancellation-aware applications and libraries, and it supports the following features:</span></span>  
  
- <span data-ttu-id="aca7b-121">取消具有协作性，且不会在侦听器上强制执行。</span><span class="sxs-lookup"><span data-stu-id="aca7b-121">Cancellation is cooperative and is not forced on the listener.</span></span> <span data-ttu-id="aca7b-122">侦听器确定如何适当地以响应取消请求终止操作。</span><span class="sxs-lookup"><span data-stu-id="aca7b-122">The listener determines how to gracefully terminate in response to a cancellation request.</span></span>  
  
- <span data-ttu-id="aca7b-123">请求与侦听不同。</span><span class="sxs-lookup"><span data-stu-id="aca7b-123">Requesting is distinct from listening.</span></span> <span data-ttu-id="aca7b-124">调用可取消操作的对象可以控制何时（如果有）请求取消。</span><span class="sxs-lookup"><span data-stu-id="aca7b-124">An object that invokes a cancelable operation can control when (if ever) cancellation is requested.</span></span>  
  
- <span data-ttu-id="aca7b-125">请求对象仅使用一种方法调用，向标记的所有副本发出取消请求。</span><span class="sxs-lookup"><span data-stu-id="aca7b-125">The requesting object issues the cancellation request to all copies of the token by using just one method call.</span></span>  
  
- <span data-ttu-id="aca7b-126">侦听器可以将多个令牌联接到一个链接令牌，从而同时侦听多个令牌。</span><span class="sxs-lookup"><span data-stu-id="aca7b-126">A listener can listen to multiple tokens simultaneously by joining them into one *linked token*.</span></span>  
  
- <span data-ttu-id="aca7b-127">用户代码可以注意并响应来自库代码的取消请求，而库代码可以注意并响应来自用户代码的取消请求。</span><span class="sxs-lookup"><span data-stu-id="aca7b-127">User code can notice and respond to cancellation requests from library code, and library code can notice and respond to cancellation requests from user code.</span></span>  
  
- <span data-ttu-id="aca7b-128">侦听器可通过轮询、回调注册或等待等待句柄来接收到取消请求的通知。</span><span class="sxs-lookup"><span data-stu-id="aca7b-128">Listeners can be notified of cancellation requests by polling, callback registration, or waiting on wait handles.</span></span>  
  
## <a name="cancellation-types"></a><span data-ttu-id="aca7b-129">取消类型</span><span class="sxs-lookup"><span data-stu-id="aca7b-129">Cancellation Types</span></span>  
 <span data-ttu-id="aca7b-130">取消框架作为相关类型集实现，如下表所列。</span><span class="sxs-lookup"><span data-stu-id="aca7b-130">The cancellation framework is implemented as a set of related types, which are listed in the following table.</span></span>  
  
|<span data-ttu-id="aca7b-131">类型名称</span><span class="sxs-lookup"><span data-stu-id="aca7b-131">Type name</span></span>|<span data-ttu-id="aca7b-132">描述</span><span class="sxs-lookup"><span data-stu-id="aca7b-132">Description</span></span>|  
|---------------|-----------------|  
|<xref:System.Threading.CancellationTokenSource>|<span data-ttu-id="aca7b-133">创建取消标记并为此标记的所有副本发出取消请求的对象。</span><span class="sxs-lookup"><span data-stu-id="aca7b-133">Object that creates a cancellation token, and also issues the cancellation request for all copies of that token.</span></span>|  
|<xref:System.Threading.CancellationToken>|<span data-ttu-id="aca7b-134">通常作为方法参数传递给一个或多个侦听器的轻量值类型。</span><span class="sxs-lookup"><span data-stu-id="aca7b-134">Lightweight value type passed to one or more listeners, typically as a method parameter.</span></span> <span data-ttu-id="aca7b-135">侦听器通过轮询、回调或等待句柄监视标记的 `IsCancellationRequested` 属性的值。</span><span class="sxs-lookup"><span data-stu-id="aca7b-135">Listeners monitor the value of the `IsCancellationRequested` property of the token by polling, callback, or wait handle.</span></span>|  
|<xref:System.OperationCanceledException>|<span data-ttu-id="aca7b-136">此异常的构造函数的重载将 <xref:System.Threading.CancellationToken> 作为参数接受。</span><span class="sxs-lookup"><span data-stu-id="aca7b-136">Overloads of this exception's constructor accept a <xref:System.Threading.CancellationToken> as a parameter.</span></span> <span data-ttu-id="aca7b-137">侦听器可能会选择性地引发此异常，议验证取消源并通知其他侦听器它已响应取消请求。</span><span class="sxs-lookup"><span data-stu-id="aca7b-137">Listeners can optionally throw this exception to verify the source of the cancellation and notify others that it has responded to a cancellation request.</span></span>|  
  
 <span data-ttu-id="aca7b-138">取消模型以多种类型集成到 .NET 中。</span><span class="sxs-lookup"><span data-stu-id="aca7b-138">The cancellation model is integrated into .NET in several types.</span></span> <span data-ttu-id="aca7b-139">最重要的类型包括 <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType>、<xref:System.Threading.Tasks.Task?displayProperty=nameWithType>、<xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 和 <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="aca7b-139">The most important ones are <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> and <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aca7b-140">建议将此协作式取消模型用于所有新的库和应用程序代码。</span><span class="sxs-lookup"><span data-stu-id="aca7b-140">We recommend that you use this cooperative cancellation model for all new library and application code.</span></span>  
  
## <a name="code-example"></a><span data-ttu-id="aca7b-141">代码示例</span><span class="sxs-lookup"><span data-stu-id="aca7b-141">Code Example</span></span>  
 <span data-ttu-id="aca7b-142">在以下示例中，请求对象创建 <xref:System.Threading.CancellationTokenSource> 对象，然后传递其 <xref:System.Threading.CancellationTokenSource.Token%2A> 属性到可取消操作中。</span><span class="sxs-lookup"><span data-stu-id="aca7b-142">In the following example, the requesting object creates a <xref:System.Threading.CancellationTokenSource> object, and then passes its <xref:System.Threading.CancellationTokenSource.Token%2A> property to the cancelable operation.</span></span> <span data-ttu-id="aca7b-143">接收请求的操作通过轮询监视标记的 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> 属性的值。</span><span class="sxs-lookup"><span data-stu-id="aca7b-143">The operation that receives the request monitors the value of the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property of the token by polling.</span></span> <span data-ttu-id="aca7b-144">值变为 `true` 后，侦听器可以适当方式终止操作。</span><span class="sxs-lookup"><span data-stu-id="aca7b-144">When the value becomes `true`, the listener can terminate in whatever manner is appropriate.</span></span> <span data-ttu-id="aca7b-145">在此示例中，方法只需退出，很多情况下都只需执行此操作。</span><span class="sxs-lookup"><span data-stu-id="aca7b-145">In this example, the method just exits, which is all that is required in many cases.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="aca7b-146">此示例使用 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 方法演示协作式取消框架与旧版 API 兼容。</span><span class="sxs-lookup"><span data-stu-id="aca7b-146">The example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to demonstrate that the cooperative cancellation framework is compatible with legacy APIs.</span></span> <span data-ttu-id="aca7b-147">有关使用首选 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 类型的示例，请参阅[操作说明：取消任务及其子级](../parallel-programming/how-to-cancel-a-task-and-its-children.md)。</span><span class="sxs-lookup"><span data-stu-id="aca7b-147">For an example that uses the preferred <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> type, see [How to: Cancel a Task and Its Children](../parallel-programming/how-to-cancel-a-task-and-its-children.md).</span></span>  
  
 [!code-csharp[Cancellation#1](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex1.cs#1)]
 [!code-vb[Cancellation#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex1.vb#1)]  
  
## <a name="operation-cancellation-versus-object-cancellation"></a><span data-ttu-id="aca7b-148">操作取消与对象取消</span><span class="sxs-lookup"><span data-stu-id="aca7b-148">Operation Cancellation Versus Object Cancellation</span></span>  
 <span data-ttu-id="aca7b-149">在协作式取消框架中，取消将引用操作，而不是对象。</span><span class="sxs-lookup"><span data-stu-id="aca7b-149">In the cooperative cancellation framework, cancellation refers to operations, not objects.</span></span> <span data-ttu-id="aca7b-150">取消请求意味着应在执行任何所需的清理后尽快停止操作。</span><span class="sxs-lookup"><span data-stu-id="aca7b-150">The cancellation request means that the operation should stop as soon as possible after any required cleanup is performed.</span></span> <span data-ttu-id="aca7b-151">一个取消标记应代指一个“可取消操作”，但可在程序中实现此操作。</span><span class="sxs-lookup"><span data-stu-id="aca7b-151">One cancellation token should refer to one "cancelable operation," however that operation may be implemented in your program.</span></span> <span data-ttu-id="aca7b-152">在标记的 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> 属性设置为 `true` 后，不能重置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="aca7b-152">After the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property of the token has been set to `true`, it cannot be reset to `false`.</span></span> <span data-ttu-id="aca7b-153">因此，取消后不能重用取消标记。</span><span class="sxs-lookup"><span data-stu-id="aca7b-153">Therefore, cancellation tokens cannot be reused after they have been canceled.</span></span>  
  
 <span data-ttu-id="aca7b-154">如果需要对象取消机制，可以通过调用 <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> 方法将其基于操作取消机制，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="aca7b-154">If you require an object cancellation mechanism, you can base it on the operation cancellation mechanism by calling the <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> method, as shown in the following example.</span></span>  
  
 [!code-csharp[Cancellation#2](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/objectcancellation1.cs#2)]
 [!code-vb[Cancellation#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/objectcancellation1.vb#2)]  
  
 <span data-ttu-id="aca7b-155">如果对象支持多个并发可取消操作，则将单独的标记作为输入传递给每个非重复的可取消操作。</span><span class="sxs-lookup"><span data-stu-id="aca7b-155">If an object supports more than one concurrent cancelable operation, pass a separate token as input to each distinct cancelable operation.</span></span> <span data-ttu-id="aca7b-156">这样，无需影响其他操作即可取消某项操作。</span><span class="sxs-lookup"><span data-stu-id="aca7b-156">That way, one operation can be cancelled without affecting the others.</span></span>  
  
## <a name="listening-and-responding-to-cancellation-requests"></a><span data-ttu-id="aca7b-157">侦听和响应取消请求</span><span class="sxs-lookup"><span data-stu-id="aca7b-157">Listening and Responding to Cancellation Requests</span></span>  
 <span data-ttu-id="aca7b-158">在用户委托中，可取消操作的实施者确定如何以响应取消请求来终止操作。</span><span class="sxs-lookup"><span data-stu-id="aca7b-158">In the user delegate, the implementer of a cancelable operation determines how to terminate the operation in response to a cancellation request.</span></span> <span data-ttu-id="aca7b-159">在很多情况下，用户委托只需执行全部所需清理，然后立即返回。</span><span class="sxs-lookup"><span data-stu-id="aca7b-159">In many cases, the user delegate can just perform any required cleanup and then return immediately.</span></span>  
  
 <span data-ttu-id="aca7b-160">但是，在更复杂的情况下，用户委托可能需要通知库代码已发生取消。</span><span class="sxs-lookup"><span data-stu-id="aca7b-160">However, in more complex cases, it might be necessary for the user delegate to notify library code that cancellation has occurred.</span></span> <span data-ttu-id="aca7b-161">在这种情况下，终止操作的正确方式是委托调用 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> 方法，这将引发 <xref:System.OperationCanceledException>。</span><span class="sxs-lookup"><span data-stu-id="aca7b-161">In such cases, the correct way to terminate the operation is for the delegate to call the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A>, method, which will cause an <xref:System.OperationCanceledException> to be thrown.</span></span> <span data-ttu-id="aca7b-162">库代码可以在用户委托线程上捕获此异常，并检查异常的标记以确定异常是否表示协作取消或一些其他的异常情况。</span><span class="sxs-lookup"><span data-stu-id="aca7b-162">Library code can catch this exception on the user delegate thread and examine the exception's token to determine whether the exception indicates cooperative cancellation or some other exceptional situation.</span></span>  
  
 <span data-ttu-id="aca7b-163"><xref:System.Threading.Tasks.Task> 类以此方式处理 <xref:System.OperationCanceledException>。</span><span class="sxs-lookup"><span data-stu-id="aca7b-163">The <xref:System.Threading.Tasks.Task> class handles <xref:System.OperationCanceledException> in this way.</span></span> <span data-ttu-id="aca7b-164">有关详细信息，请参阅[任务取消](../parallel-programming/task-cancellation.md)。</span><span class="sxs-lookup"><span data-stu-id="aca7b-164">For more information, see [Task Cancellation](../parallel-programming/task-cancellation.md).</span></span>  
  
### <a name="listening-by-polling"></a><span data-ttu-id="aca7b-165">通过轮询进行侦听</span><span class="sxs-lookup"><span data-stu-id="aca7b-165">Listening by Polling</span></span>  
 <span data-ttu-id="aca7b-166">对于循环或递归的长时间运行的计算，可以通过定期轮询 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A?displayProperty=nameWithType> 属性的值来侦听取消请求。</span><span class="sxs-lookup"><span data-stu-id="aca7b-166">For long-running computations that loop or recurse, you can listen for a cancellation request by periodically polling the value of the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="aca7b-167">如果其值为 `true`，则此方法应尽快清理并终止。</span><span class="sxs-lookup"><span data-stu-id="aca7b-167">If its value is `true`, the method should clean up and terminate as quickly as possible.</span></span> <span data-ttu-id="aca7b-168">最佳的轮询频率取决于应用程序的类型。</span><span class="sxs-lookup"><span data-stu-id="aca7b-168">The optimal frequency of polling depends on the type of application.</span></span> <span data-ttu-id="aca7b-169">由开发人员决定任一给定程序的最佳轮询频率。</span><span class="sxs-lookup"><span data-stu-id="aca7b-169">It is up to the developer to determine the best polling frequency for any given program.</span></span> <span data-ttu-id="aca7b-170">轮询本身不会显著影响性能。</span><span class="sxs-lookup"><span data-stu-id="aca7b-170">Polling itself does not significantly impact performance.</span></span> <span data-ttu-id="aca7b-171">以下示例演示了一种轮询方法。</span><span class="sxs-lookup"><span data-stu-id="aca7b-171">The following example shows one possible way to poll.</span></span>  
  
 [!code-csharp[Cancellation#3](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex11.cs#3)]
 [!code-vb[Cancellation#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex11.vb#3)]  
  
 <span data-ttu-id="aca7b-172">有关更完整的示例，请参见[如何：通过轮询侦听取消请求](how-to-listen-for-cancellation-requests-by-polling.md)。</span><span class="sxs-lookup"><span data-stu-id="aca7b-172">For a more complete example, see [How to: Listen for Cancellation Requests by Polling](how-to-listen-for-cancellation-requests-by-polling.md).</span></span>  
  
### <a name="listening-by-registering-a-callback"></a><span data-ttu-id="aca7b-173">通过注册回调进行侦听</span><span class="sxs-lookup"><span data-stu-id="aca7b-173">Listening by Registering a Callback</span></span>  
 <span data-ttu-id="aca7b-174">某些操作可能被阻止，导致其无法及时检查取消标记的值。</span><span class="sxs-lookup"><span data-stu-id="aca7b-174">Some operations can become blocked in such a way that they cannot check the value of the cancellation token in a timely manner.</span></span> <span data-ttu-id="aca7b-175">对于这些情况，可以注册在接收取消请求时取消阻止此方法的回调方法。</span><span class="sxs-lookup"><span data-stu-id="aca7b-175">For these cases, you can register a callback method that unblocks the method when a cancellation request is received.</span></span>  
  
 <span data-ttu-id="aca7b-176"><xref:System.Threading.CancellationToken.Register%2A> 方法返回专用于此目的的 <xref:System.Threading.CancellationTokenRegistration> 对象。</span><span class="sxs-lookup"><span data-stu-id="aca7b-176">The <xref:System.Threading.CancellationToken.Register%2A> method returns a <xref:System.Threading.CancellationTokenRegistration> object that is used specifically for this purpose.</span></span> <span data-ttu-id="aca7b-177">以下示例演示了如何使用 <xref:System.Threading.CancellationToken.Register%2A> 方法取消异步 Web 请求。</span><span class="sxs-lookup"><span data-stu-id="aca7b-177">The following example shows how to use the <xref:System.Threading.CancellationToken.Register%2A> method to cancel an asynchronous Web request.</span></span>  
  
 [!code-csharp[Cancellation#4](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex4.cs#4)]
 [!code-vb[Cancellation#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex4.vb#4)]  
  
 <span data-ttu-id="aca7b-178"><xref:System.Threading.CancellationTokenRegistration> 对象管理线程同步，并确保回调将在精确的时间点停止执行。</span><span class="sxs-lookup"><span data-stu-id="aca7b-178">The <xref:System.Threading.CancellationTokenRegistration> object manages thread synchronization and ensures that the callback will stop executing at a precise point in time.</span></span>  
  
 <span data-ttu-id="aca7b-179">为了确保系统的响应能力并避免死锁，注册回调时必须遵循以下准则：</span><span class="sxs-lookup"><span data-stu-id="aca7b-179">In order to ensure system responsiveness and to avoid deadlocks, the following guidelines must be followed when registering callbacks:</span></span>  
  
- <span data-ttu-id="aca7b-180">回调方法应该快速，因为它进行同步调用，所以对 <xref:System.Threading.CancellationTokenSource.Cancel%2A> 的调用直到回调返回后才会返回。</span><span class="sxs-lookup"><span data-stu-id="aca7b-180">The callback method should be fast because it is called synchronously and therefore the call to <xref:System.Threading.CancellationTokenSource.Cancel%2A> does not return until the callback returns.</span></span>  
  
- <span data-ttu-id="aca7b-181">如果回调正在运行时调用 <xref:System.Threading.CancellationTokenRegistration.Dispose%2A> 且你持有回调正在等待的锁定，则程序可能出现死锁。</span><span class="sxs-lookup"><span data-stu-id="aca7b-181">If you call <xref:System.Threading.CancellationTokenRegistration.Dispose%2A> while the callback is running, and you hold a lock that the callback is waiting on, your program can deadlock.</span></span> <span data-ttu-id="aca7b-182">`Dispose` 返回后，可释放回调所需的任何资源。</span><span class="sxs-lookup"><span data-stu-id="aca7b-182">After `Dispose` returns, you can free any resources required by the callback.</span></span>  
  
- <span data-ttu-id="aca7b-183">回调不应在回调中执行任何手动线程或 <xref:System.Threading.SynchronizationContext> 使用情况。</span><span class="sxs-lookup"><span data-stu-id="aca7b-183">Callbacks should not perform any manual thread or <xref:System.Threading.SynchronizationContext> usage in a callback.</span></span> <span data-ttu-id="aca7b-184">如果回调必须在特定线程上运行，请使用 <xref:System.Threading.CancellationTokenRegistration?displayProperty=nameWithType> 构造函数，此函数使你能够指定目标 syncContext 是活动的 <xref:System.Threading.SynchronizationContext.Current%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="aca7b-184">If a callback must run on a particular thread, use the <xref:System.Threading.CancellationTokenRegistration?displayProperty=nameWithType> constructor that enables you to specify that the target syncContext is the active <xref:System.Threading.SynchronizationContext.Current%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aca7b-185">在回调中执行手动线程处理可能导致死锁。</span><span class="sxs-lookup"><span data-stu-id="aca7b-185">Performing manual threading in a callback can cause deadlock.</span></span>  
  
 <span data-ttu-id="aca7b-186">有关更完整的示例，请参见[如何：注册取消请求的回叫](how-to-register-callbacks-for-cancellation-requests.md)。</span><span class="sxs-lookup"><span data-stu-id="aca7b-186">For a more complete example, see [How to: Register Callbacks for Cancellation Requests](how-to-register-callbacks-for-cancellation-requests.md).</span></span>  
  
### <a name="listening-by-using-a-wait-handle"></a><span data-ttu-id="aca7b-187">通过使用等待句柄进行侦听</span><span class="sxs-lookup"><span data-stu-id="aca7b-187">Listening by Using a Wait Handle</span></span>  
 <span data-ttu-id="aca7b-188">当可取消的操作可在等待同步基元（例如 <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> 或 <xref:System.Threading.Semaphore?displayProperty=nameWithType>）的同时进行阻止时），可使用 <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType> 属性启用操作同时等待事件请求和取消请求。</span><span class="sxs-lookup"><span data-stu-id="aca7b-188">When a cancelable operation can block while it waits on a synchronization primitive such as a <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> or <xref:System.Threading.Semaphore?displayProperty=nameWithType>, you can use the <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType> property to enable the operation to wait on both the event and the cancellation request.</span></span> <span data-ttu-id="aca7b-189">取消标记的等待句柄将接收到响应取消请求的信号，并且此方法可使用 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法的返回值来确定它是否为发出信号的取消标记。</span><span class="sxs-lookup"><span data-stu-id="aca7b-189">The wait handle of the cancellation token will become signaled in response to a cancellation request, and the method can use the return value of the <xref:System.Threading.WaitHandle.WaitAny%2A> method to determine whether it was the cancellation token that signaled.</span></span> <span data-ttu-id="aca7b-190">然后此操作可根据需要直接退出，或者引发 <xref:System.OperationCanceledException>。</span><span class="sxs-lookup"><span data-stu-id="aca7b-190">The operation can then just exit, or throw a <xref:System.OperationCanceledException>, as appropriate.</span></span>  
  
 [!code-csharp[Cancellation#5](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex9.cs#5)]
 [!code-vb[Cancellation#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex9.vb#5)]  
  
<span data-ttu-id="aca7b-191"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> 和 <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> 都支持其 `Wait` 方法中的取消框架。</span><span class="sxs-lookup"><span data-stu-id="aca7b-191"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> both support the cancellation framework in their `Wait` methods.</span></span> <span data-ttu-id="aca7b-192">可以将 <xref:System.Threading.CancellationToken>传递给方法，在取消请求发出后，事件就会唤醒并抛出 <xref:System.OperationCanceledException>。</span><span class="sxs-lookup"><span data-stu-id="aca7b-192">You can pass the <xref:System.Threading.CancellationToken> to the method, and when the cancellation is requested, the event wakes up and throws an <xref:System.OperationCanceledException>.</span></span>  
  
 [!code-csharp[Cancellation#6](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex10.cs#6)]
 [!code-vb[Cancellation#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex10.vb#6)]  
  
 <span data-ttu-id="aca7b-193">有关更完整的示例，请参见[如何：侦听具有等待句柄的取消请求](how-to-listen-for-cancellation-requests-that-have-wait-handles.md)。</span><span class="sxs-lookup"><span data-stu-id="aca7b-193">For a more complete example, see [How to: Listen for Cancellation Requests That Have Wait Handles](how-to-listen-for-cancellation-requests-that-have-wait-handles.md).</span></span>  
  
### <a name="listening-to-multiple-tokens-simultaneously"></a><span data-ttu-id="aca7b-194">同时侦听多个标记</span><span class="sxs-lookup"><span data-stu-id="aca7b-194">Listening to Multiple Tokens Simultaneously</span></span>  
 <span data-ttu-id="aca7b-195">在某些情况下，侦听器可能需要同时侦听多个取消标记。</span><span class="sxs-lookup"><span data-stu-id="aca7b-195">In some cases, a listener may have to listen to multiple cancellation tokens simultaneously.</span></span> <span data-ttu-id="aca7b-196">例如，除了在外部作为自变量传递到方法参数的标记以外，可取消操纵可能还必须监视内部取消标记。</span><span class="sxs-lookup"><span data-stu-id="aca7b-196">For example, a cancelable operation may have to monitor an internal cancellation token in addition to a token passed in externally as an argument to a method parameter.</span></span> <span data-ttu-id="aca7b-197">为此，需创建可将两个或多个标记联接成一个标记的链接标记源，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="aca7b-197">To accomplish this, create a linked token source that can join two or more tokens into one token, as shown in the following example.</span></span>  
  
 [!code-csharp[Cancellation#7](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex13.cs#7)]
 [!code-vb[Cancellation#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex13.vb#7)]  
  
 <span data-ttu-id="aca7b-198">请注意，完成后必须在链接标记源上调用 `Dispose`。</span><span class="sxs-lookup"><span data-stu-id="aca7b-198">Notice that you must call `Dispose` on the linked token source when you are done with it.</span></span> <span data-ttu-id="aca7b-199">有关更完整的示例，请参见[如何：侦听多个取消请求](how-to-listen-for-multiple-cancellation-requests.md)。</span><span class="sxs-lookup"><span data-stu-id="aca7b-199">For a more complete example, see [How to: Listen for Multiple Cancellation Requests](how-to-listen-for-multiple-cancellation-requests.md).</span></span>  
  
## <a name="cooperation-between-library-code-and-user-code"></a><span data-ttu-id="aca7b-200">库代码和用户代码之间的合作</span><span class="sxs-lookup"><span data-stu-id="aca7b-200">Cooperation Between Library Code and User Code</span></span>  
 <span data-ttu-id="aca7b-201">借助统一的取消框架，库代码可取消用户代码，而使用户代码可以协作的方式取消库代码。</span><span class="sxs-lookup"><span data-stu-id="aca7b-201">The unified cancellation framework makes it possible for library code to cancel user code, and for user code to cancel library code in a cooperative manner.</span></span> <span data-ttu-id="aca7b-202">合作是否顺利取决于两者是否遵循以下准则：</span><span class="sxs-lookup"><span data-stu-id="aca7b-202">Smooth cooperation depends on each side following these guidelines:</span></span>  
  
- <span data-ttu-id="aca7b-203">如果库代码提供了可取消操作，它还应提供接受外部取消标记的公共方法，以便用户代码可以请求取消。</span><span class="sxs-lookup"><span data-stu-id="aca7b-203">If library code provides cancelable operations, it should also provide public methods that accept an external cancellation token so that user code can request cancellation.</span></span>  
  
- <span data-ttu-id="aca7b-204">如果库代码调用用户代码，库代码应将 OperationCanceledException(externalToken) 解释为协作取消，不一定要解释为失败异常。</span><span class="sxs-lookup"><span data-stu-id="aca7b-204">If library code calls into user code, the library code should interpret an OperationCanceledException(externalToken) as *cooperative cancellation*, and not necessarily as a failure exception.</span></span>  
  
- <span data-ttu-id="aca7b-205">用户委托应尝试及时响应来自库代码的取消请求。</span><span class="sxs-lookup"><span data-stu-id="aca7b-205">User-delegates should attempt to respond to cancellation requests from library code in a timely manner.</span></span>  
  
 <span data-ttu-id="aca7b-206"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 和 <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> 是遵循这些准则的类的示例。</span><span class="sxs-lookup"><span data-stu-id="aca7b-206"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> are examples of classes that follow these guidelines.</span></span> <span data-ttu-id="aca7b-207">有关详细信息，请参阅[任务取消](../parallel-programming/task-cancellation.md)和[如何：取消 PLINQ 查询](../parallel-programming/how-to-cancel-a-plinq-query.md)。</span><span class="sxs-lookup"><span data-stu-id="aca7b-207">For more information, see [Task Cancellation](../parallel-programming/task-cancellation.md) and [How to: Cancel a PLINQ Query](../parallel-programming/how-to-cancel-a-plinq-query.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="aca7b-208">请参阅</span><span class="sxs-lookup"><span data-stu-id="aca7b-208">See also</span></span>

- [<span data-ttu-id="aca7b-209">托管线程处理基本知识</span><span class="sxs-lookup"><span data-stu-id="aca7b-209">Managed Threading Basics</span></span>](managed-threading-basics.md)
