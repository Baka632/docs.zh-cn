---
title: Semaphore 和 SemaphoreSlim
description: 了解 Semaphore 和 SemaphoreSlim。 Semaphore 类是环绕 Win32 信号灯对象的精简包装器。 SemaphoreSlim 类是快速轻量级信号灯。
ms.date: 03/30/2017
helpviewer_keywords:
- counting semaphores
- semaphores
- threading [.NET], cross-process synchronization
- Semaphore class, about Semaphore class
- SemaphoreSlim class, about SemaphoreSlim class
- threading [.NET], Semaphore class
ms.assetid: 7722a333-b974-47a2-a7c0-f09097fb644e
ms.openlocfilehash: bda88012fde60481d8870f701e98924acdeeb5a2
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/18/2020
ms.locfileid: "94817140"
---
# <a name="semaphore-and-semaphoreslim"></a><span data-ttu-id="1d850-105">Semaphore 和 SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="1d850-105">Semaphore and SemaphoreSlim</span></span>

<span data-ttu-id="1d850-106"><xref:System.Threading.Semaphore?displayProperty=nameWithType> 类表示一个命名（系统范围内）或本地信号量。</span><span class="sxs-lookup"><span data-stu-id="1d850-106">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> class represents a named (systemwide) or local semaphore.</span></span> <span data-ttu-id="1d850-107">它是环绕 Win32 信号量对象的精简包装器。</span><span class="sxs-lookup"><span data-stu-id="1d850-107">It is a thin wrapper around the Win32 semaphore object.</span></span> <span data-ttu-id="1d850-108">Win32 信号量是计数信号量，该可用于控制对资源池的访问。</span><span class="sxs-lookup"><span data-stu-id="1d850-108">Win32 semaphores are counting semaphores, which can be used to control access to a pool of resources.</span></span>  
  
 <span data-ttu-id="1d850-109"><xref:System.Threading.SemaphoreSlim> 类表示一个轻量、快速的信号量，可在等待时间预计很短的情况下用于在单个进程内等待。</span><span class="sxs-lookup"><span data-stu-id="1d850-109">The <xref:System.Threading.SemaphoreSlim> class represents a lightweight, fast semaphore that can be used for waiting within a single process when wait times are expected to be very short.</span></span> <span data-ttu-id="1d850-110"><xref:System.Threading.SemaphoreSlim> 尽可能多地依赖公共语言运行时 (CLR) 提供的同步基元。</span><span class="sxs-lookup"><span data-stu-id="1d850-110"><xref:System.Threading.SemaphoreSlim> relies as much as possible on synchronization primitives provided by the common language runtime (CLR).</span></span> <span data-ttu-id="1d850-111">但是，它还提供延迟初始化、基于内核的等待句柄，作为在多个信号量上进行等待的必要支持。</span><span class="sxs-lookup"><span data-stu-id="1d850-111">However, it also provides lazily initialized, kernel-based wait handles as necessary to support waiting on multiple semaphores.</span></span> <span data-ttu-id="1d850-112"><xref:System.Threading.SemaphoreSlim> 也支持使用取消标记，但不支持命名信号量或使用用于同步的等待句柄。</span><span class="sxs-lookup"><span data-stu-id="1d850-112"><xref:System.Threading.SemaphoreSlim> also supports the use of cancellation tokens, but it does not support named semaphores or the use of a wait handle for synchronization.</span></span>  
  
## <a name="managing-a-limited-resource"></a><span data-ttu-id="1d850-113">管理有限资源</span><span class="sxs-lookup"><span data-stu-id="1d850-113">Managing a Limited Resource</span></span>  
 <span data-ttu-id="1d850-114">线程通过调用从 <xref:System.Threading.WaitHandle> 类中继承的 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法进入信号量，无论对于 <xref:System.Threading.Semaphore?displayProperty=nameWithType> 对象、<xref:System.Threading.SemaphoreSlim.Wait%2A?displayProperty=nameWithType> 或 <xref:System.Threading.SemaphoreSlim.WaitAsync%2A?displayProperty=nameWithType> 方法还是 <xref:System.Threading.SemaphoreSlim> 对象都适用。</span><span class="sxs-lookup"><span data-stu-id="1d850-114">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, in the case of a <xref:System.Threading.Semaphore?displayProperty=nameWithType> object, or the <xref:System.Threading.SemaphoreSlim.Wait%2A?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A?displayProperty=nameWithType> method, in the case of a <xref:System.Threading.SemaphoreSlim> object.</span></span> <span data-ttu-id="1d850-115">当调用返回时，信号量计数会减少。</span><span class="sxs-lookup"><span data-stu-id="1d850-115">When the call returns, the count on the semaphore is decremented.</span></span> <span data-ttu-id="1d850-116">当线程请求进入且计数为零时，此线程受到阻止。</span><span class="sxs-lookup"><span data-stu-id="1d850-116">When a thread requests entry and the count is zero, the thread blocks.</span></span> <span data-ttu-id="1d850-117">线程通过调用 <xref:System.Threading.Semaphore.Release%2A?displayProperty=nameWithType> 或 <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> 方法释放信号量时，允许受阻线程进入。</span><span class="sxs-lookup"><span data-stu-id="1d850-117">As threads release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> method, blocked threads are allowed to enter.</span></span> <span data-ttu-id="1d850-118">受阻线程进入信号量无保证的顺序，比如先进先出 (FIFO) 或按后进先出 (LIFO)。</span><span class="sxs-lookup"><span data-stu-id="1d850-118">There is no guaranteed order, such as first-in, first-out (FIFO) or last-in, first-out (LIFO), for blocked threads to enter the semaphore.</span></span>  
  
 <span data-ttu-id="1d850-119">一个线程可通过反复调用 <xref:System.Threading.Semaphore?displayProperty=nameWithType> 对象的 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法或 <xref:System.Threading.SemaphoreSlim> 对象的 <xref:System.Threading.SemaphoreSlim.Wait%2A> 方法进入信号量。</span><span class="sxs-lookup"><span data-stu-id="1d850-119">A thread can enter the semaphore multiple times by calling the <xref:System.Threading.Semaphore?displayProperty=nameWithType> object's <xref:System.Threading.WaitHandle.WaitOne%2A> method or the  <xref:System.Threading.SemaphoreSlim> object's <xref:System.Threading.SemaphoreSlim.Wait%2A> method repeatedly.</span></span> <span data-ttu-id="1d850-120">为了释放信号量，线程可以调用 <xref:System.Threading.Semaphore.Release?displayProperty=nameWithType> 或 <xref:System.Threading.SemaphoreSlim.Release?displayProperty=nameWithType> 方法重载相同次数，或调用 <xref:System.Threading.Semaphore.Release%28System.Int32%29?displayProperty=nameWithType> 或 <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29?displayProperty=nameWithType> 方法重载并指定要释放的项的数量。</span><span class="sxs-lookup"><span data-stu-id="1d850-120">To release the semaphore, the thread can either call the <xref:System.Threading.Semaphore.Release?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release?displayProperty=nameWithType> method overload the same number of times, or call the <xref:System.Threading.Semaphore.Release%28System.Int32%29?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29?displayProperty=nameWithType> method overload and specify the number of entries to be released.</span></span>  
  
### <a name="semaphores-and-thread-identity"></a><span data-ttu-id="1d850-121">信号量和线程标识</span><span class="sxs-lookup"><span data-stu-id="1d850-121">Semaphores and Thread Identity</span></span>  
 <span data-ttu-id="1d850-122">两种信号量类型不会在对 <xref:System.Threading.WaitHandle.WaitOne%2A>、<xref:System.Threading.SemaphoreSlim.Wait%2A>、<xref:System.Threading.Semaphore.Release%2A> 和 <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> 方法的调用上强制线程标识。</span><span class="sxs-lookup"><span data-stu-id="1d850-122">The two semaphore types do not enforce thread identity on calls to the <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.Semaphore.Release%2A>, and <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="1d850-123">例如，信号量的一种常见使用方案涉及制造者线程和使用者线程，其中一个线程始终增加信号量计数，另一个始终减少信号量计数。</span><span class="sxs-lookup"><span data-stu-id="1d850-123">For example, a common usage scenario for semaphores involves a producer thread and a consumer thread, with one thread always incrementing the semaphore count and the other always decrementing it.</span></span>  
  
 <span data-ttu-id="1d850-124">程序员有责任确保线程不会过多次地地释放信号量。</span><span class="sxs-lookup"><span data-stu-id="1d850-124">It is the programmer's responsibility to ensure that a thread does not release the semaphore too many times.</span></span> <span data-ttu-id="1d850-125">例如，假定信号量的最大计数为 2 并且线程 A 和线程 B 都进入了该信号量。</span><span class="sxs-lookup"><span data-stu-id="1d850-125">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="1d850-126">如果线程 B 中的编程错误导致它两次成功调用了 `Release`。</span><span class="sxs-lookup"><span data-stu-id="1d850-126">If a programming error in thread B causes it to call  `Release` twice, both calls succeed.</span></span> <span data-ttu-id="1d850-127">信号灯计数已满，当线程 A 最终调用 `Release` 时，<xref:System.Threading.SemaphoreFullException> 抛出。</span><span class="sxs-lookup"><span data-stu-id="1d850-127">The count on the semaphore is full, and when thread A eventually calls `Release`, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
## <a name="named-semaphores"></a><span data-ttu-id="1d850-128">命名信号量</span><span class="sxs-lookup"><span data-stu-id="1d850-128">Named Semaphores</span></span>  
 <span data-ttu-id="1d850-129">Windows 操作系统允许信号量拥有名称。</span><span class="sxs-lookup"><span data-stu-id="1d850-129">The Windows operating system allows semaphores to have names.</span></span> <span data-ttu-id="1d850-130">命名信号量是系统范围的。</span><span class="sxs-lookup"><span data-stu-id="1d850-130">A named semaphore is system wide.</span></span> <span data-ttu-id="1d850-131">即，一旦创建了命名信号量，它对所有进程中的所有线程均可见。</span><span class="sxs-lookup"><span data-stu-id="1d850-131">That is, once the named semaphore is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="1d850-132">因此，命名信号量可用于同步进程以及线程的活动。</span><span class="sxs-lookup"><span data-stu-id="1d850-132">Thus, named semaphore can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="1d850-133">你可以通过使用指定了名称的构造函数之一来创建表示指定了已命名系统信号量的 <xref:System.Threading.Semaphore> 对象。</span><span class="sxs-lookup"><span data-stu-id="1d850-133">You can create a <xref:System.Threading.Semaphore> object that represents a named system semaphore by using one of the constructors that specifies a name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="1d850-134">因为命名信号量是系统范围的，所以它可能有多个 <xref:System.Threading.Semaphore> 对象，这些对象表示同一命名信号量。</span><span class="sxs-lookup"><span data-stu-id="1d850-134">Because named semaphores are system wide, it is possible to have multiple <xref:System.Threading.Semaphore> objects that represent the same named semaphore.</span></span> <span data-ttu-id="1d850-135">每次调用构造函数或 <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> 方法都会创建一个新的 <xref:System.Threading.Semaphore> 对象。</span><span class="sxs-lookup"><span data-stu-id="1d850-135">Each time you call a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method, a new <xref:System.Threading.Semaphore> object is created.</span></span> <span data-ttu-id="1d850-136">反复指定相同的名称会创建多个表示同一命名信号量的对象。</span><span class="sxs-lookup"><span data-stu-id="1d850-136">Specifying the same name repeatedly creates multiple objects that represent the same named semaphore.</span></span>  
  
 <span data-ttu-id="1d850-137">使用命名信号量时务必谨慎。</span><span class="sxs-lookup"><span data-stu-id="1d850-137">Be careful when you use named semaphores.</span></span> <span data-ttu-id="1d850-138">因为它们是系统范围的，使用同一名称的另一进程可能会意外地进入你的信号量。</span><span class="sxs-lookup"><span data-stu-id="1d850-138">Because they are system wide, another process that uses the same name can enter your semaphore unexpectedly.</span></span> <span data-ttu-id="1d850-139">同一台计算机上的恶意代码执行可将此作为拒绝服务攻击的基础。</span><span class="sxs-lookup"><span data-stu-id="1d850-139">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="1d850-140">使用访问控制安全性来保护表示命名信号量的 <xref:System.Threading.Semaphore> 对象，最好通过使用指定 <xref:System.Security.AccessControl.SemaphoreSecurity?displayProperty=nameWithType> 对象的构造函数。</span><span class="sxs-lookup"><span data-stu-id="1d850-140">Use access control security to protect a <xref:System.Threading.Semaphore> object that represents a named semaphore, preferably by using a constructor that specifies a <xref:System.Security.AccessControl.SemaphoreSecurity?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="1d850-141">你还可以通过使用 <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> 方法应用访问控制安全，但这会使窗口在创建信号量的时间以及信号量受到保护的时间之间留下漏洞。</span><span class="sxs-lookup"><span data-stu-id="1d850-141">You can also apply access control security using the <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> method, but this leaves a window of vulnerability between the time the semaphore is created and the time it is protected.</span></span> <span data-ttu-id="1d850-142">使用访问控制安全机制来保护信号量有助于阻止恶意攻击，但不能解决的意外的名称冲突问题。</span><span class="sxs-lookup"><span data-stu-id="1d850-142">Protecting semaphores with access control security helps prevent malicious attacks, but does not solve the problem of unintentional name collisions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1d850-143">请参阅</span><span class="sxs-lookup"><span data-stu-id="1d850-143">See also</span></span>

- <xref:System.Threading.Semaphore>
- <xref:System.Threading.SemaphoreSlim>
- [<span data-ttu-id="1d850-144">线程处理对象和功能</span><span class="sxs-lookup"><span data-stu-id="1d850-144">Threading Objects and Features</span></span>](threading-objects-and-features.md)
