---
title: EventWaitHandle
ms.date: 03/30/2017
helpviewer_keywords:
- threading [.NET], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET]
- threading [.NET], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
ms.openlocfilehash: 078bda2354a6f0aec2215b0c5da2a021f53ff922
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/24/2020
ms.locfileid: "95723779"
---
# <a name="eventwaithandle"></a><span data-ttu-id="5831c-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="5831c-102">EventWaitHandle</span></span>

<span data-ttu-id="5831c-103">借助 <xref:System.Threading.EventWaitHandle> 类，线程可以通过发出信号和等待信号进行相互通信。</span><span class="sxs-lookup"><span data-stu-id="5831c-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="5831c-104">事件等待句柄（亦简称为“事件”）是可以收到信号以释放一个或多个等待线程的等待句柄。</span><span class="sxs-lookup"><span data-stu-id="5831c-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="5831c-105">收到信号后，事件等待句柄便会进行手动或自动重置。</span><span class="sxs-lookup"><span data-stu-id="5831c-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="5831c-106"><xref:System.Threading.EventWaitHandle> 类可以表示本地事件等待句柄（本地事件），也可以表示命名系统事件等待句柄（对所有进程可见的命名事件或系统事件）。</span><span class="sxs-lookup"><span data-stu-id="5831c-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5831c-107">事件等待句柄不是 .NET [事件](../events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="5831c-107">Event wait handles are not .NET [events](../events/index.md).</span></span> <span data-ttu-id="5831c-108">并不涉及任何委托或事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="5831c-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="5831c-109">之所以使用“事件”一词是因为，它们一直都被称为操作系统事件，并且向等待句柄发出信号可以向等待线程指明事件已发生。</span><span class="sxs-lookup"><span data-stu-id="5831c-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="5831c-110">本地和命名事件等待句柄均使用系统同步对象。为了确保资源获得释放，这些对象受 <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 包装器保护。</span><span class="sxs-lookup"><span data-stu-id="5831c-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="5831c-111">可以使用 <xref:System.Threading.WaitHandle.Dispose%2A> 方法，在使用完对象后立即释放资源。</span><span class="sxs-lookup"><span data-stu-id="5831c-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="5831c-112">自动重置的事件等待句柄</span><span class="sxs-lookup"><span data-stu-id="5831c-112">Event Wait Handles That Reset Automatically</span></span>  

 <span data-ttu-id="5831c-113">若要创建自动重置事件，可以在创建 <xref:System.Threading.EventWaitHandle> 对象时指定 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5831c-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="5831c-114">顾名思义，此同步事件在一个等待线程释放后收到信号时自动重置。</span><span class="sxs-lookup"><span data-stu-id="5831c-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="5831c-115">若要向事件发出信号，请调用它的 <xref:System.Threading.EventWaitHandle.Set%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="5831c-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="5831c-116">自动重置事件通常用于一次向一个线程提供对资源的独占访问权限。</span><span class="sxs-lookup"><span data-stu-id="5831c-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="5831c-117">线程通过调用 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法来请求获取资源。</span><span class="sxs-lookup"><span data-stu-id="5831c-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="5831c-118">如果其他线程都没有等待句柄，此方法返回 `true`，且调用线程可以控制资源。</span><span class="sxs-lookup"><span data-stu-id="5831c-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="5831c-119">与所有同步机制一样，必须确保在访问受保护的资源前，所有代码路径都在相应的等待句柄上等待。</span><span class="sxs-lookup"><span data-stu-id="5831c-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="5831c-120">线程同步具有协作性。</span><span class="sxs-lookup"><span data-stu-id="5831c-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="5831c-121">如果向自动重置事件发出信号时没有线程正在等待，此信号会一直发出到有线程尝试在等待句柄上等待。</span><span class="sxs-lookup"><span data-stu-id="5831c-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="5831c-122">此时，事件会释放相应线程并立即重置自身，同时阻止后续线程。</span><span class="sxs-lookup"><span data-stu-id="5831c-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="5831c-123">手动重置的事件等待句柄</span><span class="sxs-lookup"><span data-stu-id="5831c-123">Event Wait Handles That Reset Manually</span></span>  

 <span data-ttu-id="5831c-124">若要创建手动重置事件，可以在创建 <xref:System.Threading.EventWaitHandle> 对象时指定 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="5831c-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="5831c-125">顾名思义，此同步事件必须在收到信号后进行手动重置。</span><span class="sxs-lookup"><span data-stu-id="5831c-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="5831c-126">调用 <xref:System.Threading.EventWaitHandle.Reset%2A> 方法重置事件前，在事件句柄上等待的线程会立即继续运行，而不受阻止。</span><span class="sxs-lookup"><span data-stu-id="5831c-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="5831c-127">手动重置事件如同畜栏口一样。</span><span class="sxs-lookup"><span data-stu-id="5831c-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="5831c-128">如果事件未收到信号，在事件句柄上等待的线程受阻止，如同畜栏中的马一样。</span><span class="sxs-lookup"><span data-stu-id="5831c-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="5831c-129">通过调用 <xref:System.Threading.EventWaitHandle.Set%2A> 方法向事件发出信号后，所有等待线程都获得释放，可以继续执行。</span><span class="sxs-lookup"><span data-stu-id="5831c-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="5831c-130">在 <xref:System.Threading.EventWaitHandle.Reset%2A> 方法获得调用前，一直向事件发出信号。</span><span class="sxs-lookup"><span data-stu-id="5831c-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="5831c-131">这样一来，手动重置事件就非常适用于，阻止需要等待一个线程完成任务的线程。</span><span class="sxs-lookup"><span data-stu-id="5831c-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="5831c-132">就像马离开畜栏一样，获释放的线程需要一定的时间，操作系统才能排入计划和恢复执行。</span><span class="sxs-lookup"><span data-stu-id="5831c-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="5831c-133">如果在所有线程恢复执行前 <xref:System.Threading.EventWaitHandle.Reset%2A> 方法获得调用，剩余线程将再次受阻止。</span><span class="sxs-lookup"><span data-stu-id="5831c-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="5831c-134">恢复哪些线程以及阻止哪些线程都取决于随机因素，如系统负载、等待计划程序的线程数等。</span><span class="sxs-lookup"><span data-stu-id="5831c-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="5831c-135">如果向事件发出信号的线程在发出信号后结束（这是最常见的使用模式），这就不存在问题。</span><span class="sxs-lookup"><span data-stu-id="5831c-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="5831c-136">如果希望向事件发出信号的线程在所有等待线程恢复后启动新任务，必须将它一直阻止到所有等待线程都已恢复。</span><span class="sxs-lookup"><span data-stu-id="5831c-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="5831c-137">否则，将会出现争用条件，而且代码行为也会变得不可预测。</span><span class="sxs-lookup"><span data-stu-id="5831c-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="5831c-138">自动和手动事件的常见功能</span><span class="sxs-lookup"><span data-stu-id="5831c-138">Features Common to Automatic and Manual Events</span></span>  

 <span data-ttu-id="5831c-139">通常情况下，一个或多个线程在 <xref:System.Threading.EventWaitHandle> 上一直受阻止到未受阻止的线程调用 <xref:System.Threading.EventWaitHandle.Set%2A> 方法，此方法释放等待线程之一（如果是自动重置事件）或全部线程（如果是手动重置事件）。</span><span class="sxs-lookup"><span data-stu-id="5831c-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="5831c-140">线程可以向 <xref:System.Threading.EventWaitHandle> 发出信号，然后调用静态 <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> 方法以原子操作的形式在其中受阻止。</span><span class="sxs-lookup"><span data-stu-id="5831c-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="5831c-141"><xref:System.Threading.EventWaitHandle> 对象可以与静态 <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> 和 <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> 方法结合使用。</span><span class="sxs-lookup"><span data-stu-id="5831c-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="5831c-142">由于 <xref:System.Threading.EventWaitHandle> 和 <xref:System.Threading.Mutex> 类均派生自 <xref:System.Threading.WaitHandle>，因此可以将这两个类与这些方法结合使用。</span><span class="sxs-lookup"><span data-stu-id="5831c-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="5831c-143">命名事件</span><span class="sxs-lookup"><span data-stu-id="5831c-143">Named Events</span></span>  

 <span data-ttu-id="5831c-144">Windows 操作系统允许命名事件等待句柄。</span><span class="sxs-lookup"><span data-stu-id="5831c-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="5831c-145">命名事件的范围覆盖整个系统。</span><span class="sxs-lookup"><span data-stu-id="5831c-145">A named event is system wide.</span></span> <span data-ttu-id="5831c-146">也就是说，一旦创建，命名事件就对所有进程中的全部线程可见。</span><span class="sxs-lookup"><span data-stu-id="5831c-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="5831c-147">因此，命名事件可用于同步进程和线程的活动。</span><span class="sxs-lookup"><span data-stu-id="5831c-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="5831c-148">可以使用指定事件名称的构造函数之一，创建表示命名系统事件的 <xref:System.Threading.EventWaitHandle> 对象。</span><span class="sxs-lookup"><span data-stu-id="5831c-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5831c-149">由于命名事件的范围覆盖整个系统，因此可能有多个 <xref:System.Threading.EventWaitHandle> 对象表示同一命名事件。</span><span class="sxs-lookup"><span data-stu-id="5831c-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="5831c-150">每次调用构造函数或 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> 方法，都会新建一个 <xref:System.Threading.EventWaitHandle> 对象。</span><span class="sxs-lookup"><span data-stu-id="5831c-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="5831c-151">重复指定相同的名称也会创建多个表示同一命名事件的对象。</span><span class="sxs-lookup"><span data-stu-id="5831c-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="5831c-152">建议谨慎使用命名事件。</span><span class="sxs-lookup"><span data-stu-id="5831c-152">Caution is advised in using named events.</span></span> <span data-ttu-id="5831c-153">由于命名事件的范围覆盖整个系统，因此同名的另一进程可能会意外阻止线程。</span><span class="sxs-lookup"><span data-stu-id="5831c-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="5831c-154">同一台计算机上的恶意代码执行可将此作为拒绝服务攻击的基础。</span><span class="sxs-lookup"><span data-stu-id="5831c-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="5831c-155">借助访问控制安全性，可以保护表示命名事件的 <xref:System.Threading.EventWaitHandle> 对象，最好使用指定 <xref:System.Security.AccessControl.EventWaitHandleSecurity> 对象的构造函数。</span><span class="sxs-lookup"><span data-stu-id="5831c-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="5831c-156">还可以使用 <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> 方法应用访问控制安全性，但这会导致在创建和保护事件等待句柄的时间间隔易受攻击。</span><span class="sxs-lookup"><span data-stu-id="5831c-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="5831c-157">虽然应用访问控制安全性来保护事件有助于防止恶意攻击，但不能解决无意间的名称冲突问题。</span><span class="sxs-lookup"><span data-stu-id="5831c-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5831c-158">与 <xref:System.Threading.EventWaitHandle> 类不同，派生类 <xref:System.Threading.AutoResetEvent> 和 <xref:System.Threading.ManualResetEvent> 只能表示本地等待句柄。</span><span class="sxs-lookup"><span data-stu-id="5831c-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="5831c-159">无法表示命名系统事件。</span><span class="sxs-lookup"><span data-stu-id="5831c-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5831c-160">另请参阅</span><span class="sxs-lookup"><span data-stu-id="5831c-160">See also</span></span>

- <xref:System.Threading.EventWaitHandle>
- <xref:System.Threading.WaitHandle>
- <xref:System.Threading.AutoResetEvent>
- <xref:System.Threading.ManualResetEvent>
