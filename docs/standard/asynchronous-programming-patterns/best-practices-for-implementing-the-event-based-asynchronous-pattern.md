---
title: 实现基于事件的异步模式的最佳做法
ms.date: 03/30/2017
helpviewer_keywords:
- Event-based Asynchronous Pattern
- ProgressChangedEventArgs class
- BackgroundWorker component
- events [.NET], asynchronous
- AsyncOperationManager class
- threading [.NET], asynchronous features
- AsyncOperation class
- AsyncCompletedEventArgs class
ms.assetid: 4acd2094-4f46-4eff-9190-92d0d9ff47db
ms.openlocfilehash: 6c2df4c2877f9191bd2b8190869c359a74de8e8f
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/18/2020
ms.locfileid: "94830488"
---
# <a name="best-practices-for-implementing-the-event-based-asynchronous-pattern"></a><span data-ttu-id="85ef8-102">实现基于事件的异步模式的最佳做法</span><span class="sxs-lookup"><span data-stu-id="85ef8-102">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>

<span data-ttu-id="85ef8-103">基于事件的异步模式提供了一种在类中使用熟悉的事件和委托语义公开异步行为的有效方法。</span><span class="sxs-lookup"><span data-stu-id="85ef8-103">The Event-based Asynchronous Pattern provides you with an effective way to expose asynchronous behavior in classes, with familiar event and delegate semantics.</span></span> <span data-ttu-id="85ef8-104">若要实现基于事件的异步模式，你需要遵循某些特定的行为要求。</span><span class="sxs-lookup"><span data-stu-id="85ef8-104">To implement Event-based Asynchronous Pattern, you need to follow some specific behavioral requirements.</span></span> <span data-ttu-id="85ef8-105">以下部分描述了在你实现遵循基于事件的异步模式的类时应该考虑的要求和准则。</span><span class="sxs-lookup"><span data-stu-id="85ef8-105">The following sections describe requirements and guidelines you should consider when you implement a class that follows the Event-based Asynchronous Pattern.</span></span>  
  
 <span data-ttu-id="85ef8-106">有关概述，请参阅[实现基于事件的异步模式](implementing-the-event-based-asynchronous-pattern.md)。</span><span class="sxs-lookup"><span data-stu-id="85ef8-106">For an overview, see [Implementing the Event-based Asynchronous Pattern](implementing-the-event-based-asynchronous-pattern.md).</span></span>  
  
## <a name="required-behavioral-guarantees"></a><span data-ttu-id="85ef8-107">必需的行为保证</span><span class="sxs-lookup"><span data-stu-id="85ef8-107">Required Behavioral Guarantees</span></span>

 <span data-ttu-id="85ef8-108">若要实现基于事件的异步模式，你必须提供一些保证来确保类的行为正确且类的客户端能够依赖这种行为。</span><span class="sxs-lookup"><span data-stu-id="85ef8-108">If you implement the Event-based Asynchronous Pattern, you must provide a number of guarantees to ensure that your class will behave properly and clients of your class can rely on such behavior.</span></span>  
  
### <a name="completion"></a><span data-ttu-id="85ef8-109">完成</span><span class="sxs-lookup"><span data-stu-id="85ef8-109">Completion</span></span>

 <span data-ttu-id="85ef8-110">操作成功完成、出错或取消时，始终应调用 <em>MethodName</em>Completed 事件处理程序  。</span><span class="sxs-lookup"><span data-stu-id="85ef8-110">Always invoke the <em>MethodName</em>**Completed** event handler when you have successful completion, an error, or a cancellation.</span></span> <span data-ttu-id="85ef8-111">任何情况下，应用程序都不应遇到这样的情况：应用程序保持空闲状态，而操作却一直不能完成。</span><span class="sxs-lookup"><span data-stu-id="85ef8-111">Applications should never encounter a situation where they remain idle and completion never occurs.</span></span> <span data-ttu-id="85ef8-112">此规则的例外情况是：异步操作本身设计为永不完成。</span><span class="sxs-lookup"><span data-stu-id="85ef8-112">One exception to this rule is if the asynchronous operation itself is designed so that it never completes.</span></span>  
  
### <a name="completed-event-and-eventargs"></a><span data-ttu-id="85ef8-113">已完成的事件和 EventArgs</span><span class="sxs-lookup"><span data-stu-id="85ef8-113">Completed Event and EventArgs</span></span>

<span data-ttu-id="85ef8-114">针对每个单独的 <em>MethodName</em>Async  方法，请应用以下设计要求：</span><span class="sxs-lookup"><span data-stu-id="85ef8-114">For each separate <em>MethodName</em>**Async** method, apply the following design requirements:</span></span>  
  
- <span data-ttu-id="85ef8-115">在与该方法相同的类上定义 <em>MethodName</em>Completed 事件  。</span><span class="sxs-lookup"><span data-stu-id="85ef8-115">Define a <em>MethodName</em>**Completed** event on the same class as the method.</span></span>  
  
- <span data-ttu-id="85ef8-116">为派生自 <xref:System.ComponentModel.AsyncCompletedEventArgs> 类的 <em>MethodName</em>Completed 事件定义一个 <xref:System.EventArgs> 类和随附委托。</span><span class="sxs-lookup"><span data-stu-id="85ef8-116">Define an <xref:System.EventArgs> class and accompanying delegate for the <em>MethodName</em>**Completed** event that derives from the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.</span></span> <span data-ttu-id="85ef8-117">默认类名应采用 <em>MethodName</em>CompletedEventArgs  形式。</span><span class="sxs-lookup"><span data-stu-id="85ef8-117">The default class name should be of the form <em>MethodName</em>**CompletedEventArgs**.</span></span>  
  
- <span data-ttu-id="85ef8-118">确保 <xref:System.EventArgs> 类特定于 <em>MethodName</em> 方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="85ef8-118">Ensure that the <xref:System.EventArgs> class is specific to the return values of the <em>MethodName</em> method.</span></span> <span data-ttu-id="85ef8-119">在使用 <xref:System.EventArgs> 类时，切勿要求开发人员强制转换结果。</span><span class="sxs-lookup"><span data-stu-id="85ef8-119">When you use the <xref:System.EventArgs> class, you should never require developers to cast the result.</span></span>  
  
     <span data-ttu-id="85ef8-120">下面的代码示例分别演示了此项设计要求的合理实现和错误实现。</span><span class="sxs-lookup"><span data-stu-id="85ef8-120">The following code example shows good and bad implementation of this design requirement respectively.</span></span>  
  
```csharp  
// Good design  
private void Form1_MethodNameCompleted(object sender, xxxCompletedEventArgs e)
{
    DemoType result = e.Result;  
}  
  
// Bad design  
private void Form1_MethodNameCompleted(object sender, MethodNameCompletedEventArgs e)
{
    DemoType result = (DemoType)(e.Result);  
}  
```  
  
- <span data-ttu-id="85ef8-121">不要为返回 <xref:System.EventArgs> 的返回方法定义 `void` 类。</span><span class="sxs-lookup"><span data-stu-id="85ef8-121">Do not define an <xref:System.EventArgs> class for returning methods that return `void`.</span></span> <span data-ttu-id="85ef8-122">而应使用 <xref:System.ComponentModel.AsyncCompletedEventArgs> 类的实例。</span><span class="sxs-lookup"><span data-stu-id="85ef8-122">Instead, use an instance of the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.</span></span>  
  
- <span data-ttu-id="85ef8-123">应务必始终抛出 <em>MethodName</em>Completed  事件。</span><span class="sxs-lookup"><span data-stu-id="85ef8-123">Ensure that you always raise the <em>MethodName</em>**Completed** event.</span></span> <span data-ttu-id="85ef8-124">成功完成、出错或者取消时应引发此事件。</span><span class="sxs-lookup"><span data-stu-id="85ef8-124">This event should be raised on successful completion, on an error, or on cancellation.</span></span> <span data-ttu-id="85ef8-125">任何情况下，应用程序都不应遇到这样的情况：应用程序保持空闲状态，而操作却一直不能完成。</span><span class="sxs-lookup"><span data-stu-id="85ef8-125">Applications should never encounter a situation where they remain idle and completion never occurs.</span></span>  
  
- <span data-ttu-id="85ef8-126">确保可以捕获异步操作中发生的任何异常并将捕获的异常分配给 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="85ef8-126">Ensure that you catch any exceptions that occur in the asynchronous operation and assign the caught exception to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.</span></span>  
  
- <span data-ttu-id="85ef8-127">如果完成任务时出现错误，其结果应当不可访问。</span><span class="sxs-lookup"><span data-stu-id="85ef8-127">If there was an error completing the task, the results should not be accessible.</span></span> <span data-ttu-id="85ef8-128">当 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 属性不为 `null` 时，确保访问 <xref:System.EventArgs> 结构中的任何属性都会引发异常。</span><span class="sxs-lookup"><span data-stu-id="85ef8-128">When the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property is not `null`, ensure that accessing any property in the <xref:System.EventArgs> structure raises an exception.</span></span> <span data-ttu-id="85ef8-129">使用 <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> 方法来执行此验证。</span><span class="sxs-lookup"><span data-stu-id="85ef8-129">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method to perform this verification.</span></span>  
  
- <span data-ttu-id="85ef8-130">将超时建模为错误。</span><span class="sxs-lookup"><span data-stu-id="85ef8-130">Model a time out as an error.</span></span> <span data-ttu-id="85ef8-131">如果发生超时，应抛出 <em>MethodName</em>Completed  事件，并将 <xref:System.TimeoutException> 分配给 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="85ef8-131">When a time out occurs, raise the <em>MethodName</em>**Completed** event and assign a <xref:System.TimeoutException> to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.</span></span>  
  
- <span data-ttu-id="85ef8-132">如果类支持多个并发调用，应确保 <em>MethodName</em>Completed  事件包含相应的 `userSuppliedState` 对象。</span><span class="sxs-lookup"><span data-stu-id="85ef8-132">If your class supports multiple concurrent invocations, ensure that the <em>MethodName</em>**Completed** event contains the appropriate `userSuppliedState` object.</span></span>  
  
- <span data-ttu-id="85ef8-133">应确保在应用生命周期中适时对相应线程抛出 <em>MethodName</em>Completed  事件。</span><span class="sxs-lookup"><span data-stu-id="85ef8-133">Ensure that the <em>MethodName</em>**Completed** event is raised on the appropriate thread and at the appropriate time in the application lifecycle.</span></span> <span data-ttu-id="85ef8-134">有关更多信息，请参见“线程处理和上下文”部分。</span><span class="sxs-lookup"><span data-stu-id="85ef8-134">For more information, see the Threading and Contexts section.</span></span>  
  
### <a name="simultaneously-executing-operations"></a><span data-ttu-id="85ef8-135">同时执行操作</span><span class="sxs-lookup"><span data-stu-id="85ef8-135">Simultaneously Executing Operations</span></span>  
  
- <span data-ttu-id="85ef8-136">如果类支持多个并发调用，应让开发人员可以单独跟踪各个调用，具体操作是定义 <em>MethodName</em>Async  重载，此重载需要使用对象赋值状态参数或任务 ID（名为 `userSuppliedState`）。</span><span class="sxs-lookup"><span data-stu-id="85ef8-136">If your class supports multiple concurrent invocations, enable the developer to track each invocation separately by defining the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, called `userSuppliedState`.</span></span> <span data-ttu-id="85ef8-137">此参数应始终是 <em>MethodName</em>Async  方法签名中的最后一个参数。</span><span class="sxs-lookup"><span data-stu-id="85ef8-137">This parameter should always be the last parameter in the <em>MethodName</em>**Async** method's signature.</span></span>  
  
- <span data-ttu-id="85ef8-138">如果类定义了需要使用对象赋值状态参数或任务 ID 的 <em>MethodName</em>Async  重载，应务必使用相应任务 ID 跟踪操作的生存期，并将它 返回给完成事件处理器。</span><span class="sxs-lookup"><span data-stu-id="85ef8-138">If your class defines the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, be sure to track the lifetime of the operation with that task ID, and be sure to provide it back into the completion handler.</span></span> <span data-ttu-id="85ef8-139">有一些用来提供帮助的帮助器类。</span><span class="sxs-lookup"><span data-stu-id="85ef8-139">There are helper classes available to assist.</span></span> <span data-ttu-id="85ef8-140">有关并发管理的详细信息，请参阅[如何：实现支持基于事件的异步模式的组件](component-that-supports-the-event-based-asynchronous-pattern.md)。</span><span class="sxs-lookup"><span data-stu-id="85ef8-140">For more information on concurrency management, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](component-that-supports-the-event-based-asynchronous-pattern.md).</span></span>  
  
- <span data-ttu-id="85ef8-141">如果类定义了不使用状态参数的 <em>MethodName</em>Async 方法，且它不支持多个并发调用，则应确保在先前 <em>MethodName</em>Async 调用完成前，只要尝试调用 <em>MethodName</em>Async 都会导致 <xref:System.InvalidOperationException> 抛出。</span><span class="sxs-lookup"><span data-stu-id="85ef8-141">If your class defines the <em>MethodName</em>**Async** method without the state parameter, and it does not support multiple concurrent invocations, ensure that any attempt to invoke <em>MethodName</em>**Async** before the prior <em>MethodName</em>**Async** invocation has completed raises an <xref:System.InvalidOperationException>.</span></span>  
  
- <span data-ttu-id="85ef8-142">一般来说，如果多次调用不使用 `userSuppliedState` 参数的 <em>MethodName</em>Async 方法，导致多个未结操作出现，不得抛出异常。</span><span class="sxs-lookup"><span data-stu-id="85ef8-142">In general, do not raise an exception if the <em>MethodName</em>**Async** method without the `userSuppliedState` parameter is invoked multiple times so that there are multiple outstanding operations.</span></span> <span data-ttu-id="85ef8-143">如果类无法显式处理这种情况，将引发异常，但可假定开发人员能够处理多个不可区分回调。</span><span class="sxs-lookup"><span data-stu-id="85ef8-143">You can raise an exception when your class explicitly cannot handle that situation, but assume that developers can handle these multiple indistinguishable callbacks</span></span>  
  
### <a name="accessing-results"></a><span data-ttu-id="85ef8-144">访问结果</span><span class="sxs-lookup"><span data-stu-id="85ef8-144">Accessing Results</span></span>  
  
- <span data-ttu-id="85ef8-145">如果在执行异步操作期间出现错误，其结果应当不可访问。</span><span class="sxs-lookup"><span data-stu-id="85ef8-145">If there was an error during execution of the asynchronous operation, the results should not be accessible.</span></span> <span data-ttu-id="85ef8-146">确保在 <xref:System.ComponentModel.AsyncCompletedEventArgs> 不为 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 时访问 `null` 中的任何属性都会引发由 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 引用的异常。</span><span class="sxs-lookup"><span data-stu-id="85ef8-146">Ensure that accessing any property in the <xref:System.ComponentModel.AsyncCompletedEventArgs> when <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> is not `null` raises the exception referenced by <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>.</span></span> <span data-ttu-id="85ef8-147"><xref:System.ComponentModel.AsyncCompletedEventArgs> 类为达到此目的提供了 <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="85ef8-147">The <xref:System.ComponentModel.AsyncCompletedEventArgs> class provides the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method for this purpose.</span></span>  
  
- <span data-ttu-id="85ef8-148">确保访问结果的任何尝试都将引发 <xref:System.InvalidOperationException>，指出该操作已被取消。</span><span class="sxs-lookup"><span data-stu-id="85ef8-148">Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled.</span></span> <span data-ttu-id="85ef8-149">使用 <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> 方法来执行此验证。</span><span class="sxs-lookup"><span data-stu-id="85ef8-149">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.</span></span>  
  
### <a name="progress-reporting"></a><span data-ttu-id="85ef8-150">进度报告</span><span class="sxs-lookup"><span data-stu-id="85ef8-150">Progress Reporting</span></span>  
  
- <span data-ttu-id="85ef8-151">如有可能，支持进度报告。</span><span class="sxs-lookup"><span data-stu-id="85ef8-151">Support progress reporting, if possible.</span></span> <span data-ttu-id="85ef8-152">在开发人员使用你的类时，这使他们能够提供更好的应用程序用户体验。</span><span class="sxs-lookup"><span data-stu-id="85ef8-152">This enables developers to provide a better application user experience when they use your class.</span></span>  
  
- <span data-ttu-id="85ef8-153">如果实现 ProgressChanged  或 <em>MethodName</em>ProgressChanged  事件，应确保在抛出特定异步操作的 <em>MethodName</em>Completed  事件后，不会对此操作抛出所实现的事件。</span><span class="sxs-lookup"><span data-stu-id="85ef8-153">If you implement a **ProgressChanged** or <em>MethodName</em>**ProgressChanged** event, ensure that there are no such events raised for a particular asynchronous operation after that operation's <em>MethodName</em>**Completed** event has been raised.</span></span>  
  
- <span data-ttu-id="85ef8-154">如果正在填充标准的 <xref:System.ComponentModel.ProgressChangedEventArgs>，则请确保始终能够将 <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> 解释为一个百分比。</span><span class="sxs-lookup"><span data-stu-id="85ef8-154">If the standard <xref:System.ComponentModel.ProgressChangedEventArgs> is being populated, ensure that the <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> can always be interpreted as a percentage.</span></span> <span data-ttu-id="85ef8-155">该百分比不必是一个精确值，但它应表示为百分数的形式。</span><span class="sxs-lookup"><span data-stu-id="85ef8-155">The percentage does not need to be accurate, but it should represent a percentage.</span></span> <span data-ttu-id="85ef8-156">如果你的进度报告指标不能是一个百分比，请从 <xref:System.ComponentModel.ProgressChangedEventArgs> 类中派生一个类并将 <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> 保留为 0。</span><span class="sxs-lookup"><span data-stu-id="85ef8-156">If your progress reporting metric must be something other than a percentage, derive a class from the <xref:System.ComponentModel.ProgressChangedEventArgs> class and leave <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> at 0.</span></span> <span data-ttu-id="85ef8-157">避免使用非百分比的报告指标。</span><span class="sxs-lookup"><span data-stu-id="85ef8-157">Avoid using a reporting metric other than a percentage.</span></span>  
  
- <span data-ttu-id="85ef8-158">请确保在应用程序生命周期中的适当时间在适当的线程上引发了 `ProgressChanged` 事件。</span><span class="sxs-lookup"><span data-stu-id="85ef8-158">Ensure that the `ProgressChanged` event is raised on the appropriate thread and at the appropriate time in the application lifecycle.</span></span> <span data-ttu-id="85ef8-159">有关更多信息，请参见“线程处理和上下文”部分。</span><span class="sxs-lookup"><span data-stu-id="85ef8-159">For more information, see the Threading and Contexts section.</span></span>  
  
### <a name="isbusy-implementation"></a><span data-ttu-id="85ef8-160">IsBusy 实现</span><span class="sxs-lookup"><span data-stu-id="85ef8-160">IsBusy Implementation</span></span>  
  
- <span data-ttu-id="85ef8-161">如果你的类支持多个并发调用，则不要公开 `IsBusy` 属性。</span><span class="sxs-lookup"><span data-stu-id="85ef8-161">Do not expose an `IsBusy` property if your class supports multiple concurrent invocations.</span></span> <span data-ttu-id="85ef8-162">例如，XML Web services 代理不会公开 `IsBusy` 属性，因为它们支持异步方法的多个并发调用。</span><span class="sxs-lookup"><span data-stu-id="85ef8-162">For example, XML Web service proxies do not expose an `IsBusy` property because they support multiple concurrent invocations of asynchronous methods.</span></span>  
  
- <span data-ttu-id="85ef8-163">在调用 <em>MethodName</em>Async 方法后，且在抛出 <em>MethodName</em>Completed 事件前，`IsBusy` 属性应返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="85ef8-163">The `IsBusy` property should return `true` after the <em>MethodName</em>**Async** method has been called and before the <em>MethodName</em>**Completed** event has been raised.</span></span> <span data-ttu-id="85ef8-164">否则，它应返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="85ef8-164">Otherwise it should return `false`.</span></span> <span data-ttu-id="85ef8-165"><xref:System.ComponentModel.BackgroundWorker> 和 <xref:System.Net.WebClient> 组件是公开 `IsBusy` 属性的类的示例。</span><span class="sxs-lookup"><span data-stu-id="85ef8-165">The <xref:System.ComponentModel.BackgroundWorker> and <xref:System.Net.WebClient> components are examples of classes that expose an `IsBusy` property.</span></span>  
  
### <a name="cancellation"></a><span data-ttu-id="85ef8-166">取消</span><span class="sxs-lookup"><span data-stu-id="85ef8-166">Cancellation</span></span>  
  
- <span data-ttu-id="85ef8-167">如有可能，支持取消。</span><span class="sxs-lookup"><span data-stu-id="85ef8-167">Support cancellation, if possible.</span></span> <span data-ttu-id="85ef8-168">在开发人员使用你的类时，这使他们能够提供更好的应用程序用户体验。</span><span class="sxs-lookup"><span data-stu-id="85ef8-168">This enables developers to provide a better application user experience when they use your class.</span></span>  
  
- <span data-ttu-id="85ef8-169">在发生取消时，设置 <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> 对象中的 <xref:System.ComponentModel.AsyncCompletedEventArgs> 标志。</span><span class="sxs-lookup"><span data-stu-id="85ef8-169">In the case of cancellation, set the <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> flag in the <xref:System.ComponentModel.AsyncCompletedEventArgs> object.</span></span>  
  
- <span data-ttu-id="85ef8-170">确保访问结果的任何尝试都将引发 <xref:System.InvalidOperationException>，指出该操作已被取消。</span><span class="sxs-lookup"><span data-stu-id="85ef8-170">Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled.</span></span> <span data-ttu-id="85ef8-171">使用 <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> 方法来执行此验证。</span><span class="sxs-lookup"><span data-stu-id="85ef8-171">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.</span></span>  
  
- <span data-ttu-id="85ef8-172">请确保对取消方法发出的调用始终能够成功返回，而且从不引发异常。</span><span class="sxs-lookup"><span data-stu-id="85ef8-172">Ensure that calls to a cancellation method always return successfully, and never raise an exception.</span></span> <span data-ttu-id="85ef8-173">一般来说，客户端不会得到关于在任何给定时间是否真正可取消某个操作的通知，也不会得到关于以前发出的取消是否已经成功的通知。</span><span class="sxs-lookup"><span data-stu-id="85ef8-173">In general, a client is not notified as to whether an operation is truly cancelable at any given time, and is not notified as to whether a previously issued cancellation has succeeded.</span></span> <span data-ttu-id="85ef8-174">不过，应用程序在取消成功时总能得到通知，因为应用程序参与了完成状态。</span><span class="sxs-lookup"><span data-stu-id="85ef8-174">However, the application will always be given notification when a cancellation succeeded, because the application takes part in the completion status.</span></span>  
  
- <span data-ttu-id="85ef8-175">取消操作时，应抛出 <em>MethodName</em>Completed  事件。</span><span class="sxs-lookup"><span data-stu-id="85ef8-175">Raise the <em>MethodName</em>**Completed** event when the operation is canceled.</span></span>  
  
### <a name="errors-and-exceptions"></a><span data-ttu-id="85ef8-176">错误和异常</span><span class="sxs-lookup"><span data-stu-id="85ef8-176">Errors and Exceptions</span></span>  
  
- <span data-ttu-id="85ef8-177">捕获所有发生在异步操作中的异常并将 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> 属性的值设置为该异常。</span><span class="sxs-lookup"><span data-stu-id="85ef8-177">Catch any exceptions that occur in the asynchronous operation and set the value of the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> property to that exception.</span></span>  
  
### <a name="threading-and-contexts"></a><span data-ttu-id="85ef8-178">线程处理和上下文</span><span class="sxs-lookup"><span data-stu-id="85ef8-178">Threading and Contexts</span></span>

 <span data-ttu-id="85ef8-179">为了使类正确运行，应当使用给定应用程序模型（包括 ASP.NET 和 Windows 窗体应用程序）的适当线程或上下文调用客户端事件处理程序，这一点很重要。</span><span class="sxs-lookup"><span data-stu-id="85ef8-179">For correct operation of your class, it is critical that the client's event handlers are invoked on the proper thread or context for the given application model, including ASP.NET and Windows Forms applications.</span></span> <span data-ttu-id="85ef8-180">我们提供了两个重要的帮助器类，以确保你的异步类在任何应用程序模型中都能正确运行，这两个帮助器类是 <xref:System.ComponentModel.AsyncOperation> 和 <xref:System.ComponentModel.AsyncOperationManager>。</span><span class="sxs-lookup"><span data-stu-id="85ef8-180">Two important helper classes are provided to ensure that your asynchronous class behaves correctly under any application model: <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager>.</span></span>  
  
 <span data-ttu-id="85ef8-181"><xref:System.ComponentModel.AsyncOperationManager> 提供了 <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> 方法，该方法会返回一个 <xref:System.ComponentModel.AsyncOperation>。</span><span class="sxs-lookup"><span data-stu-id="85ef8-181"><xref:System.ComponentModel.AsyncOperationManager> provides one method, <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>, which returns an <xref:System.ComponentModel.AsyncOperation>.</span></span> <span data-ttu-id="85ef8-182"><em>MethodName</em>Async  方法调用 <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>，且类使用返回的 <xref:System.ComponentModel.AsyncOperation> 跟踪异步任务的生存期。</span><span class="sxs-lookup"><span data-stu-id="85ef8-182">Your <em>MethodName</em>**Async** method calls <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> and your class uses the returned <xref:System.ComponentModel.AsyncOperation> to track the lifetime of the asynchronous task.</span></span>  
  
 <span data-ttu-id="85ef8-183">若要将进程、增量结果和完成情况报告给客户端，请调用 <xref:System.ComponentModel.AsyncOperation.Post%2A> 上的 <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> 和 <xref:System.ComponentModel.AsyncOperation> 方法。</span><span class="sxs-lookup"><span data-stu-id="85ef8-183">To report progress, incremental results, and completion to the client, call the <xref:System.ComponentModel.AsyncOperation.Post%2A> and <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> methods on the <xref:System.ComponentModel.AsyncOperation>.</span></span> <span data-ttu-id="85ef8-184"><xref:System.ComponentModel.AsyncOperation> 负责将对客户端事件处理程序的调用封送到合适的线程或上下文。</span><span class="sxs-lookup"><span data-stu-id="85ef8-184"><xref:System.ComponentModel.AsyncOperation> is responsible for marshaling calls to the client's event handlers to the proper thread or context.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="85ef8-185">如果你明确想违反应用程序模型的策略，但仍想获得使用基于事件的异步模式的其他好处，则你可以避开这些规则。</span><span class="sxs-lookup"><span data-stu-id="85ef8-185">You can circumvent these rules if you explicitly want to go against the policy of the application model, but still benefit from the other advantages of using the Event-based Asynchronous Pattern.</span></span> <span data-ttu-id="85ef8-186">例如，你可能希望在 Windows 窗体中进行操作的某个类是自由线程类。</span><span class="sxs-lookup"><span data-stu-id="85ef8-186">For example, you may want a class operating in Windows Forms to be free threaded.</span></span> <span data-ttu-id="85ef8-187">只要开发人员了解隐含的限制，你就可以创建自由线程类。</span><span class="sxs-lookup"><span data-stu-id="85ef8-187">You can create a free threaded class, as long as developers understand the implied restrictions.</span></span> <span data-ttu-id="85ef8-188">控制台应用程序不会同步 <xref:System.ComponentModel.AsyncOperation.Post%2A> 调用的执行。</span><span class="sxs-lookup"><span data-stu-id="85ef8-188">Console applications do not synchronize the execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls.</span></span> <span data-ttu-id="85ef8-189">这会导致按错误的顺序引发 `ProgressChanged` 事件。</span><span class="sxs-lookup"><span data-stu-id="85ef8-189">This can cause `ProgressChanged` events to be raised out of order.</span></span> <span data-ttu-id="85ef8-190">如果希望序列化 <xref:System.ComponentModel.AsyncOperation.Post%2A> 调用的执行，请实现并安装 <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> 类。</span><span class="sxs-lookup"><span data-stu-id="85ef8-190">If you wish to have serialized execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls, implement and install a <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> class.</span></span>  
  
 <span data-ttu-id="85ef8-191">若要详细了解如何使用 <xref:System.ComponentModel.AsyncOperation> 和 <xref:System.ComponentModel.AsyncOperationManager> 启用异步操作，请参阅[如何：实现支持基于事件的异步模式的组件](component-that-supports-the-event-based-asynchronous-pattern.md)。</span><span class="sxs-lookup"><span data-stu-id="85ef8-191">For more information about using <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager> to enable your asynchronous operations, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](component-that-supports-the-event-based-asynchronous-pattern.md).</span></span>  
  
## <a name="guidelines"></a><span data-ttu-id="85ef8-192">准则</span><span class="sxs-lookup"><span data-stu-id="85ef8-192">Guidelines</span></span>  
  
- <span data-ttu-id="85ef8-193">理论上，方法调用与方法调用之间应是相互独立的。</span><span class="sxs-lookup"><span data-stu-id="85ef8-193">Ideally, each method invocation should be independent of others.</span></span> <span data-ttu-id="85ef8-194">你应当避免在使用调用时使用共享资源。</span><span class="sxs-lookup"><span data-stu-id="85ef8-194">You should avoid coupling invocations with shared resources.</span></span> <span data-ttu-id="85ef8-195">如果要在不同调用之间共享资源，则你需要在你的实现中提供一个适当的同步机制。</span><span class="sxs-lookup"><span data-stu-id="85ef8-195">If resources are to be shared among invocations, you will need to provide a proper synchronization mechanism in your implementation.</span></span>  
  
- <span data-ttu-id="85ef8-196">建议不要进行需要客户端实现同步的设计。</span><span class="sxs-lookup"><span data-stu-id="85ef8-196">Designs that require the client to implement synchronization are discouraged.</span></span> <span data-ttu-id="85ef8-197">例如，你可以使用一个异步方法将全局静态对象作为参数来接收；这类方法的多个并发调用可能会导致数据损坏或死锁。</span><span class="sxs-lookup"><span data-stu-id="85ef8-197">For example, you could have an asynchronous method that receives a global static object as a parameter; multiple concurrent invocations of such a method could result in data corruption or deadlocks.</span></span>  
  
- <span data-ttu-id="85ef8-198">如果你使用多个调用重载（签名中的 `userState`）实现方法，你的类将需要管理由一系列用户状态、任务 ID 及其相应的挂起操作构成的一个集合。</span><span class="sxs-lookup"><span data-stu-id="85ef8-198">If you implement a method with the multiple-invocation overload (`userState` in the signature), your class will need to manage a collection of user states, or task IDs, and their corresponding pending operations.</span></span> <span data-ttu-id="85ef8-199">应当使用 `lock` 区域保护此集合，因为各种调用都会在此集合中添加和移除 `userState` 对象。</span><span class="sxs-lookup"><span data-stu-id="85ef8-199">This collection should be protected with `lock` regions, because the various invocations add and remove `userState` objects in the collection.</span></span>  
  
- <span data-ttu-id="85ef8-200">请考虑在可行且适当的情况下，重新使用 `CompletedEventArgs` 类。</span><span class="sxs-lookup"><span data-stu-id="85ef8-200">Consider reusing `CompletedEventArgs` classes where feasible and appropriate.</span></span> <span data-ttu-id="85ef8-201">在这种情况下，命名和方法名不一致，因为给定的委托和 <xref:System.EventArgs> 类型并不会与单独某个方法联系在一起。</span><span class="sxs-lookup"><span data-stu-id="85ef8-201">In this case, the naming is not consistent with the method name, because a given delegate and <xref:System.EventArgs> type are not tied to a single method.</span></span> <span data-ttu-id="85ef8-202">不过，强制开发人员对从 <xref:System.EventArgs> 上的属性检索的值进行强制转换，是绝对不可取的。</span><span class="sxs-lookup"><span data-stu-id="85ef8-202">However, forcing developers to cast the value retrieved from a property on the <xref:System.EventArgs> is never acceptable.</span></span>  
  
- <span data-ttu-id="85ef8-203">如果你正在创建自 <xref:System.ComponentModel.Component> 派生的类，请不要实现和安装你自己的 <xref:System.Threading.SynchronizationContext> 类。</span><span class="sxs-lookup"><span data-stu-id="85ef8-203">If you are authoring a class that derives from <xref:System.ComponentModel.Component>, do not implement and install your own <xref:System.Threading.SynchronizationContext> class.</span></span> <span data-ttu-id="85ef8-204">所使用的 <xref:System.Threading.SynchronizationContext> 由应用程序模型而不是组件控制。</span><span class="sxs-lookup"><span data-stu-id="85ef8-204">Application models, not components, control the <xref:System.Threading.SynchronizationContext> that is used.</span></span>  
  
- <span data-ttu-id="85ef8-205">当你使用任何形式的多线程时，都有可能会遇到非常严重且复杂的 Bug。</span><span class="sxs-lookup"><span data-stu-id="85ef8-205">When you use multithreading of any sort, you potentially expose yourself to very serious and complex bugs.</span></span> <span data-ttu-id="85ef8-206">在实现任何使用多线程处理的解决方案之前，请参阅[托管线程处理最佳做法](../threading/managed-threading-best-practices.md)。</span><span class="sxs-lookup"><span data-stu-id="85ef8-206">Before implementing any solution that uses multithreading, see [Managed Threading Best Practices](../threading/managed-threading-best-practices.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="85ef8-207">另请参阅</span><span class="sxs-lookup"><span data-stu-id="85ef8-207">See also</span></span>

- <xref:System.ComponentModel.AsyncOperation>
- <xref:System.ComponentModel.AsyncOperationManager>
- <xref:System.ComponentModel.AsyncCompletedEventArgs>
- <xref:System.ComponentModel.ProgressChangedEventArgs>
- <xref:System.ComponentModel.BackgroundWorker>
- [<span data-ttu-id="85ef8-208">实现基于事件的异步模式</span><span class="sxs-lookup"><span data-stu-id="85ef8-208">Implementing the Event-based Asynchronous Pattern</span></span>](implementing-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="85ef8-209">基于事件的异步模式 (EAP)</span><span class="sxs-lookup"><span data-stu-id="85ef8-209">Event-based Asynchronous Pattern (EAP)</span></span>](event-based-asynchronous-pattern-eap.md)
- [<span data-ttu-id="85ef8-210">确定何时实现基于事件的异步模式</span><span class="sxs-lookup"><span data-stu-id="85ef8-210">Deciding When to Implement the Event-based Asynchronous Pattern</span></span>](deciding-when-to-implement-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="85ef8-211">实现基于事件的异步模式的最佳做法</span><span class="sxs-lookup"><span data-stu-id="85ef8-211">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>](best-practices-for-implementing-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="85ef8-212">如何：使用支持基于事件的异步模式的组件</span><span class="sxs-lookup"><span data-stu-id="85ef8-212">How to: Use Components That Support the Event-based Asynchronous Pattern</span></span>](how-to-use-components-that-support-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="85ef8-213">如何：实现支持基于事件的异步模式的组件</span><span class="sxs-lookup"><span data-stu-id="85ef8-213">How to: Implement a Component That Supports the Event-based Asynchronous Pattern</span></span>](component-that-supports-the-event-based-asynchronous-pattern.md)
