---
title: 实现基于任务的异步模式
description: 本文介绍如何实现基于任务的异步模式。 可以使用它实现计算密集型和 I/O 密集型异步操作。
ms.date: 06/14/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- asynchronous design patterns, .NET
- TAP, .NET support for
- Task-based Asynchronous Pattern, .NET support for
- .NET, asynchronous design patterns
ms.assetid: fab6bd41-91bd-44ad-86f9-d8319988aa78
ms.openlocfilehash: 7613d93e1ca2ac9594759434966745a238ba166e
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/24/2020
ms.locfileid: "95726725"
---
# <a name="implementing-the-task-based-asynchronous-pattern"></a><span data-ttu-id="8fdf5-104">实现基于任务的异步模式</span><span class="sxs-lookup"><span data-stu-id="8fdf5-104">Implementing the Task-based Asynchronous Pattern</span></span>

<span data-ttu-id="8fdf5-105">可使用以下三种方式实现基于任务的异步模式 (TAP)：使用 Visual Studio 中的 C# 和 Visual Basic 编译器、手动实现或编译器和手动方法相结合。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-105">You can implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span> <span data-ttu-id="8fdf5-106">以下各节详细地讨论了每一种方法。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-106">The following sections discuss each method in detail.</span></span> <span data-ttu-id="8fdf5-107">可以使用 TAP 模式实现计算密集型和 I/O 密集型异步操作。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-107">You can use the TAP pattern to implement both compute-bound and I/O-bound asynchronous operations.</span></span> <span data-ttu-id="8fdf5-108">[工作负载](#workloads)部分介绍了各种类型的操作。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-108">The [Workloads](#workloads) section discusses each type of operation.</span></span>

## <a name="generating-tap-methods"></a><span data-ttu-id="8fdf5-109">生成 TAP 方法</span><span class="sxs-lookup"><span data-stu-id="8fdf5-109">Generating TAP methods</span></span>

### <a name="using-the-compilers"></a><span data-ttu-id="8fdf5-110">使用编译器</span><span class="sxs-lookup"><span data-stu-id="8fdf5-110">Using the compilers</span></span>

<span data-ttu-id="8fdf5-111">自 .NET Framework 4.5 起，任何归于 `async` 关键字（Visual Basic 中的 `Async`）的方法都被视为异步方法，并且 C# 和 Visual Basic 编译器会执行必要的转换，以使用 TAP 异步实现方法。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-111">Starting with .NET Framework 4.5, any method that is attributed with the `async` keyword (`Async` in Visual Basic) is considered an asynchronous method, and the C# and Visual Basic compilers perform the necessary transformations to implement the method asynchronously by using TAP.</span></span> <span data-ttu-id="8fdf5-112">异步方法应返回 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 或 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 对象。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-112">An asynchronous method should return either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="8fdf5-113">对于后者，函数的主体应返回 `TResult`，并且编译器确保此结果是通过生成的任务对象获得。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-113">For the latter, the body of the function should return a `TResult`, and the compiler ensures that this result is made available through the resulting task object.</span></span> <span data-ttu-id="8fdf5-114">同样，未在方法的主体中处理的任何异常都会被封送处理为输出任务并导致生成的任务结束以 <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> 状态结束。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-114">Similarly, any exceptions that go unhandled within the body of the method are marshaled to the output task and cause the resulting task to end in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state.</span></span> <span data-ttu-id="8fdf5-115">此规则的异常发生在 <xref:System.OperationCanceledException>（或派生类型）未得到处理时，在这种情况下生成的任务以 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 状态结束。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-115">The exception to this rule is when an <xref:System.OperationCanceledException> (or derived type) goes unhandled, in which case the resulting task ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>

### <a name="generating-tap-methods-manually"></a><span data-ttu-id="8fdf5-116">手动生成 TAP 方法</span><span class="sxs-lookup"><span data-stu-id="8fdf5-116">Generating TAP methods manually</span></span>

<span data-ttu-id="8fdf5-117">你可以手动实现 TAP 模式以更好地控制实现。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-117">You may implement the TAP pattern manually for better control over implementation.</span></span> <span data-ttu-id="8fdf5-118">编译器依赖从 <xref:System.Threading.Tasks?displayProperty=nameWithType> 命名空间公开的公共外围应用和 <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> 命名空间中支持的类型。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-118">The compiler relies on the public surface area exposed from the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace and supporting types in the <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="8fdf5-119">如要自己实现 TAP，你需要创建一个 <xref:System.Threading.Tasks.TaskCompletionSource%601> 对象、执行异步操作，并在操作完成时，调用 <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>、<xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>、<xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> 方法，或调用这些方法之一的`Try`版本。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-119">To implement the TAP yourself, you create a <xref:System.Threading.Tasks.TaskCompletionSource%601> object, perform the asynchronous operation, and when it completes, call the <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, or <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> method, or the `Try` version of one of these methods.</span></span> <span data-ttu-id="8fdf5-120">手动实现 TAP 方法时，需在所表示的异步操作完成时完成生成的任务。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-120">When you implement a TAP method manually, you must complete the resulting task when the represented asynchronous operation completes.</span></span> <span data-ttu-id="8fdf5-121">例如：</span><span class="sxs-lookup"><span data-stu-id="8fdf5-121">For example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#1)]
[!code-vb[Conceptual.TAP_Patterns#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#1)]

### <a name="hybrid-approach"></a><span data-ttu-id="8fdf5-122">混合方法</span><span class="sxs-lookup"><span data-stu-id="8fdf5-122">Hybrid approach</span></span>

 <span data-ttu-id="8fdf5-123">你可能发现手动实现 TAP 模式、但将实现核心逻辑委托给编译器的这种方法很有用。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-123">You may find it useful to implement the TAP pattern manually but to delegate the core logic for the implementation to the compiler.</span></span> <span data-ttu-id="8fdf5-124">例如，当你想要验证编译器生成的异步方法之外的参数时，可能需要使用这种混合方法，以便异常可以转义到该方法的直接调用方而不是通过 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 对象被公开：</span><span class="sxs-lookup"><span data-stu-id="8fdf5-124">For example, you may want to use the hybrid approach when you want to verify arguments outside a compiler-generated asynchronous method so that exceptions can escape to the method's direct caller rather than being exposed through the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object:</span></span>

 [!code-csharp[Conceptual.TAP_Patterns#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#2)]
 [!code-vb[Conceptual.TAP_Patterns#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#2)]

 <span data-ttu-id="8fdf5-125">这种委托有用的另一种情况是：你在实施快速路径优化并想返回缓存的任务时。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-125">Another case where such delegation is useful is when you're implementing fast-path optimization and want to return a cached task.</span></span>

## <a name="workloads"></a><span data-ttu-id="8fdf5-126">工作负载</span><span class="sxs-lookup"><span data-stu-id="8fdf5-126">Workloads</span></span>

<span data-ttu-id="8fdf5-127">你可将计算密集型和 I/O 密集型异步操作作为 TAP 方法实现。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-127">You may implement both compute-bound and I/O-bound asynchronous operations as TAP methods.</span></span> <span data-ttu-id="8fdf5-128">但是，当 TAP 方法从库中公开地公开时，应仅向涉及 I/O 密集型操作的工作负载提供这种方法（它们也可能涉及计算，但不是应仅仅是计算）。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-128">However, when TAP methods are exposed publicly from a library, they should be provided only for workloads that involve I/O-bound operations (they may also involve computation, but should not be purely computational).</span></span> <span data-ttu-id="8fdf5-129">如果是纯粹的计算密集型方法，应只公开为同步实现。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-129">If a method is purely compute-bound, it should be exposed only as a synchronous implementation.</span></span> <span data-ttu-id="8fdf5-130">然后，使用它的代码可能会选择是将同步方法调用包装到任务中以将工作卸载到另一线程，还是实现并行。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-130">The code that consumes it may then choose whether to wrap an invocation of that synchronous method into a task to offload the work to another thread or to achieve parallelism.</span></span> <span data-ttu-id="8fdf5-131">如果方法是 I/O 密集型，应只公开为异步实现。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-131">And if a method is I/O-bound, it should be exposed only as an asynchronous implementation.</span></span>

### <a name="compute-bound-tasks"></a><span data-ttu-id="8fdf5-132">计算密集型任务</span><span class="sxs-lookup"><span data-stu-id="8fdf5-132">Compute-bound tasks</span></span>

<span data-ttu-id="8fdf5-133"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 类非常适合表示计算密集型操作。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-133">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class is ideally suited for representing computationally intensive operations.</span></span> <span data-ttu-id="8fdf5-134">默认情况下，它利用 <xref:System.Threading.ThreadPool> 类中的特殊支持来提供有效的执行，还对执行异步计算的时间、地点和方式提供重要控制。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-134">By default, it takes advantage of special support within the <xref:System.Threading.ThreadPool> class to provide efficient execution, and it also provides significant control over when, where, and how asynchronous computations execute.</span></span>

<span data-ttu-id="8fdf5-135">你可以通过以下方式生成计算密集型任务：</span><span class="sxs-lookup"><span data-stu-id="8fdf5-135">You can generate compute-bound tasks in the following ways:</span></span>

- <span data-ttu-id="8fdf5-136">在 .NET Framework 4.5 及更高版本（包括 .NET Core 和 .NET 5+）中，使用静态 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 方法作为 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-136">In .NET Framework 4.5 and later versions (including .NET Core and .NET 5+), use the static <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method as a shortcut to <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8fdf5-137">你可以使用 <xref:System.Threading.Tasks.Task.Run%2A> 来轻松启动针对线程池的计算密集型任务。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-137">You may use <xref:System.Threading.Tasks.Task.Run%2A> to easily launch a compute-bound task that targets the thread pool.</span></span> <span data-ttu-id="8fdf5-138">这是用于启动一项计算密集型任务的首选机制。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-138">This is the preferred mechanism for launching a compute-bound task.</span></span> <span data-ttu-id="8fdf5-139">仅当需要更细化地控制任务时，才直接使用 `StartNew`。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-139">Use `StartNew` directly only when you want more fine-grained control over the task.</span></span>

- <span data-ttu-id="8fdf5-140">在 .NET Framework 4 中，使用 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 方法，这种方法接受异步执行委托（通常是 <xref:System.Action%601> 或 <xref:System.Func%601>）。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-140">In .NET Framework 4, use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, which accepts a delegate (typically an <xref:System.Action%601> or a <xref:System.Func%601>) to be executed asynchronously.</span></span> <span data-ttu-id="8fdf5-141">如果你提供 <xref:System.Action%601> 委托，该方法会返回表示异步执行该委托的 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 对象。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-141">If you provide an <xref:System.Action%601> delegate, the method returns a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object that represents the asynchronous execution of that delegate.</span></span> <span data-ttu-id="8fdf5-142">如果你提供 <xref:System.Func%601> 委托，该方法会返回 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 对象。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-142">If you provide a <xref:System.Func%601> delegate, the method returns a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="8fdf5-143"><xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 方法的重载接受一个取消标记（<xref:System.Threading.CancellationToken>）、任务创建选项（<xref:System.Threading.Tasks.TaskCreationOptions>）和一个任务计划程序（<xref:System.Threading.Tasks.TaskScheduler>），它们都对计划和任务执行提供细粒度控制。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-143">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method accept a cancellation token (<xref:System.Threading.CancellationToken>), task creation options (<xref:System.Threading.Tasks.TaskCreationOptions>), and a task scheduler (<xref:System.Threading.Tasks.TaskScheduler>), all of which provide fine-grained control over the scheduling and execution of the task.</span></span> <span data-ttu-id="8fdf5-144">定目标到当前任务计划程序的工厂实例可用作 <xref:System.Threading.Tasks.Task> 类的静态属性 (<xref:System.Threading.Tasks.Task.Factory%2A>)；例如：`Task.Factory.StartNew(…)`。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-144">A factory instance that targets the current task scheduler is available as a static property (<xref:System.Threading.Tasks.Task.Factory%2A>) of the <xref:System.Threading.Tasks.Task> class; for example: `Task.Factory.StartNew(…)`.</span></span>

- <span data-ttu-id="8fdf5-145">想要分别生成并计划任务时，请使用`Task`类型或`Start`方法的构造函数。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-145">Use the constructors of the `Task` type or the `Start` method if you want to generate and schedule the task separately.</span></span> <span data-ttu-id="8fdf5-146">公共方法必须仅返回已开始的任务。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-146">Public methods must only return tasks that have already been started.</span></span>

- <span data-ttu-id="8fdf5-147">使用 <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 方法的重载。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-147">Use the overloads of the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8fdf5-148">此方法创建一项在另一任务完成时已排好计划的新任务。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-148">This method creates a new task that is scheduled when another task completes.</span></span> <span data-ttu-id="8fdf5-149">某些 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 重载接受一个取消标记、延续选项和一个任务计划程序，以更好地控制计划和执行延续任务。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-149">Some of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> overloads accept a cancellation token, continuation options, and a task scheduler for better control over the scheduling and execution of the continuation task.</span></span>

- <span data-ttu-id="8fdf5-150">使用 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-150">Use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="8fdf5-151">这些方法会在提供的全部任务或任意一组任务完成时创建已计划的新任务。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-151">These methods create a new task that is scheduled when all or any of a supplied set of tasks completes.</span></span> <span data-ttu-id="8fdf5-152">这些方法还提供了重载，用于控制这些任务的计划和执行。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-152">These methods also provide overloads to control the scheduling and execution of these tasks.</span></span>

<span data-ttu-id="8fdf5-153">在计算密集型任务中，如果系统在开始运行任务之前收到取消请求，则它可以防止执行已计划的任务。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-153">In compute-bound tasks, the system can prevent the execution of a scheduled task if it receives a cancellation request before it starts running the task.</span></span> <span data-ttu-id="8fdf5-154">同样，如果你提供一个取消标记（<xref:System.Threading.CancellationToken> 对象），则可以将标记传递给监视该标记的异步代码。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-154">As such, if you provide a cancellation token (<xref:System.Threading.CancellationToken> object), you can pass that token to the asynchronous code that monitors the token.</span></span> <span data-ttu-id="8fdf5-155">你也可以将此标记提供给先前提过的方法（如 `StartNew` 或 `Run`），以便`Task`运行时也能监视该标记。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-155">You can also provide the token to one of the previously mentioned methods such as `StartNew` or `Run` so that the `Task` runtime may also monitor the token.</span></span>

<span data-ttu-id="8fdf5-156">例如，请考虑使用呈现图像的异步方法。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-156">For example, consider an asynchronous method that renders an image.</span></span> <span data-ttu-id="8fdf5-157">任务的主体可以轮询取消标记，如果在呈现过程中收到取消请求，代码可提前退出。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-157">The body of the task can poll the cancellation token so that the code may exit early if a cancellation request arrives during rendering.</span></span> <span data-ttu-id="8fdf5-158">此外，如果呈现启动之前收到取消请求，你需要阻止呈现操作：</span><span class="sxs-lookup"><span data-stu-id="8fdf5-158">In addition, if the cancellation request arrives before rendering starts, you'll want to prevent the rendering operation:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#3)]
[!code-vb[Conceptual.TAP_Patterns#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#3)]

<span data-ttu-id="8fdf5-159">如果满足下列条件之一，则计算密集型任务以 <xref:System.Threading.Tasks.TaskStatus.Canceled> 状态结束：</span><span class="sxs-lookup"><span data-stu-id="8fdf5-159">Compute-bound tasks end in a <xref:System.Threading.Tasks.TaskStatus.Canceled> state if at least one of the following conditions is true:</span></span>

- <span data-ttu-id="8fdf5-160">取消请求通过 <xref:System.Threading.CancellationToken> 对象到达，该对象在任务转换到 `StartNew` 状态前，作为创建方法的自变量（例如 `Run` 或 <xref:System.Threading.Tasks.TaskStatus.Running>）提供。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-160">A cancellation request arrives through the <xref:System.Threading.CancellationToken> object, which is provided as an argument to the creation method (for example, `StartNew` or `Run`) before the task transitions to the <xref:System.Threading.Tasks.TaskStatus.Running> state.</span></span>

- <span data-ttu-id="8fdf5-161"><xref:System.OperationCanceledException> 异常在此类任务的主体内未得到处理，该异常包含传给该任务的同一 <xref:System.Threading.CancellationToken>，并且该标记显示已请求取消操作。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-161">An <xref:System.OperationCanceledException> exception goes unhandled within the body of such a task, that exception contains the same <xref:System.Threading.CancellationToken> that is passed to the task, and that token shows that cancellation is requested.</span></span>

<span data-ttu-id="8fdf5-162">如果另一个异常在任务的主体内未得到处理，则此任务以 <xref:System.Threading.Tasks.TaskStatus.Faulted> 状态结束，并且任何等待该任务或访问其结果的尝试都将引发异常。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-162">If another exception goes unhandled within the body of the task, the task ends in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, and any attempts to wait on the task or access its result causes an exception to be thrown.</span></span>

### <a name="io-bound-tasks"></a><span data-ttu-id="8fdf5-163">I/O 密集型任务</span><span class="sxs-lookup"><span data-stu-id="8fdf5-163">I/O-bound tasks</span></span>

<span data-ttu-id="8fdf5-164">若要创建一个不应由线程直接支持其全部执行的任务，请使用 <xref:System.Threading.Tasks.TaskCompletionSource%601> 类型。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-164">To create a task that should not be directly backed by a thread for the entirety of its execution, use the <xref:System.Threading.Tasks.TaskCompletionSource%601> type.</span></span> <span data-ttu-id="8fdf5-165">此类型公开一个返回关联 <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> 实例的 <xref:System.Threading.Tasks.Task%601> 属性。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-165">This type exposes a <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> property that returns an associated <xref:System.Threading.Tasks.Task%601> instance.</span></span> <span data-ttu-id="8fdf5-166">此任务的生命周期是由 <xref:System.Threading.Tasks.TaskCompletionSource%601> 方法控制的，比如 <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>、<xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>、<xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> 以及它们的 `TrySet` 变形。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-166">The life cycle of this task is controlled by <xref:System.Threading.Tasks.TaskCompletionSource%601> methods such as <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, and their `TrySet` variants.</span></span>

<span data-ttu-id="8fdf5-167">假设你想创建一个将在指定时间段后完成的任务。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-167">Let's say that you want to create a task that will complete after a specified period of time.</span></span> <span data-ttu-id="8fdf5-168">例如，你可能想延迟用户界面中的活动。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-168">For example, you may want to delay an activity in the user interface.</span></span> <span data-ttu-id="8fdf5-169"><xref:System.Threading.Timer?displayProperty=nameWithType> 类已提供在指定时间段后以异步方式调用委托的能力，并且你可以通过使用 <xref:System.Threading.Tasks.TaskCompletionSource%601> 将 <xref:System.Threading.Tasks.Task%601> 前端放在计时器上，例如：</span><span class="sxs-lookup"><span data-stu-id="8fdf5-169">The <xref:System.Threading.Timer?displayProperty=nameWithType> class already provides the ability to asynchronously invoke a delegate after a specified period of time, and by using <xref:System.Threading.Tasks.TaskCompletionSource%601> you can put a <xref:System.Threading.Tasks.Task%601> front on the timer, for example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#4)]
[!code-vb[Conceptual.TAP_Patterns#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#4)]

<span data-ttu-id="8fdf5-170"><xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> 方法正是为此目的而提供，并且你可以在另一个异步方法内使用它。例如，要实现异步轮询循环：</span><span class="sxs-lookup"><span data-stu-id="8fdf5-170">The <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method is provided for this purpose, and you can use it inside another asynchronous method, for example, to implement an asynchronous polling loop:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#5)]
[!code-vb[Conceptual.TAP_Patterns#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#5)]

<span data-ttu-id="8fdf5-171"><xref:System.Threading.Tasks.TaskCompletionSource%601> 类并没有对应的非泛型类。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-171">The <xref:System.Threading.Tasks.TaskCompletionSource%601> class doesn't have a non-generic counterpart.</span></span> <span data-ttu-id="8fdf5-172">然而 <xref:System.Threading.Tasks.Task%601> 派生自 <xref:System.Threading.Tasks.Task>，因此你可以为仅返回任务的 I/O 密集型方法使用泛型 <xref:System.Threading.Tasks.TaskCompletionSource%601> 对象。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-172">However, <xref:System.Threading.Tasks.Task%601> derives from <xref:System.Threading.Tasks.Task>, so you can use the generic <xref:System.Threading.Tasks.TaskCompletionSource%601> object for I/O-bound methods that simply return a task.</span></span> <span data-ttu-id="8fdf5-173">为了做到这一点，你可以使用具有虚拟 `TResult`（<xref:System.Boolean> 是一个很好的默认选项，但是如果你担心 <xref:System.Threading.Tasks.Task> 用户将其向下转换成 <xref:System.Threading.Tasks.Task%601>，那么你可以转而使用私有 `TResult` 类型）。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-173">To do this, you can use a source with a dummy `TResult` (<xref:System.Boolean> is a good default choice, but if you're concerned about the user of the <xref:System.Threading.Tasks.Task> downcasting it to a <xref:System.Threading.Tasks.Task%601>, you can use a private `TResult` type instead).</span></span> <span data-ttu-id="8fdf5-174">例如，上一个示例中的 `Delay` 方法返回现有时间和所产生的偏移量（`Task<DateTimeOffset>`）。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-174">For example, the `Delay` method in the previous example returns the current time along with the resulting offset (`Task<DateTimeOffset>`).</span></span> <span data-ttu-id="8fdf5-175">如果结果值是不必要的，则可对该方法进行如下改写（注意对 <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A> 的返回类型的更改和实参的更改）：</span><span class="sxs-lookup"><span data-stu-id="8fdf5-175">If such a result value is unnecessary, the method could instead be coded as follows (note the change of return type and the change of argument to <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span></span>

[!code-csharp[Conceptual.TAP_Patterns#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#6)]
[!code-vb[Conceptual.TAP_Patterns#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#6)]

### <a name="mixed-compute-bound-and-io-bound-tasks"></a><span data-ttu-id="8fdf5-176">计算密集型和 I/O 密集型混合任务</span><span class="sxs-lookup"><span data-stu-id="8fdf5-176">Mixed compute-bound and I/O-bound tasks</span></span>

<span data-ttu-id="8fdf5-177">异步方法不只局限于计算密集型或 I/O 密集型操作，还可以是两者的结合。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-177">Asynchronous methods are not limited to just compute-bound or I/O-bound operations but may represent a mixture of the two.</span></span> <span data-ttu-id="8fdf5-178">事实上，多个异步操作通常组合成较大的混合操作。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-178">In fact, multiple asynchronous operations are often combined into larger mixed operations.</span></span> <span data-ttu-id="8fdf5-179">例如，请考虑前面示例中的 `RenderAsync` 方法，该方法执行计算密集型操作以根据某些输入 `imageData` 呈现图像。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-179">For example, the `RenderAsync` method in a previous example performed a computationally intensive operation to render an image based on some input `imageData`.</span></span> <span data-ttu-id="8fdf5-180">此 `imageData` 可能来自你异步访问的 Web 服务：</span><span class="sxs-lookup"><span data-stu-id="8fdf5-180">This `imageData` could come from a web service that you asynchronously access:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#7)]
[!code-vb[Conceptual.TAP_Patterns#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#7)]

<span data-ttu-id="8fdf5-181">此示例还演示了如何通过多个异步操作使单个取消标记线程化。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-181">This example also demonstrates how a single cancellation token may be threaded through multiple asynchronous operations.</span></span> <span data-ttu-id="8fdf5-182">有关详细信息，请参阅[使用基于任务的异步模式](consuming-the-task-based-asynchronous-pattern.md)中的取消用法部分。</span><span class="sxs-lookup"><span data-stu-id="8fdf5-182">For more information, see the cancellation usage section in [Consuming the Task-based Asynchronous Pattern](consuming-the-task-based-asynchronous-pattern.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="8fdf5-183">请参阅</span><span class="sxs-lookup"><span data-stu-id="8fdf5-183">See also</span></span>

- [<span data-ttu-id="8fdf5-184">基于任务的异步模式 (TAP)</span><span class="sxs-lookup"><span data-stu-id="8fdf5-184">Task-based Asynchronous Pattern (TAP)</span></span>](task-based-asynchronous-pattern-tap.md)
- [<span data-ttu-id="8fdf5-185">使用基于任务的异步模式</span><span class="sxs-lookup"><span data-stu-id="8fdf5-185">Consuming the Task-based Asynchronous Pattern</span></span>](consuming-the-task-based-asynchronous-pattern.md)
- [<span data-ttu-id="8fdf5-186">与其他异步模式和类型互操作</span><span class="sxs-lookup"><span data-stu-id="8fdf5-186">Interop with Other Asynchronous Patterns and Types</span></span>](interop-with-other-asynchronous-patterns-and-types.md)
