---
title: 用于并行编程的数据结构
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- data structures, multi-threading
ms.assetid: bdc82f2f-4754-45a1-a81e-fe2e9c30cef9
ms.openlocfilehash: cea9264a30469881e3ec54fc378af3ddb70bff8e
ms.sourcegitcommit: 6d09ae36acba0b0e2ba47999f8f1a725795462a2
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/29/2020
ms.locfileid: "92925319"
---
# <a name="data-structures-for-parallel-programming"></a><span data-ttu-id="10bc5-102">用于并行编程的数据结构</span><span class="sxs-lookup"><span data-stu-id="10bc5-102">Data Structures for Parallel Programming</span></span>

<span data-ttu-id="10bc5-103">.NET 提供了几种对并行编程非常有用的类型，包括一组并发集合类、轻型同步基元和用于迟缓初始化的类型。</span><span class="sxs-lookup"><span data-stu-id="10bc5-103">.NET provides several types that are useful in parallel programming, including a set of concurrent collection classes, lightweight synchronization primitives, and types for lazy initialization.</span></span> <span data-ttu-id="10bc5-104">可以将这些类型与任何多线程应用代码（包括任务并行库和 PLINQ）结合使用。</span><span class="sxs-lookup"><span data-stu-id="10bc5-104">You can use these types with any multithreaded application code, including the Task Parallel Library and PLINQ.</span></span>  
  
## <a name="concurrent-collection-classes"></a><span data-ttu-id="10bc5-105">并发回收类</span><span class="sxs-lookup"><span data-stu-id="10bc5-105">Concurrent Collection Classes</span></span>  
 <span data-ttu-id="10bc5-106"><xref:System.Collections.Concurrent?displayProperty=nameWithType> 命名空间中的回收类提供线程安全的添加和删除操作，以尽可能地避免锁定，并在需要锁定时使用细粒度锁定。</span><span class="sxs-lookup"><span data-stu-id="10bc5-106">The collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace provide thread-safe add and remove operations that avoid locks wherever possible and use fine-grained locking where locks are necessary.</span></span> <span data-ttu-id="10bc5-107">并发集合类在访问项时不需要用户代码执行任何锁定。</span><span class="sxs-lookup"><span data-stu-id="10bc5-107">A concurrent collection class does not require user code to take any locks when it accesses items.</span></span> <span data-ttu-id="10bc5-108">如果多个线程在回收中添加和删除项，并发回收类可以显著提高 <xref:System.Collections.ArrayList?displayProperty=nameWithType> 和 <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>（具有用户实现的锁定）等类型的性能。</span><span class="sxs-lookup"><span data-stu-id="10bc5-108">The concurrent collection classes can significantly improve performance over types such as <xref:System.Collections.ArrayList?displayProperty=nameWithType> and <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (with user-implemented locking) in scenarios where multiple threads add and remove items from a collection.</span></span>  
  
 <span data-ttu-id="10bc5-109">下表列出了并发集合类：</span><span class="sxs-lookup"><span data-stu-id="10bc5-109">The following table lists the concurrent collection classes:</span></span>  
  
|<span data-ttu-id="10bc5-110">类型</span><span class="sxs-lookup"><span data-stu-id="10bc5-110">Type</span></span>|<span data-ttu-id="10bc5-111">说明</span><span class="sxs-lookup"><span data-stu-id="10bc5-111">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType>|<span data-ttu-id="10bc5-112">为实现 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType> 的线程安全集合提供阻塞和限制功能。</span><span class="sxs-lookup"><span data-stu-id="10bc5-112">Provides blocking and bounding capabilities for thread-safe collections that implement <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="10bc5-113">如果没有槽可用或回收已满，阻止制作者线程。</span><span class="sxs-lookup"><span data-stu-id="10bc5-113">Producer threads block if no slots are available or if the collection is full.</span></span> <span data-ttu-id="10bc5-114">如果回收为空，阻止使用者线程。</span><span class="sxs-lookup"><span data-stu-id="10bc5-114">Consumer threads block if the collection is empty.</span></span> <span data-ttu-id="10bc5-115">此类型还支持使用者和制作者执行非阻止访问。</span><span class="sxs-lookup"><span data-stu-id="10bc5-115">This type also supports non-blocking access by consumers and producers.</span></span> <span data-ttu-id="10bc5-116">可以将 <xref:System.Collections.Concurrent.BlockingCollection%601> 用作基类或后备存储，以便为支持 <xref:System.Collections.Generic.IEnumerable%601> 的任何回收类提供阻止和绑定。</span><span class="sxs-lookup"><span data-stu-id="10bc5-116"><xref:System.Collections.Concurrent.BlockingCollection%601> can be used as a base class or backing store to provide blocking and bounding for any collection class that supports <xref:System.Collections.Generic.IEnumerable%601>.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType>|<span data-ttu-id="10bc5-117">提供可缩放的添加和获取操作的线程安全包实现。</span><span class="sxs-lookup"><span data-stu-id="10bc5-117">A thread-safe bag implementation that provides scalable add and get operations.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType>|<span data-ttu-id="10bc5-118">可缩放的并发字典类型。</span><span class="sxs-lookup"><span data-stu-id="10bc5-118">A concurrent and scalable dictionary type.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType>|<span data-ttu-id="10bc5-119">可缩放的并发 FIFO 队列。</span><span class="sxs-lookup"><span data-stu-id="10bc5-119">A concurrent and scalable FIFO queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType>|<span data-ttu-id="10bc5-120">可缩放的并发 LIFO 堆栈。</span><span class="sxs-lookup"><span data-stu-id="10bc5-120">A concurrent and scalable LIFO stack.</span></span>|  
  
 <span data-ttu-id="10bc5-121">有关详细信息，请参阅[线程安全集合](../collections/thread-safe/index.md)。</span><span class="sxs-lookup"><span data-stu-id="10bc5-121">For more information, see [Thread-Safe Collections](../collections/thread-safe/index.md).</span></span>  
  
## <a name="synchronization-primitives"></a><span data-ttu-id="10bc5-122">同步基元</span><span class="sxs-lookup"><span data-stu-id="10bc5-122">Synchronization Primitives</span></span>  
 <span data-ttu-id="10bc5-123">通过消除旧多线程处理代码中高昂的锁定机制，<xref:System.Threading?displayProperty=nameWithType> 命名空间中的同步基元实现了细粒度并发和更快速的性能。</span><span class="sxs-lookup"><span data-stu-id="10bc5-123">The synchronization primitives in the <xref:System.Threading?displayProperty=nameWithType> namespace enable fine-grained concurrency and faster performance by avoiding expensive locking mechanisms found in legacy multithreading code.</span></span>
  
 <span data-ttu-id="10bc5-124">下表列出了同步类型：</span><span class="sxs-lookup"><span data-stu-id="10bc5-124">The following table lists the synchronization types:</span></span>  
  
|<span data-ttu-id="10bc5-125">类型</span><span class="sxs-lookup"><span data-stu-id="10bc5-125">Type</span></span>|<span data-ttu-id="10bc5-126">说明</span><span class="sxs-lookup"><span data-stu-id="10bc5-126">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Threading.Barrier?displayProperty=nameWithType>|<span data-ttu-id="10bc5-127">通过让每个任务可以在某一点指示自己已到达，并一直阻止到部分或全部任务已到达，让多个线程可以并行处理算法。</span><span class="sxs-lookup"><span data-stu-id="10bc5-127">Enables multiple threads to work on an algorithm in parallel by providing a point at which each task can signal its arrival and then block until some or all tasks have arrived.</span></span> <span data-ttu-id="10bc5-128">有关详细信息，请参阅 [Barrier](../threading/barrier.md)。</span><span class="sxs-lookup"><span data-stu-id="10bc5-128">For more information, see [Barrier](../threading/barrier.md).</span></span>|  
|<xref:System.Threading.CountdownEvent?displayProperty=nameWithType>|<span data-ttu-id="10bc5-129">通过提供简单的回收机制，简化分支和联接方案。</span><span class="sxs-lookup"><span data-stu-id="10bc5-129">Simplifies fork and join scenarios by providing an easy rendezvous mechanism.</span></span> <span data-ttu-id="10bc5-130">有关详细信息，请参阅 [CountdownEvent](../threading/countdownevent.md)。</span><span class="sxs-lookup"><span data-stu-id="10bc5-130">For more information, see [CountdownEvent](../threading/countdownevent.md).</span></span>|  
|<xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>|<span data-ttu-id="10bc5-131">类似于 <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> 的同步基元。</span><span class="sxs-lookup"><span data-stu-id="10bc5-131">A synchronization primitive similar to <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span> <span data-ttu-id="10bc5-132">虽然 <xref:System.Threading.ManualResetEventSlim> 是轻型基元，但只能用于进程内通信。</span><span class="sxs-lookup"><span data-stu-id="10bc5-132"><xref:System.Threading.ManualResetEventSlim> is lighter-weight but can only be used for intra-process communication.</span></span>|  
|<xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>|<span data-ttu-id="10bc5-133">限制可同时访问资源或资源池的线程数的同步基元。</span><span class="sxs-lookup"><span data-stu-id="10bc5-133">A synchronization primitive that limits the number of threads that can concurrently access a resource or a pool of resources.</span></span> <span data-ttu-id="10bc5-134">有关详细信息，请参阅 [Semaphore 和 SemaphoreSlim](../threading/semaphore-and-semaphoreslim.md)。</span><span class="sxs-lookup"><span data-stu-id="10bc5-134">For more information, see [Semaphore and SemaphoreSlim](../threading/semaphore-and-semaphoreslim.md).</span></span>|  
|<xref:System.Threading.SpinLock?displayProperty=nameWithType>|<span data-ttu-id="10bc5-135">互斥锁基元，导致尝试获取锁的线程先在循环中等待或旋转一段时间，再生成量程。</span><span class="sxs-lookup"><span data-stu-id="10bc5-135">A mutual exclusion lock primitive that causes the thread that is trying to acquire the lock to wait in a loop, or *spin* , for a period of time before yielding its quantum.</span></span> <span data-ttu-id="10bc5-136">在应缩短锁等待时间的情况下，<xref:System.Threading.SpinLock> 的性能优于其他形式的锁定。</span><span class="sxs-lookup"><span data-stu-id="10bc5-136">In scenarios where the wait for the lock is expected to be short, <xref:System.Threading.SpinLock> offers better performance than other forms of locking.</span></span> <span data-ttu-id="10bc5-137">有关详细信息，请参阅 [SpinLock](../threading/spinlock.md)。</span><span class="sxs-lookup"><span data-stu-id="10bc5-137">For more information, see [SpinLock](../threading/spinlock.md).</span></span>|  
|<xref:System.Threading.SpinWait?displayProperty=nameWithType>|<span data-ttu-id="10bc5-138">小的轻型类型，它会旋转一段指定的时间，并最终将线程置于等待状态（如果超出旋转计数的话）。</span><span class="sxs-lookup"><span data-stu-id="10bc5-138">A small, lightweight type that will spin for a specified time and eventually put the thread into a wait state if the spin count is exceeded.</span></span>  <span data-ttu-id="10bc5-139">有关详细信息，请参阅 [SpinWait](../threading/spinwait.md)。</span><span class="sxs-lookup"><span data-stu-id="10bc5-139">For more information, see [SpinWait](../threading/spinwait.md).</span></span>|  
  
 <span data-ttu-id="10bc5-140">有关详细信息，请参阅：</span><span class="sxs-lookup"><span data-stu-id="10bc5-140">For more information, see:</span></span>  
  
- [<span data-ttu-id="10bc5-141">如何：使用 SpinLock 进行低级别同步</span><span class="sxs-lookup"><span data-stu-id="10bc5-141">How to: Use SpinLock for Low-Level Synchronization</span></span>](../threading/how-to-use-spinlock-for-low-level-synchronization.md)  
  
- <span data-ttu-id="10bc5-142">[如何：使用屏障同步并发操作](../threading/how-to-synchronize-concurrent-operations-with-a-barrier.md)。</span><span class="sxs-lookup"><span data-stu-id="10bc5-142">[How to: Synchronize Concurrent Operations with a Barrier](../threading/how-to-synchronize-concurrent-operations-with-a-barrier.md).</span></span>  
  
## <a name="lazy-initialization-classes"></a><span data-ttu-id="10bc5-143">迟缓初始化类</span><span class="sxs-lookup"><span data-stu-id="10bc5-143">Lazy Initialization Classes</span></span>  
 <span data-ttu-id="10bc5-144">通过迟缓初始化，除非需要，否则不分配对象内存。</span><span class="sxs-lookup"><span data-stu-id="10bc5-144">With lazy initialization, the memory for an object is not allocated until it is needed.</span></span> <span data-ttu-id="10bc5-145">迟缓初始化可以提升性能，具体是通过在整个程序生存期内均匀分布对象分配。</span><span class="sxs-lookup"><span data-stu-id="10bc5-145">Lazy initialization can improve performance by spreading object allocations evenly across the lifetime of a program.</span></span> <span data-ttu-id="10bc5-146">若要为任何自定义类型启用迟缓初始化，可以包装类型 <xref:System.Lazy%601>。</span><span class="sxs-lookup"><span data-stu-id="10bc5-146">You can enable lazy initialization for any custom type by wrapping the type <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="10bc5-147">下表列出了迟缓初始化类型：</span><span class="sxs-lookup"><span data-stu-id="10bc5-147">The following table lists the lazy initialization types:</span></span>  
  
|<span data-ttu-id="10bc5-148">类型</span><span class="sxs-lookup"><span data-stu-id="10bc5-148">Type</span></span>|<span data-ttu-id="10bc5-149">说明</span><span class="sxs-lookup"><span data-stu-id="10bc5-149">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601?displayProperty=nameWithType>|<span data-ttu-id="10bc5-150">提供线程安全的轻型迟缓初始化。</span><span class="sxs-lookup"><span data-stu-id="10bc5-150">Provides lightweight, thread-safe lazy-initialization.</span></span>|  
|<xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType>|<span data-ttu-id="10bc5-151">每线程提供迟缓初始化值，其中每线程迟缓调用初始化函数。</span><span class="sxs-lookup"><span data-stu-id="10bc5-151">Provides a lazily-initialized value on a per-thread basis, with each thread lazily-invoking the initialization function.</span></span>|  
|<xref:System.Threading.LazyInitializer?displayProperty=nameWithType>|<span data-ttu-id="10bc5-152">提供静态方法，避免出现需要分配专用迟缓初始化实例的情况。</span><span class="sxs-lookup"><span data-stu-id="10bc5-152">Provides static methods that avoid the need to allocate a dedicated, lazy-initialization instance.</span></span> <span data-ttu-id="10bc5-153">相反，它们使用引用是为了确保目标在获得访问时已初始化。</span><span class="sxs-lookup"><span data-stu-id="10bc5-153">Instead, they use references to ensure targets have been initialized as they are accessed.</span></span>|  
  
 <span data-ttu-id="10bc5-154">若要了解详细信息，请参阅[迟缓初始化](../../framework/performance/lazy-initialization.md)</span><span class="sxs-lookup"><span data-stu-id="10bc5-154">For more information, see [Lazy Initialization](../../framework/performance/lazy-initialization.md).</span></span>  
  
## <a name="aggregate-exceptions"></a><span data-ttu-id="10bc5-155">聚合异常</span><span class="sxs-lookup"><span data-stu-id="10bc5-155">Aggregate Exceptions</span></span>  
 <span data-ttu-id="10bc5-156"><xref:System.AggregateException?displayProperty=nameWithType> 类型可用于捕获对各个线程并发抛出的多个异常，并将它们作为一个异常返回给联接线程。</span><span class="sxs-lookup"><span data-stu-id="10bc5-156">The <xref:System.AggregateException?displayProperty=nameWithType> type can be used to capture multiple exceptions that are thrown concurrently on separate threads, and return them to the joining thread as a single exception.</span></span> <span data-ttu-id="10bc5-157">为此，<xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> 类型以及 PLINQ 大量使用 <xref:System.AggregateException>。</span><span class="sxs-lookup"><span data-stu-id="10bc5-157">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> types and PLINQ use <xref:System.AggregateException> extensively for this purpose.</span></span> <span data-ttu-id="10bc5-158">有关详细信息，请参阅[异常处理](exception-handling-task-parallel-library.md)和[如何：处理 PLINQ 查询中的异常](how-to-handle-exceptions-in-a-plinq-query.md)。</span><span class="sxs-lookup"><span data-stu-id="10bc5-158">For more information, see [Exception Handling](exception-handling-task-parallel-library.md) and [How to: Handle Exceptions in a PLINQ Query](how-to-handle-exceptions-in-a-plinq-query.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="10bc5-159">请参阅</span><span class="sxs-lookup"><span data-stu-id="10bc5-159">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- <xref:System.Threading?displayProperty=nameWithType>
- [<span data-ttu-id="10bc5-160">并行编程</span><span class="sxs-lookup"><span data-stu-id="10bc5-160">Parallel Programming</span></span>](index.md)
