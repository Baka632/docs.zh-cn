---
title: PLINQ 中的合并选项
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, merge options
ms.assetid: e8f7be3b-88de-4f33-ab14-dc008e76c1ba
ms.openlocfilehash: e6690a600b7b00272471362bc087633d52a98f25
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/18/2020
ms.locfileid: "94824839"
---
# <a name="merge-options-in-plinq"></a><span data-ttu-id="6b936-102">PLINQ 中的合并选项</span><span class="sxs-lookup"><span data-stu-id="6b936-102">Merge Options in PLINQ</span></span>
<span data-ttu-id="6b936-103">如果并行执行查询，PLINQ 对源序列进行分区，以便多个线程能够并发处理不同部分，通常是在不同的线程中。</span><span class="sxs-lookup"><span data-stu-id="6b936-103">When a query is executing as parallel, PLINQ partitions the source sequence so that multiple threads can work on different parts concurrently, typically on separate threads.</span></span> <span data-ttu-id="6b936-104">如果要在一个线程（例如，`foreach`（Visual Basic 中的 `For Each`）循环）中使用结果，必须将每个线程的结果合并回一个序列中。</span><span class="sxs-lookup"><span data-stu-id="6b936-104">If the results are to be consumed on one thread, for example, in a `foreach` (`For Each` in Visual Basic) loop, then the results from every thread must be merged back into one sequence.</span></span> <span data-ttu-id="6b936-105">PLINQ 执行的合并类型具体视查询中的运算符而定。</span><span class="sxs-lookup"><span data-stu-id="6b936-105">The kind of merge that PLINQ performs depends on the operators that are present in the query.</span></span> <span data-ttu-id="6b936-106">例如，对结果强制施加新顺序的运算符必须缓冲所有线程中的全部元素。</span><span class="sxs-lookup"><span data-stu-id="6b936-106">For example, operators that impose a new order on the results must buffer all elements from all threads.</span></span> <span data-ttu-id="6b936-107">从使用线程（以及应用用户）的角度来看，完全缓冲查询可能会运行很长时间，才能生成第一个结果。</span><span class="sxs-lookup"><span data-stu-id="6b936-107">From the perspective of the consuming thread (which is also that of the application user) a fully buffered query might run for a noticeable period of time before it produces its first result.</span></span> <span data-ttu-id="6b936-108">默认情况下，其他运算符进行部分缓冲，并分批生成结果。</span><span class="sxs-lookup"><span data-stu-id="6b936-108">Other operators, by default, are partially buffered; they yield their results in batches.</span></span> <span data-ttu-id="6b936-109">默认不缓冲的一个运算符是 <xref:System.Linq.ParallelEnumerable.ForAll%2A>。</span><span class="sxs-lookup"><span data-stu-id="6b936-109">One operator, <xref:System.Linq.ParallelEnumerable.ForAll%2A> is not buffered by default.</span></span> <span data-ttu-id="6b936-110">它会立即生成所有线程中的所有元素。</span><span class="sxs-lookup"><span data-stu-id="6b936-110">It yields all elements from all threads immediately.</span></span>  
  
 <span data-ttu-id="6b936-111">使用 <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> 方法（如下面的示例所示），可以向 PLINQ 提供提示，指明要执行的合并类型。</span><span class="sxs-lookup"><span data-stu-id="6b936-111">By using the <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> method, as shown in the following example, you can provide a hint to PLINQ that indicates what kind of merging to perform.</span></span>  
  
 [!code-csharp[PLINQ#26](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#26)]
 [!code-vb[PLINQ#26](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#26)]  
  
 <span data-ttu-id="6b936-112">有关完整的示例，请参阅[如何：在 PLINQ 中指定合并选项](how-to-specify-merge-options-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="6b936-112">For the complete example, see [How to: Specify Merge Options in PLINQ](how-to-specify-merge-options-in-plinq.md).</span></span>  
  
 <span data-ttu-id="6b936-113">如果特定查询无法支持请求执行的选项，将会直接忽略此选项。</span><span class="sxs-lookup"><span data-stu-id="6b936-113">If the particular query cannot support the requested option, then the option will just be ignored.</span></span> <span data-ttu-id="6b936-114">大多数情况下，无需为 PLINQ 查询指定合并选项。</span><span class="sxs-lookup"><span data-stu-id="6b936-114">In most cases, you do not have to specify a merge option for a PLINQ query.</span></span> <span data-ttu-id="6b936-115">不过，在某些情况下，通过测试和度量，可以发现查询在非默认模式下执行效果最佳。</span><span class="sxs-lookup"><span data-stu-id="6b936-115">However, in some cases you may find by testing and measurement that a query executes best in a non-default mode.</span></span> <span data-ttu-id="6b936-116">这种做法的常见用途是，强制区块合并运算符流式传输结果，以提升用户界面的响应速度。</span><span class="sxs-lookup"><span data-stu-id="6b936-116">A common use of this option is to force a chunk-merging operator to stream its results in order to provide a more responsive user interface.</span></span>  
  
## <a name="parallelmergeoptions"></a><span data-ttu-id="6b936-117">ParallelMergeOptions</span><span class="sxs-lookup"><span data-stu-id="6b936-117">ParallelMergeOptions</span></span>  
 <span data-ttu-id="6b936-118"><xref:System.Linq.ParallelMergeOptions> 枚举包括以下选项，用于针对受支持的查询形状，指定在一个线程上使用结果时如何生成查询的最终输出：</span><span class="sxs-lookup"><span data-stu-id="6b936-118">The <xref:System.Linq.ParallelMergeOptions> enumeration includes the following options that specify, for supported query shapes, how the final output of the query is yielded when the results are consumed on one thread:</span></span>  
  
- `Not Buffered`  
  
     <span data-ttu-id="6b936-119">使用 <xref:System.Linq.ParallelMergeOptions.NotBuffered> 选项，每个处理过的元素一生成就会由各个线程返回。</span><span class="sxs-lookup"><span data-stu-id="6b936-119">The <xref:System.Linq.ParallelMergeOptions.NotBuffered> option causes each processed element to be returned from each thread as soon as it is produced.</span></span> <span data-ttu-id="6b936-120">这种行为类同于“流式传输”输出。</span><span class="sxs-lookup"><span data-stu-id="6b936-120">This behavior is analogous to "streaming" the output.</span></span> <span data-ttu-id="6b936-121">如果查询中有 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 运算符，`NotBuffered` 暂留源元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="6b936-121">If the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator is present in the query, `NotBuffered` preserves the order of the source elements.</span></span> <span data-ttu-id="6b936-122">虽然 `NotBuffered` 一有结果就立即开始生成，但生成所有结果的总时间可能仍长于使用其他合并选项之一的用时。</span><span class="sxs-lookup"><span data-stu-id="6b936-122">Although `NotBuffered` starts yielding results as soon as they're available, the total time to produce all the results might still be longer than using one of the other merge options.</span></span>  
  
- `Auto Buffered`  
  
     <span data-ttu-id="6b936-123">通过 <xref:System.Linq.ParallelMergeOptions.AutoBuffered> 选项，查询将元素收集到缓冲区中，并定期一次性将所有缓冲内容生成到使用线程中。</span><span class="sxs-lookup"><span data-stu-id="6b936-123">The <xref:System.Linq.ParallelMergeOptions.AutoBuffered> option causes the query to collect elements into a buffer and then periodically yield the buffer contents all at once to the consuming thread.</span></span> <span data-ttu-id="6b936-124">这类同于分“区块”生成源数据，而不是使用 `NotBuffered` 的“流式传输”行为。</span><span class="sxs-lookup"><span data-stu-id="6b936-124">This is analogous to yielding the source data in "chunks" instead of using the "streaming" behavior of `NotBuffered`.</span></span> <span data-ttu-id="6b936-125">`AutoBuffered` 可能需要花费比 `NotBuffered` 更长的时间，才能在使用线程中生成第一个元素。</span><span class="sxs-lookup"><span data-stu-id="6b936-125">`AutoBuffered` may take longer than `NotBuffered` to make the first element available on the consuming thread.</span></span> <span data-ttu-id="6b936-126">缓冲大小和确切的生成行为不可配置，并因与查询相关的各种因素而异。</span><span class="sxs-lookup"><span data-stu-id="6b936-126">The size of the buffer and the exact yielding behavior are not configurable and may vary, depending on various factors that relate to the query.</span></span>  
  
- `FullyBuffered`  
  
     <span data-ttu-id="6b936-127">使用 <xref:System.Linq.ParallelMergeOptions.FullyBuffered> 选项，可以先缓冲整个查询的输出，再生成任何元素。</span><span class="sxs-lookup"><span data-stu-id="6b936-127">The <xref:System.Linq.ParallelMergeOptions.FullyBuffered> option causes the output of the whole query to be buffered before any of the elements are yielded.</span></span> <span data-ttu-id="6b936-128">使用此选项时，虽然在使用线程中生成第一个元素的耗时更长，但完整结果的生成时间可能仍短于使用其他选项的用时。</span><span class="sxs-lookup"><span data-stu-id="6b936-128">When you use this option, it can take longer before the first element is available on the consuming thread, but the complete results might still be produced faster than by using the other options.</span></span>  
  
## <a name="query-operators-that-support-merge-options"></a><span data-ttu-id="6b936-129">支持合并选项的查询运算符</span><span class="sxs-lookup"><span data-stu-id="6b936-129">Query Operators that Support Merge Options</span></span>  
 <span data-ttu-id="6b936-130">下表列出了支持所有合并选项模式的运算符（受指定的限制约束）。</span><span class="sxs-lookup"><span data-stu-id="6b936-130">The following table lists the operators that support all merge option modes, subject to the specified restrictions.</span></span>  
  
|<span data-ttu-id="6b936-131">运算符</span><span class="sxs-lookup"><span data-stu-id="6b936-131">Operator</span></span>|<span data-ttu-id="6b936-132">限制</span><span class="sxs-lookup"><span data-stu-id="6b936-132">Restrictions</span></span>|  
|--------------|------------------|  
|<xref:System.Linq.ParallelEnumerable.AsEnumerable%2A>|<span data-ttu-id="6b936-133">None</span><span class="sxs-lookup"><span data-stu-id="6b936-133">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Cast%2A>|<span data-ttu-id="6b936-134">None</span><span class="sxs-lookup"><span data-stu-id="6b936-134">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Concat%2A>|<span data-ttu-id="6b936-135">只包含 Array 或 List 源的无序查询。</span><span class="sxs-lookup"><span data-stu-id="6b936-135">Non-ordered queries that have an Array or List source only.</span></span>|  
|<xref:System.Linq.ParallelEnumerable.DefaultIfEmpty%2A>|<span data-ttu-id="6b936-136">None</span><span class="sxs-lookup"><span data-stu-id="6b936-136">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.OfType%2A>|<span data-ttu-id="6b936-137">None</span><span class="sxs-lookup"><span data-stu-id="6b936-137">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Reverse%2A>|<span data-ttu-id="6b936-138">只包含 Array 或 List 源的无序查询。</span><span class="sxs-lookup"><span data-stu-id="6b936-138">Non-ordered queries that have an Array or List source only.</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Select%2A>|<span data-ttu-id="6b936-139">None</span><span class="sxs-lookup"><span data-stu-id="6b936-139">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SelectMany%2A>|<span data-ttu-id="6b936-140">None</span><span class="sxs-lookup"><span data-stu-id="6b936-140">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Skip%2A>|<span data-ttu-id="6b936-141">None</span><span class="sxs-lookup"><span data-stu-id="6b936-141">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Take%2A>|<span data-ttu-id="6b936-142">None</span><span class="sxs-lookup"><span data-stu-id="6b936-142">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Where%2A>|<span data-ttu-id="6b936-143">None</span><span class="sxs-lookup"><span data-stu-id="6b936-143">None</span></span>|  
  
 <span data-ttu-id="6b936-144">其他所有 PLINQ 查询运算符可能会忽略用户提供的合并选项。</span><span class="sxs-lookup"><span data-stu-id="6b936-144">All other PLINQ query operators might ignore user-provided merge options.</span></span> <span data-ttu-id="6b936-145">一些查询运算符（例如，<xref:System.Linq.ParallelEnumerable.Reverse%2A> 和 <xref:System.Linq.ParallelEnumerable.OrderBy%2A>）在生成并重新排序所有元素之前，无法生成任何元素。</span><span class="sxs-lookup"><span data-stu-id="6b936-145">Some query operators, for example, <xref:System.Linq.ParallelEnumerable.Reverse%2A> and <xref:System.Linq.ParallelEnumerable.OrderBy%2A>, cannot yield any elements until all have been produced and reordered.</span></span> <span data-ttu-id="6b936-146">因此，如果在还包含 <xref:System.Linq.ParallelEnumerable.Reverse%2A> 等运算符的查询中使用 <xref:System.Linq.ParallelMergeOptions>，除非运算符生成了结果，否则将不会在查询中应用合并行为。</span><span class="sxs-lookup"><span data-stu-id="6b936-146">Therefore, when <xref:System.Linq.ParallelMergeOptions> is used in a query that also contains an operator such as <xref:System.Linq.ParallelEnumerable.Reverse%2A>, the merge behavior will not be applied in the query until after that operator has produced its results.</span></span>  
  
 <span data-ttu-id="6b936-147">一些运算符处理合并选项的能力，取决于源序列的类型，以及之前是否在查询中使用过 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 运算符。</span><span class="sxs-lookup"><span data-stu-id="6b936-147">The ability of some operators to handle merge options depends on the type of the source sequence, and whether the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator was used earlier in the query.</span></span> <span data-ttu-id="6b936-148"><xref:System.Linq.ParallelEnumerable.ForAll%2A> 始终为 <xref:System.Linq.ParallelMergeOptions.NotBuffered>；它立即生成元素。</span><span class="sxs-lookup"><span data-stu-id="6b936-148"><xref:System.Linq.ParallelEnumerable.ForAll%2A> is always <xref:System.Linq.ParallelMergeOptions.NotBuffered> ; it yields its elements immediately.</span></span> <span data-ttu-id="6b936-149"><xref:System.Linq.ParallelEnumerable.OrderBy%2A> 始终为 <xref:System.Linq.ParallelMergeOptions.FullyBuffered>；它必须先对整个列表进行排序，再生成元素。</span><span class="sxs-lookup"><span data-stu-id="6b936-149"><xref:System.Linq.ParallelEnumerable.OrderBy%2A> is always <xref:System.Linq.ParallelMergeOptions.FullyBuffered>; it must sort the whole list before it yields.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6b936-150">请参阅</span><span class="sxs-lookup"><span data-stu-id="6b936-150">See also</span></span>

- [<span data-ttu-id="6b936-151">并行 LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="6b936-151">Parallel LINQ (PLINQ)</span></span>](introduction-to-plinq.md)
- [<span data-ttu-id="6b936-152">如何：在 PLINQ 中指定合并选项</span><span class="sxs-lookup"><span data-stu-id="6b936-152">How to: Specify Merge Options in PLINQ</span></span>](how-to-specify-merge-options-in-plinq.md)
