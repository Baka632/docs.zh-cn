---
title: PLINQ 和 TPL 的自定义分区程序
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
ms.openlocfilehash: 2268df2eb5cae4dcd7adde491b42c86c546aa1fc
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/18/2020
ms.locfileid: "94829227"
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="6086f-102">PLINQ 和 TPL 的自定义分区程序</span><span class="sxs-lookup"><span data-stu-id="6086f-102">Custom Partitioners for PLINQ and TPL</span></span>

<span data-ttu-id="6086f-103">若要并行执行对数据源的操作，关键步骤之一是，将数据源分区  成多个部分，以供多个线程同时访问。</span><span class="sxs-lookup"><span data-stu-id="6086f-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="6086f-104">PLINQ 和任务并行库 (TPL) 提供了默认分区程序，在用户编写并行查询或 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 循环时透明运行。</span><span class="sxs-lookup"><span data-stu-id="6086f-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="6086f-105">对于更高级的方案，可以插入自己的分区程序。</span><span class="sxs-lookup"><span data-stu-id="6086f-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>

## <a name="kinds-of-partitioning"></a><span data-ttu-id="6086f-106">分区的种类</span><span class="sxs-lookup"><span data-stu-id="6086f-106">Kinds of Partitioning</span></span>

<span data-ttu-id="6086f-107">对数据源进行分区的方法有很多种。</span><span class="sxs-lookup"><span data-stu-id="6086f-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="6086f-108">最高效的方法是，多个线程一起协作，共同处理原始源序列，而不是将数据源实际分割成多个子序列。</span><span class="sxs-lookup"><span data-stu-id="6086f-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="6086f-109">对于长度提前已知的数组和其他索引源（如 <xref:System.Collections.IList> 集合），范围分区  是最简单的分区种类。</span><span class="sxs-lookup"><span data-stu-id="6086f-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="6086f-110">每个线程都会收到唯一起始和结束索引，这样就可以处理范围内的数据源，而又不会覆盖其他任何线程或被其他任何线程覆盖。</span><span class="sxs-lookup"><span data-stu-id="6086f-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="6086f-111">范围分区涉及的唯一开销是，创建范围这项初始工作；之后就无需执行其他任何同步工作了。</span><span class="sxs-lookup"><span data-stu-id="6086f-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="6086f-112">因此，只要工作负载是均分的，就可以确保实现良好性能。</span><span class="sxs-lookup"><span data-stu-id="6086f-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="6086f-113">范围分区的缺点是，即使某线程提前完成，也无法帮助其他线程完成工作。</span><span class="sxs-lookup"><span data-stu-id="6086f-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>

<span data-ttu-id="6086f-114">对于长度未知的链接列表或其他集合，可以使用区块分区  。</span><span class="sxs-lookup"><span data-stu-id="6086f-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="6086f-115">在区块分区中，并行循环或查询中的每个线程或任务都会使用并处理一个区块中的若干源元素，再返回检索其他元素。</span><span class="sxs-lookup"><span data-stu-id="6086f-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="6086f-116">分区程序可确保所有元素均已分发，且没有重复项。</span><span class="sxs-lookup"><span data-stu-id="6086f-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="6086f-117">区块可为任意大小。</span><span class="sxs-lookup"><span data-stu-id="6086f-117">A chunk may be any size.</span></span> <span data-ttu-id="6086f-118">例如，[如何：实现动态分区](how-to-implement-dynamic-partitions.md)中展示的分区程序创建的区块就只包含一个元素。</span><span class="sxs-lookup"><span data-stu-id="6086f-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="6086f-119">只要区块不是太大，这类分区就一定会执行负载均衡，因为向线程分配的元素不是预先确定的。</span><span class="sxs-lookup"><span data-stu-id="6086f-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="6086f-120">不过，每当线程需要获取其他区块时，分区程序就要承担一次同步开销。</span><span class="sxs-lookup"><span data-stu-id="6086f-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="6086f-121">在这种情况下产生的同步量与区块大小成反比。</span><span class="sxs-lookup"><span data-stu-id="6086f-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>

<span data-ttu-id="6086f-122">通常情况下，范围分区只有在以下情况下才会更快：委托的执行时间为小到中等，数据源有大量元素，且每个分区的工作总量大致相等。</span><span class="sxs-lookup"><span data-stu-id="6086f-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="6086f-123">因此，大多数情况下，区块分区通常更快。</span><span class="sxs-lookup"><span data-stu-id="6086f-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="6086f-124">如果数据源有少量元素或委托的执行时间较长，那么区块分区和范围分区的性能大致相同。</span><span class="sxs-lookup"><span data-stu-id="6086f-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>

<span data-ttu-id="6086f-125">TPL 分区程序还支持动态数量的分区。</span><span class="sxs-lookup"><span data-stu-id="6086f-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="6086f-126">也就是说，可以在 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 循环生成新任务时（举个例子）快速创建分区。</span><span class="sxs-lookup"><span data-stu-id="6086f-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="6086f-127">借助此功能，分区程序可以与循环本身一起缩放。</span><span class="sxs-lookup"><span data-stu-id="6086f-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="6086f-128">动态分区程序也一定会执行负载均衡。</span><span class="sxs-lookup"><span data-stu-id="6086f-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="6086f-129">创建自定义分区程序时，必须支持可通过 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 循环使用的动态分区。</span><span class="sxs-lookup"><span data-stu-id="6086f-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>

### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="6086f-130">配置 PLINQ 负载均衡分区程序</span><span class="sxs-lookup"><span data-stu-id="6086f-130">Configuring Load Balancing Partitioners for PLINQ</span></span>

<span data-ttu-id="6086f-131">借助 <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> 方法的一些重载，可以为数组或 <xref:System.Collections.IList> 源创建分区程序，并指定是否应尝试均衡各线程的工作负载。</span><span class="sxs-lookup"><span data-stu-id="6086f-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="6086f-132">如果分区程序被配置为执行负载均衡，那么使用的就是区块分区，元素会根据请求以小区块的形式分配到每个分区。</span><span class="sxs-lookup"><span data-stu-id="6086f-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="6086f-133">这种方法有助于确保在整个循环或查询完成前，所有分区都有元素可供处理。</span><span class="sxs-lookup"><span data-stu-id="6086f-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="6086f-134">附加重载可用于提供任何 <xref:System.Collections.IEnumerable> 源的负载均衡分区。</span><span class="sxs-lookup"><span data-stu-id="6086f-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>

<span data-ttu-id="6086f-135">负载均衡通常要求分区相对频繁地从分区程序请求获取元素。</span><span class="sxs-lookup"><span data-stu-id="6086f-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="6086f-136">相比之下，执行静态分区的分区程序可以使用范围分区或区块分区，将元素一次性全部分配给每个分区程序。</span><span class="sxs-lookup"><span data-stu-id="6086f-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="6086f-137">虽然这样做产生的开销少于负载均衡，但如果一个线程的工作量最终大大多于其他线程，那么执行时间可能就会变长。</span><span class="sxs-lookup"><span data-stu-id="6086f-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="6086f-138">默认情况下，如果传入的是 IList 或数组，PLINQ 始终都会使用不执行负载均衡的范围分区。</span><span class="sxs-lookup"><span data-stu-id="6086f-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="6086f-139">若要为 PLINQ 启用负载均衡，请使用 `Partitioner.Create` 方法，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="6086f-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>

[!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
[!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]

<span data-ttu-id="6086f-140">在任何给定方案中确定是否使用负载均衡的最佳方式是，在有代表性的负载和计算机配置下，试验并度量操作需要多长时间才能完成。</span><span class="sxs-lookup"><span data-stu-id="6086f-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="6086f-141">例如，如果是只有几个内核的多核计算机，静态分区可以让速度显著提升；但如果是内核相对较多的计算机，静态分区可能会导致速度降低。</span><span class="sxs-lookup"><span data-stu-id="6086f-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>

<span data-ttu-id="6086f-142">下表列出了 <xref:System.Collections.Concurrent.Partitioner.Create%2A> 方法的可用重载。</span><span class="sxs-lookup"><span data-stu-id="6086f-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="6086f-143">这些分区程序不仅限于在 PLINQ 或 <xref:System.Threading.Tasks.Task> 中使用。</span><span class="sxs-lookup"><span data-stu-id="6086f-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="6086f-144">还可用于任何自定义并行构造。</span><span class="sxs-lookup"><span data-stu-id="6086f-144">They can also be used with any custom parallel construct.</span></span>

|<span data-ttu-id="6086f-145">重载</span><span class="sxs-lookup"><span data-stu-id="6086f-145">Overload</span></span>|<span data-ttu-id="6086f-146">使用负载均衡</span><span class="sxs-lookup"><span data-stu-id="6086f-146">Uses load balancing</span></span>|
|--------------|-------------------------|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="6086f-147">Always</span><span class="sxs-lookup"><span data-stu-id="6086f-147">Always</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="6086f-148">将布尔参数指定为 true 时</span><span class="sxs-lookup"><span data-stu-id="6086f-148">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="6086f-149">将布尔参数指定为 true 时</span><span class="sxs-lookup"><span data-stu-id="6086f-149">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="6086f-150">Never</span><span class="sxs-lookup"><span data-stu-id="6086f-150">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="6086f-151">Never</span><span class="sxs-lookup"><span data-stu-id="6086f-151">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="6086f-152">Never</span><span class="sxs-lookup"><span data-stu-id="6086f-152">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="6086f-153">Never</span><span class="sxs-lookup"><span data-stu-id="6086f-153">Never</span></span>|

### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="6086f-154">配置 Parallel.ForEach 静态范围分区程序</span><span class="sxs-lookup"><span data-stu-id="6086f-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>

<span data-ttu-id="6086f-155">在 <xref:System.Threading.Tasks.Parallel.For%2A> 循环中，循环的主体作为委托提供给方法。</span><span class="sxs-lookup"><span data-stu-id="6086f-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="6086f-156">调用此委托的成本与调用虚拟方法大致相同。</span><span class="sxs-lookup"><span data-stu-id="6086f-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="6086f-157">在某些情况下，并行循环的主体可能非常小，这就会导致对每个循环迭代调用委托的成本变得十分高昂。</span><span class="sxs-lookup"><span data-stu-id="6086f-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="6086f-158">在这种情况下，可以使用 <xref:System.Collections.Concurrent.Partitioner.Create%2A> 重载之一，对数据源元素创建范围分区的 <xref:System.Collections.Generic.IEnumerable%601>。</span><span class="sxs-lookup"><span data-stu-id="6086f-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="6086f-159">然后，可以将此范围集合传递到主体包含常规 `for` 循环的 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="6086f-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="6086f-160">这种方法的优势在于，委托调用成本在每个范围内只产生一次，而不是每个元素都产生一次。</span><span class="sxs-lookup"><span data-stu-id="6086f-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="6086f-161">下面的示例展示了基本模式。</span><span class="sxs-lookup"><span data-stu-id="6086f-161">The following example demonstrates the basic pattern.</span></span>

[!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
[!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]

<span data-ttu-id="6086f-162">循环中的每个线程都会收到自己的 <xref:System.Tuple%602>，其中包含指定子范围中的起始和结束索引值。</span><span class="sxs-lookup"><span data-stu-id="6086f-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="6086f-163">内循环 `for` 使用 `fromInclusive` 和 `toExclusive` 值直接循环访问数组或 <xref:System.Collections.IList>。</span><span class="sxs-lookup"><span data-stu-id="6086f-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>

<span data-ttu-id="6086f-164">借助 <xref:System.Collections.Concurrent.Partitioner.Create%2A> 重载之一，可以指定分区大小和分区数量。</span><span class="sxs-lookup"><span data-stu-id="6086f-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="6086f-165">此重载适用于以下情况：每个元素的工作量很少，甚至每个元素调用一个虚拟方法都会对性能产生显著影响。</span><span class="sxs-lookup"><span data-stu-id="6086f-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>

## <a name="custom-partitioners"></a><span data-ttu-id="6086f-166">自定义分区程序</span><span class="sxs-lookup"><span data-stu-id="6086f-166">Custom Partitioners</span></span>

<span data-ttu-id="6086f-167">在某些情况下，实现自己的分区程序可能是值得尝试的，或甚至有必要这样做。</span><span class="sxs-lookup"><span data-stu-id="6086f-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="6086f-168">例如，假设有一个自定义集合类，可以根据对类内部结构的了解情况进行更有效的分区（与默认分区程序相比）。</span><span class="sxs-lookup"><span data-stu-id="6086f-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="6086f-169">或者，不妨根据对源集合中不同位置的元素处理时长的了解情况，创建不同大小的范围分区。</span><span class="sxs-lookup"><span data-stu-id="6086f-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>

<span data-ttu-id="6086f-170">若要创建基本自定义分区程序，请从 <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> 派生类，并重写虚拟方法，如下表所述。</span><span class="sxs-lookup"><span data-stu-id="6086f-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="6086f-171">此方法由主线程调用一次，并返回 IList(IEnumerator(TSource))。</span><span class="sxs-lookup"><span data-stu-id="6086f-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="6086f-172">循环或查询中的每个工作线程都可以对列表调用 `GetEnumerator`，以在不同的分区中检索 <xref:System.Collections.Generic.IEnumerator%601>。</span><span class="sxs-lookup"><span data-stu-id="6086f-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="6086f-173">如果实现 <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>，返回 `true`；否则，返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="6086f-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="6086f-174">如果 <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> 是 `true`，可以视需要选择调用此方法（而不是 <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>）。</span><span class="sxs-lookup"><span data-stu-id="6086f-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="6086f-175">如果结果必须可排序，或需要对元素进行索引访问，请从 <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> 派生类，并重写虚拟方法，如下表所述。</span><span class="sxs-lookup"><span data-stu-id="6086f-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="6086f-176">此方法由主线程调用一次，并返回 `IList(IEnumerator(TSource))`。</span><span class="sxs-lookup"><span data-stu-id="6086f-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="6086f-177">循环或查询中的每个工作线程都可以对列表调用 `GetEnumerator`，以在不同的分区中检索 <xref:System.Collections.Generic.IEnumerator%601>。</span><span class="sxs-lookup"><span data-stu-id="6086f-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="6086f-178">如果实现 <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>，返回 `true`；否则，返回 false。</span><span class="sxs-lookup"><span data-stu-id="6086f-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="6086f-179">这通常直接调用 <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>。</span><span class="sxs-lookup"><span data-stu-id="6086f-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="6086f-180">如果 <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> 是 `true`，可以视需要选择调用此方法（而不是 <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>）。</span><span class="sxs-lookup"><span data-stu-id="6086f-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="6086f-181">下表详细介绍了三种负载均衡分区程序是如何实现 <xref:System.Collections.Concurrent.OrderablePartitioner%601> 类的。</span><span class="sxs-lookup"><span data-stu-id="6086f-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>

|<span data-ttu-id="6086f-182">方法/属性</span><span class="sxs-lookup"><span data-stu-id="6086f-182">Method/Property</span></span>|<span data-ttu-id="6086f-183">IList/数组（不执行负载均衡）</span><span class="sxs-lookup"><span data-stu-id="6086f-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="6086f-184">IList/数组（执行负载均衡）</span><span class="sxs-lookup"><span data-stu-id="6086f-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="6086f-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="6086f-185">IEnumerable</span></span>|
|----------------------|-------------------------------------------|----------------------------------------|-----------------|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="6086f-186">使用范围分区</span><span class="sxs-lookup"><span data-stu-id="6086f-186">Uses range partitioning</span></span>|<span data-ttu-id="6086f-187">使用更适合列表的区块分区（partitionCount 已指定）</span><span class="sxs-lookup"><span data-stu-id="6086f-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="6086f-188">通过创建静态数量的分区来使用区块分区。</span><span class="sxs-lookup"><span data-stu-id="6086f-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="6086f-189">抛出不支持异常</span><span class="sxs-lookup"><span data-stu-id="6086f-189">Throws not-supported exception</span></span>|<span data-ttu-id="6086f-190">使用更适合列表和动态分区的区块分区</span><span class="sxs-lookup"><span data-stu-id="6086f-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="6086f-191">通过创建动态数量的分区来使用区块分区。</span><span class="sxs-lookup"><span data-stu-id="6086f-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="6086f-192">返回 `true`</span><span class="sxs-lookup"><span data-stu-id="6086f-192">Returns `true`</span></span>|<span data-ttu-id="6086f-193">返回 `true`</span><span class="sxs-lookup"><span data-stu-id="6086f-193">Returns `true`</span></span>|<span data-ttu-id="6086f-194">返回 `true`</span><span class="sxs-lookup"><span data-stu-id="6086f-194">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="6086f-195">返回 `true`</span><span class="sxs-lookup"><span data-stu-id="6086f-195">Returns `true`</span></span>|<span data-ttu-id="6086f-196">返回 `false`</span><span class="sxs-lookup"><span data-stu-id="6086f-196">Returns `false`</span></span>|<span data-ttu-id="6086f-197">返回 `false`</span><span class="sxs-lookup"><span data-stu-id="6086f-197">Returns `false`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="6086f-198">返回 `true`</span><span class="sxs-lookup"><span data-stu-id="6086f-198">Returns `true`</span></span>|<span data-ttu-id="6086f-199">返回 `true`</span><span class="sxs-lookup"><span data-stu-id="6086f-199">Returns `true`</span></span>|<span data-ttu-id="6086f-200">返回 `true`</span><span class="sxs-lookup"><span data-stu-id="6086f-200">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="6086f-201">返回 `false`</span><span class="sxs-lookup"><span data-stu-id="6086f-201">Returns `false`</span></span>|<span data-ttu-id="6086f-202">返回 `true`</span><span class="sxs-lookup"><span data-stu-id="6086f-202">Returns `true`</span></span>|<span data-ttu-id="6086f-203">返回 `true`</span><span class="sxs-lookup"><span data-stu-id="6086f-203">Returns `true`</span></span>|

### <a name="dynamic-partitions"></a><span data-ttu-id="6086f-204">动态分区</span><span class="sxs-lookup"><span data-stu-id="6086f-204">Dynamic Partitions</span></span>

<span data-ttu-id="6086f-205">若要在 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 方法中使用分区程序，必须能够返回动态数量的分区。</span><span class="sxs-lookup"><span data-stu-id="6086f-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="6086f-206">也就是说，分区程序可以在循环执行期间随时按需提供新分区的枚举器。</span><span class="sxs-lookup"><span data-stu-id="6086f-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="6086f-207">这基本上意味着，每当循环添加新并行任务时，就会请求获取此任务的新分区。</span><span class="sxs-lookup"><span data-stu-id="6086f-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="6086f-208">如果要求数据必须可排序，请从 <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> 派生类，这样就可以为所有分区中的每个项都分配一个唯一索引。</span><span class="sxs-lookup"><span data-stu-id="6086f-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>

<span data-ttu-id="6086f-209">有关详细信息及示例，请参阅[如何：实现动态分区](how-to-implement-dynamic-partitions.md)。</span><span class="sxs-lookup"><span data-stu-id="6086f-209">For more information, and an example, see [How to: Implement Dynamic Partitions](how-to-implement-dynamic-partitions.md).</span></span>

### <a name="contract-for-partitioners"></a><span data-ttu-id="6086f-210">分区程序合同</span><span class="sxs-lookup"><span data-stu-id="6086f-210">Contract for Partitioners</span></span>

<span data-ttu-id="6086f-211">实现自定义分区程序时，请遵循以下指南，它们有助于确保与 PLINQ 和 TPL 中的 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 进行正确交互：</span><span class="sxs-lookup"><span data-stu-id="6086f-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>

- <span data-ttu-id="6086f-212">如果调用 <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> 时 `partitionsCount` 参数值等于或小于零，抛出 <xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="6086f-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="6086f-213">虽然 PLINQ 和 TPL 绝不会传入等于 0 的 `partitionCount`，但仍建议防范这种可能性。</span><span class="sxs-lookup"><span data-stu-id="6086f-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>

- <span data-ttu-id="6086f-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> 和 <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> 应始终返回分区的 `partitionsCount` 数。</span><span class="sxs-lookup"><span data-stu-id="6086f-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="6086f-215">如果分区程序用尽数据，且无法根据请求创建任意多个分区，方法应为剩余的每个分区返回空枚举器。</span><span class="sxs-lookup"><span data-stu-id="6086f-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="6086f-216">否则，PLINQ 和 TPL 都会抛出 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="6086f-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="6086f-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>、<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>、<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A> 和 <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> 不得返回 `null`（在 Visual Basic 中为 `Nothing`）。</span><span class="sxs-lookup"><span data-stu-id="6086f-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="6086f-218">如果返回，PLINQ/TPL 会抛出 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="6086f-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="6086f-219">返回分区的方法应始终返回可完全且唯一枚举数据源的分区。</span><span class="sxs-lookup"><span data-stu-id="6086f-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="6086f-220">除非分区程序在设计上有特别要求，否则数据源或跳过的项不得有重复项。</span><span class="sxs-lookup"><span data-stu-id="6086f-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="6086f-221">如果未遵循此规则，输出顺序可能会出现混乱。</span><span class="sxs-lookup"><span data-stu-id="6086f-221">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="6086f-222">为了让输出顺序不出现混乱，下面的布尔 Getter 必须始终准确返回以下值：</span><span class="sxs-lookup"><span data-stu-id="6086f-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>

  - <span data-ttu-id="6086f-223">`KeysOrderedInEachPartition`：每个分区返回密钥索引递增的元素。</span><span class="sxs-lookup"><span data-stu-id="6086f-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>

  - <span data-ttu-id="6086f-224">`KeysOrderedAcrossPartitions`：对于返回的所有分区，分区 i  中的密钥索引大于分区 i  -1 中的密钥索引。</span><span class="sxs-lookup"><span data-stu-id="6086f-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>

  - <span data-ttu-id="6086f-225">`KeysNormalized`：所有密钥索引从零开始不间断单调递增。</span><span class="sxs-lookup"><span data-stu-id="6086f-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>

- <span data-ttu-id="6086f-226">所有索引都必须是唯一的。</span><span class="sxs-lookup"><span data-stu-id="6086f-226">All indices must be unique.</span></span> <span data-ttu-id="6086f-227">不得有重复索引。</span><span class="sxs-lookup"><span data-stu-id="6086f-227">There may not be duplicate indices.</span></span> <span data-ttu-id="6086f-228">如果未遵循此规则，输出顺序可能会出现混乱。</span><span class="sxs-lookup"><span data-stu-id="6086f-228">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="6086f-229">所有索引都必须为非负索引。</span><span class="sxs-lookup"><span data-stu-id="6086f-229">All indices must be nonnegative.</span></span> <span data-ttu-id="6086f-230">如果未遵循此规则，PLINQ/TPL 可能会抛出异常。</span><span class="sxs-lookup"><span data-stu-id="6086f-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>

## <a name="see-also"></a><span data-ttu-id="6086f-231">另请参阅</span><span class="sxs-lookup"><span data-stu-id="6086f-231">See also</span></span>

- [<span data-ttu-id="6086f-232">并行编程</span><span class="sxs-lookup"><span data-stu-id="6086f-232">Parallel Programming</span></span>](index.md)
- [<span data-ttu-id="6086f-233">如何：实现动态分区</span><span class="sxs-lookup"><span data-stu-id="6086f-233">How to: Implement Dynamic Partitions</span></span>](how-to-implement-dynamic-partitions.md)
- [<span data-ttu-id="6086f-234">如何：实现静态分区程序</span><span class="sxs-lookup"><span data-stu-id="6086f-234">How to: Implement a Partitioner for Static Partitioning</span></span>](how-to-implement-a-partitioner-for-static-partitioning.md)
