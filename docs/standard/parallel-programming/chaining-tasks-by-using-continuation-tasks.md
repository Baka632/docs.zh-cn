---
title: 使用延续任务来链接任务
description: 了解如何在 .NET 中使用延续任务来链接任务。 延续任务是由其他任务调用的异步任务。
ms.date: 07/20/2020
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, continuations
ms.assetid: 0b45e9a2-de28-46ce-8212-1817280ed42d
ms.openlocfilehash: c7afbc1bb22a1743aed8e4ebd0a06c4f3fb57e86
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/18/2020
ms.locfileid: "94830605"
---
# <a name="chaining-tasks-using-continuation-tasks"></a><span data-ttu-id="3a8a9-104">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="3a8a9-104">Chaining tasks using continuation tasks</span></span>

<span data-ttu-id="3a8a9-105">在异步编程中，一个异步操作在完成时调用另一个操作的情况较常见。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-105">In asynchronous programming, it's common for one asynchronous operation, on completion, to invoke a second operation.</span></span> <span data-ttu-id="3a8a9-106">延续使后续操作可以使用第一次操作的结果。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-106">Continuations allow decedent operations to consume the results of the first operation.</span></span> <span data-ttu-id="3a8a9-107">传统上，延续性是通过使用回调方法完成的。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-107">Traditionally, continuations have been done by using callback methods.</span></span> <span data-ttu-id="3a8a9-108">在任务并行库中， _延续任务_ 提供了同样的功能。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-108">In the Task Parallel Library, the same functionality is provided by _continuation tasks_.</span></span> <span data-ttu-id="3a8a9-109">延续任务（也简称为“延续”）是一个异步任务，在完成时由另一个任务（称为“先行任务”）调用。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-109">A continuation task (also known just as a continuation) is an asynchronous task that's invoked by another task, known as the _antecedent_, when the antecedent finishes.</span></span>

<span data-ttu-id="3a8a9-110">尽管延续相对容易使用，但也十分强大和灵活。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-110">Continuations are relatively easy to use, but are nevertheless powerful and flexible.</span></span> <span data-ttu-id="3a8a9-111">例如，你可以：</span><span class="sxs-lookup"><span data-stu-id="3a8a9-111">For example, you can:</span></span>

- <span data-ttu-id="3a8a9-112">将数据从前面的任务传递到延续。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-112">Pass data from the antecedent to the continuation.</span></span>
- <span data-ttu-id="3a8a9-113">指定将调用或不调用延续所依据的精确条件。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-113">Specify the precise conditions under which the continuation will be invoked or not invoked.</span></span>
- <span data-ttu-id="3a8a9-114">在延续启动之前取消延续，或在延续正在运行时以协作方式取消延续。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-114">Cancel a continuation either before it starts or cooperatively as it is running.</span></span>
- <span data-ttu-id="3a8a9-115">提供有关应如何计划延续的提示。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-115">Provide hints about how the continuation should be scheduled.</span></span>
- <span data-ttu-id="3a8a9-116">从同一前面的任务中调用多个延续。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-116">Invoke multiple continuations from the same antecedent.</span></span>
- <span data-ttu-id="3a8a9-117">在多个前面的任务中的全部或任意任务完成时调用一个延续。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-117">Invoke one continuation when all or any one of multiple antecedents complete.</span></span>
- <span data-ttu-id="3a8a9-118">将延续依次相连，形成任意长度。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-118">Chain continuations one after another to any arbitrary length.</span></span>
- <span data-ttu-id="3a8a9-119">使用延续来处理前面的任务所引发的异常。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-119">Use a continuation to handle exceptions thrown by the antecedent.</span></span>

## <a name="about-continuations"></a><span data-ttu-id="3a8a9-120">关于延续</span><span class="sxs-lookup"><span data-stu-id="3a8a9-120">About continuations</span></span>

<span data-ttu-id="3a8a9-121">延续创建时的状态为 <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation> 。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-121">A continuation is a task that is created in the <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation> state.</span></span> <span data-ttu-id="3a8a9-122">在一个或多个前面的任务完成时，它将自动激活。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-122">It is activated automatically when its antecedent task or tasks complete.</span></span> <span data-ttu-id="3a8a9-123">若在用户代码中对延续调用 <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> ，将引发 <xref:System.InvalidOperationException?displayProperty=nameWithType> 异常。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-123">Calling <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> on a continuation in user code throws an <xref:System.InvalidOperationException?displayProperty=nameWithType> exception.</span></span>

<span data-ttu-id="3a8a9-124">延续本身是 <xref:System.Threading.Tasks.Task> ，并不阻止它在其上启动的线程。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-124">A continuation is itself a <xref:System.Threading.Tasks.Task> and does not block the thread on which it is started.</span></span> <span data-ttu-id="3a8a9-125">调用 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 方法进行阻止，直到延续任务完成。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-125">Call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to block until the continuation task finishes.</span></span>

## <a name="create-a-continuation-for-a-single-antecedent"></a><span data-ttu-id="3a8a9-126">为一个先行任务创建延续</span><span class="sxs-lookup"><span data-stu-id="3a8a9-126">Create a continuation for a single antecedent</span></span>

<span data-ttu-id="3a8a9-127">通过调用 <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 方法创建在其前面的任务完成时执行的延续。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-127">You create a continuation that executes when its antecedent has completed by calling the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3a8a9-128">下面的示例演示基本模式（为清楚起见，省略了异常处理）。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-128">The following example shows the basic pattern (for clarity, exception handling is omitted).</span></span> <span data-ttu-id="3a8a9-129">它会执行一个先行任务 - `taskA`，将返回一个 <xref:System.DayOfWeek> 对象，指示当天为周几。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-129">It executes an antecedent task, `taskA`, that returns a <xref:System.DayOfWeek> object that indicates the name of the current day of the week.</span></span> <span data-ttu-id="3a8a9-130">前面的任务完成时，将向延续任务 `continuation` 传递前面的任务，并显示包含其结果的字符串。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-130">When the antecedent completes, the continuation task, `continuation`, is passed the antecedent and displays a string that includes its result.</span></span>

> [!NOTE]
> <span data-ttu-id="3a8a9-131">本文中的 C# 示例利用 `Main` 方法的 `async` 修饰符。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-131">The C# samples in this article make use of the `async` modifier on the `Main` method.</span></span> <span data-ttu-id="3a8a9-132">此功能在 C# 7.1 及更高版本中提供。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-132">That feature is available in C# 7.1 and later.</span></span> <span data-ttu-id="3a8a9-133">以前的版本在编译此示例代码时生成 [`CS5001`](../../csharp/misc/cs5001.md)。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-133">Previous versions generate [`CS5001`](../../csharp/misc/cs5001.md) when compiling this sample code.</span></span> <span data-ttu-id="3a8a9-134">需要将语言版本设置为 C#7.1 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-134">You'll need to set the language version to C# 7.1 or newer.</span></span> <span data-ttu-id="3a8a9-135">可以通过有关[配置语言版本](../../csharp/language-reference/configure-language-version.md)的文章了解如何配置语言版本。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-135">You can learn how to configure the language version in the article on [configure language version](../../csharp/language-reference/configure-language-version.md).</span></span>

:::code language="csharp" source="snippets/cs/simple1.cs":::

[!code-vb[TPL_Continuations#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/simple1.vb#1)]

## <a name="create-a-continuation-for-multiple-antecedents"></a><span data-ttu-id="3a8a9-136">为多个先行任务创建延续</span><span class="sxs-lookup"><span data-stu-id="3a8a9-136">Create a continuation for multiple antecedents</span></span>

<span data-ttu-id="3a8a9-137">还可以创建一个将在一组任务中的任意或全部任务完成时运行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-137">You can also create a continuation that will run when any or all of a group of tasks has completed.</span></span> <span data-ttu-id="3a8a9-138">若要在所有前面的任务都完成后执行延续，则可以调用静态（在 Visual Basic 中为`Shared` ） <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> 方法或实例 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-138">To execute a continuation when all antecedent tasks have completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3a8a9-139">若要在多个前面的任务中的任意任务完成时执行延续，则可以调用静态（在 Visual Basic 中为`Shared` ） <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> 方法或实例 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-139">To execute a continuation when any of the antecedent tasks has completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="3a8a9-140">调用 <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> 重载不会阻止调用线程。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-140">Calls to the <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> overloads do not block the calling thread.</span></span> <span data-ttu-id="3a8a9-141">不过，通常调用除 <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> 方法外的其他所有方法来检索返回的 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 属性，这样不会阻止调用线程。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-141">However, you typically call all but the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> methods to retrieve the returned <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property, which does block the calling thread.</span></span>

<span data-ttu-id="3a8a9-142">下面的示例调用 <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> 方法来创建反映其 10 个前面的任务的结果的延续任务。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-142">The following example calls the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> method to create a continuation task that reflects the results of its 10 antecedent tasks.</span></span> <span data-ttu-id="3a8a9-143">每个前面的任务计算从 1 到 10 的索引值的平方值。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-143">Each antecedent task squares an index value that ranges from one to 10.</span></span> <span data-ttu-id="3a8a9-144">如果前面的任务成功完成（其 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 属性为 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>），则延续任务的 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 属性为由每个前面的任务返回的 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 值组成的数组。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-144">If the antecedents complete successfully (their <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>), the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the continuation is an array of the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> values returned by each antecedent.</span></span> <span data-ttu-id="3a8a9-145">该示例计算它们的总和，得出 1 到 10 之间的所有数字的平方和。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-145">The example adds them to compute the sum of squares for all numbers between one and 10.</span></span>

:::code language="csharp" source="snippets/cs/whenall1.cs":::

[!code-vb[TPL_Continuations#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/whenall1.vb#5)]

## <a name="continuation-options"></a><span data-ttu-id="3a8a9-146">延续选项</span><span class="sxs-lookup"><span data-stu-id="3a8a9-146">Continuation options</span></span>

<span data-ttu-id="3a8a9-147">在创建单任务延续时，你可以使用 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 重载，该重载采用 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 枚举值来指定启动延续所依据的条件。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-147">When you create a single-task continuation, you can use a <xref:System.Threading.Tasks.Task.ContinueWith%2A> overload that takes a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration value to specify the conditions under which the continuation starts.</span></span> <span data-ttu-id="3a8a9-148">例如，可以将延续指定为仅在前面的任务已完成运行时运行，或仅在前面的任务完成时处于错误状态时运行。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-148">For example, you can specify that the continuation is to run only if the antecedent completes successfully, or only if it completes in a faulted state.</span></span> <span data-ttu-id="3a8a9-149">如果该条件在前面的任务准备调用延续时未得到满足，则延续将直接转换为 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 状态，之后将无法启动。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-149">If the condition is not true when the antecedent is ready to invoke the continuation, the continuation transitions directly to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state and subsequently cannot be started.</span></span>

<span data-ttu-id="3a8a9-150">许多多任务延续方法（如 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> 方法的重载）也包括 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 参数。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-150">A number of multi-task continuation methods, such as overloads of the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method, also include a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> parameter.</span></span> <span data-ttu-id="3a8a9-151">但是，只有所有 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 枚举成员的一个子集有效。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-151">Only a subset of all <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration members are valid, however.</span></span> <span data-ttu-id="3a8a9-152">你可以指定在 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 枚举中具有对应的值的 <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> 值，如 <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType>、 <xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType>和 <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-152">You can specify <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> values that have counterparts in the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> enumeration, such as <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a8a9-153">如果为多任务延续指定 `NotOn` 或 `OnlyOn` 选项中的任意一个，则在运行时将引发 <xref:System.ArgumentOutOfRangeException> 异常。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-153">If you specify any of the `NotOn` or `OnlyOn` options with a multi-task continuation, an <xref:System.ArgumentOutOfRangeException> exception will be thrown at run time.</span></span>

<span data-ttu-id="3a8a9-154">有关任务延续选项的详细信息，请参阅 <xref:System.Threading.Tasks.TaskContinuationOptions> 主题。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-154">For more information on task continuation options, see the <xref:System.Threading.Tasks.TaskContinuationOptions> topic.</span></span>

## <a name="pass-data-to-a-continuation"></a><span data-ttu-id="3a8a9-155">将数据传递到延续</span><span class="sxs-lookup"><span data-stu-id="3a8a9-155">Pass data to a continuation</span></span>

<span data-ttu-id="3a8a9-156"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 方法将对前面的任务的引用以参数形式传递到延续的用户委托。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-156">The <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method passes a reference to the antecedent to the user delegate of the continuation as an argument.</span></span> <span data-ttu-id="3a8a9-157">如果前面的任务是一个 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 对象，并且任务在完成前保持运行，则延续可以访问任务的 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-157">If the antecedent is a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object, and the task ran until it was completed, then the continuation can access the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the task.</span></span>

<span data-ttu-id="3a8a9-158">在任务完成之前，将阻止 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-158">The <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property blocks until the task has completed.</span></span> <span data-ttu-id="3a8a9-159">但是，如果任务已取消或出错，则尝试访问 <xref:System.Threading.Tasks.Task%601.Result%2A> 属性将引发 <xref:System.AggregateException> 异常。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-159">However, if the task was canceled or faulted, attempting to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property throws an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="3a8a9-160">可通过使用 <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion> 选项避免此问题，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-160">You can avoid this problem by using the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion> option, as shown in the following example.</span></span>

:::code language="csharp" source="snippets/cs/result1.cs":::

[!code-vb[TPL_Continuations#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/result1.vb#2)]

<span data-ttu-id="3a8a9-161">如果希望延续即使在前面的任务未完成运行时也运行，则必须防止出现异常。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-161">If you want the continuation to run even if the antecedent did not run to successful completion, you must guard against the exception.</span></span> <span data-ttu-id="3a8a9-162">一种方法是测试前面的任务的 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 属性，并且仅在状态不是 <xref:System.Threading.Tasks.Task%601.Result%2A> 或 <xref:System.Threading.Tasks.TaskStatus.Faulted> 时才尝试访问 <xref:System.Threading.Tasks.TaskStatus.Canceled>属性。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-162">One approach is to test the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of the antecedent, and only attempt to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property if the status is not <xref:System.Threading.Tasks.TaskStatus.Faulted> or <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span> <span data-ttu-id="3a8a9-163">也可以检查前面的任务的 <xref:System.Threading.Tasks.Task.Exception%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-163">You can also examine the <xref:System.Threading.Tasks.Task.Exception%2A> property of the antecedent.</span></span> <span data-ttu-id="3a8a9-164">有关详细信息，请参阅[异常处理](exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-164">For more information, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span> <span data-ttu-id="3a8a9-165">下面的示例将之前的示例修改为仅在前面的任务的状态为 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 时，才访问该任务的 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>属性。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-165">The following example modifies the previous example to access antecedent's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property only if its status is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>.</span></span>

:::code language="csharp" source="snippets/cs/result2.cs":::

[!code-vb[TPL_Continuations#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/result2.vb#7)]

## <a name="cancel-a-continuation"></a><span data-ttu-id="3a8a9-166">取消延续</span><span class="sxs-lookup"><span data-stu-id="3a8a9-166">Cancel a continuation</span></span>

<span data-ttu-id="3a8a9-167">在以下情况下，延续的 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 属性将设置为 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> ：</span><span class="sxs-lookup"><span data-stu-id="3a8a9-167">The <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of a continuation is set to <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> in the following situations:</span></span>

- <span data-ttu-id="3a8a9-168">延续引发 <xref:System.OperationCanceledException> 以响应取消请求。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-168">It throws an <xref:System.OperationCanceledException> exception in response to a cancellation request.</span></span> <span data-ttu-id="3a8a9-169">就像任何任务一样，如果异常包含已传递到延续的相同标记，则会将其视为确认协作取消。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-169">As with any task, if the exception contains the same token that was passed to the continuation, it is treated as an acknowledgment of cooperative cancellation.</span></span>
- <span data-ttu-id="3a8a9-170">将 <xref:System.Threading.CancellationToken?displayProperty=nameWithType> 属性为 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> 的 `true`传递到延续。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-170">The continuation is passed a <xref:System.Threading.CancellationToken?displayProperty=nameWithType> whose <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property is `true`.</span></span> <span data-ttu-id="3a8a9-171">在这种情况下，延续不会启动，并且将转换为 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 状态。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-171">In this case, the continuation does not start, and it transitions to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>
- <span data-ttu-id="3a8a9-172">延续由于其 <xref:System.Threading.Tasks.TaskContinuationOptions> 参数设置的条件未得到满足而从不运行。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-172">The continuation never runs because the condition set by its <xref:System.Threading.Tasks.TaskContinuationOptions> argument was not met.</span></span> <span data-ttu-id="3a8a9-173">例如，如果前面的任务进入 <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> 状态，则该任务被传递了 <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType> 选项的延续将不会运行，而是将转换为 <xref:System.Threading.Tasks.TaskStatus.Canceled> 状态。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-173">For example, if an antecedent goes into a <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its continuation that was passed the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType> option will not run but will transition to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>

<span data-ttu-id="3a8a9-174">如果一项任务及其延续表示同一逻辑操作的两个部分，则可以将相同的取消标记传递到这两个任务，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-174">If a task and its continuation represent two parts of the same logical operation, you can pass the same cancellation token to both tasks, as shown in the following example.</span></span> <span data-ttu-id="3a8a9-175">它包含的前面的任务可生成由可被 33 的整数组成的列表，并将该列表传递给延续。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-175">It consists of an antecedent that generates a list of integers that are divisible by 33, which it passes to the continuation.</span></span> <span data-ttu-id="3a8a9-176">而延续反过来显示该列表。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-176">The continuation in turn displays the list.</span></span> <span data-ttu-id="3a8a9-177">前面的任务和延续任务都将定期以随机间隔暂停。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-177">Both the antecedent and the continuation pause regularly for random intervals.</span></span> <span data-ttu-id="3a8a9-178">此外， <xref:System.Threading.Timer?displayProperty=nameWithType> 对象用于在五秒的超时间隔后执行 `Elapsed` 方法。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-178">In addition, a <xref:System.Threading.Timer?displayProperty=nameWithType> object is used to execute the `Elapsed` method after a five-second timeout interval.</span></span> <span data-ttu-id="3a8a9-179">此示例调用 <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> 方法，从而将导致当前正在执行的任务调用 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-179">This example calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method, which causes the currently executing task to call the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3a8a9-180">是否在前面的任务或其延续正在执行时调用 <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> 方法取决于随机生成的暂停的持续时间。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-180">Whether the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method is called when the antecedent or its continuation is executing depends on the duration of the randomly generated pauses.</span></span> <span data-ttu-id="3a8a9-181">如果已取消前面的任务，则延续将不会启动。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-181">If the antecedent is canceled, the continuation will not start.</span></span> <span data-ttu-id="3a8a9-182">如果未取消前面的任务，则仍然可以使用标记来取消延续。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-182">If the antecedent is not canceled, the token can still be used to cancel the continuation.</span></span>

:::code language="csharp" source="snippets/cs/cancellation1.cs":::

[!code-vb[TPL_Continuations#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation1.vb#3)]

<span data-ttu-id="3a8a9-183">通过在创建延续时指定 <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType> 选项，在不向延续提供取消标记而取消其前面的任务的情况下，你也可阻止延续的执行。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-183">You can also prevent a continuation from executing if its antecedent is canceled without supplying the continuation a cancellation token by specifying the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType> option when you create the continuation.</span></span> <span data-ttu-id="3a8a9-184">下面是一个简单的示例。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-184">The following is a simple example.</span></span>

:::code language="csharp" source="snippets/cs/cancellation2.cs":::

[!code-vb[TPL_Continuations#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation2.vb#8)]

<span data-ttu-id="3a8a9-185">在延续转换为 <xref:System.Threading.Tasks.TaskStatus.Canceled> 状态后，它可能会影响后面的延续，具体情况取决于为这些延续指定的 <xref:System.Threading.Tasks.TaskContinuationOptions> 。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-185">After a continuation goes into the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, it may affect continuations that follow, depending on the <xref:System.Threading.Tasks.TaskContinuationOptions> that were specified for those continuations.</span></span>

<span data-ttu-id="3a8a9-186">已释放的延续将不会启动。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-186">Continuations that are disposed will not start.</span></span>

## <a name="continuations-and-child-tasks"></a><span data-ttu-id="3a8a9-187">延续和子任务</span><span class="sxs-lookup"><span data-stu-id="3a8a9-187">Continuations and child tasks</span></span>

<span data-ttu-id="3a8a9-188">在前面的任务及其所有附加的子任务完成之前，延续将不会运行。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-188">A continuation does not run until the antecedent and all of its attached child tasks have completed.</span></span> <span data-ttu-id="3a8a9-189">延续不会等待分离的子任务完成。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-189">The continuation does not wait for detached child tasks to finish.</span></span> <span data-ttu-id="3a8a9-190">以下两个示例阐释了两个子任务，其中一个附加到创建了延续的前面的任务，另一个从创建了延续的前面的任务中分离。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-190">The following two examples illustrate child tasks that are attached to and detached from an antecedent that creates a continuation.</span></span> <span data-ttu-id="3a8a9-191">在下面的示例中，延续仅在所有子任务都完成后才会运行，并且多次运行该示例时，每次生成的输出相同。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-191">In the following example, the continuation runs only after all child tasks have completed, and running the example multiple times produces identical output each time.</span></span> <span data-ttu-id="3a8a9-192">该示例通过调用 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 方法来启动前面的任务，因为在默认情况下， <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 方法将创建一个默认任务创建选项为 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>的父任务。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-192">The example launches the antecedent by calling the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, since by default the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method creates a parent task whose default task creation option is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>

:::code language="csharp" source="snippets/cs/attached1.cs":::

[!code-vb[TPL_Continuations#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/attached1.vb#9)]

<span data-ttu-id="3a8a9-193">但是，如果子任务与前面的任务分离，则前面的任务任务一旦终止，延续就将立即开始运行，而无论子任务的状态。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-193">If child tasks are detached from the antecedent, however, the continuation runs as soon as the antecedent has terminated, regardless of the state of the child tasks.</span></span> <span data-ttu-id="3a8a9-194">因此，多次运行下面的示例可能生成可变输出，具体取决于任务计划程序处理每个子任务的方式。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-194">As a result, multiple runs of the following example can produce variable output that depends on how the task scheduler handled each child task.</span></span>

:::code language="csharp" source="snippets/cs/detached1.cs":::

[!code-vb[TPL_Continuations#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/detached1.vb#10)]

<span data-ttu-id="3a8a9-195">前面的任务的最终状态取决于任何附加的子任务的最终状态。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-195">The final status of the antecedent task depends on the final status of any attached child tasks.</span></span> <span data-ttu-id="3a8a9-196">分离的子任务的状态不影响父级。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-196">The status of detached child tasks does not affect the parent.</span></span> <span data-ttu-id="3a8a9-197">有关详细信息，请参阅[附加和分离的子任务](attached-and-detached-child-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-197">For more information, see [Attached and Detached Child Tasks](attached-and-detached-child-tasks.md).</span></span>

## <a name="associate-state-with-continuations"></a><span data-ttu-id="3a8a9-198">将状态与延续关联</span><span class="sxs-lookup"><span data-stu-id="3a8a9-198">Associate state with continuations</span></span>

<span data-ttu-id="3a8a9-199">可以将任意状态与任务延续关联。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-199">You can associate arbitrary state with a task continuation.</span></span> <span data-ttu-id="3a8a9-200"><xref:System.Threading.Tasks.Task.ContinueWith%2A> 方法提供重载版本，每个重载版本都带有一个表示延续状态的 <xref:System.Object> 值。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-200">The <xref:System.Threading.Tasks.Task.ContinueWith%2A> method provides overloaded versions that each take an <xref:System.Object> value that represents the state of the continuation.</span></span> <span data-ttu-id="3a8a9-201">可以之后通过使用 <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> 属性访问此状态对象。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-201">You can later access this state object by using the <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="3a8a9-202">如果未提供值，则此状态对象为 `null` 。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-202">This state object is `null` if you do not provide a value.</span></span>

<span data-ttu-id="3a8a9-203">将使用 [异步编程模型 (APM)](../asynchronous-programming-patterns/asynchronous-programming-model-apm.md) 的现有代码转换为使用 TPL 时，延续状态非常有用。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-203">Continuation state is useful when you convert existing code that uses the [Asynchronous Programming Model (APM)](../asynchronous-programming-patterns/asynchronous-programming-model-apm.md) to use the TPL.</span></span> <span data-ttu-id="3a8a9-204">在 APM 中，通常在 **Begin**_Method_ 方法中提供对象状态，并在之后通过使用 <xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType> 属性访问该状态。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-204">In the APM, you typically provide object state in the **Begin**_Method_ method and later access that state by using the <xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="3a8a9-205">通过使用 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 方法，你可在将使用 APM 的代码转换为使用 TPL 时保留此状态。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-205">By using the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method, you can preserve this state when you convert code that uses the APM to use the TPL.</span></span>

<span data-ttu-id="3a8a9-206">在 Visual Studio 调试器中处理 <xref:System.Threading.Tasks.Task> 对象时，延续状态也非常有用。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-206">Continuation state can also be useful when you work with <xref:System.Threading.Tasks.Task> objects in the Visual Studio debugger.</span></span> <span data-ttu-id="3a8a9-207">例如，在“并行任务”  窗口中，“任务”  列显示每个任务的状态对象的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-207">For example, in the **Parallel Tasks** window, the **Task** column displays the string representation of the state object for each task.</span></span> <span data-ttu-id="3a8a9-208">有关“并行任务”窗口的详细信息，请参阅[使用并行任务窗口](/visualstudio/debugger/using-the-tasks-window)。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-208">For more information about the **Parallel Tasks** window, see [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window).</span></span>

<span data-ttu-id="3a8a9-209">下面的示例演示如何使用延续状态。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-209">The following example shows how to use continuation state.</span></span> <span data-ttu-id="3a8a9-210">它将创建一个延续任务链。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-210">It creates a chain of continuation tasks.</span></span> <span data-ttu-id="3a8a9-211">每个任务都将为 <xref:System.DateTime> 方法的 `state` 参数提供当前时间，即一个 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 对象。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-211">Each task provides the current time, a <xref:System.DateTime> object, for the `state` parameter of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method.</span></span> <span data-ttu-id="3a8a9-212">每个 <xref:System.DateTime> 对象都表示创建延续任务的时间。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-212">Each <xref:System.DateTime> object represents the time at which the continuation task is created.</span></span> <span data-ttu-id="3a8a9-213">每个任务都将生成第二个 <xref:System.DateTime> 对象作为其结果，该对象表示任务的完成时间。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-213">Each task produces as its result a second <xref:System.DateTime> object that represents the time at which the task finishes.</span></span> <span data-ttu-id="3a8a9-214">所有任务都完成后，本示例将显示每个延续任务的创建时间和完成时间。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-214">After all tasks finish, this example displays the creation time and the time at which each continuation task finishes.</span></span>

:::code language="csharp" source="snippets/cs/continuationstate.cs":::

[!code-vb[TPL_ContinuationState#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuationstate/vb/continuationstate.vb#1)]

## <a name="continuations-that-return-task-types"></a><span data-ttu-id="3a8a9-215">返回 Task 类型的延续</span><span class="sxs-lookup"><span data-stu-id="3a8a9-215">Continuations that return Task types</span></span>

<span data-ttu-id="3a8a9-216">有时，可能需要链接可返回 <xref:System.Threading.Tasks.Task> 类型的延续。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-216">Sometimes you may need to chain a continuation that returns a <xref:System.Threading.Tasks.Task> type.</span></span> <span data-ttu-id="3a8a9-217">这些任务称为嵌套任务，它们很常见。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-217">These are referred to as nested tasks, and they are common.</span></span> <span data-ttu-id="3a8a9-218">当父任务调用 <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType>，并提供作为任务返回的 `continuationFunction` 时，你可以调用 <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> 来创建表示 `<Task<Task<T>>>` 或 `Task(Of Task(Of T))` (Visual Basic) 的异步操作的代理任务。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-218">When a parent task calls <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType>, and provides a `continuationFunction` that is task returning you call <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> to create a proxy task that represents the asynchronous operation of the `<Task<Task<T>>>` or `Task(Of Task(Of T))` (Visual Basic).</span></span>

<span data-ttu-id="3a8a9-219">下面的示例展示如何使用包装附加任务返回函数的延续。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-219">The following example shows how to use continuations that wrap additional task returning functions.</span></span> <span data-ttu-id="3a8a9-220">每个延续都可以进行解包，并公开已包装的内部任务。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-220">Each continuation can be unwrapped, exposing the inner task that was wrapped.</span></span>

:::code language="csharp" source="snippets/cs/unwrap.cs":::
:::code language="vb" source="snippets/vb/unwrap.vb":::

<span data-ttu-id="3a8a9-221">有关使用 <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> 的详细信息，请参阅[如何：展开嵌套任务](how-to-unwrap-a-nested-task.md)。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-221">For more information on using <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A>, see [How to: Unwrap a nested Task](how-to-unwrap-a-nested-task.md).</span></span>

## <a name="handle-exceptions-thrown-from-continuations"></a><span data-ttu-id="3a8a9-222">处理从延续中引发的异常</span><span class="sxs-lookup"><span data-stu-id="3a8a9-222">Handle exceptions thrown from continuations</span></span>

<span data-ttu-id="3a8a9-223">前面的任务与延续之间的关系不是父/子关系。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-223">An antecedent-continuation relationship is not a parent-child relationship.</span></span> <span data-ttu-id="3a8a9-224">由延续引发的异常不会传播到前面的任务。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-224">Exceptions thrown by continuations are not propagated to the antecedent.</span></span> <span data-ttu-id="3a8a9-225">因此，请按在任何其他任务中处理异常的方式来处理由延续引发的异常，如下所示：</span><span class="sxs-lookup"><span data-stu-id="3a8a9-225">Therefore, handle exceptions thrown by continuations as you would handle them in any other task, as follows:</span></span>

- <span data-ttu-id="3a8a9-226">你可以使用 <xref:System.Threading.Tasks.Task.Wait%2A>、 <xref:System.Threading.Tasks.Task.WaitAll%2A>或 <xref:System.Threading.Tasks.Task.WaitAny%2A> 法或其对应的泛型方法来等待延续。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-226">You can use the <xref:System.Threading.Tasks.Task.Wait%2A>, <xref:System.Threading.Tasks.Task.WaitAll%2A>, or <xref:System.Threading.Tasks.Task.WaitAny%2A> method, or its generic counterpart, to wait on the continuation.</span></span> <span data-ttu-id="3a8a9-227">你可以在同一 `try` 语句中等待前面的任务及其延续，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-227">You can wait for an antecedent and its continuations in the same `try` statement, as shown in the following example.</span></span>

:::code language="csharp" source="snippets/cs/exception1.cs":::

[!code-vb[TPL_Continuations#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception1.vb#6)]

- <span data-ttu-id="3a8a9-228">可以使用第二个延续来观察第一个延续的 <xref:System.Threading.Tasks.Task.Exception%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-228">You can use a second continuation to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property of the first continuation.</span></span> <span data-ttu-id="3a8a9-229">在下面的示例中，某个任务尝试从不存在的文件中进行读取。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-229">In the following example, a task attempts to read from a non-existent file.</span></span> <span data-ttu-id="3a8a9-230">然后，延续将显示有关前面的任务中的异常的信息。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-230">The continuation then displays information about the exception in the antecedent task.</span></span>

:::code language="csharp" source="snippets/cs/exception2.cs" id="example":::

[!code-vb[TPL_Continuations#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#4)]

<span data-ttu-id="3a8a9-231">因为使用 <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType> 选项运行，所以仅当前面的任务中发生异常时才会执行延续，并且可以假设前面的任务的 <xref:System.Threading.Tasks.Task.Exception%2A> 属性不为 `null`。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-231">Because it was run with the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType> option, the continuation executes only if an exception occurs in the antecedent, and therefore it can assume that the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null`.</span></span> <span data-ttu-id="3a8a9-232">如果无论前面的任务中是否引发了异常都将执行延续，则必须先检查前面的任务的 <xref:System.Threading.Tasks.Task.Exception%2A> 属性是否不为 `null` ，然后再尝试处理该异常，如以下代码片段所示。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-232">If the continuation executes whether or not an exception is thrown in the antecedent, it would have to check whether the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null` before attempting to handle the exception, as the following code fragment shows.</span></span>

:::code language="csharp" source="snippets/cs/exception2.cs" id="exception":::

[!code-vb[TPL_Continuations#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#11)]

<span data-ttu-id="3a8a9-233">有关详细信息，请参阅[异常处理](exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-233">For more information, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span>

- <span data-ttu-id="3a8a9-234">如果延续为附加子任务并且是通过使用 <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> 选项创建的，则父级会将该延续的异常传播回调用线程，就像任何其他附加子级的情况一样。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-234">If the continuation is an attached child task that was created by using the <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> option, its exceptions will be propagated by the parent back to the calling thread, as is the case in any other attached child.</span></span> <span data-ttu-id="3a8a9-235">有关详细信息，请参阅[附加和分离的子任务](attached-and-detached-child-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="3a8a9-235">For more information, see [Attached and Detached Child Tasks](attached-and-detached-child-tasks.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="3a8a9-236">请参阅</span><span class="sxs-lookup"><span data-stu-id="3a8a9-236">See also</span></span>

- [<span data-ttu-id="3a8a9-237">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="3a8a9-237">Task Parallel Library (TPL)</span></span>](task-parallel-library-tpl.md)
