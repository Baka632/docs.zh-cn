---
title: 了解 PLINQ 中的加速
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
ms.openlocfilehash: 247ebb868a9256deaf59c1369e6143e15af4d6b0
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/18/2020
ms.locfileid: "94829968"
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="69bc5-102">了解 PLINQ 中的加速</span><span class="sxs-lookup"><span data-stu-id="69bc5-102">Understanding Speedup in PLINQ</span></span>
<span data-ttu-id="69bc5-103">PLINQ 的主要用途是，在多核计算机上并行执行查询委托，以加速执行 LINQ to Objects 查询。</span><span class="sxs-lookup"><span data-stu-id="69bc5-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="69bc5-104">如果单独处理源集合中的每个元素，且各个代理之间不涉及共享状态，PLINQ 的性能最佳。</span><span class="sxs-lookup"><span data-stu-id="69bc5-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="69bc5-105">此类操作在 LINQ to Objects 和 PLINQ 中很常见，通常称为“适合并行”，因为它们可以轻松适应计划多个线程的工作。</span><span class="sxs-lookup"><span data-stu-id="69bc5-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="69bc5-106">不过，并非所有查询完全都由适合并行操作组成；在大多数情况下，查询涉及一些无法并行执行或减慢并行执行的运算符。</span><span class="sxs-lookup"><span data-stu-id="69bc5-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="69bc5-107">即使查询完全都由适合并行组成，PLINQ 仍必须对数据源进行分区，并计划线程工作，通常还需要在查询完成时合并结果。</span><span class="sxs-lookup"><span data-stu-id="69bc5-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="69bc5-108">所有这些操作都增加了并行执行的计算成本；增加并行执行而产生的这些成本称为“开销”。</span><span class="sxs-lookup"><span data-stu-id="69bc5-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="69bc5-109">为了实现 PLINQ 查询的最佳性能，目标是最大限度地增加适合并行执行的部分，并尽量减少需要开销的部分。</span><span class="sxs-lookup"><span data-stu-id="69bc5-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="69bc5-110">本文有助于确保编写的 PLINQ 查询尽可能高效，且仍能产生正确结果。</span><span class="sxs-lookup"><span data-stu-id="69bc5-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="69bc5-111">PLINQ 查询性能的影响因素</span><span class="sxs-lookup"><span data-stu-id="69bc5-111">Factors that Impact PLINQ Query Performance</span></span>  
 <span data-ttu-id="69bc5-112">下面各部分列出了并行查询性能的一些最重要的影响因素。</span><span class="sxs-lookup"><span data-stu-id="69bc5-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="69bc5-113">这些都是一般性说明，本身并不足以用于在所有情况下预测查询性能。</span><span class="sxs-lookup"><span data-stu-id="69bc5-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="69bc5-114">和以往一样，请务必在具有一系列代表性配置和负载的计算机上度量特定查询的实际性能。</span><span class="sxs-lookup"><span data-stu-id="69bc5-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1. <span data-ttu-id="69bc5-115">整体工作的计算成本。</span><span class="sxs-lookup"><span data-stu-id="69bc5-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="69bc5-116">为了实现加速，PLINQ 查询必须有足够多的适合并行操作来抵消开销。</span><span class="sxs-lookup"><span data-stu-id="69bc5-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="69bc5-117">工作可以表示为每个委托的计算成本乘以源集合中的元素数量。</span><span class="sxs-lookup"><span data-stu-id="69bc5-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="69bc5-118">假设操作可以并行执行，它的计算成本越高，加速的机会就越大。</span><span class="sxs-lookup"><span data-stu-id="69bc5-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="69bc5-119">例如，如果函数的执行时间为 1 毫秒，那么超过 1000 个元素的顺序查询需要 1 秒的时间才能执行此操作，而在四核计算机上，并行查询可能只需要 250 毫秒就能完成。</span><span class="sxs-lookup"><span data-stu-id="69bc5-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="69bc5-120">这就产生 750 毫秒的加速。</span><span class="sxs-lookup"><span data-stu-id="69bc5-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="69bc5-121">如果函数执行每个元素需要 1 秒，就会产生 750 秒的加速。</span><span class="sxs-lookup"><span data-stu-id="69bc5-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="69bc5-122">如果委托成本很高，PLINQ 可能会让速度显著提升，前提是源集合中只有几项。</span><span class="sxs-lookup"><span data-stu-id="69bc5-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="69bc5-123">相反，包含最简单的委托的小型源集合通常不适合执行 PLINQ。</span><span class="sxs-lookup"><span data-stu-id="69bc5-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="69bc5-124">在下面的示例中，queryA 可能很适合执行 PLINQ，前提是它的 Select 函数涉及很多工作。</span><span class="sxs-lookup"><span data-stu-id="69bc5-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="69bc5-125">queryB 可能不适合执行 PLINQ，因为 Select 语句中没有足够多的工作，并行开销会抵消大部分或全部加速。</span><span class="sxs-lookup"><span data-stu-id="69bc5-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2. <span data-ttu-id="69bc5-126">系统上的逻辑内核数量（并行度）。</span><span class="sxs-lookup"><span data-stu-id="69bc5-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="69bc5-127">这一点是上一部分的必然结果，在具有更多内核的计算机上，适合并行查询运行得更快，这是因为可以在更多并发线程之间划分工作。</span><span class="sxs-lookup"><span data-stu-id="69bc5-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="69bc5-128">加速总量取决于查询整体工作的并行度百分比。</span><span class="sxs-lookup"><span data-stu-id="69bc5-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="69bc5-129">不过，不要认为所有查询在八核计算机上的运行速度都是在四核计算机上的两倍。</span><span class="sxs-lookup"><span data-stu-id="69bc5-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="69bc5-130">优化查询以实现最佳性能时，请务必在具有不同数量内核的计算机上度量实际结果。</span><span class="sxs-lookup"><span data-stu-id="69bc5-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="69bc5-131">这一点与第 1 点相关：需要更大的数据集，才能利用更多的计算资源。</span><span class="sxs-lookup"><span data-stu-id="69bc5-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3. <span data-ttu-id="69bc5-132">操作的数量和种类。</span><span class="sxs-lookup"><span data-stu-id="69bc5-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="69bc5-133">如果有必要维护源序列中的元素顺序，PLINQ 提供 AsOrdered 运算符。</span><span class="sxs-lookup"><span data-stu-id="69bc5-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="69bc5-134">虽然排序有相关成本，但此成本通常还算低。</span><span class="sxs-lookup"><span data-stu-id="69bc5-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="69bc5-135">GroupBy 和 Join 操作同样也会产生开销。</span><span class="sxs-lookup"><span data-stu-id="69bc5-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="69bc5-136">如果允许按任意顺序处理源集合中的元素，并在准备就绪后立即将它们传递给下一个运算符，PLINQ 的性能最佳。</span><span class="sxs-lookup"><span data-stu-id="69bc5-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="69bc5-137">有关详细信息，请参阅 [PLINQ 中的顺序保留](order-preservation-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="69bc5-137">For more information, see [Order Preservation in PLINQ](order-preservation-in-plinq.md).</span></span>  
  
4. <span data-ttu-id="69bc5-138">查询执行形式。</span><span class="sxs-lookup"><span data-stu-id="69bc5-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="69bc5-139">若要通过调用 ToArray 或 ToList 存储查询结果，所有并行线程的结果都必须合并到一个数据结构中。</span><span class="sxs-lookup"><span data-stu-id="69bc5-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="69bc5-140">这就涉及不可避免的计算成本。</span><span class="sxs-lookup"><span data-stu-id="69bc5-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="69bc5-141">同样，如果使用 foreach（Visual Basic 中的 For Each）循环来循环访问结果，工作线程的结果必须串行化到枚举器线程。</span><span class="sxs-lookup"><span data-stu-id="69bc5-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="69bc5-142">不过，如果只想根据每个线程的结果执行某操作，可以使用 ForAll 方法对多个线程执行此操作。</span><span class="sxs-lookup"><span data-stu-id="69bc5-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5. <span data-ttu-id="69bc5-143">合并选项类型。</span><span class="sxs-lookup"><span data-stu-id="69bc5-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="69bc5-144">PLINQ 可以配置为缓冲输出并在生成整个结果集后分块区生成或一次性全部生成，也可以配置为在各个结果生成时流式传输它们。</span><span class="sxs-lookup"><span data-stu-id="69bc5-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="69bc5-145">前一个导致总体执行时间减少，后一个导致所生成元素之间的延迟减少。</span><span class="sxs-lookup"><span data-stu-id="69bc5-145">The former results in decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="69bc5-146">尽管合并选项不一定会对总体查询性能造成重大影响，但它们可能会影响感知性能，因为它们控制用户在看到结果前必须等待的时间。</span><span class="sxs-lookup"><span data-stu-id="69bc5-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="69bc5-147">有关详细信息，请参阅 [PLINQ 中的合并选项](merge-options-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="69bc5-147">For more information, see [Merge Options in PLINQ](merge-options-in-plinq.md).</span></span>  
  
6. <span data-ttu-id="69bc5-148">分区种类。</span><span class="sxs-lookup"><span data-stu-id="69bc5-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="69bc5-149">在某些情况下，对可索引源集合执行 PLINQ 查询可能会导致工作负载不平衡。</span><span class="sxs-lookup"><span data-stu-id="69bc5-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="69bc5-150">如果发生这种情况，可以创建自定义分区程序，从而提升查询性能。</span><span class="sxs-lookup"><span data-stu-id="69bc5-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="69bc5-151">有关详细信息，请参阅 [PLINQ 和 TPL 的自定义分区程序](custom-partitioners-for-plinq-and-tpl.md)。</span><span class="sxs-lookup"><span data-stu-id="69bc5-151">For more information, see [Custom Partitioners for PLINQ and TPL](custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="69bc5-152">如果 PLINQ 选择顺序模式</span><span class="sxs-lookup"><span data-stu-id="69bc5-152">When PLINQ Chooses Sequential Mode</span></span>  
 <span data-ttu-id="69bc5-153">PLINQ 始终都会尝试至少像顺序运行查询一样快地执行查询。</span><span class="sxs-lookup"><span data-stu-id="69bc5-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="69bc5-154">虽然 PLINQ 没有考虑用户委托的计算成本或输入源大小，但它确实会查找特定查询“形状”。</span><span class="sxs-lookup"><span data-stu-id="69bc5-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="69bc5-155">具体来说，它会查找通常会减慢查询在并行模式下的执行速度的查询运算符或运算符组合。</span><span class="sxs-lookup"><span data-stu-id="69bc5-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="69bc5-156">如果找到此类形状，PLINQ 默认会回退到顺序模式。</span><span class="sxs-lookup"><span data-stu-id="69bc5-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="69bc5-157">不过，在度量特定查询的性能后，可以确定它在并行模式下的实际运行速度更快。</span><span class="sxs-lookup"><span data-stu-id="69bc5-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="69bc5-158">在这种情况下，可以通过 <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> 方法使用 <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> 标志来指示 PLINQ 并行执行查询。</span><span class="sxs-lookup"><span data-stu-id="69bc5-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="69bc5-159">有关详细信息，请参阅[如何：在 PLINQ 中指定执行模式](how-to-specify-the-execution-mode-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="69bc5-159">For more information, see [How to: Specify the Execution Mode in PLINQ](how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="69bc5-160">下面列出了 PLINQ 在顺序模式下默认执行的查询形状：</span><span class="sxs-lookup"><span data-stu-id="69bc5-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
- <span data-ttu-id="69bc5-161">在删除或重新排列了原始索引的排序或筛选运算符后面，包含 Select、已编制索引 Where、已编制索引 SelectMany 或 ElementAt 子句的查询。</span><span class="sxs-lookup"><span data-stu-id="69bc5-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
- <span data-ttu-id="69bc5-162">包含 Take、TakeWhile、Skip、SkipWhile 运算符且源序列中的索引不是原始顺序的查询。</span><span class="sxs-lookup"><span data-stu-id="69bc5-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
- <span data-ttu-id="69bc5-163">包含 Zip 或 SequenceEquals 的查询，除非其中一个数据源具有按原始顺序排列的索引，并且另一个数据源是可索引的（即，数组或 IList(T)）。</span><span class="sxs-lookup"><span data-stu-id="69bc5-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
- <span data-ttu-id="69bc5-164">包含 Concat 的查询，除非应用于可索引的数据源。</span><span class="sxs-lookup"><span data-stu-id="69bc5-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
- <span data-ttu-id="69bc5-165">包含 Reverse 的查询，除非应用于可索引的数据源。</span><span class="sxs-lookup"><span data-stu-id="69bc5-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="69bc5-166">请参阅</span><span class="sxs-lookup"><span data-stu-id="69bc5-166">See also</span></span>

- [<span data-ttu-id="69bc5-167">并行 LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="69bc5-167">Parallel LINQ (PLINQ)</span></span>](introduction-to-plinq.md)
