---
title: PLINQ 介绍
description: 了解如何使用 .NET 中的 PLINQ 并行执行查询。 PLINQ 代表并行语言集成查询 (LINQ)。
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, introduction to
ms.assetid: eaa720d8-8999-4eb7-8df5-3c19ca61cad0
ms.openlocfilehash: 37414c7963a3803518b41a5c6d262740313e2b37
ms.sourcegitcommit: 6d09ae36acba0b0e2ba47999f8f1a725795462a2
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/29/2020
ms.locfileid: "92925345"
---
# <a name="introduction-to-plinq"></a><span data-ttu-id="b6072-104">PLINQ 介绍</span><span class="sxs-lookup"><span data-stu-id="b6072-104">Introduction to PLINQ</span></span>

<span data-ttu-id="b6072-105">并行 LINQ (PLINQ) 是[语言集成查询 (LINQ)](../../csharp/programming-guide/concepts/linq/index.md) 模式的并行实现。</span><span class="sxs-lookup"><span data-stu-id="b6072-105">Parallel LINQ (PLINQ) is a parallel implementation of the [Language-Integrated Query (LINQ)](../../csharp/programming-guide/concepts/linq/index.md) pattern.</span></span> <span data-ttu-id="b6072-106">PLINQ 将整套 LINQ 标准查询运算符实现为 <xref:System.Linq> 命名空间的扩展方法，并提供适用于并行操作的其他运算符。</span><span class="sxs-lookup"><span data-stu-id="b6072-106">PLINQ implements the full set of LINQ standard query operators as extension methods for the <xref:System.Linq> namespace and has additional operators for parallel operations.</span></span> <span data-ttu-id="b6072-107">PLINQ 将 LINQ 语法的简洁和可靠性与并行编程的强大功能结合在一起。</span><span class="sxs-lookup"><span data-stu-id="b6072-107">PLINQ combines the simplicity and readability of LINQ syntax with the power of parallel programming.</span></span>

> [!TIP]
> <span data-ttu-id="b6072-108">如果不熟悉 LINQ，则它具有统一的模型，用于以类型安全方式查询任何可枚举数据源。</span><span class="sxs-lookup"><span data-stu-id="b6072-108">If you're not familiar with LINQ, it features a unified model for querying any enumerable data source in a type-safe manner.</span></span> <span data-ttu-id="b6072-109">LINQ to Objects 是针对内存中集合（如 <xref:System.Collections.Generic.List%601> 和数组）运行的 LINQ 查询的名称。</span><span class="sxs-lookup"><span data-stu-id="b6072-109">LINQ to Objects is the name for LINQ queries that are run against in-memory collections such as <xref:System.Collections.Generic.List%601> and arrays.</span></span> <span data-ttu-id="b6072-110">本文假定你对 LINQ 有基本的了解。</span><span class="sxs-lookup"><span data-stu-id="b6072-110">This article assumes that you have a basic understanding of LINQ.</span></span> <span data-ttu-id="b6072-111">有关详细信息，请参阅[语言集成查询 (LINQ)](../../csharp/programming-guide/concepts/linq/index.md)。</span><span class="sxs-lookup"><span data-stu-id="b6072-111">For more information, see [Language-Integrated Query (LINQ)](../../csharp/programming-guide/concepts/linq/index.md).</span></span>

## <a name="what-is-a-parallel-query"></a><span data-ttu-id="b6072-112">什么是并行查询？</span><span class="sxs-lookup"><span data-stu-id="b6072-112">What is a Parallel query?</span></span>

<span data-ttu-id="b6072-113">一个 PLINQ 查询的许多方面都类似于非并行的 LINQ to Objects 查询。</span><span class="sxs-lookup"><span data-stu-id="b6072-113">A PLINQ query in many ways resembles a non-parallel LINQ to Objects query.</span></span> <span data-ttu-id="b6072-114">与顺序 LINQ 查询一样，PLINQ 查询对任何内存中 <xref:System.Collections.IEnumerable> 或 <xref:System.Collections.Generic.IEnumerable%601> 数据源执行操作，并且推迟了执行，即在枚举查询前不会开始执行。</span><span class="sxs-lookup"><span data-stu-id="b6072-114">PLINQ queries, just like sequential LINQ queries, operate on any in-memory <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> data source, and have deferred execution, which means they do not begin executing until the query is enumerated.</span></span> <span data-ttu-id="b6072-115">主要区别在于，PLINQ 会尝试充分利用系统上的所有处理器。</span><span class="sxs-lookup"><span data-stu-id="b6072-115">The primary difference is that PLINQ attempts to make full use of all the processors on the system.</span></span> <span data-ttu-id="b6072-116">方法是将数据源分区成片段，然后在多个处理器上针对单独工作线程上的每个片段执行并行查询。</span><span class="sxs-lookup"><span data-stu-id="b6072-116">It does this by partitioning the data source into segments, and then executing the query on each segment on separate worker threads in parallel on multiple processors.</span></span> <span data-ttu-id="b6072-117">在许多情况下，并行执行意味着查询运行速度显著提高。</span><span class="sxs-lookup"><span data-stu-id="b6072-117">In many cases, parallel execution means that the query runs significantly faster.</span></span>

<span data-ttu-id="b6072-118">通过并行执行，通常只需向数据源添加 <xref:System.Linq.ParallelEnumerable.AsParallel%2A> 查询操作，PLINQ 即可显著提升性能（与某些类型查询的旧代码相比）。</span><span class="sxs-lookup"><span data-stu-id="b6072-118">Through parallel execution, PLINQ can achieve significant performance improvements over legacy code for certain kinds of queries, often just by adding the <xref:System.Linq.ParallelEnumerable.AsParallel%2A> query operation to the data source.</span></span> <span data-ttu-id="b6072-119">但是，并行可能会引入其自身的复杂性，因此并非所有的查询操作的运行速度在 PLINQ 中都更快。</span><span class="sxs-lookup"><span data-stu-id="b6072-119">However, parallelism can introduce its own complexities, and not all query operations run faster in PLINQ.</span></span> <span data-ttu-id="b6072-120">事实上，并行实际上会降低某些查询的速度。</span><span class="sxs-lookup"><span data-stu-id="b6072-120">In fact, parallelization actually slows down certain queries.</span></span> <span data-ttu-id="b6072-121">因此，应了解排序等问题将如何对并行查询产生影响。</span><span class="sxs-lookup"><span data-stu-id="b6072-121">Therefore, you should understand how issues such as ordering affect parallel queries.</span></span> <span data-ttu-id="b6072-122">有关详细信息，请参阅[了解 PLINQ 中的加速](understanding-speedup-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="b6072-122">For more information, see [Understanding Speedup in PLINQ](understanding-speedup-in-plinq.md).</span></span>

> [!NOTE]
> <span data-ttu-id="b6072-123">本文档使用 lambda 表达式在 PLINQ 中定义委托。</span><span class="sxs-lookup"><span data-stu-id="b6072-123">This documentation uses lambda expressions to define delegates in PLINQ.</span></span> <span data-ttu-id="b6072-124">如果不熟悉 C# 或 Visual Basic 中的 lambda 表达式，请参阅 [PLINQ 和 TPL 中的 Lambda 表达式](lambda-expressions-in-plinq-and-tpl.md)。</span><span class="sxs-lookup"><span data-stu-id="b6072-124">If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](lambda-expressions-in-plinq-and-tpl.md).</span></span>

<span data-ttu-id="b6072-125">本文的其余部分将概述主 PLINQ 类，并讨论如何创建 PLINQ 查询。</span><span class="sxs-lookup"><span data-stu-id="b6072-125">The remainder of this article gives an overview of the main PLINQ classes and discusses how to create PLINQ queries.</span></span> <span data-ttu-id="b6072-126">每部分包含指向更详细信息以及代码示例的链接。</span><span class="sxs-lookup"><span data-stu-id="b6072-126">Each section contains links to more detailed information and code examples.</span></span>

## <a name="the-parallelenumerable-class"></a><span data-ttu-id="b6072-127">ParallelEnumerable 类</span><span class="sxs-lookup"><span data-stu-id="b6072-127">The ParallelEnumerable Class</span></span>

<span data-ttu-id="b6072-128"><xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> 类公开了几乎所有的 PLINQ 功能。</span><span class="sxs-lookup"><span data-stu-id="b6072-128">The <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> class exposes almost all of PLINQ's functionality.</span></span> <span data-ttu-id="b6072-129">它和 <xref:System.Linq?displayProperty=nameWithType> 命名空间类型的其余部分一起被编译到 System.Core.dll 程序集中。</span><span class="sxs-lookup"><span data-stu-id="b6072-129">It and the rest of the <xref:System.Linq?displayProperty=nameWithType> namespace types are compiled into the System.Core.dll assembly.</span></span> <span data-ttu-id="b6072-130">Visual Studio 中默认的 C# 和 Visual Basic 项目均会引用该程序集并导入该命名空间。</span><span class="sxs-lookup"><span data-stu-id="b6072-130">The default C# and Visual Basic projects in Visual Studio both reference the assembly and import the namespace.</span></span>

<span data-ttu-id="b6072-131">尽管 <xref:System.Linq.ParallelEnumerable> 实现了 LINQ to Objects 支持的所有标准查询运算符，但它不会尝试并行执行每个实现。</span><span class="sxs-lookup"><span data-stu-id="b6072-131"><xref:System.Linq.ParallelEnumerable> includes implementations of all the standard query operators that LINQ to Objects supports, although it does not attempt to parallelize each one.</span></span> <span data-ttu-id="b6072-132">如果你不熟悉 LINQ，请参阅 [LINQ (C#) 简介](../../csharp/programming-guide/concepts/linq/index.md)和 [LINQ (Visual Basic) 简介](../../visual-basic/programming-guide/concepts/linq/introduction-to-linq.md)。</span><span class="sxs-lookup"><span data-stu-id="b6072-132">If you are not familiar with LINQ, see [Introduction to LINQ (C#)](../../csharp/programming-guide/concepts/linq/index.md) and [Introduction to LINQ (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/introduction-to-linq.md).</span></span>

<span data-ttu-id="b6072-133">除了标准查询运算符外，<xref:System.Linq.ParallelEnumerable> 类还包含一组启用并行执行专用行为的方法。</span><span class="sxs-lookup"><span data-stu-id="b6072-133">In addition to the standard query operators, the <xref:System.Linq.ParallelEnumerable> class contains a set of methods that enable behaviors specific to parallel execution.</span></span> <span data-ttu-id="b6072-134">下表中列出了这些特定于 PLINQ 的方法。</span><span class="sxs-lookup"><span data-stu-id="b6072-134">These PLINQ-specific methods are listed in the following table.</span></span>

|<span data-ttu-id="b6072-135">ParallelEnumerable 运算符</span><span class="sxs-lookup"><span data-stu-id="b6072-135">ParallelEnumerable Operator</span></span>|<span data-ttu-id="b6072-136">描述</span><span class="sxs-lookup"><span data-stu-id="b6072-136">Description</span></span>|
|---------------------------------|-----------------|
|<xref:System.Linq.ParallelEnumerable.AsParallel%2A>|<span data-ttu-id="b6072-137">PLINQ 的入口点。</span><span class="sxs-lookup"><span data-stu-id="b6072-137">The entry point for PLINQ.</span></span> <span data-ttu-id="b6072-138">指定如果可能，应并行化查询的其余部分。</span><span class="sxs-lookup"><span data-stu-id="b6072-138">Specifies that the rest of the query should be parallelized, if it is possible.</span></span>|
|<xref:System.Linq.ParallelEnumerable.AsSequential%2A>|<span data-ttu-id="b6072-139">指定查询的其余部分应像非并行的 LINQ 查询一样按顺序运行。</span><span class="sxs-lookup"><span data-stu-id="b6072-139">Specifies that the rest of the query should be run sequentially, as a non-parallel LINQ query.</span></span>|
|<xref:System.Linq.ParallelEnumerable.AsOrdered%2A>|<span data-ttu-id="b6072-140">指定 PLINQ 应为查询的其余部分保留源序列的排序，或直到例如通过使用 orderby（在 Visual Basic 中为 Order By）子句更改排序为止。</span><span class="sxs-lookup"><span data-stu-id="b6072-140">Specifies that PLINQ should preserve the ordering of the source sequence for the rest of the query, or until the ordering is changed, for example by the use of an orderby (Order By in Visual Basic) clause.</span></span>|
|<xref:System.Linq.ParallelEnumerable.AsUnordered%2A>|<span data-ttu-id="b6072-141">指定保留源序列的排序不需要查询其余部分的 PLINQ。</span><span class="sxs-lookup"><span data-stu-id="b6072-141">Specifies that PLINQ for the rest of the query is not required to preserve the ordering of the source sequence.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithCancellation%2A>|<span data-ttu-id="b6072-142">指定 PLINQ 应定期监视请求取消时所提供的取消标记的状态以及取消执行。</span><span class="sxs-lookup"><span data-stu-id="b6072-142">Specifies that PLINQ should periodically monitor the state of the provided cancellation token and cancel execution if it is requested.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A>|<span data-ttu-id="b6072-143">指定 PLINQ 应用于并行化查询的处理器的最大数量。</span><span class="sxs-lookup"><span data-stu-id="b6072-143">Specifies the maximum number of processors that PLINQ should use to parallelize the query.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A>|<span data-ttu-id="b6072-144">提供有关 PLINQ 应如何（如果可能）将并行结果合并回使用线程上的一个序列的提示。</span><span class="sxs-lookup"><span data-stu-id="b6072-144">Provides a hint about how PLINQ should, if it is possible, merge parallel results back into just one sequence on the consuming thread.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A>|<span data-ttu-id="b6072-145">指定 PLINQ 应如何并行化查询（即使是当默认行为是按顺序运行查询时）。</span><span class="sxs-lookup"><span data-stu-id="b6072-145">Specifies whether PLINQ should parallelize the query even when the default behavior would be to run it sequentially.</span></span>|
|<xref:System.Linq.ParallelEnumerable.ForAll%2A>|<span data-ttu-id="b6072-146">一种多线程枚举方法，与循环访问查询结果不同，它允许在不首先合并回使用者线程的情况下并行处理结果。</span><span class="sxs-lookup"><span data-stu-id="b6072-146">A multithreaded enumeration method that, unlike iterating over the results of the query, enables results to be processed in parallel without first merging back to the consumer thread.</span></span>|
|<span data-ttu-id="b6072-147"><xref:System.Linq.ParallelEnumerable.Aggregate%2A> 重载</span><span class="sxs-lookup"><span data-stu-id="b6072-147"><xref:System.Linq.ParallelEnumerable.Aggregate%2A> overload</span></span>|<span data-ttu-id="b6072-148">对于 PLINQ 唯一的重载，它启用对线程本地分区的中间聚合以及一个用于合并所有分区结果的最终聚合函数。</span><span class="sxs-lookup"><span data-stu-id="b6072-148">An overload that is unique to PLINQ and enables intermediate aggregation over thread-local partitions, plus a final aggregation function to combine the results of all partitions.</span></span>|

## <a name="the-opt-in-model"></a><span data-ttu-id="b6072-149">选择使用模型</span><span class="sxs-lookup"><span data-stu-id="b6072-149">The Opt-in Model</span></span>

<span data-ttu-id="b6072-150">编写查询时，请对数据源调用 <xref:System.Linq.ParallelEnumerable.AsParallel%2A?displayProperty=nameWithType> 扩展方法，以选择使用 PLINQ，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="b6072-150">When you write a query, opt in to PLINQ by invoking the <xref:System.Linq.ParallelEnumerable.AsParallel%2A?displayProperty=nameWithType> extension method on the data source, as shown in the following example.</span></span>

[!code-csharp[PLINQ#1](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#1)]
[!code-vb[PLINQ#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#1)]

<span data-ttu-id="b6072-151"><xref:System.Linq.ParallelEnumerable.AsParallel%2A> 扩展方法将后续查询运算符（在此示例中为 `where` 和 `select`）绑定到 <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> 实现。</span><span class="sxs-lookup"><span data-stu-id="b6072-151">The <xref:System.Linq.ParallelEnumerable.AsParallel%2A> extension method binds the subsequent query operators, in this case, `where` and `select`, to the <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> implementations.</span></span>

## <a name="execution-modes"></a><span data-ttu-id="b6072-152">执行模式</span><span class="sxs-lookup"><span data-stu-id="b6072-152">Execution Modes</span></span>

<span data-ttu-id="b6072-153">默认情况下，PLINQ 是保守的。</span><span class="sxs-lookup"><span data-stu-id="b6072-153">By default, PLINQ is conservative.</span></span> <span data-ttu-id="b6072-154">在运行时，PLINQ 基础结构将分析查询的总体结构。</span><span class="sxs-lookup"><span data-stu-id="b6072-154">At run time, the PLINQ infrastructure analyzes the overall structure of the query.</span></span> <span data-ttu-id="b6072-155">如果通过并行可能会提高查询速度，PLINQ 则将源序列分区为可以同时运行的任务。</span><span class="sxs-lookup"><span data-stu-id="b6072-155">If the query is likely to yield speedups by parallelization, PLINQ partitions the source sequence into tasks that can be run concurrently.</span></span> <span data-ttu-id="b6072-156">如果并行化查询不安全，PLINQ 则只会按顺序运行查询。</span><span class="sxs-lookup"><span data-stu-id="b6072-156">If it is not safe to parallelize a query, PLINQ just runs the query sequentially.</span></span> <span data-ttu-id="b6072-157">如果 PLINQ 可以在可能会较昂贵的并行算法或成本较低的顺序算法之间进行选择，它会默认选择顺序算法。</span><span class="sxs-lookup"><span data-stu-id="b6072-157">If PLINQ has a choice between a potentially expensive parallel algorithm or an inexpensive sequential algorithm, it chooses the sequential algorithm by default.</span></span> <span data-ttu-id="b6072-158">可以使用 <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> 方法和 <xref:System.Linq.ParallelExecutionMode?displayProperty=nameWithType> 枚举指示 PLINQ 选择并行算法。</span><span class="sxs-lookup"><span data-stu-id="b6072-158">You can use the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method and the <xref:System.Linq.ParallelExecutionMode?displayProperty=nameWithType> enumeration to instruct PLINQ to select the parallel algorithm.</span></span> <span data-ttu-id="b6072-159">如果你通过测试和测量知道特定查询以并行方式执行得更快时，此做法非常有用。</span><span class="sxs-lookup"><span data-stu-id="b6072-159">This is useful when you know by testing and measurement that a particular query executes faster in parallel.</span></span> <span data-ttu-id="b6072-160">有关详细信息，请参阅[如何：在 PLINQ 中指定执行模式](how-to-specify-the-execution-mode-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="b6072-160">For more information, see [How to: Specify the Execution Mode in PLINQ](how-to-specify-the-execution-mode-in-plinq.md).</span></span>

## <a name="degree-of-parallelism"></a><span data-ttu-id="b6072-161">并行度</span><span class="sxs-lookup"><span data-stu-id="b6072-161">Degree of Parallelism</span></span>

<span data-ttu-id="b6072-162">默认情况下，PLINQ 使用主机计算机上的所有处理器。</span><span class="sxs-lookup"><span data-stu-id="b6072-162">By default, PLINQ uses all of the processors on the host computer.</span></span> <span data-ttu-id="b6072-163">可以使用 <xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A> 方法指示 PLINQ 使用不超过指定数量的处理器。</span><span class="sxs-lookup"><span data-stu-id="b6072-163">You can instruct PLINQ to use no more than a specified number of processors by using the <xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A> method.</span></span> <span data-ttu-id="b6072-164">当你要确保计算机上运行的其他进程收到一定的 CPU 时间量时，此做法将非常有用。</span><span class="sxs-lookup"><span data-stu-id="b6072-164">This is useful when you want to make sure that other processes running on the computer receive a certain amount of CPU time.</span></span> <span data-ttu-id="b6072-165">下面的片段将查询限制为最多使用两个处理器。</span><span class="sxs-lookup"><span data-stu-id="b6072-165">The following snippet limits the query to utilizing a maximum of two processors.</span></span>

[!code-csharp[PLINQ#5](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#5)]
[!code-vb[PLINQ#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#5)]

<span data-ttu-id="b6072-166">在查询要执行大量非受计算限制的工作（如文件 I/O）的情况下，最好指定比计算机上的内核数要大的并行度。</span><span class="sxs-lookup"><span data-stu-id="b6072-166">In cases where a query is performing a significant amount of non-compute-bound work such as File I/O, it might be beneficial to specify a degree of parallelism greater than the number of cores on the machine.</span></span>

## <a name="ordered-versus-unordered-parallel-queries"></a><span data-ttu-id="b6072-167">已排序和未排序的并行查询</span><span class="sxs-lookup"><span data-stu-id="b6072-167">Ordered Versus Unordered Parallel Queries</span></span>

<span data-ttu-id="b6072-168">在某些查询中，一个查询运算符必须产生保留源序列排序的结果。</span><span class="sxs-lookup"><span data-stu-id="b6072-168">In some queries, a query operator must produce results that preserve the ordering of the source sequence.</span></span> <span data-ttu-id="b6072-169">为此，PLINQ 提供了 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 运算符。</span><span class="sxs-lookup"><span data-stu-id="b6072-169">PLINQ provides the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator for this purpose.</span></span> <span data-ttu-id="b6072-170"><xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 不同于 <xref:System.Linq.ParallelEnumerable.AsSequential%2A>。</span><span class="sxs-lookup"><span data-stu-id="b6072-170"><xref:System.Linq.ParallelEnumerable.AsOrdered%2A> is distinct from <xref:System.Linq.ParallelEnumerable.AsSequential%2A>.</span></span> <span data-ttu-id="b6072-171">尽管仍并行处理 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 序列，但会缓冲和排序它的结果。</span><span class="sxs-lookup"><span data-stu-id="b6072-171">An <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> sequence is still processed in parallel, but its results are buffered and sorted.</span></span> <span data-ttu-id="b6072-172">由于顺序暂留通常涉及额外的工作，因此处理 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 序列可能比处理默认 <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> 序列更慢。</span><span class="sxs-lookup"><span data-stu-id="b6072-172">Because order preservation typically involves extra work, an <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> sequence might be processed more slowly than the default <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> sequence.</span></span> <span data-ttu-id="b6072-173">特定的已排序并行操作是否比操作的顺序版本更快取决于许多因素。</span><span class="sxs-lookup"><span data-stu-id="b6072-173">Whether a particular ordered parallel operation is faster than a sequential version of the operation depends on many factors.</span></span>

<span data-ttu-id="b6072-174">下面的代码示例演示了如何选择使用顺序保留。</span><span class="sxs-lookup"><span data-stu-id="b6072-174">The following code example shows how to opt in to order preservation.</span></span>

[!code-csharp[PLINQ#3](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#3)]
[!code-vb[PLINQ#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#3)]

<span data-ttu-id="b6072-175">有关详细信息，请参阅 [PLINQ 中的顺序保留](order-preservation-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="b6072-175">For more information, see [Order Preservation in PLINQ](order-preservation-in-plinq.md).</span></span>

## <a name="parallel-vs-sequential-queries"></a><span data-ttu-id="b6072-176">并行和顺序查询</span><span class="sxs-lookup"><span data-stu-id="b6072-176">Parallel vs. Sequential Queries</span></span>

<span data-ttu-id="b6072-177">某些操作要求按顺序提供源数据。</span><span class="sxs-lookup"><span data-stu-id="b6072-177">Some operations require that the source data be delivered in a sequential manner.</span></span> <span data-ttu-id="b6072-178">必要时，<xref:System.Linq.ParallelEnumerable> 查询运算符自动还原为顺序模式。</span><span class="sxs-lookup"><span data-stu-id="b6072-178">The <xref:System.Linq.ParallelEnumerable> query operators revert to sequential mode automatically when it is required.</span></span> <span data-ttu-id="b6072-179">对于要求顺序执行的用户定义的查询运算符和用户委托，PLINQ 提供了 <xref:System.Linq.ParallelEnumerable.AsSequential%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b6072-179">For user-defined query operators and user delegates that require sequential execution, PLINQ provides the <xref:System.Linq.ParallelEnumerable.AsSequential%2A> method.</span></span> <span data-ttu-id="b6072-180">使用 <xref:System.Linq.ParallelEnumerable.AsSequential%2A> 时，查询中的所有后续运算符都会顺序执行，直到再次调用 <xref:System.Linq.ParallelEnumerable.AsParallel%2A>。</span><span class="sxs-lookup"><span data-stu-id="b6072-180">When you use <xref:System.Linq.ParallelEnumerable.AsSequential%2A>, all subsequent operators in the query are executed sequentially until <xref:System.Linq.ParallelEnumerable.AsParallel%2A> is called again.</span></span> <span data-ttu-id="b6072-181">有关详细信息，请参阅[如何：合并并行和顺序 LINQ 查询](how-to-combine-parallel-and-sequential-linq-queries.md)。</span><span class="sxs-lookup"><span data-stu-id="b6072-181">For more information, see [How to: Combine Parallel and Sequential LINQ Queries](how-to-combine-parallel-and-sequential-linq-queries.md).</span></span>

## <a name="options-for-merging-query-results"></a><span data-ttu-id="b6072-182">合并查询结果的选项</span><span class="sxs-lookup"><span data-stu-id="b6072-182">Options for Merging Query Results</span></span>

<span data-ttu-id="b6072-183">当一个 PLINQ 查询并行执行时，它从每个工作线程得到的结果必须合并回到主线程上，以便由 `foreach` 循环（在 Visual Basic 中为 `For Each`）使用或插入到列表或数组中。</span><span class="sxs-lookup"><span data-stu-id="b6072-183">When a PLINQ query executes in parallel, its results from each worker thread must be merged back onto the main thread for consumption by a `foreach` loop (`For Each` in Visual Basic), or insertion into a list or array.</span></span> <span data-ttu-id="b6072-184">例如在某些情况下，指定一个特定类型的合并操作可能会有好处，以更快地开始产生结果。</span><span class="sxs-lookup"><span data-stu-id="b6072-184">In some cases, it might be beneficial to specify a particular kind of merge operation, for example, to begin producing results more quickly.</span></span> <span data-ttu-id="b6072-185">为此，PLINQ 支持 <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> 方法和 <xref:System.Linq.ParallelMergeOptions> 枚举。</span><span class="sxs-lookup"><span data-stu-id="b6072-185">For this purpose, PLINQ supports the <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> method, and the <xref:System.Linq.ParallelMergeOptions> enumeration.</span></span> <span data-ttu-id="b6072-186">有关详细信息，请参阅 [PLINQ 中的合并选项](merge-options-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="b6072-186">For more information, see [Merge Options in PLINQ](merge-options-in-plinq.md).</span></span>

## <a name="the-forall-operator"></a><span data-ttu-id="b6072-187">ForAll 运算符</span><span class="sxs-lookup"><span data-stu-id="b6072-187">The ForAll Operator</span></span>

<span data-ttu-id="b6072-188">在顺序 LINQ 查询中，执行一直延迟到在 `foreach`（Visual Basic 中为 `For Each`）循环中或通过调用 <xref:System.Linq.ParallelEnumerable.ToList%2A>、<xref:System.Linq.ParallelEnumerable.ToArray%2A> 或 <xref:System.Linq.ParallelEnumerable.ToDictionary%2A> 等方法枚举查询。</span><span class="sxs-lookup"><span data-stu-id="b6072-188">In sequential LINQ queries, execution is deferred until the query is enumerated either in a `foreach` (`For Each` in Visual Basic) loop or by invoking a method such as <xref:System.Linq.ParallelEnumerable.ToList%2A> , <xref:System.Linq.ParallelEnumerable.ToArray%2A> , or <xref:System.Linq.ParallelEnumerable.ToDictionary%2A>.</span></span> <span data-ttu-id="b6072-189">在 PLINQ 中，还可以使用 `foreach` 执行查询以及循环访问结果。</span><span class="sxs-lookup"><span data-stu-id="b6072-189">In PLINQ, you can also use `foreach` to execute the query and iterate through the results.</span></span> <span data-ttu-id="b6072-190">但是，`foreach` 本身不会并行运行，因此，它要求将所有并行任务的输出合并回该循环正在上面运行的线程中。</span><span class="sxs-lookup"><span data-stu-id="b6072-190">However, `foreach` itself does not run in parallel, and therefore, it requires that the output from all parallel tasks be merged back into the thread on which the loop is running.</span></span> <span data-ttu-id="b6072-191">在 PLINQ 中，在必须保留查询结果的最终排序，以及以按串行方式处理结果时，例如当为每个元素调用 `Console.WriteLine` 时，则可以使用 `foreach`。</span><span class="sxs-lookup"><span data-stu-id="b6072-191">In PLINQ, you can use `foreach` when you must preserve the final ordering of the query results, and also whenever you are processing the results in a serial manner, for example when you are calling `Console.WriteLine` for each element.</span></span> <span data-ttu-id="b6072-192">为了在无需顺序暂留以及可自行并行处理结果时更快地执行查询，请使用 <xref:System.Linq.ParallelEnumerable.ForAll%2A> 方法执行 PLINQ 查询。</span><span class="sxs-lookup"><span data-stu-id="b6072-192">For faster query execution when order preservation is not required and when the processing of the results can itself be parallelized, use the <xref:System.Linq.ParallelEnumerable.ForAll%2A> method to execute a PLINQ query.</span></span> <span data-ttu-id="b6072-193"><xref:System.Linq.ParallelEnumerable.ForAll%2A> 不执行最终的这一合并步骤。</span><span class="sxs-lookup"><span data-stu-id="b6072-193"><xref:System.Linq.ParallelEnumerable.ForAll%2A> does not perform this final merge step.</span></span> <span data-ttu-id="b6072-194">下面的代码示例说明如何使用 <xref:System.Linq.ParallelEnumerable.ForAll%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b6072-194">The following code example shows how to use the <xref:System.Linq.ParallelEnumerable.ForAll%2A> method.</span></span> <span data-ttu-id="b6072-195">此处使用 <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> 是因为它已优化，可以同时添加多个线程，而无需尝试移除任何项。</span><span class="sxs-lookup"><span data-stu-id="b6072-195"><xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> is used here because it is optimized for multiple threads adding concurrently without attempting to remove any items.</span></span>

[!code-csharp[PLINQ#4](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#4)]
[!code-vb[PLINQ#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#4)]

<span data-ttu-id="b6072-196">下图展示了 `foreach` 与 <xref:System.Linq.ParallelEnumerable.ForAll%2A> 在查询执行方面的区别。</span><span class="sxs-lookup"><span data-stu-id="b6072-196">The following illustration shows the difference between `foreach` and <xref:System.Linq.ParallelEnumerable.ForAll%2A> with regard to query execution.</span></span>

<span data-ttu-id="b6072-197">![ForAll 与ForEach](media/vs-isvnt-allvseach.png "VS_ISVNT_ALLvsEACH")</span><span class="sxs-lookup"><span data-stu-id="b6072-197">![ForAll vs. ForEach](media/vs-isvnt-allvseach.png "VS_ISVNT_ALLvsEACH")</span></span>

## <a name="cancellation"></a><span data-ttu-id="b6072-198">取消</span><span class="sxs-lookup"><span data-stu-id="b6072-198">Cancellation</span></span>

<span data-ttu-id="b6072-199">PLINQ 在 .NET 中与取消类型集成在一起。</span><span class="sxs-lookup"><span data-stu-id="b6072-199">PLINQ is integrated with the cancellation types in .NET.</span></span> <span data-ttu-id="b6072-200">（有关详细信息，请参阅[托管线程中的取消](../threading/cancellation-in-managed-threads.md)。）因此，与顺序 LINQ to Objects 查询不同，可以取消 PLINQ 查询。</span><span class="sxs-lookup"><span data-stu-id="b6072-200">(For more information, see [Cancellation in Managed Threads](../threading/cancellation-in-managed-threads.md).) Therefore, unlike sequential LINQ to Objects queries, PLINQ queries can be canceled.</span></span> <span data-ttu-id="b6072-201">若要创建可取消 PLINQ 查询，请在查询中使用 <xref:System.Linq.ParallelEnumerable.WithCancellation%2A> 运算符，并提供 <xref:System.Threading.CancellationToken> 实例作为参数。</span><span class="sxs-lookup"><span data-stu-id="b6072-201">To create a cancelable PLINQ query, use the <xref:System.Linq.ParallelEnumerable.WithCancellation%2A> operator on the query and provide a <xref:System.Threading.CancellationToken> instance as the argument.</span></span> <span data-ttu-id="b6072-202">如果令牌上的 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> 属性设置为 true，PLINQ 就会注意到它，停止处理所有线程并抛出 <xref:System.OperationCanceledException>。</span><span class="sxs-lookup"><span data-stu-id="b6072-202">When the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property on the token is set to true, PLINQ will notice it, stop processing on all threads, and throw an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="b6072-203">在设置取消标记后，PLINQ 查询还可能会继续处理一些元素。</span><span class="sxs-lookup"><span data-stu-id="b6072-203">It is possible that a PLINQ query might continue to process some elements after the cancellation token is set.</span></span>

<span data-ttu-id="b6072-204">为了提高响应速度，还可以在长时间运行的用户委托中响应取消请求。</span><span class="sxs-lookup"><span data-stu-id="b6072-204">For greater responsiveness, you can also respond to cancellation requests in long-running user delegates.</span></span> <span data-ttu-id="b6072-205">有关详细信息，请参阅[如何：取消 PLINQ 查询](how-to-cancel-a-plinq-query.md)。</span><span class="sxs-lookup"><span data-stu-id="b6072-205">For more information, see [How to: Cancel a PLINQ Query](how-to-cancel-a-plinq-query.md).</span></span>

## <a name="exceptions"></a><span data-ttu-id="b6072-206">异常</span><span class="sxs-lookup"><span data-stu-id="b6072-206">Exceptions</span></span>

<span data-ttu-id="b6072-207">当一个 PLINQ 查询执行时，可能会同时从不同的线程引发多个异常。</span><span class="sxs-lookup"><span data-stu-id="b6072-207">When a PLINQ query executes, multiple exceptions might be thrown from different threads simultaneously.</span></span> <span data-ttu-id="b6072-208">此外，处理异常的代码可能与引发异常的代码处于不同的线程上。</span><span class="sxs-lookup"><span data-stu-id="b6072-208">Also, the code to handle the exception might be on a different thread than the code that threw the exception.</span></span> <span data-ttu-id="b6072-209">PLINQ 使用 <xref:System.AggregateException> 类型封装查询抛出的所有异常，并将这些异常封送回调用线程。</span><span class="sxs-lookup"><span data-stu-id="b6072-209">PLINQ uses the <xref:System.AggregateException> type to encapsulate all the exceptions that were thrown by a query, and marshal those exceptions back to the calling thread.</span></span> <span data-ttu-id="b6072-210">在调用线程上，只需要一个 try-catch 块。</span><span class="sxs-lookup"><span data-stu-id="b6072-210">On the calling thread, only one try-catch block is required.</span></span> <span data-ttu-id="b6072-211">不过，可以循环访问在 <xref:System.AggregateException> 中封装的所有异常，并捕获任何可以安全恢复的异常。</span><span class="sxs-lookup"><span data-stu-id="b6072-211">However, you can iterate through all of the exceptions that are encapsulated in the <xref:System.AggregateException> and catch any that you can safely recover from.</span></span> <span data-ttu-id="b6072-212">在极少数情况下，可能会抛出未在 <xref:System.AggregateException> 中包装的一些异常，<xref:System.Threading.ThreadAbortException> 也没有进行包装。</span><span class="sxs-lookup"><span data-stu-id="b6072-212">In rare cases, some exceptions may be thrown that are not wrapped in an <xref:System.AggregateException>, and <xref:System.Threading.ThreadAbortException>s  are also not wrapped.</span></span>

<span data-ttu-id="b6072-213">如果允许异常向上冒泡回到联接线程，则查询也许可以在引发异常后继续处理一些项。</span><span class="sxs-lookup"><span data-stu-id="b6072-213">When exceptions are allowed to bubble up back to the joining thread, then it is possible that a query may continue to process some items after the exception is raised.</span></span>

<span data-ttu-id="b6072-214">有关详细信息，请参阅[如何：处理 PLINQ 查询中的异常](how-to-handle-exceptions-in-a-plinq-query.md)。</span><span class="sxs-lookup"><span data-stu-id="b6072-214">For more information, see [How to: Handle Exceptions in a PLINQ Query](how-to-handle-exceptions-in-a-plinq-query.md).</span></span>

## <a name="custom-partitioners"></a><span data-ttu-id="b6072-215">自定义分区程序</span><span class="sxs-lookup"><span data-stu-id="b6072-215">Custom Partitioners</span></span>

<span data-ttu-id="b6072-216">在某些情况下，可以通过编写利用源数据的某些特征的自定义分区程序来提高查询性能。</span><span class="sxs-lookup"><span data-stu-id="b6072-216">In some cases, you can improve query performance by writing a custom partitioner that takes advantage of some characteristic of the source data.</span></span> <span data-ttu-id="b6072-217">在查询中，自定义分区程序本身是被查询的可枚举对象。</span><span class="sxs-lookup"><span data-stu-id="b6072-217">In the query, the custom partitioner itself is the enumerable object that is queried.</span></span>

[!code-csharp[PLINQ#2](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#2)]
[!code-vb[PLINQ#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq3.vb#2)]

<span data-ttu-id="b6072-218">PLINQ 支持固定数量的分区（尽管在运行时期间为了负载均衡可能会将数据重新动态分配到这些分区）。</span><span class="sxs-lookup"><span data-stu-id="b6072-218">PLINQ supports a fixed number of partitions (although data may be dynamically reassigned to those partitions during run time for load balancing.).</span></span> <span data-ttu-id="b6072-219"><xref:System.Threading.Tasks.Parallel.For%2A> 和 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 仅支持动态分区。也就是说，分区数在运行时发生变化。</span><span class="sxs-lookup"><span data-stu-id="b6072-219"><xref:System.Threading.Tasks.Parallel.For%2A> and <xref:System.Threading.Tasks.Parallel.ForEach%2A> support only dynamic partitioning, which means that the number of partitions changes at run time.</span></span> <span data-ttu-id="b6072-220">有关详细信息，请参阅 [PLINQ 和 TPL 的自定义分区程序](custom-partitioners-for-plinq-and-tpl.md)。</span><span class="sxs-lookup"><span data-stu-id="b6072-220">For more information, see [Custom Partitioners for PLINQ and TPL](custom-partitioners-for-plinq-and-tpl.md).</span></span>

## <a name="measuring-plinq-performance"></a><span data-ttu-id="b6072-221">衡量 PLINQ 性能</span><span class="sxs-lookup"><span data-stu-id="b6072-221">Measuring PLINQ Performance</span></span>

<span data-ttu-id="b6072-222">在很多情况下，可以并行化查询，但是设置并行查询的开销可能会超出获得的性能收益。</span><span class="sxs-lookup"><span data-stu-id="b6072-222">In many cases, a query can be parallelized, but the overhead of setting up the parallel query outweighs the performance benefit gained.</span></span> <span data-ttu-id="b6072-223">如果查询不执行大量的计算，或者如果数据源较小，则 PLINQ 查询的速度可能比顺序 LINQ to Objects 查询的速度慢。</span><span class="sxs-lookup"><span data-stu-id="b6072-223">If a query does not perform much computation or if the data source is small, a PLINQ query may be slower than a sequential LINQ to Objects query.</span></span> <span data-ttu-id="b6072-224">可以在 Visual Studio Team Server 中使用并行性能分析器比较各种查询的性能，查找处理瓶颈，以及确定查询是并行运行还是按顺序运行。</span><span class="sxs-lookup"><span data-stu-id="b6072-224">You can use the Parallel Performance Analyzer in Visual Studio Team Server to compare the performance of various queries, to locate processing bottlenecks, and to determine whether your query is running in parallel or sequentially.</span></span> <span data-ttu-id="b6072-225">有关详细信息，请参阅[并发可视化工具 SDK](/visualstudio/profiling/concurrency-visualizer)和[如何：衡量 PLINQ 查询性能](how-to-measure-plinq-query-performance.md)。</span><span class="sxs-lookup"><span data-stu-id="b6072-225">For more information, see [Concurrency Visualizer](/visualstudio/profiling/concurrency-visualizer) and [How to: Measure PLINQ Query Performance](how-to-measure-plinq-query-performance.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="b6072-226">请参阅</span><span class="sxs-lookup"><span data-stu-id="b6072-226">See also</span></span>

- [<span data-ttu-id="b6072-227">并行 LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="b6072-227">Parallel LINQ (PLINQ)</span></span>](introduction-to-plinq.md)
- [<span data-ttu-id="b6072-228">了解 PLINQ 中的加速</span><span class="sxs-lookup"><span data-stu-id="b6072-228">Understanding Speedup in PLINQ</span></span>](understanding-speedup-in-plinq.md)
