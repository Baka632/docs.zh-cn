---
title: 异常处理（任务并行库）
description: 探索 .NET 中使用任务并行库 (TPL) 的异常处理。 了解嵌套聚合异常、内部异常、未观察到的任务异常等。
ms.date: 04/20/2020
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, exceptions
ms.assetid: beb51e50-9061-4d3d-908c-56a4f7c2e8c1
ms.openlocfilehash: fd16fd4263c092f8678589e1a8dd9544955e798a
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/18/2020
ms.locfileid: "94827329"
---
# <a name="exception-handling-task-parallel-library"></a><span data-ttu-id="dceaf-104">异常处理（任务并行库）</span><span class="sxs-lookup"><span data-stu-id="dceaf-104">Exception handling (Task Parallel Library)</span></span>

<span data-ttu-id="dceaf-105">由在任务内部运行的用户代码引发的未处理异常会传播回调用线程，但本主题稍后部分介绍的某些情况除外。</span><span class="sxs-lookup"><span data-stu-id="dceaf-105">Unhandled exceptions that are thrown by user code that is running inside a task are propagated back to the calling thread, except in certain scenarios that are described later in this topic.</span></span> <span data-ttu-id="dceaf-106">如果使用静态或实例 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 方法之一，异常会传播，异常处理方法为将调用封闭到 `try`/`catch` 语句中。</span><span class="sxs-lookup"><span data-stu-id="dceaf-106">Exceptions are propagated when you use one of the static or instance <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> methods, and you handle them by enclosing the call in a `try`/`catch` statement.</span></span> <span data-ttu-id="dceaf-107">如果任务是所附加子任务的父级，或在等待多个任务，那么可能会引发多个异常。</span><span class="sxs-lookup"><span data-stu-id="dceaf-107">If a task is the parent of attached child tasks, or if you are waiting on multiple tasks, multiple exceptions could be thrown.</span></span>

<span data-ttu-id="dceaf-108">为了将所有异常传播回调用线程，任务基础结构会将这些异常包装在 <xref:System.AggregateException> 实例中。</span><span class="sxs-lookup"><span data-stu-id="dceaf-108">To propagate all the exceptions back to the calling thread, the Task infrastructure wraps them in an <xref:System.AggregateException> instance.</span></span> <span data-ttu-id="dceaf-109"><xref:System.AggregateException> 异常具有 <xref:System.AggregateException.InnerExceptions%2A> 属性，可枚举该属性来检查引发的所有原始异常，并单独处理（或不处理）每个异常。</span><span class="sxs-lookup"><span data-stu-id="dceaf-109">The <xref:System.AggregateException> exception has an <xref:System.AggregateException.InnerExceptions%2A> property that can be enumerated to examine all the original exceptions that were thrown, and handle (or not handle) each one individually.</span></span> <span data-ttu-id="dceaf-110">也可以使用 <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> 方法处理原始异常。</span><span class="sxs-lookup"><span data-stu-id="dceaf-110">You can also handle the original exceptions by using the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="dceaf-111">即使只引发了一个异常，仍会将该异常包装在 <xref:System.AggregateException> 中，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="dceaf-111">Even if only one exception is thrown, it is still wrapped in an <xref:System.AggregateException> exception, as the following example shows.</span></span>

[!code-csharp[TPL_Exceptions#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling21.cs#21)]
[!code-vb[TPL_Exceptions#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling21.vb#21)]

<span data-ttu-id="dceaf-112">可以通过只捕获 <xref:System.AggregateException> 而不观察任何内部异常来避免未处理的异常。</span><span class="sxs-lookup"><span data-stu-id="dceaf-112">You could avoid an unhandled exception by just catching the <xref:System.AggregateException> and not observing any of the inner exceptions.</span></span> <span data-ttu-id="dceaf-113">但是，我们建议你不要这样做，因为这样相当于在非并行情况下捕获基 <xref:System.Exception> 类型。</span><span class="sxs-lookup"><span data-stu-id="dceaf-113">However, we recommend that you do not do this because it is analogous to catching the base <xref:System.Exception> type in non-parallel scenarios.</span></span> <span data-ttu-id="dceaf-114">捕获异常而不采取具体措施从中恢复可能会使程序进入不确定状态。</span><span class="sxs-lookup"><span data-stu-id="dceaf-114">To catch an exception without taking specific actions to recover from it can leave your program in an indeterminate state.</span></span>

<span data-ttu-id="dceaf-115">如果不想调用 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 方法来等待任务完成，也可以通过任务的 <xref:System.Threading.Tasks.Task.Exception%2A> 属性检索 <xref:System.AggregateException> 异常，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="dceaf-115">If you do not want to call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for a task's completion, you can also retrieve the <xref:System.AggregateException> exception from the task's <xref:System.Threading.Tasks.Task.Exception%2A> property, as the following example shows.</span></span> <span data-ttu-id="dceaf-116">有关详细信息，请参阅本主题中的[通过使用 Task.Exception 属性观察异常](#observing-exceptions-by-using-the-taskexception-property)部分。</span><span class="sxs-lookup"><span data-stu-id="dceaf-116">For more information, see the [Observing exceptions by using the Task.Exception property](#observing-exceptions-by-using-the-taskexception-property) section in this topic.</span></span>

[!code-csharp[TPL_Exceptions#29](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling22.cs#29)]
[!code-vb[TPL_Exceptions#29](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling22.vb#29)]

<span data-ttu-id="dceaf-117">如果不等待传播异常的任务，或要访问其 <xref:System.Threading.Tasks.Task.Exception%2A> 属性，则会在对该任务进行垃圾回收时根据 .NET 异常策略提升异常。</span><span class="sxs-lookup"><span data-stu-id="dceaf-117">If you do not wait on a task that propagates an exception, or access its <xref:System.Threading.Tasks.Task.Exception%2A> property, the exception is escalated according to the .NET exception policy when the task is garbage-collected.</span></span>

<span data-ttu-id="dceaf-118">如果允许异常向上冒泡回到联接线程，则一个任务也许可以在引发异常后继续处理一些项。</span><span class="sxs-lookup"><span data-stu-id="dceaf-118">When exceptions are allowed to bubble up back to the joining thread, it is possible that a task may continue to process some items after the exception is raised.</span></span>

> [!NOTE]
> <span data-ttu-id="dceaf-119">某些情况下，当启用“仅我的代码”后，Visual Studio 会在引发异常的行中断运行并显示一条错误消息，该消息显示“用户代码未处理异常”。</span><span class="sxs-lookup"><span data-stu-id="dceaf-119">When "Just My Code" is enabled, Visual Studio in some cases will break on the line that throws the exception and display an error message that says "exception not handled by user code."</span></span> <span data-ttu-id="dceaf-120">此错误是良性的。</span><span class="sxs-lookup"><span data-stu-id="dceaf-120">This error is benign.</span></span> <span data-ttu-id="dceaf-121">可以按 F5 继续并查看在这些示例中演示的异常处理行为。</span><span class="sxs-lookup"><span data-stu-id="dceaf-121">You can press F5 to continue and see the exception-handling behavior that is demonstrated in these examples.</span></span> <span data-ttu-id="dceaf-122">若要阻止 Visual Studio 在出现第一个错误时中断运行，只需在“工具”-&gt;“选项”-&gt;“调试”-&gt;“常规”  下取消选中“启用‘仅我的代码’” 复选框即可。</span><span class="sxs-lookup"><span data-stu-id="dceaf-122">To prevent Visual Studio from breaking on the first error, just uncheck the **Enable Just My Code** checkbox under **Tools, Options, Debugging, General**.</span></span>

## <a name="attached-child-tasks-and-nested-aggregateexceptions"></a><span data-ttu-id="dceaf-123">附加子任务和嵌套 AggregateExceptions</span><span class="sxs-lookup"><span data-stu-id="dceaf-123">Attached child tasks and nested AggregateExceptions</span></span>

<span data-ttu-id="dceaf-124">如果某个任务具有引发异常的附加子任务，则会在将该异常传播到父任务之前将其包装在 <xref:System.AggregateException> 中，父任务将该异常包装在自己的 <xref:System.AggregateException> 中，然后再将其传播回调用线程。</span><span class="sxs-lookup"><span data-stu-id="dceaf-124">If a task has an attached child task that throws an exception, that exception is wrapped in an <xref:System.AggregateException> before it is propagated to the parent task, which wraps that exception in its own <xref:System.AggregateException> before it propagates it back to the calling thread.</span></span> <span data-ttu-id="dceaf-125">在这种情况下，在 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>、<xref:System.Threading.Tasks.Task.WaitAny%2A>、或 <xref:System.Threading.Tasks.Task.WaitAll%2A> 方法处捕获的 <xref:System.AggregateException> 异常的 <xref:System.AggregateException.InnerExceptions%2A> 属性包含一个或多个 <xref:System.AggregateException> 实例，而不包含导致错误的原始异常。</span><span class="sxs-lookup"><span data-stu-id="dceaf-125">In such cases, the <xref:System.AggregateException.InnerExceptions%2A> property of the <xref:System.AggregateException> exception that is caught at the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task.WaitAny%2A>, or <xref:System.Threading.Tasks.Task.WaitAll%2A> method contains one or more <xref:System.AggregateException> instances, not the original exceptions that caused the fault.</span></span> <span data-ttu-id="dceaf-126">为了避免必须循环访问嵌套 <xref:System.AggregateException> 异常，可以使用 <xref:System.AggregateException.Flatten%2A> 方法删除所有嵌套 <xref:System.AggregateException> 异常，以便 <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> 属性包含原始异常。</span><span class="sxs-lookup"><span data-stu-id="dceaf-126">To avoid having to iterate over nested <xref:System.AggregateException> exceptions, you can use the <xref:System.AggregateException.Flatten%2A> method to remove all the nested <xref:System.AggregateException> exceptions, so that the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains the original exceptions.</span></span> <span data-ttu-id="dceaf-127">在下面的示例中，嵌套 <xref:System.AggregateException> 实例已经平展，并且仅在一个循环中处理。</span><span class="sxs-lookup"><span data-stu-id="dceaf-127">In the following example, nested <xref:System.AggregateException> instances are flattened and handled in just one loop.</span></span>

[!code-csharp[TPL_Exceptions#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/flatten2.cs#22)]
[!code-vb[TPL_Exceptions#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/flatten2.vb#22)]

<span data-ttu-id="dceaf-128">还可以使用 <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> 方法，通过多个任务在一个 <xref:System.AggregateException> 实例中抛出的多个 <xref:System.AggregateException> 实例重新抛出内部异常，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="dceaf-128">You can also use the <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> method to rethrow the inner exceptions from multiple <xref:System.AggregateException> instances thrown by multiple tasks in a single <xref:System.AggregateException> instance, as the following example shows.</span></span>

[!code-csharp[TPL_Exceptions#13](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions2.cs#13)]
[!code-vb[TPL_Exceptions#13](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions2.vb#13)]

## <a name="exceptions-from-detached-child-tasks"></a><span data-ttu-id="dceaf-129">分离子任务中的异常</span><span class="sxs-lookup"><span data-stu-id="dceaf-129">Exceptions from detached child tasks</span></span>

<span data-ttu-id="dceaf-130">默认情况下，子任务在创建时处于分离状态。</span><span class="sxs-lookup"><span data-stu-id="dceaf-130">By default, child tasks are created as detached.</span></span> <span data-ttu-id="dceaf-131">必须在直接父任务中处理或重新引发从分离任务引发的异常；将不会采用与附加子任务传播回异常相同的方式将这些异常传播回调用线程。</span><span class="sxs-lookup"><span data-stu-id="dceaf-131">Exceptions thrown from detached tasks must be handled or rethrown in the immediate parent task; they are not propagated back to the calling thread in the same way as attached child tasks propagated back.</span></span> <span data-ttu-id="dceaf-132">最顶层的父级可以手动重新引发分离子级中的异常，以使其包装在 <xref:System.AggregateException> 中并传播回调用线程。</span><span class="sxs-lookup"><span data-stu-id="dceaf-132">The topmost parent can manually rethrow an exception from a detached child to cause it to be wrapped in an <xref:System.AggregateException> and propagated back to the calling thread.</span></span>

[!code-csharp[TPL_Exceptions#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/detached21.cs#23)]
[!code-vb[TPL_Exceptions#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/detached21.vb#23)]

<span data-ttu-id="dceaf-133">即使使用延续观察子任务中的异常，该异常仍然必须由父任务观察。</span><span class="sxs-lookup"><span data-stu-id="dceaf-133">Even if you use a continuation to observe an exception in a child task, the exception still must be observed by the parent task.</span></span>

## <a name="exceptions-that-indicate-cooperative-cancellation"></a><span data-ttu-id="dceaf-134">指示协作取消的异常</span><span class="sxs-lookup"><span data-stu-id="dceaf-134">Exceptions that indicate cooperative cancellation</span></span>

<span data-ttu-id="dceaf-135">在任务中的用户代码响应取消请求时，正确的过程是引发传入在其上传达请求的取消标记中的 <xref:System.OperationCanceledException> 。</span><span class="sxs-lookup"><span data-stu-id="dceaf-135">When user code in a task responds to a cancellation request, the correct procedure is to throw an <xref:System.OperationCanceledException> passing in the cancellation token on which the request was communicated.</span></span> <span data-ttu-id="dceaf-136">在尝试传播异常之前，任务实例会将异常中的标记与创建异常时传递给异常的标记进行比较。</span><span class="sxs-lookup"><span data-stu-id="dceaf-136">Before it attempts to propagate the exception, the task instance compares the token in the exception to the one that was passed to it when it was created.</span></span> <span data-ttu-id="dceaf-137">如果标记相同，则任务会传播包装在 <xref:System.Threading.Tasks.TaskCanceledException> 中的 <xref:System.AggregateException>，并且将可以在检查内部异常时看到它。</span><span class="sxs-lookup"><span data-stu-id="dceaf-137">If they are the same, the task propagates a <xref:System.Threading.Tasks.TaskCanceledException> wrapped in the <xref:System.AggregateException>, and it can be seen when the inner exceptions are examined.</span></span> <span data-ttu-id="dceaf-138">但是，如果调用线程未在等待任务，则将不会传播此特定异常。</span><span class="sxs-lookup"><span data-stu-id="dceaf-138">However, if the calling thread is not waiting on the task, this specific exception will not be propagated.</span></span> <span data-ttu-id="dceaf-139">有关详细信息，请参阅[任务取消](task-cancellation.md)。</span><span class="sxs-lookup"><span data-stu-id="dceaf-139">For more information, see [Task Cancellation](task-cancellation.md).</span></span>

[!code-csharp[TPL_Exceptions#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptions.cs#4)]
[!code-vb[TPL_Exceptions#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/tpl_exceptions.vb#4)]

## <a name="using-the-handle-method-to-filter-inner-exceptions"></a><span data-ttu-id="dceaf-140">使用 Handle 方法筛选内部异常</span><span class="sxs-lookup"><span data-stu-id="dceaf-140">Using the handle method to filter inner exceptions</span></span>

<span data-ttu-id="dceaf-141">可以使用 <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> 方法，筛选掉可视为“已处理”的异常，而无需进一步使用任何逻辑。</span><span class="sxs-lookup"><span data-stu-id="dceaf-141">You can use the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to filter out exceptions that you can treat as "handled" without using any further logic.</span></span> <span data-ttu-id="dceaf-142">在提供给 <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> 方法的用户委托中，可以检查异常类型及其 <xref:System.Exception.Message%2A> 属性，或可便于确定异常是否为良性的其他任何信息。</span><span class="sxs-lookup"><span data-stu-id="dceaf-142">In the user delegate that is supplied to the <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> method, you can examine the exception type, its <xref:System.Exception.Message%2A> property, or any other information about it that will let you determine whether it is benign.</span></span> <span data-ttu-id="dceaf-143">在 <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> 方法返回结果后，便会立即在新实例 <xref:System.AggregateException> 中重新抛出委托针对其返回 `false` 的任何异常。</span><span class="sxs-lookup"><span data-stu-id="dceaf-143">Any exceptions for which the delegate returns `false` are rethrown in a new <xref:System.AggregateException> instance immediately after the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method returns.</span></span>

<span data-ttu-id="dceaf-144">下面的示例在功能上相当于本主题中的第一个示例（检查 <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> 集合中的所有异常）。</span><span class="sxs-lookup"><span data-stu-id="dceaf-144">The following example is functionally equivalent to the first example in this topic, which examines each exception in the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> collection.</span></span>  <span data-ttu-id="dceaf-145">相反，此异常处理程序对每个异常调用 <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> 方法对象，并仅重新抛出不是 `CustomException` 实例的异常。</span><span class="sxs-lookup"><span data-stu-id="dceaf-145">Instead, this exception handler calls the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method object for each exception, and only rethrows exceptions that are not `CustomException` instances.</span></span>

[!code-csharp[TPL_Exceptions#26](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handlemethod21.cs#26)]
[!code-vb[TPL_Exceptions#26](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handlemethod21.vb#26)]

<span data-ttu-id="dceaf-146">下面是更完整的示例，在枚举文件时，使用 <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> 方法提供 <xref:System.UnauthorizedAccessException> 异常的特殊处理。</span><span class="sxs-lookup"><span data-stu-id="dceaf-146">The following is a more complete example that uses the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to provide special handling for an <xref:System.UnauthorizedAccessException> exception when enumerating files.</span></span>

[!code-csharp[TPL_Exceptions#12](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions.cs#12)]
[!code-vb[TPL_Exceptions#12](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions.vb#12)]

## <a name="observing-exceptions-by-using-the-taskexception-property"></a><span data-ttu-id="dceaf-147">通过使用 Task.Exception 属性观察异常</span><span class="sxs-lookup"><span data-stu-id="dceaf-147">Observing exceptions by using the Task.Exception property</span></span>

<span data-ttu-id="dceaf-148">如果任务完成时的状态为 <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType>，可以检查它的 <xref:System.Threading.Tasks.Task.Exception%2A> 属性，以发现是哪个异常导致错误发生。</span><span class="sxs-lookup"><span data-stu-id="dceaf-148">If a task completes in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its <xref:System.Threading.Tasks.Task.Exception%2A> property can be examined to discover which specific exception caused the fault.</span></span> <span data-ttu-id="dceaf-149">观察 <xref:System.Threading.Tasks.Task.Exception%2A> 属性的一个好方法是使用仅在前面的任务出错时才运行的延续，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="dceaf-149">A good way to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property is to use a continuation that runs only if the antecedent task faults, as shown in the following example.</span></span>

[!code-csharp[TPL_Exceptions#27](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptionprop21.cs#27)]
[!code-vb[TPL_Exceptions#27](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/exceptionprop21.vb#27)]

<span data-ttu-id="dceaf-150">在有意义的应用程序中，延续委托可能会记录有关异常的详细信息，并可能生成新任务以从异常中恢复。</span><span class="sxs-lookup"><span data-stu-id="dceaf-150">In a meaningful application, the continuation delegate could log detailed information about the exception and possibly spawn new tasks to recover from the exception.</span></span> <span data-ttu-id="dceaf-151">如果任务出错，以下表达式将引发异常：</span><span class="sxs-lookup"><span data-stu-id="dceaf-151">If a task faults, the following expressions throw the exception:</span></span>

- `await task`
- `task.Wait()`
- `task.Result`
- `task.GetAwaiter().GetResult()`

<span data-ttu-id="dceaf-152">使用 [`try-catch`](../../csharp/language-reference/keywords/try-catch.md) 语句来处理和观察引发的异常。</span><span class="sxs-lookup"><span data-stu-id="dceaf-152">Use a [`try-catch`](../../csharp/language-reference/keywords/try-catch.md) statement to handle and observe thrown exceptions.</span></span> <span data-ttu-id="dceaf-153">或者，通过访问 <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> 属性来观察异常。</span><span class="sxs-lookup"><span data-stu-id="dceaf-153">Alternatively, observe the exception by accessing the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> property.</span></span>

## <a name="unobservedtaskexception-event"></a><span data-ttu-id="dceaf-154">UnobservedTaskException 事件</span><span class="sxs-lookup"><span data-stu-id="dceaf-154">UnobservedTaskException event</span></span>

<span data-ttu-id="dceaf-155">在某些情况下（例如承载不受信任的插件时），良性异常可能比较普遍，因此很难以手动方式观察到所有异常。</span><span class="sxs-lookup"><span data-stu-id="dceaf-155">In some scenarios, such as when hosting untrusted plug-ins, benign exceptions might be common, and it might be too difficult to manually observe them all.</span></span> <span data-ttu-id="dceaf-156">在这些情况下，可以处理 <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> 事件。</span><span class="sxs-lookup"><span data-stu-id="dceaf-156">In these cases, you can handle the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="dceaf-157">传递到处理程序的 <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType> 实例可用于阻止未观察到的异常传播回联接线程。</span><span class="sxs-lookup"><span data-stu-id="dceaf-157">The <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType> instance that is passed to your handler can be used to prevent the unobserved exception from being propagated back to the joining thread.</span></span>

## <a name="see-also"></a><span data-ttu-id="dceaf-158">请参阅</span><span class="sxs-lookup"><span data-stu-id="dceaf-158">See also</span></span>

- [<span data-ttu-id="dceaf-159">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="dceaf-159">Task Parallel Library (TPL)</span></span>](task-parallel-library-tpl.md)
