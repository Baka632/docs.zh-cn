---
title: PLINQ 中的顺序保留
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, order preservation
ms.assetid: 10d202bc-19e1-4b5c-bbf1-9a977322a9ca
ms.openlocfilehash: 997bb80b6e30d4769613c4a1df647e6cd475a8ed
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/24/2020
ms.locfileid: "95730599"
---
# <a name="order-preservation-in-plinq"></a><span data-ttu-id="64b5d-102">PLINQ 中的顺序保留</span><span class="sxs-lookup"><span data-stu-id="64b5d-102">Order Preservation in PLINQ</span></span>

<span data-ttu-id="64b5d-103">在 PLINQ 中，目标是在保持正确性的同时，最大限度地提升性能。</span><span class="sxs-lookup"><span data-stu-id="64b5d-103">In PLINQ, the goal is to maximize performance while maintaining correctness.</span></span> <span data-ttu-id="64b5d-104">虽然查询应尽可能快地运行，但仍应生成正确结果。</span><span class="sxs-lookup"><span data-stu-id="64b5d-104">A query should run as fast as possible but still produce the correct results.</span></span> <span data-ttu-id="64b5d-105">在某些情况下，为了满足正确性要求，必须暂留源序列的顺序；不过，顺序暂留的计算成本可能非常高。</span><span class="sxs-lookup"><span data-stu-id="64b5d-105">In some cases, correctness requires the order of the source sequence to be preserved; however, ordering can be computationally expensive.</span></span> <span data-ttu-id="64b5d-106">因此，默认情况下，PLINQ 不暂留源序列的顺序。</span><span class="sxs-lookup"><span data-stu-id="64b5d-106">Therefore, by default, PLINQ does not preserve the order of the source sequence.</span></span> <span data-ttu-id="64b5d-107">在这方面，PLINQ 类似于 [!INCLUDE[vbtecdlinq](../../../includes/vbtecdlinq-md.md)]，但与确实暂留顺序的 LINQ to Objects 不同。</span><span class="sxs-lookup"><span data-stu-id="64b5d-107">In this regard, PLINQ resembles [!INCLUDE[vbtecdlinq](../../../includes/vbtecdlinq-md.md)], but is unlike LINQ to Objects, which does preserve ordering.</span></span>  
  
 <span data-ttu-id="64b5d-108">若要替代默认行为，可以对源序列使用 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 运算符，启用顺序暂留。</span><span class="sxs-lookup"><span data-stu-id="64b5d-108">To override the default behavior, you can turn on order-preservation by using the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator on the source sequence.</span></span> <span data-ttu-id="64b5d-109">稍后，可以使用 <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> 方法，在查询中禁用顺序暂留。</span><span class="sxs-lookup"><span data-stu-id="64b5d-109">You can then turn off order preservation later in the query by using the <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> method.</span></span> <span data-ttu-id="64b5d-110">使用这两种方法时，查询的处理依据为，确定是并行执行还是顺序执行查询的启发。</span><span class="sxs-lookup"><span data-stu-id="64b5d-110">With both methods, the query is processed based on the heuristics that determine whether to execute the query as parallel or as sequential.</span></span> <span data-ttu-id="64b5d-111">有关详细信息，请参阅[了解 PLINQ 中的加速](understanding-speedup-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="64b5d-111">For more information, see [Understanding Speedup in PLINQ](understanding-speedup-in-plinq.md).</span></span>  
  
 <span data-ttu-id="64b5d-112">下面的示例展示了无序并行查询，以筛选符合条件的所有元素，而完全不尝试对结果进行排序。</span><span class="sxs-lookup"><span data-stu-id="64b5d-112">The following example shows an unordered parallel query that filters for all the elements that match a condition, without trying to order the results in any way.</span></span>  
  
 [!code-csharp[PLINQ#8](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#8)]
 [!code-vb[PLINQ#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#8)]  
  
 <span data-ttu-id="64b5d-113">此查询不一定会生成源序列中符合条件的前 1000 个城市，而会生成符合条件的 1000 个城市中的一部分。</span><span class="sxs-lookup"><span data-stu-id="64b5d-113">This query does not necessarily produce the first 1000 cities in the source sequence that meet the condition, but rather some set of 1000 cities that meet the condition.</span></span> <span data-ttu-id="64b5d-114">PLINQ 查询运算符将源序列划分为多个子序列，并将它们作为并发任务进行处理。</span><span class="sxs-lookup"><span data-stu-id="64b5d-114">PLINQ query operators partition the source sequence into multiple subsequences that are processed as concurrent tasks.</span></span> <span data-ttu-id="64b5d-115">如果未指定顺序暂留，每个分区生成的结果以任意顺序传递到查询的下一个阶段。</span><span class="sxs-lookup"><span data-stu-id="64b5d-115">If order preservation is not specified, the results from each partition are handed off to the next stage of the query in an arbitrary order.</span></span> <span data-ttu-id="64b5d-116">此外，在继续处理其余元素前，分区可能还会生成一部分结果。</span><span class="sxs-lookup"><span data-stu-id="64b5d-116">Also, a partition may yield a subset of its results before it continues to process the remaining elements.</span></span> <span data-ttu-id="64b5d-117">因此，顺序可能每次都不同。</span><span class="sxs-lookup"><span data-stu-id="64b5d-117">The resulting order may be different every time.</span></span> <span data-ttu-id="64b5d-118">应用无法对此进行控制，因为它取决于操作系统如何将线程排入计划。</span><span class="sxs-lookup"><span data-stu-id="64b5d-118">Your application cannot control this because it depends on how the operating system schedules the threads.</span></span>  
  
 <span data-ttu-id="64b5d-119">下面的示例对源序列使用 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 运算符，以替代默认行为。</span><span class="sxs-lookup"><span data-stu-id="64b5d-119">The following example overrides the default behavior by using the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator on the source sequence.</span></span> <span data-ttu-id="64b5d-120">这样可确保 <xref:System.Linq.ParallelEnumerable.Take%2A> 方法返回源序列中符合条件的前 1000 个城市。</span><span class="sxs-lookup"><span data-stu-id="64b5d-120">This ensures that the <xref:System.Linq.ParallelEnumerable.Take%2A> method returns the first 1000 cities in the source sequence that meet the condition.</span></span>  
  
 [!code-csharp[PLINQ#9](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#9)]
 [!code-vb[PLINQ#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#9)]  
  
 <span data-ttu-id="64b5d-121">不过，此查询可能不会像无序版本那样快速运行，因为它必须跟踪整个分区中的原始顺序，并且在合并时确保顺序是一致的。</span><span class="sxs-lookup"><span data-stu-id="64b5d-121">However, this query probably does not run as fast as the unordered version because it must keep track of the original ordering throughout the partitions and at merge time ensure that the ordering is consistent.</span></span> <span data-ttu-id="64b5d-122">因此，建议仅在需要时，才将 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A>用于需要它的查询部分。</span><span class="sxs-lookup"><span data-stu-id="64b5d-122">Therefore, we recommend that you use <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> only when it is required, and only for those parts of the query that require it.</span></span> <span data-ttu-id="64b5d-123">如果不再需要顺序暂留，请使用 <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> 禁用它。</span><span class="sxs-lookup"><span data-stu-id="64b5d-123">When order preservation is no longer required, use <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> to turn it off.</span></span> <span data-ttu-id="64b5d-124">为此，下面的示例撰写了两个查询。</span><span class="sxs-lookup"><span data-stu-id="64b5d-124">The following example achieves this by composing two queries.</span></span>  
  
 [!code-csharp[PLINQ#6](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#6)]
 [!code-vb[PLINQ#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#6)]  
  
 <span data-ttu-id="64b5d-125">请注意，PLINQ 暂留查询其余部分的顺序强制施加运算符生成的序列顺序。</span><span class="sxs-lookup"><span data-stu-id="64b5d-125">Note that PLINQ preserves the ordering of a sequence produced by order-imposing operators for the rest of the query.</span></span> <span data-ttu-id="64b5d-126">也就是说，<xref:System.Linq.ParallelEnumerable.OrderBy%2A> 和 <xref:System.Linq.ParallelEnumerable.ThenBy%2A> 等运算符被视为后跟 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 调用。</span><span class="sxs-lookup"><span data-stu-id="64b5d-126">In other words, operators such as <xref:System.Linq.ParallelEnumerable.OrderBy%2A> and <xref:System.Linq.ParallelEnumerable.ThenBy%2A> are treated as if they were followed by a call to <xref:System.Linq.ParallelEnumerable.AsOrdered%2A>.</span></span>  
  
## <a name="query-operators-and-ordering"></a><span data-ttu-id="64b5d-127">查询运算符和顺序</span><span class="sxs-lookup"><span data-stu-id="64b5d-127">Query Operators and Ordering</span></span>  

 <span data-ttu-id="64b5d-128">下面的查询运算符将顺序暂留引入查询中的所有后续操作，或一直运行到 <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> 获得调用：</span><span class="sxs-lookup"><span data-stu-id="64b5d-128">The following query operators introduce order preservation into all subsequent operations in a query, or until <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> is called:</span></span>  
  
- <xref:System.Linq.ParallelEnumerable.OrderBy%2A>  
  
- <xref:System.Linq.ParallelEnumerable.OrderByDescending%2A>  
  
- <xref:System.Linq.ParallelEnumerable.ThenBy%2A>  
  
- <xref:System.Linq.ParallelEnumerable.ThenByDescending%2A>  
  
 <span data-ttu-id="64b5d-129">在某些情况下，下面的 PLINQ 查询运算符可能需要有序的源序列，才能生成正确结果：</span><span class="sxs-lookup"><span data-stu-id="64b5d-129">The following PLINQ query operators may in some cases require ordered source sequences to produce correct results:</span></span>  
  
- <xref:System.Linq.ParallelEnumerable.Reverse%2A>  
  
- <xref:System.Linq.ParallelEnumerable.SequenceEqual%2A>  
  
- <xref:System.Linq.ParallelEnumerable.TakeWhile%2A>  
  
- <xref:System.Linq.ParallelEnumerable.SkipWhile%2A>  
  
- <xref:System.Linq.ParallelEnumerable.Zip%2A>  
  
 <span data-ttu-id="64b5d-130">一些 PLINQ 查询运算符的行为因源序列是有序还是无序而异。</span><span class="sxs-lookup"><span data-stu-id="64b5d-130">Some PLINQ query operators behave differently, depending on whether their source sequence is ordered or unordered.</span></span> <span data-ttu-id="64b5d-131">下表列出了这些运算符。</span><span class="sxs-lookup"><span data-stu-id="64b5d-131">The following table lists these operators.</span></span>  
  
|<span data-ttu-id="64b5d-132">运算符</span><span class="sxs-lookup"><span data-stu-id="64b5d-132">Operator</span></span>|<span data-ttu-id="64b5d-133">源序列为有序时的结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-133">Result when the source sequence is ordered</span></span>|<span data-ttu-id="64b5d-134">源序列为无序时的结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-134">Result when the source sequence is unordered</span></span>|  
|--------------|------------------------------------------------|--------------------------------------------------|  
|<xref:System.Linq.ParallelEnumerable.Aggregate%2A>|<span data-ttu-id="64b5d-135">非关联或非交换操作的非确定性输出</span><span class="sxs-lookup"><span data-stu-id="64b5d-135">Nondeterministic output for nonassociative or noncommutative operations</span></span>|<span data-ttu-id="64b5d-136">非关联或非交换操作的非确定性输出</span><span class="sxs-lookup"><span data-stu-id="64b5d-136">Nondeterministic output for nonassociative or noncommutative operations</span></span>|  
|<xref:System.Linq.ParallelEnumerable.All%2A>|<span data-ttu-id="64b5d-137">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-137">Not applicable</span></span>|<span data-ttu-id="64b5d-138">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-138">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Any%2A>|<span data-ttu-id="64b5d-139">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-139">Not applicable</span></span>|<span data-ttu-id="64b5d-140">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-140">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.AsEnumerable%2A>|<span data-ttu-id="64b5d-141">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-141">Not applicable</span></span>|<span data-ttu-id="64b5d-142">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-142">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Average%2A>|<span data-ttu-id="64b5d-143">非关联或非交换操作的非确定性输出</span><span class="sxs-lookup"><span data-stu-id="64b5d-143">Nondeterministic output for nonassociative or noncommutative operations</span></span>|<span data-ttu-id="64b5d-144">非关联或非交换操作的非确定性输出</span><span class="sxs-lookup"><span data-stu-id="64b5d-144">Nondeterministic output for nonassociative or noncommutative operations</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Cast%2A>|<span data-ttu-id="64b5d-145">有序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-145">Ordered results</span></span>|<span data-ttu-id="64b5d-146">无序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-146">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Concat%2A>|<span data-ttu-id="64b5d-147">有序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-147">Ordered results</span></span>|<span data-ttu-id="64b5d-148">无序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-148">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Count%2A>|<span data-ttu-id="64b5d-149">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-149">Not applicable</span></span>|<span data-ttu-id="64b5d-150">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-150">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.DefaultIfEmpty%2A>|<span data-ttu-id="64b5d-151">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-151">Not applicable</span></span>|<span data-ttu-id="64b5d-152">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-152">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Distinct%2A>|<span data-ttu-id="64b5d-153">有序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-153">Ordered results</span></span>|<span data-ttu-id="64b5d-154">无序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-154">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ElementAt%2A>|<span data-ttu-id="64b5d-155">返回指定元素</span><span class="sxs-lookup"><span data-stu-id="64b5d-155">Return specified element</span></span>|<span data-ttu-id="64b5d-156">任意元素</span><span class="sxs-lookup"><span data-stu-id="64b5d-156">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ElementAtOrDefault%2A>|<span data-ttu-id="64b5d-157">返回指定元素</span><span class="sxs-lookup"><span data-stu-id="64b5d-157">Return specified element</span></span>|<span data-ttu-id="64b5d-158">任意元素</span><span class="sxs-lookup"><span data-stu-id="64b5d-158">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Except%2A>|<span data-ttu-id="64b5d-159">无序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-159">Unordered results</span></span>|<span data-ttu-id="64b5d-160">无序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-160">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.First%2A>|<span data-ttu-id="64b5d-161">返回指定元素</span><span class="sxs-lookup"><span data-stu-id="64b5d-161">Return specified element</span></span>|<span data-ttu-id="64b5d-162">任意元素</span><span class="sxs-lookup"><span data-stu-id="64b5d-162">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.FirstOrDefault%2A>|<span data-ttu-id="64b5d-163">返回指定元素</span><span class="sxs-lookup"><span data-stu-id="64b5d-163">Return specified element</span></span>|<span data-ttu-id="64b5d-164">任意元素</span><span class="sxs-lookup"><span data-stu-id="64b5d-164">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ForAll%2A>|<span data-ttu-id="64b5d-165">非确定性并行执行</span><span class="sxs-lookup"><span data-stu-id="64b5d-165">Executes nondeterministically in parallel</span></span>|<span data-ttu-id="64b5d-166">非确定性并行执行</span><span class="sxs-lookup"><span data-stu-id="64b5d-166">Executes nondeterministically in parallel</span></span>|  
|<xref:System.Linq.ParallelEnumerable.GroupBy%2A>|<span data-ttu-id="64b5d-167">有序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-167">Ordered results</span></span>|<span data-ttu-id="64b5d-168">无序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-168">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.GroupJoin%2A>|<span data-ttu-id="64b5d-169">有序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-169">Ordered results</span></span>|<span data-ttu-id="64b5d-170">无序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-170">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Intersect%2A>|<span data-ttu-id="64b5d-171">有序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-171">Ordered results</span></span>|<span data-ttu-id="64b5d-172">无序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-172">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Join%2A>|<span data-ttu-id="64b5d-173">有序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-173">Ordered results</span></span>|<span data-ttu-id="64b5d-174">无序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-174">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Last%2A>|<span data-ttu-id="64b5d-175">返回指定元素</span><span class="sxs-lookup"><span data-stu-id="64b5d-175">Return specified element</span></span>|<span data-ttu-id="64b5d-176">任意元素</span><span class="sxs-lookup"><span data-stu-id="64b5d-176">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.LastOrDefault%2A>|<span data-ttu-id="64b5d-177">返回指定元素</span><span class="sxs-lookup"><span data-stu-id="64b5d-177">Return specified element</span></span>|<span data-ttu-id="64b5d-178">任意元素</span><span class="sxs-lookup"><span data-stu-id="64b5d-178">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.LongCount%2A>|<span data-ttu-id="64b5d-179">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-179">Not applicable</span></span>|<span data-ttu-id="64b5d-180">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-180">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Min%2A>|<span data-ttu-id="64b5d-181">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-181">Not applicable</span></span>|<span data-ttu-id="64b5d-182">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-182">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.OrderBy%2A>|<span data-ttu-id="64b5d-183">对序列重新排序</span><span class="sxs-lookup"><span data-stu-id="64b5d-183">Reorders the sequence</span></span>|<span data-ttu-id="64b5d-184">开始新的有序部分</span><span class="sxs-lookup"><span data-stu-id="64b5d-184">Starts new ordered section</span></span>|  
|<xref:System.Linq.ParallelEnumerable.OrderByDescending%2A>|<span data-ttu-id="64b5d-185">对序列重新排序</span><span class="sxs-lookup"><span data-stu-id="64b5d-185">Reorders the sequence</span></span>|<span data-ttu-id="64b5d-186">开始新的有序部分</span><span class="sxs-lookup"><span data-stu-id="64b5d-186">Starts new ordered section</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Range%2A>|<span data-ttu-id="64b5d-187">暂无（默认值与 <xref:System.Linq.ParallelEnumerable.AsParallel%2A> 相同）</span><span class="sxs-lookup"><span data-stu-id="64b5d-187">Not applicable (same default as <xref:System.Linq.ParallelEnumerable.AsParallel%2A> )</span></span>|<span data-ttu-id="64b5d-188">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-188">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Repeat%2A>|<span data-ttu-id="64b5d-189">暂无（默认值与 <xref:System.Linq.ParallelEnumerable.AsParallel%2A> 相同）</span><span class="sxs-lookup"><span data-stu-id="64b5d-189">Not applicable (same default as <xref:System.Linq.ParallelEnumerable.AsParallel%2A>)</span></span>|<span data-ttu-id="64b5d-190">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-190">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Reverse%2A>|<span data-ttu-id="64b5d-191">反转</span><span class="sxs-lookup"><span data-stu-id="64b5d-191">Reverses</span></span>|<span data-ttu-id="64b5d-192">不执行任何操作</span><span class="sxs-lookup"><span data-stu-id="64b5d-192">Does nothing</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Select%2A>|<span data-ttu-id="64b5d-193">有序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-193">Ordered results</span></span>|<span data-ttu-id="64b5d-194">无序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-194">Unordered results</span></span>|  
|<span data-ttu-id="64b5d-195"><xref:System.Linq.ParallelEnumerable.Select%2A>（已编入索引）</span><span class="sxs-lookup"><span data-stu-id="64b5d-195"><xref:System.Linq.ParallelEnumerable.Select%2A> (indexed)</span></span>|<span data-ttu-id="64b5d-196">有序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-196">Ordered results</span></span>|<span data-ttu-id="64b5d-197">无序结果。</span><span class="sxs-lookup"><span data-stu-id="64b5d-197">Unordered results.</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SelectMany%2A>|<span data-ttu-id="64b5d-198">有序结果。</span><span class="sxs-lookup"><span data-stu-id="64b5d-198">Ordered results.</span></span>|<span data-ttu-id="64b5d-199">无序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-199">Unordered results</span></span>|  
|<span data-ttu-id="64b5d-200"><xref:System.Linq.ParallelEnumerable.SelectMany%2A>（已编入索引）</span><span class="sxs-lookup"><span data-stu-id="64b5d-200"><xref:System.Linq.ParallelEnumerable.SelectMany%2A> (indexed)</span></span>|<span data-ttu-id="64b5d-201">有序结果。</span><span class="sxs-lookup"><span data-stu-id="64b5d-201">Ordered results.</span></span>|<span data-ttu-id="64b5d-202">无序结果。</span><span class="sxs-lookup"><span data-stu-id="64b5d-202">Unordered results.</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SequenceEqual%2A>|<span data-ttu-id="64b5d-203">有序比较</span><span class="sxs-lookup"><span data-stu-id="64b5d-203">Ordered comparison</span></span>|<span data-ttu-id="64b5d-204">无序比较</span><span class="sxs-lookup"><span data-stu-id="64b5d-204">Unordered comparison</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Single%2A>|<span data-ttu-id="64b5d-205">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-205">Not applicable</span></span>|<span data-ttu-id="64b5d-206">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-206">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SingleOrDefault%2A>|<span data-ttu-id="64b5d-207">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-207">Not applicable</span></span>|<span data-ttu-id="64b5d-208">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-208">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Skip%2A>|<span data-ttu-id="64b5d-209">跳过第一个 n 元素 </span><span class="sxs-lookup"><span data-stu-id="64b5d-209">Skips first *n* elements</span></span>|<span data-ttu-id="64b5d-210">跳过所有 n 元素 </span><span class="sxs-lookup"><span data-stu-id="64b5d-210">Skips any *n* elements</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SkipWhile%2A>|<span data-ttu-id="64b5d-211">有序结果。</span><span class="sxs-lookup"><span data-stu-id="64b5d-211">Ordered results.</span></span>|<span data-ttu-id="64b5d-212">非确定性。</span><span class="sxs-lookup"><span data-stu-id="64b5d-212">Nondeterministic.</span></span> <span data-ttu-id="64b5d-213">以当前任意顺序执行 SkipWhile</span><span class="sxs-lookup"><span data-stu-id="64b5d-213">Performs SkipWhile on the current arbitrary order</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Sum%2A>|<span data-ttu-id="64b5d-214">非关联或非交换操作的非确定性输出</span><span class="sxs-lookup"><span data-stu-id="64b5d-214">Nondeterministic output for nonassociative or noncommutative operations</span></span>|<span data-ttu-id="64b5d-215">非关联或非交换操作的非确定性输出</span><span class="sxs-lookup"><span data-stu-id="64b5d-215">Nondeterministic output for nonassociative or noncommutative operations</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Take%2A>|<span data-ttu-id="64b5d-216">获取前 `n` 个元素</span><span class="sxs-lookup"><span data-stu-id="64b5d-216">Takes first `n` elements</span></span>|<span data-ttu-id="64b5d-217">获取任意 `n` 个元素</span><span class="sxs-lookup"><span data-stu-id="64b5d-217">Takes any `n` elements</span></span>|  
|<xref:System.Linq.ParallelEnumerable.TakeWhile%2A>|<span data-ttu-id="64b5d-218">有序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-218">Ordered results</span></span>|<span data-ttu-id="64b5d-219">非确定性。</span><span class="sxs-lookup"><span data-stu-id="64b5d-219">Nondeterministic.</span></span> <span data-ttu-id="64b5d-220">以当前任意顺序执行 TakeWhile</span><span class="sxs-lookup"><span data-stu-id="64b5d-220">Performs TakeWhile on the current arbitrary order</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ThenBy%2A>|<span data-ttu-id="64b5d-221">补充 `OrderBy`</span><span class="sxs-lookup"><span data-stu-id="64b5d-221">Supplements `OrderBy`</span></span>|<span data-ttu-id="64b5d-222">补充 `OrderBy`</span><span class="sxs-lookup"><span data-stu-id="64b5d-222">Supplements `OrderBy`</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ThenByDescending%2A>|<span data-ttu-id="64b5d-223">补充 `OrderBy`</span><span class="sxs-lookup"><span data-stu-id="64b5d-223">Supplements `OrderBy`</span></span>|<span data-ttu-id="64b5d-224">补充 `OrderBy`</span><span class="sxs-lookup"><span data-stu-id="64b5d-224">Supplements `OrderBy`</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToArray%2A>|<span data-ttu-id="64b5d-225">有序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-225">Ordered results</span></span>|<span data-ttu-id="64b5d-226">无序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-226">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToDictionary%2A>|<span data-ttu-id="64b5d-227">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-227">Not applicable</span></span>|<span data-ttu-id="64b5d-228">不适用</span><span class="sxs-lookup"><span data-stu-id="64b5d-228">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToList%2A>|<span data-ttu-id="64b5d-229">有序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-229">Ordered results</span></span>|<span data-ttu-id="64b5d-230">无序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-230">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToLookup%2A>|<span data-ttu-id="64b5d-231">有序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-231">Ordered results</span></span>|<span data-ttu-id="64b5d-232">无序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-232">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Union%2A>|<span data-ttu-id="64b5d-233">有序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-233">Ordered results</span></span>|<span data-ttu-id="64b5d-234">无序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-234">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Where%2A>|<span data-ttu-id="64b5d-235">有序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-235">Ordered results</span></span>|<span data-ttu-id="64b5d-236">无序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-236">Unordered results</span></span>|  
|<span data-ttu-id="64b5d-237"><xref:System.Linq.ParallelEnumerable.Where%2A>（已编入索引）</span><span class="sxs-lookup"><span data-stu-id="64b5d-237"><xref:System.Linq.ParallelEnumerable.Where%2A> (indexed)</span></span>|<span data-ttu-id="64b5d-238">有序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-238">Ordered results</span></span>|<span data-ttu-id="64b5d-239">无序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-239">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Zip%2A>|<span data-ttu-id="64b5d-240">有序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-240">Ordered results</span></span>|<span data-ttu-id="64b5d-241">无序结果</span><span class="sxs-lookup"><span data-stu-id="64b5d-241">Unordered results</span></span>|  
  
 <span data-ttu-id="64b5d-242">无序结果并不是主动随机无序；就是没有应用任何特殊顺序逻辑。</span><span class="sxs-lookup"><span data-stu-id="64b5d-242">Unordered results are not actively shuffled; they simply do not have any special ordering logic applied to them.</span></span> <span data-ttu-id="64b5d-243">在某些情况下，无序查询可能会暂留源序列的顺序。</span><span class="sxs-lookup"><span data-stu-id="64b5d-243">In some cases, an unordered query may retain the ordering of the source sequence.</span></span> <span data-ttu-id="64b5d-244">对于使用已编入索引的 Select 运算符的查询，PLINQ 保证输出元素按索引升序排列，但不保证向元素分配哪些索引。</span><span class="sxs-lookup"><span data-stu-id="64b5d-244">For queries that use the indexed Select operator, PLINQ guarantees that the output elements will come out in the order of increasing indices, but makes no guarantees about which indices will be assigned to which elements.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="64b5d-245">另请参阅</span><span class="sxs-lookup"><span data-stu-id="64b5d-245">See also</span></span>

- [<span data-ttu-id="64b5d-246">并行 LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="64b5d-246">Parallel LINQ (PLINQ)</span></span>](introduction-to-plinq.md)
- [<span data-ttu-id="64b5d-247">并行编程</span><span class="sxs-lookup"><span data-stu-id="64b5d-247">Parallel Programming</span></span>](index.md)
