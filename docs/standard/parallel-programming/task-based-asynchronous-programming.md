---
title: 基于任务的异步编程 - .NET
description: 本文介绍如何通过 .NET 中的任务并行库 (TPL) 使用基于任务的异步编程。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- parallelism, task
ms.assetid: 458b5e69-5210-45e5-bc44-3888f86abd6f
ms.openlocfilehash: a1abe474628cd88e0c24f4152d83bd8ed7ad7950
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/18/2020
ms.locfileid: "94830020"
---
# <a name="task-based-asynchronous-programming"></a><span data-ttu-id="b4392-103">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="b4392-103">Task-based asynchronous programming</span></span>

<span data-ttu-id="b4392-104">任务并行库 (TPL) 以“任务”的概念为基础，后者表示异步操作。</span><span class="sxs-lookup"><span data-stu-id="b4392-104">The Task Parallel Library (TPL) is based on the concept of a *task*, which represents an asynchronous operation.</span></span> <span data-ttu-id="b4392-105">在某些方面，任务类似于线程或 <xref:System.Threading.ThreadPool> 工作项，但是抽象级别更高。</span><span class="sxs-lookup"><span data-stu-id="b4392-105">In some ways, a task resembles a thread or <xref:System.Threading.ThreadPool> work item, but at a higher level of abstraction.</span></span> <span data-ttu-id="b4392-106">术语“任务并行”是指一个或多个独立的任务同时运行。</span><span class="sxs-lookup"><span data-stu-id="b4392-106">The term *task parallelism* refers to one or more independent tasks running concurrently.</span></span> <span data-ttu-id="b4392-107">任务提供两个主要好处：</span><span class="sxs-lookup"><span data-stu-id="b4392-107">Tasks provide two primary benefits:</span></span>

- <span data-ttu-id="b4392-108">系统资源的使用效率更高，可伸缩性更好。</span><span class="sxs-lookup"><span data-stu-id="b4392-108">More efficient and more scalable use of system resources.</span></span>

     <span data-ttu-id="b4392-109">在后台，任务排队到已使用算法增强的 <xref:System.Threading.ThreadPool>，这些算法能够确定线程数并随之调整，提供负载平衡以实现吞吐量最大化。</span><span class="sxs-lookup"><span data-stu-id="b4392-109">Behind the scenes, tasks are queued to the <xref:System.Threading.ThreadPool>, which has been enhanced with algorithms  that determine and adjust to the number of threads and that provide load balancing to maximize throughput.</span></span> <span data-ttu-id="b4392-110">这会使任务相对轻量，你可以创建很多任务以启用细化并行。</span><span class="sxs-lookup"><span data-stu-id="b4392-110">This makes tasks relatively lightweight, and you can create many of them to enable fine-grained parallelism.</span></span>

- <span data-ttu-id="b4392-111">对于线程或工作项，可以使用更多的编程控件。</span><span class="sxs-lookup"><span data-stu-id="b4392-111">More programmatic control than is possible with a thread or work item.</span></span>

     <span data-ttu-id="b4392-112">任务和围绕它们生成的框架提供了一组丰富的 API，这些 API 支持等待、取消、继续、可靠的异常处理、详细状态、自定义计划等功能。</span><span class="sxs-lookup"><span data-stu-id="b4392-112">Tasks and the framework built around them provide a rich set of APIs that support waiting, cancellation, continuations, robust exception handling, detailed status, custom scheduling, and more.</span></span>

<span data-ttu-id="b4392-113">出于这两个原因，在 .NET 中，TPL 是用于编写多线程、异步和并行代码的首选 API。</span><span class="sxs-lookup"><span data-stu-id="b4392-113">For both of these reasons, TPL is the preferred API for writing multi-threaded, asynchronous, and parallel code in .NET.</span></span>

## <a name="creating-and-running-tasks-implicitly"></a><span data-ttu-id="b4392-114">隐式创建和运行任务</span><span class="sxs-lookup"><span data-stu-id="b4392-114">Creating and running tasks implicitly</span></span>

<span data-ttu-id="b4392-115"><xref:System.Threading.Tasks.Parallel.Invoke%2A?displayProperty=nameWithType> 方法提供了一种简便方式，可同时运行任意数量的任意语句。</span><span class="sxs-lookup"><span data-stu-id="b4392-115">The <xref:System.Threading.Tasks.Parallel.Invoke%2A?displayProperty=nameWithType> method provides a convenient way to run any number of arbitrary statements concurrently.</span></span> <span data-ttu-id="b4392-116">只需为每个工作项传入 <xref:System.Action> 委托即可。</span><span class="sxs-lookup"><span data-stu-id="b4392-116">Just pass in an <xref:System.Action> delegate for each item of work.</span></span> <span data-ttu-id="b4392-117">创建这些委托的最简单方式是使用 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="b4392-117">The easiest way to create these delegates is to use lambda expressions.</span></span> <span data-ttu-id="b4392-118">lambda 表达式可调用指定的方法，或提供内联代码。</span><span class="sxs-lookup"><span data-stu-id="b4392-118">The lambda expression can either call a named method or provide the code inline.</span></span> <span data-ttu-id="b4392-119">下面的示例演示一个基本的 <xref:System.Threading.Tasks.Parallel.Invoke%2A> 调用，该调用创建并启动同时运行的两个任务。</span><span class="sxs-lookup"><span data-stu-id="b4392-119">The following example shows a basic <xref:System.Threading.Tasks.Parallel.Invoke%2A> call that creates and starts two tasks that run concurrently.</span></span> <span data-ttu-id="b4392-120">第一个任务由调用名为 `DoSomeWork` 的方法的 lambda 表达式表示，第二个任务由调用名为 `DoSomeOtherWork` 的方法的 lambda 表达式表示。</span><span class="sxs-lookup"><span data-stu-id="b4392-120">The first task is represented by a lambda expression that calls a method named `DoSomeWork`, and the second task is represented by a lambda expression that calls a method named `DoSomeOtherWork`.</span></span>

> [!NOTE]
> <span data-ttu-id="b4392-121">本文档使用 lambda 表达式在 TPL 中定义委托。</span><span class="sxs-lookup"><span data-stu-id="b4392-121">This documentation uses lambda expressions to define delegates in TPL.</span></span> <span data-ttu-id="b4392-122">如果不熟悉 C# 或 Visual Basic 中的 lambda 表达式，请参阅 [PLINQ 和 TPL 中的 Lambda 表达式](lambda-expressions-in-plinq-and-tpl.md)。</span><span class="sxs-lookup"><span data-stu-id="b4392-122">If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](lambda-expressions-in-plinq-and-tpl.md).</span></span>

[!code-csharp[TPL#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl/cs/tpl.cs#21)]
[!code-vb[TPL#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl/vb/tpl_vb.vb#21)]

> [!NOTE]
> <span data-ttu-id="b4392-123"><xref:System.Threading.Tasks.Task> 在后台创建的 <xref:System.Threading.Tasks.Parallel.Invoke%2A> 实例数不一定与所提供的委托数相等。</span><span class="sxs-lookup"><span data-stu-id="b4392-123">The number of <xref:System.Threading.Tasks.Task> instances that are created behind the scenes by <xref:System.Threading.Tasks.Parallel.Invoke%2A> is not necessarily equal to the number of delegates that are provided.</span></span> <span data-ttu-id="b4392-124">TPL 可能会使用各种优化，特别是对于大量的委托。</span><span class="sxs-lookup"><span data-stu-id="b4392-124">The TPL may employ various optimizations, especially with large numbers of delegates.</span></span>

<span data-ttu-id="b4392-125">有关详细信息，请参阅[如何：使用 Parallel.Invoke 来执行并行操作](how-to-use-parallel-invoke-to-execute-parallel-operations.md)。</span><span class="sxs-lookup"><span data-stu-id="b4392-125">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>

<span data-ttu-id="b4392-126">为了更好地控制任务执行或从任务返回值，必须更加显式地使用 <xref:System.Threading.Tasks.Task> 对象。</span><span class="sxs-lookup"><span data-stu-id="b4392-126">For greater control over task execution or to return a value from the task, you have to work with <xref:System.Threading.Tasks.Task> objects more explicitly.</span></span>

## <a name="creating-and-running-tasks-explicitly"></a><span data-ttu-id="b4392-127">显式创建和运行任务</span><span class="sxs-lookup"><span data-stu-id="b4392-127">Creating and running tasks explicitly</span></span>

<span data-ttu-id="b4392-128">不返回值的任务由 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 类表示。</span><span class="sxs-lookup"><span data-stu-id="b4392-128">A task that does not return a value is represented by the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="b4392-129">返回值的任务由 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 类表示，该类从 <xref:System.Threading.Tasks.Task> 继承。</span><span class="sxs-lookup"><span data-stu-id="b4392-129">A task that returns a value is represented by the <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> class, which inherits from <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="b4392-130">任务对象处理基础结构详细信息，并提供可在任务的整个生存期内从调用线程访问的方法和属性。</span><span class="sxs-lookup"><span data-stu-id="b4392-130">The task object handles the infrastructure details and provides methods and properties that are accessible from the calling thread throughout the lifetime of the task.</span></span> <span data-ttu-id="b4392-131">例如，可以随时访问任务的 <xref:System.Threading.Tasks.Task.Status%2A> 属性，以确定它是已开始运行、已完成运行、已取消还是引发了异常。</span><span class="sxs-lookup"><span data-stu-id="b4392-131">For example, you can access the <xref:System.Threading.Tasks.Task.Status%2A> property of a task at any time to determine whether it has started running, ran to completion, was canceled, or has thrown an exception.</span></span> <span data-ttu-id="b4392-132">状态由 <xref:System.Threading.Tasks.TaskStatus> 枚举表示。</span><span class="sxs-lookup"><span data-stu-id="b4392-132">The status is represented by a <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span>

<span data-ttu-id="b4392-133">在创建任务时，你赋予它一个用户委托，该委托封装该任务将执行的代码。</span><span class="sxs-lookup"><span data-stu-id="b4392-133">When you create a task, you give it a user delegate that encapsulates the code that the task will execute.</span></span> <span data-ttu-id="b4392-134">该委托可以表示为命名的委托、匿名方法或 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="b4392-134">The delegate can be expressed as a named delegate, an anonymous method, or a lambda expression.</span></span> <span data-ttu-id="b4392-135">lambda 表达式可以包含对命名方法的调用，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="b4392-135">Lambda expressions can contain a call to a named method, as shown in the following example.</span></span> <span data-ttu-id="b4392-136">请注意，该示例包含对 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 方法的调用，以确保任务在控制台模式应用程序结束之前完成执行。</span><span class="sxs-lookup"><span data-stu-id="b4392-136">Note that the example includes a call to the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to ensure that the task completes execution before the console mode application ends.</span></span>

[!code-csharp[TPL_TaskIntro#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/lambda1.cs#1)]
[!code-vb[TPL_TaskIntro#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/lambda1.vb#1)]

<span data-ttu-id="b4392-137">你还可以使用 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 方法通过一个操作创建并启动任务。</span><span class="sxs-lookup"><span data-stu-id="b4392-137">You can also use the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> methods to create and start a task in one operation.</span></span> <span data-ttu-id="b4392-138">无论是哪个任务计划程序与当前线程关联，<xref:System.Threading.Tasks.Task.Run%2A> 方法都将使用默认的任务计划程序来管理任务。</span><span class="sxs-lookup"><span data-stu-id="b4392-138">To manage the task, the <xref:System.Threading.Tasks.Task.Run%2A> methods use the default  task scheduler, regardless of which task scheduler is associated with the current thread.</span></span> <span data-ttu-id="b4392-139">不需要对任务的创建和计划进行更多控制时，首选 <xref:System.Threading.Tasks.Task.Run%2A> 方法创建并启动任务。</span><span class="sxs-lookup"><span data-stu-id="b4392-139">The <xref:System.Threading.Tasks.Task.Run%2A> methods are the preferred way to create and start tasks when more control over the creation and scheduling of the task is not needed.</span></span>

[!code-csharp[TPL_TaskIntro#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/run1.cs#2)]
[!code-vb[TPL_TaskIntro#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/run1.vb#2)]

<span data-ttu-id="b4392-140">你还可以使用 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 方法在一个操作中创建并启动任务。</span><span class="sxs-lookup"><span data-stu-id="b4392-140">You can also use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method to create and start a task in one operation.</span></span> <span data-ttu-id="b4392-141">不必将创建和计划分开并且需要其他任务创建选项或使用特定计划程序时，或者需要将其他状态传递到可以通过 <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> 属性检索到的任务时，请使用此方法，如下例所示。</span><span class="sxs-lookup"><span data-stu-id="b4392-141">Use this method when creation and scheduling do not have to be separated and you require additional task creation options or the use of a specific scheduler, or when you need to pass additional state into the task that you can retrieve through its <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property, as shown in the following example.</span></span>

[!code-csharp[TPL_TaskIntro#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/asyncstate.cs#23)]
[!code-vb[TPL_TaskIntro#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/asyncstate.vb#23)]

<span data-ttu-id="b4392-142"><xref:System.Threading.Tasks.Task> 和 <xref:System.Threading.Tasks.Task%601> 均公开静态 <xref:System.Threading.Tasks.Task.Factory%2A> 属性，该属性返回 <xref:System.Threading.Tasks.TaskFactory> 的默认实例，因此你可以调用该方法为 `Task.Factory.StartNew()`。</span><span class="sxs-lookup"><span data-stu-id="b4392-142"><xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> each expose a static <xref:System.Threading.Tasks.Task.Factory%2A> property that returns a default instance of <xref:System.Threading.Tasks.TaskFactory>, so that you can call the method as `Task.Factory.StartNew()`.</span></span> <span data-ttu-id="b4392-143">此外，在以下示例中，由于任务的类型为 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>，因此每个任务都具有包含计算结果的公共 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="b4392-143">Also, in the following example, because the tasks are of type <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, they each have a public <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property that contains the result of the computation.</span></span> <span data-ttu-id="b4392-144">任务以异步方式运行，可以按任意顺序完成。</span><span class="sxs-lookup"><span data-stu-id="b4392-144">The tasks run asynchronously and may complete in any order.</span></span> <span data-ttu-id="b4392-145">如果在计算完成之前访问 <xref:System.Threading.Tasks.Task%601.Result%2A> 属性，则该属性将阻止调用线程，直到值可用为止。</span><span class="sxs-lookup"><span data-stu-id="b4392-145">If the <xref:System.Threading.Tasks.Task%601.Result%2A> property is accessed before the computation finishes, the property blocks the calling thread until the value is available.</span></span>

[!code-csharp[TPL_TaskIntro#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/result1.cs#4)]
[!code-vb[TPL_TaskIntro#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/result1.vb#4)]

<span data-ttu-id="b4392-146">有关详细信息，请参阅[如何：从任务中返回值](how-to-return-a-value-from-a-task.md)。</span><span class="sxs-lookup"><span data-stu-id="b4392-146">For more information, see [How to: Return a Value from a Task](how-to-return-a-value-from-a-task.md).</span></span>

<span data-ttu-id="b4392-147">使用 lambda 表达式创建委托时，你有权访问源代码中当时可见的所有变量。</span><span class="sxs-lookup"><span data-stu-id="b4392-147">When you use a lambda expression to create a delegate, you have access to all the variables that are visible at that point in your source code.</span></span> <span data-ttu-id="b4392-148">然而，在某些情况下，特别是在循环中，lambda 不按照预期的方式捕获变量。</span><span class="sxs-lookup"><span data-stu-id="b4392-148">However, in some cases, most notably within loops, a lambda doesn't capture the variable as expected.</span></span> <span data-ttu-id="b4392-149">它仅捕获最终值，而不是它每次迭代后更改的值。</span><span class="sxs-lookup"><span data-stu-id="b4392-149">It only captures the final value, not the value as it mutates after each iteration.</span></span> <span data-ttu-id="b4392-150">以下示例演示了该问题。</span><span class="sxs-lookup"><span data-stu-id="b4392-150">The following example illustrates the problem.</span></span> <span data-ttu-id="b4392-151">它将循环计数器传递给实例化 `CustomData` 对象并使用循环计数器作为对象标识符的 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="b4392-151">It passes a loop counter to a lambda expression that instantiates a `CustomData` object and uses the loop counter as the object's identifier.</span></span> <span data-ttu-id="b4392-152">如示例输出所示，每个 `CustomData` 对象都具有相同的标识符。</span><span class="sxs-lookup"><span data-stu-id="b4392-152">As the output from the example shows, each `CustomData` object has an identical identifier.</span></span>

[!code-csharp[TPL_TaskIntro#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/iteration1b.cs#22)]
[!code-vb[TPL_TaskIntro#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/iteration1b.vb#22)]

<span data-ttu-id="b4392-153">通过使用构造函数向任务提供状态对象，可以在每次迭代时访问该值。</span><span class="sxs-lookup"><span data-stu-id="b4392-153">You can access the value on each iteration by providing a state object to a task through its constructor.</span></span> <span data-ttu-id="b4392-154">以下示例在上一示例的基础上做了修改，在创建 `CustomData` 对象时使用循环计数器，该对象继而传递给 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="b4392-154">The following example modifies the previous example by using the loop counter when creating the `CustomData` object, which, in turn, is passed to the lambda expression.</span></span>  <span data-ttu-id="b4392-155">如示例输出所示，每个 `CustomData` 对象现在都具有唯一的一个标识符，该标识符基于该对象实例化时循环计数器的值。</span><span class="sxs-lookup"><span data-stu-id="b4392-155">As the output from the example shows, each `CustomData` object now has a unique identifier based on the value of the loop counter at the time the object was instantiated.</span></span>

[!code-csharp[TPL_TaskIntro#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/iteration1a.cs#21)]
[!code-vb[TPL_TaskIntro#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/iteration1a.vb#21)]

<span data-ttu-id="b4392-156">此状态作为参数传递给任务委托，并且可通过使用 <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> 属性从任务对象访问。</span><span class="sxs-lookup"><span data-stu-id="b4392-156">This state is passed as an argument to the task delegate, and it can be accessed from the task object by using the <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property.</span></span>  <span data-ttu-id="b4392-157">以下示例在上一示例的基础上演变而来。</span><span class="sxs-lookup"><span data-stu-id="b4392-157">The following example is a variation on the previous example.</span></span> <span data-ttu-id="b4392-158">它使用 <xref:System.Threading.Tasks.Task.AsyncState%2A> 属性显示关于传递到 lambda 表达式的 `CustomData` 对象的信息。</span><span class="sxs-lookup"><span data-stu-id="b4392-158">It uses the <xref:System.Threading.Tasks.Task.AsyncState%2A> property to display information about the `CustomData` objects passed to the lambda expression.</span></span>

[!code-csharp[TPL_TaskIntro#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/asyncstate.cs#23)]
[!code-vb[TPL_TaskIntro#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/asyncstate.vb#23)]

## <a name="task-id"></a><span data-ttu-id="b4392-159">任务 ID</span><span class="sxs-lookup"><span data-stu-id="b4392-159">Task ID</span></span>

<span data-ttu-id="b4392-160">每个任务都获得一个在应用程序域中唯一标识自己的整数 ID，可以使用 <xref:System.Threading.Tasks.Task.Id%2A?displayProperty=nameWithType> 属性访问该 ID。</span><span class="sxs-lookup"><span data-stu-id="b4392-160">Every task receives an integer ID that uniquely identifies it in an application domain and can be accessed by using the <xref:System.Threading.Tasks.Task.Id%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="b4392-161">该 ID 可有效用于在 Visual Studio 调试器的“并行堆栈”和“任务”窗口中查看任务信息。</span><span class="sxs-lookup"><span data-stu-id="b4392-161">The ID is useful for viewing task information in the Visual Studio debugger **Parallel Stacks** and **Tasks** windows.</span></span> <span data-ttu-id="b4392-162">该 ID 是惰式创建的，这意味着它不会在被请求之前创建；因此每次运行该程序时，任务可能具有不同的 ID。</span><span class="sxs-lookup"><span data-stu-id="b4392-162">The ID is lazily created, which means that it isn't created until it is requested; therefore, a task may have a different ID every time the program is run.</span></span> <span data-ttu-id="b4392-163">有关如何在调试器中查看任务 ID 的详细信息，请参阅[使用任务窗口](/visualstudio/debugger/using-the-tasks-window)和[使用并行堆栈窗口](/visualstudio/debugger/using-the-parallel-stacks-window)。</span><span class="sxs-lookup"><span data-stu-id="b4392-163">For more information about how to view task IDs in the debugger, see [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window) and [Using the Parallel Stacks Window](/visualstudio/debugger/using-the-parallel-stacks-window).</span></span>

## <a name="task-creation-options"></a><span data-ttu-id="b4392-164">任务创建选项</span><span class="sxs-lookup"><span data-stu-id="b4392-164">Task creation options</span></span>

<span data-ttu-id="b4392-165">创建任务的大多数 API 提供接受 <xref:System.Threading.Tasks.TaskCreationOptions> 参数的重载。</span><span class="sxs-lookup"><span data-stu-id="b4392-165">Most APIs that create tasks provide overloads that accept a <xref:System.Threading.Tasks.TaskCreationOptions> parameter.</span></span> <span data-ttu-id="b4392-166">通过指定下列某个或多个选项，可指示任务计划程序在线程池中安排任务计划的方式。</span><span class="sxs-lookup"><span data-stu-id="b4392-166">By specifying one or more of these options, you tell the task scheduler how to schedule the task on the thread pool.</span></span> <span data-ttu-id="b4392-167">可以使用位 OR 运算组合选项。</span><span class="sxs-lookup"><span data-stu-id="b4392-167">Options may be combined by using a bitwise **OR** operation.</span></span>

<span data-ttu-id="b4392-168">下面的示例演示一个具有 <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> 和 <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness> 选项的任务。</span><span class="sxs-lookup"><span data-stu-id="b4392-168">The following example shows a task that has the <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> and <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness> options.</span></span>

[!code-csharp[TPL_TaskIntro#03](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#03)]
[!code-vb[TPL_TaskIntro#03](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#03)]

## <a name="tasks-threads-and-culture"></a><span data-ttu-id="b4392-169">任务、线程和区域性</span><span class="sxs-lookup"><span data-stu-id="b4392-169">Tasks, threads, and culture</span></span>

<span data-ttu-id="b4392-170">每个线程都具有一个关联的区域性和 UI 区域性，分别由 <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> 和 <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> 属性定义。</span><span class="sxs-lookup"><span data-stu-id="b4392-170">Each thread has an associated culture and UI culture, which are defined by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> properties, respectively.</span></span> <span data-ttu-id="b4392-171">线程的区域性用在诸如格式、分析、排序和字符串比较操作中。</span><span class="sxs-lookup"><span data-stu-id="b4392-171">A thread's culture is used in such operations as formatting, parsing, sorting, and string comparison.</span></span> <span data-ttu-id="b4392-172">线程的 UI 区域性用于查找资源。</span><span class="sxs-lookup"><span data-stu-id="b4392-172">A thread's UI culture is used in resource lookup.</span></span>

<span data-ttu-id="b4392-173">除非使用 <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> 和 <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> 属性在应用程序域中为所有线程指定默认区域性，线程的默认区域性和 UI 区域性则由系统区域性定义。</span><span class="sxs-lookup"><span data-stu-id="b4392-173">Unless you specify a default culture for all the threads in an application domain by using the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties, the default culture and UI culture of a thread is defined by the system culture.</span></span> <span data-ttu-id="b4392-174">如果你显式设置线程的区域性并启动新线程，则新线程不会继承正在调用的线程的区域性；相反，其区域性就是默认系统区域性。</span><span class="sxs-lookup"><span data-stu-id="b4392-174">If you explicitly set a thread's culture and launch a new thread, the new thread does not inherit the culture of the calling thread; instead, its culture is the default system culture.</span></span> <span data-ttu-id="b4392-175">但是，在基于任务的编程中，任务使用调用线程的区域性，即使任务在不同线程上以异步方式运行也是如此。</span><span class="sxs-lookup"><span data-stu-id="b4392-175">However, in task-based programming, tasks use the calling thread's culture, even if the task runs asynchronously on a different thread.</span></span>

<span data-ttu-id="b4392-176">下面的示例提供了简单的演示。</span><span class="sxs-lookup"><span data-stu-id="b4392-176">The following example provides a simple illustration.</span></span> <span data-ttu-id="b4392-177">它将应用的当前区域性更改为 French (France)；或者，如果 French (France) 已为当前区域性，则将其更改为 English (United States)。</span><span class="sxs-lookup"><span data-stu-id="b4392-177">It changes the app's current culture to French (France) (or, if French (France) is already the current culture, to English (United States)).</span></span> <span data-ttu-id="b4392-178">然后，调用一个名为 `formatDelegate` 的委托，该委托返回在新区域性中格式化为货币值的数字。</span><span class="sxs-lookup"><span data-stu-id="b4392-178">It then invokes a delegate named `formatDelegate` that returns some numbers formatted as currency values in the new culture.</span></span> <span data-ttu-id="b4392-179">无论委托是由任务同步调用还是异步调用，该任务都将使用调用线程的区域性。</span><span class="sxs-lookup"><span data-stu-id="b4392-179">Whether the delegate is invoked by a task either synchronously or asynchronously, the task uses the culture of the calling thread.</span></span>

:::code language="csharp" source="snippets/cs/asyncculture1.cs" id="1":::

:::code language="vbnet" source="snippets/vb/asyncculture1.vb" id="1":::

> [!NOTE]
> <span data-ttu-id="b4392-180">在 .NET Framework 4.6 之前的 .NET Framework 版本中，任务的区域性由它在其上运行的线程区域性确定，而不是调用线程的区域性 。</span><span class="sxs-lookup"><span data-stu-id="b4392-180">In versions of .NET Framework prior to .NET Framework 4.6, a task's culture is determined by the culture of the thread on which it *runs*, not the culture of the *calling thread*.</span></span> <span data-ttu-id="b4392-181">对于异步任务，这意味着任务使用的区域性可能不同于调用线程的区域性。</span><span class="sxs-lookup"><span data-stu-id="b4392-181">For asynchronous tasks, this means the culture used by the task could be different to the calling thread's culture.</span></span>

<span data-ttu-id="b4392-182">有关异步任务和区域性的详细信息，请参阅 <xref:System.Globalization.CultureInfo> 主题中的“区域性和基于异步任务的操作”部分。</span><span class="sxs-lookup"><span data-stu-id="b4392-182">For more information on asynchronous tasks and culture, see the "Culture and asynchronous task-based operations" section in the <xref:System.Globalization.CultureInfo> topic.</span></span>

## <a name="creating-task-continuations"></a><span data-ttu-id="b4392-183">创建任务延续</span><span class="sxs-lookup"><span data-stu-id="b4392-183">Creating task continuations</span></span>

<span data-ttu-id="b4392-184">使用 <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> 方法，可以指定要在先行任务完成时启动的任务。</span><span class="sxs-lookup"><span data-stu-id="b4392-184">The <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> methods let you specify a task to start when the *antecedent task* finishes.</span></span> <span data-ttu-id="b4392-185">延续任务的委托已传递了对先行任务的引用，因此它可以检查先行任务的状态，并通过检索 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 属性的值将先行任务的输出用作延续任务的输入。</span><span class="sxs-lookup"><span data-stu-id="b4392-185">The delegate of the continuation task is passed a reference to the antecedent task so that it can examine the antecedent task's status and, by retrieving the value of the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property, can use the output of the antecedent as input for the continuation.</span></span>

<span data-ttu-id="b4392-186">在下面的示例中，`getData` 任务通过调用 <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> 方法来启动。</span><span class="sxs-lookup"><span data-stu-id="b4392-186">In the following example, the `getData` task is started by a call to the <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="b4392-187">当 `processData` 完成时，`getData` 任务自动启动，当 `displayData` 完成时，`processData` 启动。</span><span class="sxs-lookup"><span data-stu-id="b4392-187">The `processData` task is started automatically when `getData` finishes, and `displayData` is started when `processData` finishes.</span></span> <span data-ttu-id="b4392-188">`getData` 产生一个整数数组，通过 `processData` 任务的 `getData` 属性，<xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 任务可访问该数组。</span><span class="sxs-lookup"><span data-stu-id="b4392-188">`getData` produces an integer array, which is accessible to the `processData` task through the `getData` task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="b4392-189">`processData` 任务处理该数组并返回结果，结果的类型从传递到 <xref:System.Threading.Tasks.Task%601.ContinueWith%60%601%28System.Func%7BSystem.Threading.Tasks.Task%7B%600%7D%2C%60%600%7D%29?displayProperty=nameWithType> 方法的 Lambda 表达式的返回类型推断而来。</span><span class="sxs-lookup"><span data-stu-id="b4392-189">The `processData` task processes that array and returns a result whose type is inferred from the return type of the lambda expression passed to the <xref:System.Threading.Tasks.Task%601.ContinueWith%60%601%28System.Func%7BSystem.Threading.Tasks.Task%7B%600%7D%2C%60%600%7D%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="b4392-190">`displayData` 完成时，`processData` 任务自动执行，而 <xref:System.Tuple%603> 任务可通过 `processData` 任务的 `displayData` 属性访问由 `processData` lambda 表达式返回的 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 对象。</span><span class="sxs-lookup"><span data-stu-id="b4392-190">The `displayData` task executes automatically when `processData` finishes, and the <xref:System.Tuple%603> object returned by the `processData` lambda expression is accessible to the `displayData` task through the `processData` task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="b4392-191">`displayData` 任务采用 `processData` 任务的结果，继而得出自己的结果，其类型以相似方式推断而来，且可由程序中的 <xref:System.Threading.Tasks.Task%601.Result%2A> 属性使用。</span><span class="sxs-lookup"><span data-stu-id="b4392-191">The `displayData` task takes the result of the `processData` task and produces a result whose type is inferred in a similar manner and which is made available to the program in the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span>

[!code-csharp[TPL_TaskIntro#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/continuations1.cs#5)]
[!code-vb[TPL_TaskIntro#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/continuations1.vb#5)]

<span data-ttu-id="b4392-192">因为 <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 是实例方法，所以你可以将方法调用链接在一起，而不是为每个先行任务去实例化 <xref:System.Threading.Tasks.Task%601> 对象。</span><span class="sxs-lookup"><span data-stu-id="b4392-192">Because <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> is an instance method, you can chain method calls together instead of instantiating a <xref:System.Threading.Tasks.Task%601> object for each antecedent task.</span></span> <span data-ttu-id="b4392-193">以下示例与上一示例在功能上等同，唯一的不同在于它将对 <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 方法的调用链接在一起。</span><span class="sxs-lookup"><span data-stu-id="b4392-193">The following example is functionally identical to the previous example, except that it chains together calls to the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="b4392-194">请注意，通过方法调用链返回的 <xref:System.Threading.Tasks.Task%601> 对象是最终延续任务。</span><span class="sxs-lookup"><span data-stu-id="b4392-194">Note that the <xref:System.Threading.Tasks.Task%601> object returned by the chain of method calls is the final continuation task.</span></span>

[!code-csharp[TPL_TaskIntro#24](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/continuations2.cs#24)]
[!code-vb[TPL_TaskIntro#24](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/continuations2.vb#24)]

<span data-ttu-id="b4392-195">使用 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> 和 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> 方法，可以从多个任务继续。</span><span class="sxs-lookup"><span data-stu-id="b4392-195">The <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> methods enable you to continue from multiple tasks.</span></span>

<span data-ttu-id="b4392-196">有关详细信息，请参阅[使用延续任务链接任务](chaining-tasks-by-using-continuation-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="b4392-196">For more information, see [Chaining Tasks by Using Continuation Tasks](chaining-tasks-by-using-continuation-tasks.md).</span></span>

## <a name="creating-detached-child-tasks"></a><span data-ttu-id="b4392-197">创建分离的子任务</span><span class="sxs-lookup"><span data-stu-id="b4392-197">Creating detached child tasks</span></span>

<span data-ttu-id="b4392-198">如果在任务中运行的用户代码创建一个新任务，且未指定 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> 选项，则该新任务不采用任何特殊方式与父任务同步。</span><span class="sxs-lookup"><span data-stu-id="b4392-198">When user code that is running in a task creates a new task and does not specify the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option, the new task is not synchronized with the parent task in any special way.</span></span> <span data-ttu-id="b4392-199">这种不同步的任务类型称为“分离的嵌套任务”或“分离的子任务”。</span><span class="sxs-lookup"><span data-stu-id="b4392-199">This type of non-synchronized task is called a *detached nested task* or *detached child task*.</span></span> <span data-ttu-id="b4392-200">以下示例展示了创建一个分离子任务的任务。</span><span class="sxs-lookup"><span data-stu-id="b4392-200">The following example shows a task that creates one detached child task.</span></span>

[!code-csharp[TPL_TaskIntro#07](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#07)]
[!code-vb[TPL_TaskIntro#07](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#07)]

<span data-ttu-id="b4392-201">请注意，父任务不会等待分离子任务完成。</span><span class="sxs-lookup"><span data-stu-id="b4392-201">Note that the parent task does not wait for the detached child task to finish.</span></span>

## <a name="creating-child-tasks"></a><span data-ttu-id="b4392-202">创建子任务</span><span class="sxs-lookup"><span data-stu-id="b4392-202">Creating child tasks</span></span>

<span data-ttu-id="b4392-203">如果任务中运行的用户代码在创建任务时指定了 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> 选项，新任务就称为父任务的附加子任务。</span><span class="sxs-lookup"><span data-stu-id="b4392-203">When user code that is running in a task creates a task with the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option, the new task is known as an *attached child task* of the parent task.</span></span> <span data-ttu-id="b4392-204">因为父任务隐式地等待所有附加子任务完成，所以你可以使用 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> 选项表示结构化的任务并行。</span><span class="sxs-lookup"><span data-stu-id="b4392-204">You can use the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option to express structured task parallelism, because the parent task implicitly waits for all attached child tasks to finish.</span></span> <span data-ttu-id="b4392-205">以下示例展示了创建十个附加子任务的父任务。</span><span class="sxs-lookup"><span data-stu-id="b4392-205">The following example shows a parent task that creates ten attached child tasks.</span></span> <span data-ttu-id="b4392-206">请注意，虽然此示例调用 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 方法等待父任务完成，但不必显式等待附加子任务完成。</span><span class="sxs-lookup"><span data-stu-id="b4392-206">Note that although the example calls the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for the parent task to finish, it does not have to explicitly wait for the attached child tasks to complete.</span></span>

[!code-csharp[TPL_TaskIntro#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/child1.cs#8)]
[!code-vb[TPL_TaskIntro#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/child1.vb#8)]

<span data-ttu-id="b4392-207">父任务可使用 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> 选项阻止其他任务附加到父任务。</span><span class="sxs-lookup"><span data-stu-id="b4392-207">A parent task can use the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option to prevent other tasks from attaching to the parent task.</span></span> <span data-ttu-id="b4392-208">有关详细信息，请参阅[附加和分离的子任务](attached-and-detached-child-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="b4392-208">For more information, see [Attached and Detached Child Tasks](attached-and-detached-child-tasks.md).</span></span>

## <a name="waiting-for-tasks-to-finish"></a><span data-ttu-id="b4392-209">等待任务完成</span><span class="sxs-lookup"><span data-stu-id="b4392-209">Waiting for tasks to finish</span></span>

<span data-ttu-id="b4392-210"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 类型提供了 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 方法的若干重载，以便能够等待任务完成。</span><span class="sxs-lookup"><span data-stu-id="b4392-210">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types provide several overloads of the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> methods that enable you to wait for a task to finish.</span></span> <span data-ttu-id="b4392-211">此外，使用静态 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> 方法的重载可以等待一批任务中的任一任务或所有任务完成。</span><span class="sxs-lookup"><span data-stu-id="b4392-211">In addition, overloads of the static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> methods let you wait for any or all of an array of tasks to finish.</span></span>

<span data-ttu-id="b4392-212">通常，会出于以下某个原因等待任务：</span><span class="sxs-lookup"><span data-stu-id="b4392-212">Typically, you would wait for a task for one of these reasons:</span></span>

- <span data-ttu-id="b4392-213">主线程依赖于任务计算的最终结果。</span><span class="sxs-lookup"><span data-stu-id="b4392-213">The main thread depends on the final result computed by a task.</span></span>

- <span data-ttu-id="b4392-214">你必须处理可能从任务引发的异常。</span><span class="sxs-lookup"><span data-stu-id="b4392-214">You have to handle exceptions that might be thrown from the task.</span></span>

- <span data-ttu-id="b4392-215">应用程序可以在所有任务执行完毕之前终止。</span><span class="sxs-lookup"><span data-stu-id="b4392-215">The application may terminate before all tasks have completed execution.</span></span> <span data-ttu-id="b4392-216">例如，执行 `Main`（应用程序入口点）中的所有同步代码后，控制台应用程序将立即终止。</span><span class="sxs-lookup"><span data-stu-id="b4392-216">For example, console applications will terminate as soon as all synchronous code in `Main` (the application entry point) has executed.</span></span>

<span data-ttu-id="b4392-217">下面的示例演示不包含异常处理的基本模式。</span><span class="sxs-lookup"><span data-stu-id="b4392-217">The following example shows the basic pattern that does not involve exception handling.</span></span>

[!code-csharp[TPL_TaskIntro#06](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#06)]
[!code-vb[TPL_TaskIntro#06](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#06)]

<span data-ttu-id="b4392-218">有关演示异常处理的示例，请参见[异常处理](exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="b4392-218">For an example that shows exception handling, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span>

<span data-ttu-id="b4392-219">某些重载允许你指定超时，而其他重载采用额外的 <xref:System.Threading.CancellationToken> 作为输入参数，以便可以通过编程方式或根据用户输入来取消等待。</span><span class="sxs-lookup"><span data-stu-id="b4392-219">Some overloads let you specify a time-out, and others take an additional <xref:System.Threading.CancellationToken> as an input parameter, so that the wait itself can be canceled either programmatically or in response to user input.</span></span>

<span data-ttu-id="b4392-220">等待任务时，其实是在隐式等待使用 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 选项创建的该任务的所有子级。</span><span class="sxs-lookup"><span data-stu-id="b4392-220">When you wait for a task, you implicitly wait for all children of that task that were created by using the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="b4392-221"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 在该任务已完成时立即返回。</span><span class="sxs-lookup"><span data-stu-id="b4392-221"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> returns immediately if the task has already completed.</span></span> <span data-ttu-id="b4392-222"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 方法将抛出由某任务引发的任何异常，即使 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 方法是在该任务完成之后调用的。</span><span class="sxs-lookup"><span data-stu-id="b4392-222">Any exceptions raised by a task will be thrown by a <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method, even if the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method was called after the task completed.</span></span>

## <a name="composing-tasks"></a><span data-ttu-id="b4392-223">组合任务</span><span class="sxs-lookup"><span data-stu-id="b4392-223">Composing tasks</span></span>

<span data-ttu-id="b4392-224"><xref:System.Threading.Tasks.Task> 类和 <xref:System.Threading.Tasks.Task%601> 类提供多种方法，这些方法能够帮助你组合多个任务以实现常见模式，并更好地使用由 C#、Visual Basic 和 F# 提供的异步语言功能。</span><span class="sxs-lookup"><span data-stu-id="b4392-224">The <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes provide several methods that can help you compose multiple tasks to implement common patterns and to better use the asynchronous language features that are provided by C#, Visual Basic, and F#.</span></span> <span data-ttu-id="b4392-225">本节介绍了 <xref:System.Threading.Tasks.Task.WhenAll%2A>、<xref:System.Threading.Tasks.Task.WhenAny%2A>、<xref:System.Threading.Tasks.Task.Delay%2A> 和 <xref:System.Threading.Tasks.Task.FromResult%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b4392-225">This section describes the <xref:System.Threading.Tasks.Task.WhenAll%2A>, <xref:System.Threading.Tasks.Task.WhenAny%2A>, <xref:System.Threading.Tasks.Task.Delay%2A>, and <xref:System.Threading.Tasks.Task.FromResult%2A> methods.</span></span>

### <a name="taskwhenall"></a><span data-ttu-id="b4392-226">Task.WhenAll</span><span class="sxs-lookup"><span data-stu-id="b4392-226">Task.WhenAll</span></span>

<span data-ttu-id="b4392-227"><xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> 方法异步等待多个 <xref:System.Threading.Tasks.Task> 或 <xref:System.Threading.Tasks.Task%601> 对象完成。</span><span class="sxs-lookup"><span data-stu-id="b4392-227">The <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method asynchronously waits for multiple <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to finish.</span></span> <span data-ttu-id="b4392-228">通过它提供的重载版本可以等待非均匀任务组。</span><span class="sxs-lookup"><span data-stu-id="b4392-228">It provides overloaded versions that enable you to wait for non-uniform sets of tasks.</span></span> <span data-ttu-id="b4392-229">例如，你可以等待多个 <xref:System.Threading.Tasks.Task> 和 <xref:System.Threading.Tasks.Task%601> 对象在一个方法调用中完成。</span><span class="sxs-lookup"><span data-stu-id="b4392-229">For example, you can wait for multiple <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects to complete from one method call.</span></span>

### <a name="taskwhenany"></a><span data-ttu-id="b4392-230">Task.WhenAny</span><span class="sxs-lookup"><span data-stu-id="b4392-230">Task.WhenAny</span></span>

<span data-ttu-id="b4392-231"><xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> 方法异步等待多个 <xref:System.Threading.Tasks.Task> 或 <xref:System.Threading.Tasks.Task%601> 对象中的一个完成。</span><span class="sxs-lookup"><span data-stu-id="b4392-231">The <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> method asynchronously waits for one of multiple <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to finish.</span></span> <span data-ttu-id="b4392-232">与在 <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> 方法中一样，该方法提供重载版本，让你能等待非均匀任务组。</span><span class="sxs-lookup"><span data-stu-id="b4392-232">As in the <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method, this method provides overloaded versions that enable you to wait for non-uniform sets of tasks.</span></span> <span data-ttu-id="b4392-233"><xref:System.Threading.Tasks.Task.WhenAny%2A> 方法在下列情境中尤其有用。</span><span class="sxs-lookup"><span data-stu-id="b4392-233">The <xref:System.Threading.Tasks.Task.WhenAny%2A> method is especially useful in the following scenarios.</span></span>

- <span data-ttu-id="b4392-234">冗余运算。</span><span class="sxs-lookup"><span data-stu-id="b4392-234">Redundant operations.</span></span> <span data-ttu-id="b4392-235">请考虑可以用多种方式执行的算法或运算。</span><span class="sxs-lookup"><span data-stu-id="b4392-235">Consider an algorithm or operation that can be performed in many ways.</span></span> <span data-ttu-id="b4392-236">你可使用 <xref:System.Threading.Tasks.Task.WhenAny%2A> 方法来选择先完成的运算，然后取消剩余的运算。</span><span class="sxs-lookup"><span data-stu-id="b4392-236">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to select the operation that finishes first and then cancel the remaining operations.</span></span>

- <span data-ttu-id="b4392-237">交叉运算。</span><span class="sxs-lookup"><span data-stu-id="b4392-237">Interleaved operations.</span></span> <span data-ttu-id="b4392-238">你可启动必须全部完成的多项运算，并使用 <xref:System.Threading.Tasks.Task.WhenAny%2A> 方法在每项运算完成时处理结果。</span><span class="sxs-lookup"><span data-stu-id="b4392-238">You can start multiple operations that must all finish and use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to process results as each operation finishes.</span></span> <span data-ttu-id="b4392-239">在一项运算完成后，可以启动一个或多个其他任务。</span><span class="sxs-lookup"><span data-stu-id="b4392-239">After one operation finishes, you can start one or more additional tasks.</span></span>

- <span data-ttu-id="b4392-240">受限制的运算。</span><span class="sxs-lookup"><span data-stu-id="b4392-240">Throttled operations.</span></span> <span data-ttu-id="b4392-241">你可使用 <xref:System.Threading.Tasks.Task.WhenAny%2A> 方法通过限制并发运算的数量来扩展前面的情境。</span><span class="sxs-lookup"><span data-stu-id="b4392-241">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to extend the previous scenario by limiting the number of concurrent operations.</span></span>

- <span data-ttu-id="b4392-242">过期的运算。</span><span class="sxs-lookup"><span data-stu-id="b4392-242">Expired operations.</span></span> <span data-ttu-id="b4392-243">你可使用 <xref:System.Threading.Tasks.Task.WhenAny%2A> 方法在一个或多个任务与特定时间后完成的任务（例如 <xref:System.Threading.Tasks.Task.Delay%2A> 方法返回的任务）间进行选择。</span><span class="sxs-lookup"><span data-stu-id="b4392-243">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to select between one or more tasks and a task that finishes after a specific time, such as a task that is returned by the <xref:System.Threading.Tasks.Task.Delay%2A> method.</span></span> <span data-ttu-id="b4392-244">下节描述了 <xref:System.Threading.Tasks.Task.Delay%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b4392-244">The <xref:System.Threading.Tasks.Task.Delay%2A> method is described in the following section.</span></span>

### <a name="taskdelay"></a><span data-ttu-id="b4392-245">Task.Delay</span><span class="sxs-lookup"><span data-stu-id="b4392-245">Task.Delay</span></span>

<span data-ttu-id="b4392-246"><xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> 方法将生成在指定时间后完成的 <xref:System.Threading.Tasks.Task> 对象。</span><span class="sxs-lookup"><span data-stu-id="b4392-246">The <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method produces a <xref:System.Threading.Tasks.Task> object that finishes after the specified time.</span></span> <span data-ttu-id="b4392-247">你可使用此方法来生成偶尔轮询数据的循环，引入超时，将对用户输入的处理延迟预定的一段时间等。</span><span class="sxs-lookup"><span data-stu-id="b4392-247">You can use this method to build loops that occasionally poll for data, introduce time-outs, delay the handling of user input for a predetermined time, and so on.</span></span>

### <a name="tasktfromresult"></a><span data-ttu-id="b4392-248">Task(T).FromResult</span><span class="sxs-lookup"><span data-stu-id="b4392-248">Task(T).FromResult</span></span>

<span data-ttu-id="b4392-249">通过使用 <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> 方法，你可以创建包含预计算结果的 <xref:System.Threading.Tasks.Task%601> 对象。</span><span class="sxs-lookup"><span data-stu-id="b4392-249">By using the <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> method, you can create a <xref:System.Threading.Tasks.Task%601> object that holds a pre-computed result.</span></span> <span data-ttu-id="b4392-250">执行返回 <xref:System.Threading.Tasks.Task%601> 对象的异步运算，且已计算该 <xref:System.Threading.Tasks.Task%601> 对象的结果时，此方法将十分有用。</span><span class="sxs-lookup"><span data-stu-id="b4392-250">This method is useful when you perform an asynchronous operation that returns a <xref:System.Threading.Tasks.Task%601> object, and the result of that <xref:System.Threading.Tasks.Task%601> object is already computed.</span></span> <span data-ttu-id="b4392-251">有关使用 <xref:System.Threading.Tasks.Task.FromResult%2A> 检索缓存中包含的异步下载运算结果的示例，请参阅[如何：创建预先计算的任务](how-to-create-pre-computed-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="b4392-251">For an example that uses <xref:System.Threading.Tasks.Task.FromResult%2A> to retrieve the results of asynchronous download operations that are held in a cache, see [How to: Create Pre-Computed Tasks](how-to-create-pre-computed-tasks.md).</span></span>

## <a name="handling-exceptions-in-tasks"></a><span data-ttu-id="b4392-252">处理任务中的异常</span><span class="sxs-lookup"><span data-stu-id="b4392-252">Handling exceptions in tasks</span></span>

<span data-ttu-id="b4392-253">当某个任务抛出一个或多个异常时，异常包装在 <xref:System.AggregateException> 异常中。</span><span class="sxs-lookup"><span data-stu-id="b4392-253">When a task throws one or more exceptions, the exceptions are wrapped in an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="b4392-254">该异常传播回与该任务联接的线程，通常该线程正在等待该任务完成或该线程访问 <xref:System.Threading.Tasks.Task%601.Result%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="b4392-254">That exception is propagated back to the thread that joins with the task, which is typically the thread that is waiting for the task to finish or the thread that accesses the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span> <span data-ttu-id="b4392-255">此行为用于强制实施 .NET Framework 策略 - 默认所有未处理的异常应终止进程。</span><span class="sxs-lookup"><span data-stu-id="b4392-255">This behavior serves to enforce the .NET Framework policy that all unhandled exceptions by default should terminate the process.</span></span> <span data-ttu-id="b4392-256">调用代码可以通过使用 `try`/`catch` 块中的以下任意方法来处理异常：</span><span class="sxs-lookup"><span data-stu-id="b4392-256">The calling code can handle the exceptions by using any of the following in a `try`/`catch` block:</span></span>

- <span data-ttu-id="b4392-257"><xref:System.Threading.Tasks.Task.Wait%2A> 方法</span><span class="sxs-lookup"><span data-stu-id="b4392-257">The <xref:System.Threading.Tasks.Task.Wait%2A> method</span></span>

- <span data-ttu-id="b4392-258"><xref:System.Threading.Tasks.Task.WaitAll%2A> 方法</span><span class="sxs-lookup"><span data-stu-id="b4392-258">The <xref:System.Threading.Tasks.Task.WaitAll%2A> method</span></span>

- <span data-ttu-id="b4392-259"><xref:System.Threading.Tasks.Task.WaitAny%2A> 方法</span><span class="sxs-lookup"><span data-stu-id="b4392-259">The <xref:System.Threading.Tasks.Task.WaitAny%2A> method</span></span>

- <span data-ttu-id="b4392-260"><xref:System.Threading.Tasks.Task%601.Result%2A> 属性</span><span class="sxs-lookup"><span data-stu-id="b4392-260">The <xref:System.Threading.Tasks.Task%601.Result%2A> property</span></span>

<span data-ttu-id="b4392-261">联接线程也可以通过在对任务进行垃圾回收之前访问 <xref:System.Threading.Tasks.Task.Exception%2A> 属性来处理异常。</span><span class="sxs-lookup"><span data-stu-id="b4392-261">The joining thread can also handle exceptions by accessing the <xref:System.Threading.Tasks.Task.Exception%2A> property before the task is garbage-collected.</span></span> <span data-ttu-id="b4392-262">通过访问此属性，可防止未处理的异常在对象完成时触发终止进程的异常传播行为。</span><span class="sxs-lookup"><span data-stu-id="b4392-262">By accessing this property, you prevent the unhandled exception from triggering the exception propagation behavior that terminates the process when the object is finalized.</span></span>

<span data-ttu-id="b4392-263">有关异常和任务的的详细信息，请参阅[异常处理](exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="b4392-263">For more information about exceptions and tasks, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span>

## <a name="canceling-tasks"></a><span data-ttu-id="b4392-264">取消任务</span><span class="sxs-lookup"><span data-stu-id="b4392-264">Canceling tasks</span></span>

<span data-ttu-id="b4392-265"><xref:System.Threading.Tasks.Task> 类支持协作取消，并与 .NET Framework 4 中新增的 <xref:System.Threading.CancellationTokenSource?displayProperty=nameWithType> 类和 <xref:System.Threading.CancellationToken?displayProperty=nameWithType> 类完全集成。</span><span class="sxs-lookup"><span data-stu-id="b4392-265">The <xref:System.Threading.Tasks.Task> class supports cooperative cancellation and is fully integrated with the <xref:System.Threading.CancellationTokenSource?displayProperty=nameWithType> and <xref:System.Threading.CancellationToken?displayProperty=nameWithType> classes, which were introduced in the .NET Framework 4.</span></span> <span data-ttu-id="b4392-266"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 类中的大多数构造函数采用 <xref:System.Threading.CancellationToken> 对象作为输入参数。</span><span class="sxs-lookup"><span data-stu-id="b4392-266">Many of the constructors in the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class take a <xref:System.Threading.CancellationToken> object as an input parameter.</span></span> <span data-ttu-id="b4392-267">许多 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 和 <xref:System.Threading.Tasks.Task.Run%2A> 重载还包括 <xref:System.Threading.CancellationToken> 参数。</span><span class="sxs-lookup"><span data-stu-id="b4392-267">Many of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> and <xref:System.Threading.Tasks.Task.Run%2A> overloads also include a <xref:System.Threading.CancellationToken> parameter.</span></span>

<span data-ttu-id="b4392-268">你可以创建标记，并使用 <xref:System.Threading.CancellationTokenSource> 类在以后某一时间发出取消请求。</span><span class="sxs-lookup"><span data-stu-id="b4392-268">You can create the token, and issue the cancellation request at some later time, by using the <xref:System.Threading.CancellationTokenSource> class.</span></span> <span data-ttu-id="b4392-269">可以将该标记作为参数传递给 <xref:System.Threading.Tasks.Task>，还可以在执行响应取消请求的工作的用户委托中引用同一标记。</span><span class="sxs-lookup"><span data-stu-id="b4392-269">Pass the token to the <xref:System.Threading.Tasks.Task> as an argument, and also reference the same token in your user delegate, which does the work of responding to a cancellation request.</span></span>

<span data-ttu-id="b4392-270">有关详细信息，请参阅[任务取消](task-cancellation.md)和[如何：取消任务及其子级](how-to-cancel-a-task-and-its-children.md)。</span><span class="sxs-lookup"><span data-stu-id="b4392-270">For more information, see [Task Cancellation](task-cancellation.md) and [How to: Cancel a Task and Its Children](how-to-cancel-a-task-and-its-children.md).</span></span>

## <a name="the-taskfactory-class"></a><span data-ttu-id="b4392-271">TaskFactory 类</span><span class="sxs-lookup"><span data-stu-id="b4392-271">The TaskFactory class</span></span>

<span data-ttu-id="b4392-272"><xref:System.Threading.Tasks.TaskFactory> 类提供静态方法，这些方法封装了用于创建和启动任务和延续任务的一些常用模式。</span><span class="sxs-lookup"><span data-stu-id="b4392-272">The <xref:System.Threading.Tasks.TaskFactory> class provides static methods that encapsulate some common patterns for creating and starting tasks and continuation tasks.</span></span>

- <span data-ttu-id="b4392-273">最常用模式为 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A>，它在一个语句中创建并启动任务。</span><span class="sxs-lookup"><span data-stu-id="b4392-273">The most common pattern is <xref:System.Threading.Tasks.TaskFactory.StartNew%2A>, which creates and starts a task in one statement.</span></span>

- <span data-ttu-id="b4392-274">如果通过多个先行任务创建延续任务，请使用 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> 方法或 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> 方法，或它们在 <xref:System.Threading.Tasks.Task%601> 类中的相当方法。</span><span class="sxs-lookup"><span data-stu-id="b4392-274">When you create continuation tasks from multiple antecedents, use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> method or <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> method or their equivalents in the <xref:System.Threading.Tasks.Task%601> class.</span></span> <span data-ttu-id="b4392-275">有关详细信息，请参阅[使用延续任务链接任务](chaining-tasks-by-using-continuation-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="b4392-275">For more information, see [Chaining Tasks by Using Continuation Tasks](chaining-tasks-by-using-continuation-tasks.md).</span></span>

- <span data-ttu-id="b4392-276">若要在 `BeginX` 或 `EndX` 实例中封装异步编程模型 <xref:System.Threading.Tasks.Task> 和 <xref:System.Threading.Tasks.Task%601> 方法，请使用 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b4392-276">To encapsulate Asynchronous Programming Model `BeginX` and `EndX` methods in a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> instance, use the <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> methods.</span></span> <span data-ttu-id="b4392-277">有关详细信息，请参阅 [TPL 和传统 .NET Framework 异步编程](tpl-and-traditional-async-programming.md)。</span><span class="sxs-lookup"><span data-stu-id="b4392-277">For more information, see [TPL and Traditional .NET Framework Asynchronous Programming](tpl-and-traditional-async-programming.md).</span></span>

<span data-ttu-id="b4392-278">默认的 <xref:System.Threading.Tasks.TaskFactory> 可作为 <xref:System.Threading.Tasks.Task> 类或 <xref:System.Threading.Tasks.Task%601> 类上的静态属性访问。</span><span class="sxs-lookup"><span data-stu-id="b4392-278">The default <xref:System.Threading.Tasks.TaskFactory> can be accessed as a static property on the <xref:System.Threading.Tasks.Task> class or <xref:System.Threading.Tasks.Task%601> class.</span></span> <span data-ttu-id="b4392-279">你还可以直接实例化 <xref:System.Threading.Tasks.TaskFactory> 并指定各种选项，包括 <xref:System.Threading.CancellationToken>、<xref:System.Threading.Tasks.TaskCreationOptions> 选项、<xref:System.Threading.Tasks.TaskContinuationOptions> 选项或 <xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="b4392-279">You can also instantiate a <xref:System.Threading.Tasks.TaskFactory> directly and specify various options that include a <xref:System.Threading.CancellationToken>, a <xref:System.Threading.Tasks.TaskCreationOptions> option, a <xref:System.Threading.Tasks.TaskContinuationOptions> option, or a <xref:System.Threading.Tasks.TaskScheduler>.</span></span> <span data-ttu-id="b4392-280">创建任务工厂时所指定的任何选项将应用于它创建的所有任务，除非 <xref:System.Threading.Tasks.Task> 是通过使用 <xref:System.Threading.Tasks.TaskCreationOptions> 枚举创建的（在这种情况下，任务的选项重写任务工厂的选项）。</span><span class="sxs-lookup"><span data-stu-id="b4392-280">Whatever options are specified when you create the task factory will be applied to all tasks that it creates, unless the <xref:System.Threading.Tasks.Task> is created by using the <xref:System.Threading.Tasks.TaskCreationOptions> enumeration, in which case the task's options override those of the task factory.</span></span>

## <a name="tasks-without-delegates"></a><span data-ttu-id="b4392-281">无委托的任务</span><span class="sxs-lookup"><span data-stu-id="b4392-281">Tasks without delegates</span></span>

<span data-ttu-id="b4392-282">在某些情况下，可能需要使用 <xref:System.Threading.Tasks.Task> 封装由外部组件（而不是你自己的用户委托）执行的某个异步操作。</span><span class="sxs-lookup"><span data-stu-id="b4392-282">In some cases, you may want to use a <xref:System.Threading.Tasks.Task> to encapsulate some asynchronous operation that is performed by an external component instead of your own user delegate.</span></span> <span data-ttu-id="b4392-283">如果该操作基于异步编程模型 Begin/End 模式，你可以使用 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b4392-283">If the operation is based on the Asynchronous Programming Model Begin/End pattern, you can use the <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> methods.</span></span> <span data-ttu-id="b4392-284">如果不是这种情况，你可以使用 <xref:System.Threading.Tasks.TaskCompletionSource%601> 对象将该操作包装在任务中，并因而获得 <xref:System.Threading.Tasks.Task> 可编程性的一些好处，例如对异常传播和延续的支持。</span><span class="sxs-lookup"><span data-stu-id="b4392-284">If that is not the case, you can use the <xref:System.Threading.Tasks.TaskCompletionSource%601> object to wrap the operation in a task and thereby gain some of the benefits of <xref:System.Threading.Tasks.Task> programmability, for example, support for exception propagation and continuations.</span></span> <span data-ttu-id="b4392-285">有关详细信息，请参阅 <xref:System.Threading.Tasks.TaskCompletionSource%601>。</span><span class="sxs-lookup"><span data-stu-id="b4392-285">For more information, see <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span></span>

## <a name="custom-schedulers"></a><span data-ttu-id="b4392-286">自定义计划程序</span><span class="sxs-lookup"><span data-stu-id="b4392-286">Custom schedulers</span></span>

<span data-ttu-id="b4392-287">大多数应用程序或库开发人员并不关心任务在哪个处理器上运行、任务如何将其工作与其他任务同步以及如何在 <xref:System.Threading.ThreadPool?displayProperty=nameWithType> 中计划任务。</span><span class="sxs-lookup"><span data-stu-id="b4392-287">Most application or library developers do not care which processor the task runs on, how it synchronizes its work with other tasks, or how it is scheduled on the <xref:System.Threading.ThreadPool?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b4392-288">他们只需要它在主机上尽可能高效地执行。</span><span class="sxs-lookup"><span data-stu-id="b4392-288">They only require that it execute as efficiently as possible on the host computer.</span></span> <span data-ttu-id="b4392-289">如果需要对计划细节进行更细化的控制，可以使用任务并行库在默认任务计划程序上配置一些设置，甚至是提供自定义计划程序。</span><span class="sxs-lookup"><span data-stu-id="b4392-289">If you require more fine-grained control over the scheduling details, the Task Parallel Library lets you configure some settings on the default task scheduler, and even lets you supply a custom scheduler.</span></span> <span data-ttu-id="b4392-290">有关详细信息，请参阅 <xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="b4392-290">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>

## <a name="related-data-structures"></a><span data-ttu-id="b4392-291">相关数据结构</span><span class="sxs-lookup"><span data-stu-id="b4392-291">Related data structures</span></span>

<span data-ttu-id="b4392-292">TPL 有几种在并行和顺序方案中都有用的新公共类型。</span><span class="sxs-lookup"><span data-stu-id="b4392-292">The TPL has several new public types that are useful in both parallel and sequential scenarios.</span></span> <span data-ttu-id="b4392-293">它们包括 <xref:System.Collections.Concurrent?displayProperty=nameWithType> 命名空间中的一些线程安全的、快速且可缩放的集合类，还包括一些新的同步类型（例如 <xref:System.Threading.Semaphore?displayProperty=nameWithType> 和 <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>），对特定类型的工作负荷而言，这些新同步类型比旧的同步类型效率更高。</span><span class="sxs-lookup"><span data-stu-id="b4392-293">These include several thread-safe, fast and scalable collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, and several new synchronization types, for example, <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>, which are more efficient than their predecessors for specific kinds of workloads.</span></span> <span data-ttu-id="b4392-294">.NET Framework 4 中的其他新类型（例如 <xref:System.Threading.Barrier?displayProperty=nameWithType> 和 <xref:System.Threading.SpinLock?displayProperty=nameWithType>）提供了早期版本中未提供的功能。</span><span class="sxs-lookup"><span data-stu-id="b4392-294">Other new types in the .NET Framework 4, for example, <xref:System.Threading.Barrier?displayProperty=nameWithType> and <xref:System.Threading.SpinLock?displayProperty=nameWithType>, provide functionality that was not available in earlier releases.</span></span> <span data-ttu-id="b4392-295">有关详细信息，请参阅[用于并行编程的数据结构](data-structures-for-parallel-programming.md)。</span><span class="sxs-lookup"><span data-stu-id="b4392-295">For more information, see [Data Structures for Parallel Programming](data-structures-for-parallel-programming.md).</span></span>

## <a name="custom-task-types"></a><span data-ttu-id="b4392-296">自定义任务类型</span><span class="sxs-lookup"><span data-stu-id="b4392-296">Custom task types</span></span>

<span data-ttu-id="b4392-297">建议不要从 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 或 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 继承。</span><span class="sxs-lookup"><span data-stu-id="b4392-297">We recommend that you do not inherit from <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b4392-298">相反，我们建议你使用 <xref:System.Threading.Tasks.Task.AsyncState%2A> 属性将其他数据或状态与 <xref:System.Threading.Tasks.Task> 或 <xref:System.Threading.Tasks.Task%601> 对象相关联。</span><span class="sxs-lookup"><span data-stu-id="b4392-298">Instead, we recommend that you use the <xref:System.Threading.Tasks.Task.AsyncState%2A> property to associate additional data or state with a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object.</span></span> <span data-ttu-id="b4392-299">还可以使用扩展方法扩展 <xref:System.Threading.Tasks.Task> 和 <xref:System.Threading.Tasks.Task%601> 类的功能。</span><span class="sxs-lookup"><span data-stu-id="b4392-299">You can also use extension methods to extend the functionality of the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes.</span></span> <span data-ttu-id="b4392-300">有关扩展方法的详细信息，请参阅[扩展方法](../../csharp/programming-guide/classes-and-structs/extension-methods.md)和[扩展方法](../../visual-basic/programming-guide/language-features/procedures/extension-methods.md)。</span><span class="sxs-lookup"><span data-stu-id="b4392-300">For more information about extension methods, see [Extension Methods](../../csharp/programming-guide/classes-and-structs/extension-methods.md) and [Extension Methods](../../visual-basic/programming-guide/language-features/procedures/extension-methods.md).</span></span>

<span data-ttu-id="b4392-301">如果必须从 <xref:System.Threading.Tasks.Task> 或 <xref:System.Threading.Tasks.Task%601> 继承，则不能使用 <xref:System.Threading.Tasks.Task.Run%2A> 或 <xref:System.Threading.Tasks.TaskFactory?displayProperty=nameWithType>，<xref:System.Threading.Tasks.TaskFactory%601?displayProperty=nameWithType> 或 <xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=nameWithType> 类创建自定义任务类型的实例，因为这些类仅创建 <xref:System.Threading.Tasks.Task> 和 <xref:System.Threading.Tasks.Task%601> 对象。</span><span class="sxs-lookup"><span data-stu-id="b4392-301">If you must inherit from <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601>, you cannot use <xref:System.Threading.Tasks.Task.Run%2A>, or the <xref:System.Threading.Tasks.TaskFactory?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskFactory%601?displayProperty=nameWithType>, or <xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=nameWithType> classes to create instances of your custom task type because these mechanisms create only <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects.</span></span> <span data-ttu-id="b4392-302">此外，不能使用 <xref:System.Threading.Tasks.Task>、<xref:System.Threading.Tasks.Task%601>、<xref:System.Threading.Tasks.TaskFactory> 和 <xref:System.Threading.Tasks.TaskFactory%601> 提供的任务延续机制创建自定义任务类型的实例，因为这些机制也只创建 <xref:System.Threading.Tasks.Task> 和 <xref:System.Threading.Tasks.Task%601> 对象。</span><span class="sxs-lookup"><span data-stu-id="b4392-302">In addition, you cannot use the task continuation mechanisms that are provided by <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.TaskFactory>, and  <xref:System.Threading.Tasks.TaskFactory%601> to create instances of your custom task type because these mechanisms also create only <xref:System.Threading.Tasks.Task> and  <xref:System.Threading.Tasks.Task%601> objects.</span></span>

## <a name="related-topics"></a><span data-ttu-id="b4392-303">相关主题</span><span class="sxs-lookup"><span data-stu-id="b4392-303">Related topics</span></span>

|<span data-ttu-id="b4392-304">Title</span><span class="sxs-lookup"><span data-stu-id="b4392-304">Title</span></span>|<span data-ttu-id="b4392-305">描述</span><span class="sxs-lookup"><span data-stu-id="b4392-305">Description</span></span>|
|-|-|
|[<span data-ttu-id="b4392-306">使用延续任务来链接任务</span><span class="sxs-lookup"><span data-stu-id="b4392-306">Chaining Tasks by Using Continuation Tasks</span></span>](chaining-tasks-by-using-continuation-tasks.md)|<span data-ttu-id="b4392-307">描述延续任务的工作方式。</span><span class="sxs-lookup"><span data-stu-id="b4392-307">Describes how continuations work.</span></span>|
|[<span data-ttu-id="b4392-308">附加和分离的子任务</span><span class="sxs-lookup"><span data-stu-id="b4392-308">Attached and Detached Child Tasks</span></span>](attached-and-detached-child-tasks.md)|<span data-ttu-id="b4392-309">描述附加子任务和分离子任务之间的差异。</span><span class="sxs-lookup"><span data-stu-id="b4392-309">Describes the difference between attached and detached child tasks.</span></span>|
|[<span data-ttu-id="b4392-310">任务取消</span><span class="sxs-lookup"><span data-stu-id="b4392-310">Task Cancellation</span></span>](task-cancellation.md)|<span data-ttu-id="b4392-311">描述在 <xref:System.Threading.Tasks.Task> 对象中内置的取消支持。</span><span class="sxs-lookup"><span data-stu-id="b4392-311">Describes the cancellation support that is built into the <xref:System.Threading.Tasks.Task> object.</span></span>|
|[<span data-ttu-id="b4392-312">异常处理</span><span class="sxs-lookup"><span data-stu-id="b4392-312">Exception Handling</span></span>](exception-handling-task-parallel-library.md)|<span data-ttu-id="b4392-313">描述如何处理并行线程中的异常。</span><span class="sxs-lookup"><span data-stu-id="b4392-313">Describes how exceptions on concurrent threads are handled.</span></span>|
|[<span data-ttu-id="b4392-314">如何：使用 Parallel.Invoke 来执行并行操作</span><span class="sxs-lookup"><span data-stu-id="b4392-314">How to: Use Parallel.Invoke to Execute Parallel Operations</span></span>](how-to-use-parallel-invoke-to-execute-parallel-operations.md)|<span data-ttu-id="b4392-315">描述如何使用 <xref:System.Threading.Tasks.Parallel.Invoke%2A>。</span><span class="sxs-lookup"><span data-stu-id="b4392-315">Describes how to use <xref:System.Threading.Tasks.Parallel.Invoke%2A>.</span></span>|
|[<span data-ttu-id="b4392-316">如何：从任务中返回值</span><span class="sxs-lookup"><span data-stu-id="b4392-316">How to: Return a Value from a Task</span></span>](how-to-return-a-value-from-a-task.md)|<span data-ttu-id="b4392-317">描述如何从任务中返回值。</span><span class="sxs-lookup"><span data-stu-id="b4392-317">Describes how to return values from tasks.</span></span>|
|[<span data-ttu-id="b4392-318">如何：取消任务及其子级</span><span class="sxs-lookup"><span data-stu-id="b4392-318">How to: Cancel a Task and Its Children</span></span>](how-to-cancel-a-task-and-its-children.md)|<span data-ttu-id="b4392-319">描述如何取消任务。</span><span class="sxs-lookup"><span data-stu-id="b4392-319">Describes how to cancel tasks.</span></span>|
|[<span data-ttu-id="b4392-320">如何：创建预先计算的任务</span><span class="sxs-lookup"><span data-stu-id="b4392-320">How to: Create Pre-Computed Tasks</span></span>](how-to-create-pre-computed-tasks.md)|<span data-ttu-id="b4392-321">描述如何使用 <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> 方法去检索缓存中包含的异步下载运算结果。</span><span class="sxs-lookup"><span data-stu-id="b4392-321">Describes how to use the <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> method to retrieve the results of asynchronous download operations that are held in a cache.</span></span>|
|[<span data-ttu-id="b4392-322">如何：使用并行任务遍历二叉树</span><span class="sxs-lookup"><span data-stu-id="b4392-322">How to: Traverse a Binary Tree with Parallel Tasks</span></span>](how-to-traverse-a-binary-tree-with-parallel-tasks.md)|<span data-ttu-id="b4392-323">描述如何使用任务遍历二叉树。</span><span class="sxs-lookup"><span data-stu-id="b4392-323">Describes how to use tasks to traverse a binary tree.</span></span>|
|[<span data-ttu-id="b4392-324">如何：解除嵌套任务的包装</span><span class="sxs-lookup"><span data-stu-id="b4392-324">How to: Unwrap a Nested Task</span></span>](how-to-unwrap-a-nested-task.md)|<span data-ttu-id="b4392-325">演示如何使用 <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> 扩展方法。</span><span class="sxs-lookup"><span data-stu-id="b4392-325">Demonstrates how to use the <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> extension method.</span></span>|
|[<span data-ttu-id="b4392-326">数据并行</span><span class="sxs-lookup"><span data-stu-id="b4392-326">Data Parallelism</span></span>](data-parallelism-task-parallel-library.md)|<span data-ttu-id="b4392-327">描述如何使用 <xref:System.Threading.Tasks.Parallel.For%2A> 和 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 来创建循环访问数据的并行循环。</span><span class="sxs-lookup"><span data-stu-id="b4392-327">Describes how to use <xref:System.Threading.Tasks.Parallel.For%2A> and <xref:System.Threading.Tasks.Parallel.ForEach%2A> to create parallel loops over data.</span></span>|
|[<span data-ttu-id="b4392-328">并行编程</span><span class="sxs-lookup"><span data-stu-id="b4392-328">Parallel Programming</span></span>](index.md)|<span data-ttu-id="b4392-329">.NET Framework 并行编程的顶级节点。</span><span class="sxs-lookup"><span data-stu-id="b4392-329">Top level node for .NET Framework parallel programming.</span></span>|

## <a name="see-also"></a><span data-ttu-id="b4392-330">请参阅</span><span class="sxs-lookup"><span data-stu-id="b4392-330">See also</span></span>

- [<span data-ttu-id="b4392-331">并行编程</span><span class="sxs-lookup"><span data-stu-id="b4392-331">Parallel Programming</span></span>](index.md)
- [<span data-ttu-id="b4392-332">使用 .NET Core 和 .NET Standard 并行编程的示例</span><span class="sxs-lookup"><span data-stu-id="b4392-332">Samples for Parallel Programming with the .NET Core & .NET Standard</span></span>](/samples/browse/?products=dotnet-core%2Cdotnet-standard&term=parallel)
