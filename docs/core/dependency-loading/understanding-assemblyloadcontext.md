---
title: 了解 AssemblyLoadContext - .NET Core
description: 用来了解 .NET Core 中 AssemblyLoadContext 的用途和行为的关键概念。
ms.date: 08/09/2019
author: sdmaclea
ms.author: stmaclea
ms.openlocfilehash: 4d3f0e50e7c336469bd9af4d1589427388684434
ms.sourcegitcommit: dfcbc096ad7908cd58a5f0aeabd2256f05266bac
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/21/2020
ms.locfileid: "92332817"
---
# <a name="understanding-systemruntimeloaderassemblyloadcontext"></a><span data-ttu-id="fe3c0-103">了解 System.Runtime.Loader.AssemblyLoadContext</span><span class="sxs-lookup"><span data-stu-id="fe3c0-103">Understanding System.Runtime.Loader.AssemblyLoadContext</span></span>

<span data-ttu-id="fe3c0-104"><xref:System.Runtime.Loader.AssemblyLoadContext> 类对于 .NET Core 是唯一的。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-104">The <xref:System.Runtime.Loader.AssemblyLoadContext> class is unique to .NET Core.</span></span> <span data-ttu-id="fe3c0-105">本文尝试使用概念性信息来补充 <xref:System.Runtime.Loader.AssemblyLoadContext> API 文档。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-105">This article attempts to supplement the <xref:System.Runtime.Loader.AssemblyLoadContext> API documentation with conceptual information.</span></span>

<span data-ttu-id="fe3c0-106">本文与实现动态加载的开发人员有关，尤其是动态加载框架的开发人员。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-106">This article is relevant to developers implementing dynamic loading, especially dynamic loading framework developers.</span></span>

## <a name="what-is-the-assemblyloadcontext"></a><span data-ttu-id="fe3c0-107">什么是 AssemblyLoadContext？</span><span class="sxs-lookup"><span data-stu-id="fe3c0-107">What is the AssemblyLoadContext?</span></span>

<span data-ttu-id="fe3c0-108">每个 .NET Core 应用程序均隐式使用 <xref:System.Runtime.Loader.AssemblyLoadContext>。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-108">Every .NET Core application implicitly uses the <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span>
<span data-ttu-id="fe3c0-109">它是运行时的提供程序，用于定位和加载依赖项。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-109">It's the runtime's provider for locating and loading dependencies.</span></span> <span data-ttu-id="fe3c0-110">只要加载了依赖项，就会调用 <xref:System.Runtime.Loader.AssemblyLoadContext> 实例来定位该依赖项。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-110">Whenever a dependency is loaded, an <xref:System.Runtime.Loader.AssemblyLoadContext> instance is invoked to locate it.</span></span>

- <span data-ttu-id="fe3c0-111">它提供定位、加载和缓存托管程序集和其他依赖项的服务。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-111">It provides a service of locating, loading, and caching managed assemblies and other dependencies.</span></span>

- <span data-ttu-id="fe3c0-112">为了支持动态代码加载和卸载，它创建了一个独立上下文，用于在其自己的 <xref:System.Runtime.Loader.AssemblyLoadContext> 实例中加载代码及其依赖项。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-112">To support dynamic code loading and unloading, it creates an isolated context for loading code and its dependencies in their own <xref:System.Runtime.Loader.AssemblyLoadContext> instance.</span></span>

## <a name="when-do-you-need-multiple-assemblyloadcontext-instances"></a><span data-ttu-id="fe3c0-113">何时需要多个 AssemblyLoadContext 实例？</span><span class="sxs-lookup"><span data-stu-id="fe3c0-113">When do you need multiple AssemblyLoadContext instances?</span></span>

<span data-ttu-id="fe3c0-114">单个 <xref:System.Runtime.Loader.AssemblyLoadContext> 实例限制为每个简单程序集名称 <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> 只加载 <xref:System.Reflection.Assembly> 的一个版本。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-114">A single <xref:System.Runtime.Loader.AssemblyLoadContext> instance is limited to loading exactly one version of an <xref:System.Reflection.Assembly> per simple assembly name, <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="fe3c0-115">当动态加载代码模块时，此限制可能会成为一个问题。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-115">This restriction can become a problem when loading code modules dynamically.</span></span> <span data-ttu-id="fe3c0-116">每个模块都是独立编译的，并且可能依赖于不同版本的 <xref:System.Reflection.Assembly>。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-116">Each module is independently compiled and may depend on different versions of an <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="fe3c0-117">当不同的模块依赖于常用库的不同版本时，通常会出现此问题。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-117">This problem commonly occurs when different modules depend on different versions of a commonly used library.</span></span>

<span data-ttu-id="fe3c0-118">为了支持动态加载代码，<xref:System.Runtime.Loader.AssemblyLoadContext> API 提供在同一个应用程序中加载 <xref:System.Reflection.Assembly> 冲突版本的功能。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-118">To support dynamically loading code, the <xref:System.Runtime.Loader.AssemblyLoadContext> API provides for loading conflicting versions of an <xref:System.Reflection.Assembly> in the same application.</span></span> <span data-ttu-id="fe3c0-119">每个 <xref:System.Runtime.Loader.AssemblyLoadContext> 实例提供一个唯一字典，该字典将每个 <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> 映射到特定的 <xref:System.Reflection.Assembly> 实例。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-119">Each <xref:System.Runtime.Loader.AssemblyLoadContext> instance provides a unique dictionary mapping each <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> to a specific <xref:System.Reflection.Assembly> instance.</span></span>

<span data-ttu-id="fe3c0-120">它还提供了一种方便的机制，将与代码模块相关的依赖项分组，以便以后进行卸载。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-120">It also provides a convenient mechanism for grouping dependencies related to a code module for later unload.</span></span>

## <a name="what-is-special-about-the-assemblyloadcontextdefault-instance"></a><span data-ttu-id="fe3c0-121">AssemblyLoadContext.Default 实例有什么特别之处？</span><span class="sxs-lookup"><span data-stu-id="fe3c0-121">What is special about the AssemblyLoadContext.Default instance?</span></span>

<span data-ttu-id="fe3c0-122">启动时，运行时将自动填充 <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> 实例。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-122">The <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> instance is automatically populated by the runtime at startup.</span></span>  <span data-ttu-id="fe3c0-123">它使用[默认探测](default-probing.md)来定位和查找所有静态依赖项。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-123">It uses [default probing](default-probing.md) to locate and find all static dependencies.</span></span>

<span data-ttu-id="fe3c0-124">它解决了最常见的依赖项加载方案。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-124">It solves the most common dependency loading scenarios.</span></span>

## <a name="how-does-assemblyloadcontext-support-dynamic-dependencies"></a><span data-ttu-id="fe3c0-125">AssemblyLoadContext 如何支持动态依赖项？</span><span class="sxs-lookup"><span data-stu-id="fe3c0-125">How does AssemblyLoadContext support dynamic dependencies?</span></span>

<span data-ttu-id="fe3c0-126"><xref:System.Runtime.Loader.AssemblyLoadContext> 具有可替代的各种事件和虚函数。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-126"><xref:System.Runtime.Loader.AssemblyLoadContext> has various events and virtual functions that can be overridden.</span></span>

<span data-ttu-id="fe3c0-127"><xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> 实例仅支持替代事件。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-127">The <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> instance only supports overriding the events.</span></span>

<span data-ttu-id="fe3c0-128">[托管程序集加载算法](loading-managed.md)、[附属程序集加载算法](loading-resources.md)和[非托管（本机）库加载算法](loading-unmanaged.md)文章引用了所有可用事件和虚拟函数。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-128">The articles [Managed assembly loading algorithm](loading-managed.md), [Satellite assembly loading algorithm](loading-resources.md), and [Unmanaged (native) library loading algorithm](loading-unmanaged.md) refer to all the available events and virtual functions.</span></span>  <span data-ttu-id="fe3c0-129">这些文章显示加载算法中的每个事件和函数的相对位置。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-129">The articles show each event and function's relative position in the loading algorithms.</span></span> <span data-ttu-id="fe3c0-130">本文不会重现该信息。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-130">This article doesn't reproduce that information.</span></span>

<span data-ttu-id="fe3c0-131">本部分介绍相关事件和函数的一般原则。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-131">This section covers the general principles for the relevant events and functions.</span></span>

- <span data-ttu-id="fe3c0-132">**可重复** 。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-132">**Be repeatable** .</span></span> <span data-ttu-id="fe3c0-133">针对特定依赖项的查询必须始终产生相同的响应。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-133">A query for a specific dependency must always result in the same response.</span></span> <span data-ttu-id="fe3c0-134">必须返回同一个已加载的依赖项实例。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-134">The same loaded dependency instance must be returned.</span></span> <span data-ttu-id="fe3c0-135">此要求是保持缓存一致性的基础。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-135">This requirement is fundamental  for cache consistency.</span></span> <span data-ttu-id="fe3c0-136">特别是对于托管程序集，我们要创建 <xref:System.Reflection.Assembly> 缓存。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-136">For managed assemblies in particular, we're creating an <xref:System.Reflection.Assembly> cache.</span></span> <span data-ttu-id="fe3c0-137">缓存键是一个简单的程序集名称 <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-137">The cache key is a simple assembly name, <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="fe3c0-138">**通常不引发** 。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-138">**Typically don't throw** .</span></span>  <span data-ttu-id="fe3c0-139">当找不到请求的依赖项时，这些函数应返回 `null` 而不是引发。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-139">It's expected that these functions return `null` rather than throw when unable to find the requested dependency.</span></span> <span data-ttu-id="fe3c0-140">引发将提前结束搜索，并将异常传至调用方。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-140">Throwing will prematurely end the search and be propagate an exception to the caller.</span></span> <span data-ttu-id="fe3c0-141">应将引发限制为针对意外错误，如程序集损坏或内存不足等情况。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-141">Throwing should be restricted to unexpected errors like a corrupted assembly or an out of memory condition.</span></span>
- <span data-ttu-id="fe3c0-142">**避免递归** 。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-142">**Avoid recursion** .</span></span> <span data-ttu-id="fe3c0-143">请注意，这些函数和处理程序实现了用于定位依赖项的加载规则。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-143">Be aware that these functions and handlers implement the loading rules for locating dependencies.</span></span> <span data-ttu-id="fe3c0-144">实现不应调用触发递归的 API。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-144">Your implementation shouldn't call APIs that trigger recursion.</span></span> <span data-ttu-id="fe3c0-145">代码通常应调用 AssemblyLoadContext  加载函数，这些函数需要特定路径或内存引用参数。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-145">Your code should typically call **AssemblyLoadContext** load functions that require a specific path or memory reference argument.</span></span>
- <span data-ttu-id="fe3c0-146">**加载到正确的 AssemblyLoadContext** 。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-146">**Load into the correct AssemblyLoadContext** .</span></span> <span data-ttu-id="fe3c0-147">选择加载依赖项的位置是应用程序特定的。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-147">The choice of where to load dependencies is application-specific.</span></span>  <span data-ttu-id="fe3c0-148">选择是通过这些事件和函数实现的。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-148">The choice is implemented by these events and functions.</span></span> <span data-ttu-id="fe3c0-149">当代码调用 AssemblyLoadContext  时，按路径加载函数在你要加载代码的实例上调用它们。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-149">When your code calls **AssemblyLoadContext** load-by-path functions call them on the instance where you want the code loaded.</span></span> <span data-ttu-id="fe3c0-150">有时返回 `null`，并让 <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> 处理加载可能是最简单的选项。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-150">Sometime returning `null` and letting the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> handle the load may be the simplest option.</span></span>
- <span data-ttu-id="fe3c0-151">**注意线程争用** 。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-151">**Be aware of thread races** .</span></span> <span data-ttu-id="fe3c0-152">加载可由多个线程触发。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-152">Loading can be triggered by multiple threads.</span></span> <span data-ttu-id="fe3c0-153">AssemblyLoadContext 通过以原子方式将程序集添加到其缓存来处理线程争用。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-153">The AssemblyLoadContext handles thread races by atomically adding assemblies to its cache.</span></span> <span data-ttu-id="fe3c0-154">将丢弃争用失败方的实例。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-154">The race loser's instance is discarded.</span></span> <span data-ttu-id="fe3c0-155">在实现逻辑中，不要添加未正确处理多个线程的额外逻辑。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-155">In your implementation logic, don't add extra logic that doesn't handle multiple threads properly.</span></span>

## <a name="how-are-dynamic-dependencies-isolated"></a><span data-ttu-id="fe3c0-156">如何隔离动态依赖项？</span><span class="sxs-lookup"><span data-stu-id="fe3c0-156">How are dynamic dependencies isolated?</span></span>

<span data-ttu-id="fe3c0-157">每个 <xref:System.Runtime.Loader.AssemblyLoadContext> 实例都表示 <xref:System.Reflection.Assembly> 实例和 <xref:System.Type> 定义的唯一范围。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-157">Each <xref:System.Runtime.Loader.AssemblyLoadContext> instance represents a unique scope for <xref:System.Reflection.Assembly> instances and <xref:System.Type> definitions.</span></span>

<span data-ttu-id="fe3c0-158">这些依赖项之间没有任何二进制隔离。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-158">There's no binary isolation between these dependencies.</span></span> <span data-ttu-id="fe3c0-159">它们仅通过不按名称查找彼此来进行隔离。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-159">They're only isolated by not finding each other by name.</span></span>

<span data-ttu-id="fe3c0-160">在每个 <xref:System.Runtime.Loader.AssemblyLoadContext> 中：</span><span class="sxs-lookup"><span data-stu-id="fe3c0-160">In each <xref:System.Runtime.Loader.AssemblyLoadContext>:</span></span>

- <span data-ttu-id="fe3c0-161"><xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> 可以引用不同的 <xref:System.Reflection.Assembly> 实例。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-161"><xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> may refer to a different <xref:System.Reflection.Assembly> instance.</span></span>
- <span data-ttu-id="fe3c0-162"><xref:System.Type.GetType%2A?displayProperty=nameWithType> 可能会为同一类型 `name` 返回不同类型的实例。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-162"><xref:System.Type.GetType%2A?displayProperty=nameWithType> may return a different type instance for the same type `name`.</span></span>

## <a name="how-are-dependencies-shared"></a><span data-ttu-id="fe3c0-163">如何共享依赖项？</span><span class="sxs-lookup"><span data-stu-id="fe3c0-163">How are dependencies shared?</span></span>

<span data-ttu-id="fe3c0-164">可以在 <xref:System.Runtime.Loader.AssemblyLoadContext> 实例之间轻松共享依赖项。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-164">Dependencies can easily be shared between <xref:System.Runtime.Loader.AssemblyLoadContext> instances.</span></span> <span data-ttu-id="fe3c0-165">常规模型用于一个 <xref:System.Runtime.Loader.AssemblyLoadContext> 来加载依赖项。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-165">The general model is for one <xref:System.Runtime.Loader.AssemblyLoadContext> to load a dependency.</span></span>  <span data-ttu-id="fe3c0-166">另一个通过使用对已加载程序集的引用来共享依赖项。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-166">The other shares the dependency by using a reference to the loaded assembly.</span></span>

<span data-ttu-id="fe3c0-167">此共享是运行时程序集所必需的。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-167">This sharing is required of the runtime assemblies.</span></span> <span data-ttu-id="fe3c0-168">这些程序集只能加载到 <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-168">These assemblies can only be loaded into the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span> <span data-ttu-id="fe3c0-169">`ASP.NET`、`WPF` 或 `WinForms` 等框架也是如此。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-169">The same is required for frameworks like `ASP.NET`, `WPF`, or `WinForms`.</span></span>

<span data-ttu-id="fe3c0-170">建议将共享依赖项加载到 <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-170">It's recommended that shared dependencies should be loaded into <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span> <span data-ttu-id="fe3c0-171">此共享是常见的设计模式。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-171">This sharing is the common design pattern.</span></span>

<span data-ttu-id="fe3c0-172">共享是通过自定义 <xref:System.Runtime.Loader.AssemblyLoadContext> 实例编码实现的。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-172">Sharing is implemented in the coding of the custom <xref:System.Runtime.Loader.AssemblyLoadContext> instance.</span></span> <span data-ttu-id="fe3c0-173"><xref:System.Runtime.Loader.AssemblyLoadContext> 具有可替代的各种事件和虚函数。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-173"><xref:System.Runtime.Loader.AssemblyLoadContext> has various events and virtual functions that can be overridden.</span></span> <span data-ttu-id="fe3c0-174">当这些函数中的任何函数返回对在另一个 <xref:System.Runtime.Loader.AssemblyLoadContext> 实例中加载的 <xref:System.Reflection.Assembly> 实例的引用时，将共享 <xref:System.Reflection.Assembly> 实例。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-174">When any of these functions return a reference to an <xref:System.Reflection.Assembly> instance that was loaded in another <xref:System.Runtime.Loader.AssemblyLoadContext> instance, the <xref:System.Reflection.Assembly> instance is shared.</span></span> <span data-ttu-id="fe3c0-175">标准加载算法会延迟 <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> 加载，以简化通用共享模式。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-175">The standard load algorithm defers to <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> for loading to simplify the common sharing pattern.</span></span>  <span data-ttu-id="fe3c0-176">请参阅[托管程序集加载算法](loading-managed.md)。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-176">See [Managed assembly loading algorithm](loading-managed.md).</span></span>

## <a name="complications"></a><span data-ttu-id="fe3c0-177">复杂情况</span><span class="sxs-lookup"><span data-stu-id="fe3c0-177">Complications</span></span>

### <a name="type-conversion-issues"></a><span data-ttu-id="fe3c0-178">类型转换问题</span><span class="sxs-lookup"><span data-stu-id="fe3c0-178">Type conversion issues</span></span>

<span data-ttu-id="fe3c0-179">当两个 <xref:System.Runtime.Loader.AssemblyLoadContext> 实例包含具有相同 `name` 的类型定义时，它们不是同一类型。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-179">When two <xref:System.Runtime.Loader.AssemblyLoadContext> instances contain type definitions with the same `name`, they're not the same type.</span></span> <span data-ttu-id="fe3c0-180">当且仅当它们来自同一个 <xref:System.Reflection.Assembly> 实例时，它们的类型相同。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-180">They're the same type if and only if they come from the same <xref:System.Reflection.Assembly> instance.</span></span>

<span data-ttu-id="fe3c0-181">使事情复杂化的是，这些不匹配类型的异常消息可能会令人困惑。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-181">To complicate matters, exception messages about these mismatched types can be confusing.</span></span> <span data-ttu-id="fe3c0-182">在异常消息中，按简单类型名称来引用这些类型。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-182">The types are referred to in the exception messages by their simple type names.</span></span> <span data-ttu-id="fe3c0-183">在这种情况下，常见异常消息的格式如下所示：</span><span class="sxs-lookup"><span data-stu-id="fe3c0-183">The common exception message in this case would be of the form:</span></span>

> <span data-ttu-id="fe3c0-184">无法将类型为“IsolatedType”的对象转换为类型“IsolatedType”。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-184">Object of type 'IsolatedType' cannot be converted to type 'IsolatedType'.</span></span>

### <a name="debugging-type-conversion-issues"></a><span data-ttu-id="fe3c0-185">调试类型转换问题</span><span class="sxs-lookup"><span data-stu-id="fe3c0-185">Debugging type conversion issues</span></span>

<span data-ttu-id="fe3c0-186">如果给定一对不匹配的类型，还必须要了解：</span><span class="sxs-lookup"><span data-stu-id="fe3c0-186">Given a pair of mismatched types it's important to also know:</span></span>

- <span data-ttu-id="fe3c0-187">每种类型的 <xref:System.Type.Assembly?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="fe3c0-187">Each type's <xref:System.Type.Assembly?displayProperty=nameWithType></span></span>
- <span data-ttu-id="fe3c0-188">每种类型的 <xref:System.Runtime.Loader.AssemblyLoadContext>，这可以通过 <xref:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)?displayProperty=nameWithType> 函数获得。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-188">Each type's <xref:System.Runtime.Loader.AssemblyLoadContext>, which can be obtained via the <xref:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)?displayProperty=nameWithType> function.</span></span>

<span data-ttu-id="fe3c0-189">如果给定两个对象 `a` 和 `b`，在调试器中评估以下内容将非常有用：</span><span class="sxs-lookup"><span data-stu-id="fe3c0-189">Given two objects `a` and `b`, evaluating the following in the debugger will be helpful:</span></span>

```csharp
// In debugger look at each assembly's instance, Location, and FullName
a.GetType().Assembly
b.GetType().Assembly
// In debugger look at each AssemblyLoadContext's instance and name
System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(a.GetType().Assembly)
System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(b.GetType().Assembly)
```

### <a name="resolving-type-conversion-issues"></a><span data-ttu-id="fe3c0-190">解决类型转换问题</span><span class="sxs-lookup"><span data-stu-id="fe3c0-190">Resolving type conversion issues</span></span>

<span data-ttu-id="fe3c0-191">可以通过两种设计模式来解决这些类型转换问题。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-191">There are two design patterns for solving these type conversion issues.</span></span>

1. <span data-ttu-id="fe3c0-192">使用常见的共享类型。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-192">Use common shared types.</span></span> <span data-ttu-id="fe3c0-193">此共享类型可以是基元运行时类型，也可以涉及在共享程序集中创建新的共享类型。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-193">This shared type can either be a primitive runtime type, or it can involve creating a new shared type in a shared assembly.</span></span>  <span data-ttu-id="fe3c0-194">共享类型通常是在应用程序的程序集中定义的[接口](../../csharp/language-reference/keywords/interface.md)。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-194">Often the shared type is an [interface](../../csharp/language-reference/keywords/interface.md) defined in an application assembly.</span></span> <span data-ttu-id="fe3c0-195">另请参阅：[如何共享依赖项？](#how-are-dependencies-shared)。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-195">See also: [How are dependencies shared?](#how-are-dependencies-shared).</span></span>

2. <span data-ttu-id="fe3c0-196">使用封送处理技术从一种类型转换为另一种类型。</span><span class="sxs-lookup"><span data-stu-id="fe3c0-196">Use marshaling techniques to convert from one type to another.</span></span>
